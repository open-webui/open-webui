{"version":3,"file":"codemirror-Dr2Hgejs.js","sources":["../node_modules/crelt/index.js","../node_modules/@codemirror/search/dist/index.js","../node_modules/@codemirror/lint/dist/index.js","../node_modules/codemirror/dist/index.js"],"sourcesContent":["export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n","import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\", value: line });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"Ã—\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n","import { Decoration, showPanel, EditorView, ViewPlugin, logException, gutter, showTooltip, hoverTooltip, getPanel, WidgetType, GutterMarker } from '@codemirror/view';\nimport { StateEffect, StateField, Facet, combineConfig, RangeSet } from '@codemirror/state';\nimport elt from 'crelt';\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic) {\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected) {\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let markedDiagnostics = diagnostics;\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter)\n            markedDiagnostics = diagnosticFilter(markedDiagnostics, state);\n        let ranges = Decoration.set(markedDiagnostics.map((d) => {\n            // For zero-length ranges or ranges covering only a line break, create a widget\n            return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)\n                ? Decoration.widget({\n                    widget: new DiagnosticWidget(d),\n                    diagnostic: d\n                }).range(d.from)\n                : Decoration.mark({\n                    attributes: { class: \"cm-lintRange cm-lintRange-\" + d.severity + (d.markClass ? \" \" + d.markClass : \"\") },\n                    diagnostic: d,\n                    inclusive: true\n                }).range(d.from, d.to);\n        }), true);\n        return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec }) => {\n        if (diagnostic && spec.diagnostic != diagnostic)\n            return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/\nfunction setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/\nconst setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/StateEffect.define();\nconst lintState = /*@__PURE__*/StateField.define({\n    create() {\n        return new LintState(Decoration.none, null, null);\n    },\n    update(value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                value = LintState.init(effect.value, value.panel, tr.state);\n            }\n            else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            }\n            else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: f => [showPanel.from(f, val => val.panel),\n        EditorView.decorations.from(f, s => s.diagnostics)]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/\nfunction diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/Decoration.mark({ class: \"cm-lintRange cm-lintRange-active\", inclusive: true });\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {\n        if (pos >= from && pos <= to &&\n            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (diagnosticFilter)\n        found = diagnosticFilter(found, view.state);\n    if (!found.length)\n        return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        create() {\n            return { dom: diagnosticsTooltip(view, found) };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return elt(\"ul\", { class: \"cm-tooltip-lint\" }, diagnostics.map(d => renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/\nconst openLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });\n    let panel = getPanel(view, LintPanel.open);\n    if (panel)\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/\nconst closeLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        return false;\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/\nconst nextDiagnostic = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to)\n            return false;\n    }\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/\nconst previousDiagnostic = (view) => {\n    let { state } = view, field = state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to) => {\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from)\n        return false;\n    view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/\nconst lintKeymap = [\n    { key: \"Mod-Shift-m\", run: openLintPanel, preventDefault: true },\n    { key: \"F8\", run: nextDiagnostic }\n];\nconst lintPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        }\n        else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            if (sources.length)\n                Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {\n                    let all = annotations.reduce((a, b) => a.concat(b));\n                    if (this.view.state.doc == state.doc)\n                        this.view.dispatch(setDiagnostics(this.view.state, all));\n                }, error => { logException(this.view.state, error); });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) ||\n            config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nconst lintConfig = /*@__PURE__*/Facet.define({\n    combine(input) {\n        return Object.assign({ sources: input.map(i => i.source).filter(x => x != null) }, combineConfig(input.map(i => i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null\n        }, {\n            needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed). If `null` is given as\nsource, this only configures the lint extension.\n*/\nfunction linter(source, config = {}) {\n    return [\n        lintConfig.of({ source, config }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/\nfunction forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin)\n        plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions)\n        actions: for (let { name } of actions) {\n            for (let i = 0; i < name.length; i++) {\n                let ch = name[i];\n                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\n                    assigned.push(ch);\n                    continue actions;\n                }\n            }\n            assigned.push(\"\");\n        }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return elt(\"li\", { class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity }, elt(\"span\", { class: \"cm-diagnosticText\" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\n        let fired = false, click = (e) => {\n            e.preventDefault();\n            if (fired)\n                return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found)\n                action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),\n            elt(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)];\n        return elt(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && elt(\"div\", { class: \"cm-diagnosticSource\" }, diagnostic.source));\n}\nclass DiagnosticWidget extends WidgetType {\n    constructor(diagnostic) {\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) { return other.diagnostic == this.diagnostic; }\n    toDOM() {\n        return elt(\"span\", { class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic) {\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view) {\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event) => {\n            if (event.keyCode == 27) { // Escape\n                closeLintPanel(this.view);\n                this.view.focus();\n            }\n            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            }\n            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            }\n            else if (event.keyCode == 36) { // Home\n                this.moveSelection(0);\n            }\n            else if (event.keyCode == 35) { // End\n                this.moveSelection(this.items.length - 1);\n            }\n            else if (event.keyCode == 13) { // Enter\n                this.view.focus();\n            }\n            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for (let i = 0; i < keys.length; i++)\n                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                        if (found)\n                            diagnostic.actions[i].apply(view, found.from, found.to);\n                    }\n            }\n            else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event) => {\n            for (let i = 0; i < this.items.length; i++) {\n                if (this.items[i].dom.contains(event.target))\n                    this.moveSelection(i);\n            }\n        };\n        this.list = elt(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = elt(\"div\", { class: \"cm-panel-lint\" }, this.list, elt(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: () => closeLintPanel(this.view)\n        }, \"Ã—\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected)\n            return -1;\n        for (let i = 0; i < this.items.length; i++)\n            if (this.items[i].diagnostic == selected.diagnostic)\n                return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\n            let found = -1, item;\n            for (let j = i; j < this.items.length; j++)\n                if (this.items[j].diagnostic == spec.diagnostic) {\n                    found = j;\n                    break;\n                }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            }\n            else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            }\n            else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1, to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\n                write: ({ sel, panel }) => {\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top)\n                        this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom)\n                        this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        }\n        else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync)\n            this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items) {\n            if (item.dom.parentNode == this.list) {\n                while (domPos != item.dom)\n                    rm();\n                domPos = item.dom.nextSibling;\n            }\n            else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while (domPos)\n            rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0)\n            return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection)\n            return;\n        this.view.dispatch({\n            selection: { anchor: selection.from, head: selection.to },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) { return new LintPanel(view); }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": { borderLeft: \"5px solid #d11\" },\n    \".cm-diagnostic-warning\": { borderLeft: \"5px solid orange\" },\n    \".cm-diagnostic-info\": { borderLeft: \"5px solid #999\" },\n    \".cm-diagnostic-hint\": { borderLeft: \"5px solid #66d\" },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\",\n    },\n    \".cm-lintRange-error\": { backgroundImage: /*@__PURE__*/underline(\"#d11\") },\n    \".cm-lintRange-warning\": { backgroundImage: /*@__PURE__*/underline(\"orange\") },\n    \".cm-lintRange-info\": { backgroundImage: /*@__PURE__*/underline(\"#999\") },\n    \".cm-lintRange-hint\": { backgroundImage: /*@__PURE__*/underline(\"#66d\") },\n    \".cm-lintRange-active\": { backgroundColor: \"#ffdd9980\" },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": { borderBottomColor: \"orange\" }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": { borderBottomColor: \"#999\" }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": { borderBottomColor: \"#66d\" }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": { textDecoration: \"underline\" }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": { textDecoration: \"none\" },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nclass LintGutterMarker extends GutterMarker {\n    constructor(diagnostics) {\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = diagnostics.reduce((max, d) => severityWeight(max) < severityWeight(d.severity) ? d.severity : max, \"hint\");\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter)\n            diagnostics = diagnosticsFilter(diagnostics, view.state);\n        if (diagnostics.length)\n            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event) => {\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */ && event.clientX < rect.right + 10 /* Hover.Margin */ &&\n            event.clientY > rect.top - 10 /* Hover.Margin */ && event.clientY < rect.bottom + 10 /* Hover.Margin */)\n            return;\n        for (let target = event.target; target; target = target.parentNode) {\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\"))\n                return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip))\n            view.dispatch({ effects: setLintGutterTooltip.of(null) });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({ effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    create() {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: () => marker.getBoundingClientRect()\n                        };\n                    }\n                }) });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = () => {\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = () => {\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics) {\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for (let line in byLine) {\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/gutter({\n    class: \"cm-gutter-lint\",\n    markers: view => view.state.field(lintGutterMarkers),\n});\nconst lintGutterMarkers = /*@__PURE__*/StateField.define({\n    create() {\n        return RangeSet.empty;\n    },\n    update(markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter)\n                    diagnostics = diagnosticFilter(diagnostics || [], tr.state);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/StateField.define({\n    create() { return null; },\n    update(tooltip, tr) {\n        if (tooltip && tr.docChanged)\n            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });\n        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: field => showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`),\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    },\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/EditorView.decorations.compute([lintState], state => {\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/hoverTooltip(lintTooltip, { hideOn: hideTooltip }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            hoverTime: 300 /* Hover.Time */,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/\nfunction lintGutter(config = {}) {\n    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/\nfunction forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size)\n        for (let iter = RangeSet.iter([lState.diagnostics]); iter.value; iter.next())\n            f(iter.value.spec.diagnostic, iter.from, iter.to);\n}\n\nexport { closeLintPanel, diagnosticCount, forEachDiagnostic, forceLinting, lintGutter, lintKeymap, linter, nextDiagnostic, openLintPanel, previousDiagnostic, setDiagnostics, setDiagnosticsEffect };\n","import { lineNumbers, highlightActiveLineGutter, highlightSpecialChars, drawSelection, dropCursor, rectangularSelection, crosshairCursor, highlightActiveLine, keymap } from '@codemirror/view';\nexport { EditorView } from '@codemirror/view';\nimport { EditorState } from '@codemirror/state';\nimport { foldGutter, indentOnInput, syntaxHighlighting, defaultHighlightStyle, bracketMatching, foldKeymap } from '@codemirror/language';\nimport { history, defaultKeymap, historyKeymap } from '@codemirror/commands';\nimport { highlightSelectionMatches, searchKeymap } from '@codemirror/search';\nimport { closeBrackets, autocompletion, closeBracketsKeymap, completionKeymap } from '@codemirror/autocomplete';\nimport { lintKeymap } from '@codemirror/lint';\n\n// (The superfluous function calls around the list of extensions work\n// around current limitations in tree-shaking software.)\n/**\nThis is an extension value that just pulls together a number of\nextensions that you might want in a basic editor. It is meant as a\nconvenient helper to quickly set up CodeMirror without installing\nand importing a lot of separate packages.\n\nSpecifically, it includes...\n\n - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)\n - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)\n - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)\n - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)\n - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)\n - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)\n - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)\n - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\n - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)\n - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)\n - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)\n - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)\n - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)\n - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)\n - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)\n - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)\n - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)\n - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)\n - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)\n\n(You'll probably want to add some language package to your setup\ntoo.)\n\nThis extension does not allow customization. The idea is that,\nonce you decide you want to configure your editor more precisely,\nyou take this package's source (which is just a bunch of imports\nand an array literal), copy it into your own code, and adjust it\nas desired.\n*/\nconst basicSetup = /*@__PURE__*/(() => [\n    lineNumbers(),\n    highlightActiveLineGutter(),\n    highlightSpecialChars(),\n    history(),\n    foldGutter(),\n    drawSelection(),\n    dropCursor(),\n    EditorState.allowMultipleSelections.of(true),\n    indentOnInput(),\n    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n    bracketMatching(),\n    closeBrackets(),\n    autocompletion(),\n    rectangularSelection(),\n    crosshairCursor(),\n    highlightActiveLine(),\n    highlightSelectionMatches(),\n    keymap.of([\n        ...closeBracketsKeymap,\n        ...defaultKeymap,\n        ...searchKeymap,\n        ...historyKeymap,\n        ...foldKeymap,\n        ...completionKeymap,\n        ...lintKeymap\n    ])\n])();\n/**\nA minimal set of extensions to create a functional editor. Only\nincludes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo\nhistory](https://codemirror.net/6/docs/ref/#commands.history), [special character\nhighlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection\ndrawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight\nstyle](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).\n*/\nconst minimalSetup = /*@__PURE__*/(() => [\n    highlightSpecialChars(),\n    history(),\n    drawSelection(),\n    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n    keymap.of([\n        ...defaultKeymap,\n        ...historyKeymap,\n    ])\n])();\n\nexport { basicSetup, minimalSetup };\n"],"names":["crelt","elt","arguments","document","createElement","i","next","nodeType","Array","isArray","name","Object","prototype","hasOwnProperty","call","value","setAttribute","length","add","child","appendChild","createTextNode","RangeError","basicNormalize","String","normalize","x","SearchCursor","constructor","text","query","from","to","test","this","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","peek","codePointAt","pop","nextOverlapping","str","fromCodePoint","start","codePointSize","norm","pos","code","charCodeAt","match","end","index","keep","splice","push","Symbol","iterator","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","toCharEnd","getLine","skip","lineBreak","slice","nextLine","off","lastIndex","flattened","WeakMap","FlattenedDoc","get","doc","cached","flat","sliceString","set","cachedFrom","chunkEnd","line","createLineDialog","view","input","class","state","selection","main","head","number","go","sign","ln","cl","percent","col","pc","lines","Math","round","docLine","max","min","EditorSelection","cursor","dispatch","effects","dialogEffect","of","EditorView","scrollIntoView","y","focus","dom","onkeydown","event","keyCode","preventDefault","onsubmit","phrase","type","StateEffect","define","dialogField","StateField","create","update","tr","e","is","provide","f","showPanel","val","baseTheme$1","baseTheme","padding","fontSize","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","wholeWords","highlightConfig","Facet","combine","combineConfig","a","b","matchDeco","Decoration","mark","mainMatchDeco","insideWordBoundaries","check","sliceDoc","CharCategory","Word","matchHighlighter","ViewPlugin","fromClass","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","word","wordAt","charCategorizer","len","insideWord","deco","part","visibleRanges","v","defaultTheme","backgroundColor","searchConfigFacet","configs","top","caseSensitive","literal","regexp","wholeWord","createPanel","SearchPanel","scrollToMatch","SearchQuery","config","search","replace","valid","source","_a","validRegExp","unquoted","unquote","_","ch","eq","other","RegExpQuery","StringQuery","getCursor","st","EditorState","regexpCursor","stringCursor","QueryType","spec","undefined","toLowerCase","categorizer","buf","bufPos","charBefore","charAfter","super","nextMatch","curFrom","curTo","prevMatchInRange","prevMatch","getReplacement","_result","matchAll","limit","highlight","_from","_to","findClusterBreak","size","result","m","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","panel","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","field","startState","builder","RangeSetBuilder","l","selected","some","r","finish","searchCommand","openSearchPanel","findNext","single","announceMatch","userEvent","selectSearchInput","findPrevious","prev","selectMatches","map","replaceNext","readOnly","replacement","changes","toText","insert","announce","replaceAll","announceText","fallback","_b","_c","_d","_e","selText","getSearchInput","getPanel","querySelector","root","activeElement","select","searchInput","appendConfig","searchExtensions","closeSearchPanel","contains","searchKeymap","key","run","scope","shift","cur","newSel","mainIndex","selectWord","searchedText","fullWord","cycled","findNextOccurrence","addRange","button","onclick","content","commit","bind","searchField","placeholder","form","onchange","onkeyup","replaceField","caseField","checked","reField","wordField","keydown","runScopeHandlers","target","shiftKey","transactions","setQuery","mount","AnnounceMargin","Break","lineEnd","position","right","border","font","margin","marginRight","whiteSpace","Prec","low","SelectedDiagnostic","diagnostic","LintState","diagnostics","init","markedDiagnostics","diagnosticFilter","lintConfig","markerFilter","d","widget","DiagnosticWidget","attributes","severity","markClass","inclusive","findDiagnostic","after","found","between","setDiagnosticsEffect","movePanelSelection","lintState","mapped","selPos","mapPos","LintPanel","open","s","activeMark","lintTooltip","side","stackStart","stackEnd","tooltipFilter","above","diagnosticsTooltip","renderDiagnostic","closeLintPanel","lintKeymap","concat","lintExtensions","anchor","assign","sources","filter","delay","needsRefresh","u","assignKeys","actions","assigned","c","inPanel","keys","renderMessage","message","action","fired","click","apply","keyIndex","indexOf","nameElt","onmousedown","WidgetType","toDOM","PanelItem","id","floor","random","toString","items","list","tabIndex","role","moveSelection","selectedIndex","toUpperCase","needsSync","newSelectedItem","_start","_end","item","j","hasAttribute","removeAttribute","requestMeasure","read","getBoundingClientRect","write","scaleY","height","offsetHeight","scrollTop","bottom","sync","domPos","firstChild","rm","nextSibling","remove","parentNode","insertBefore","underline","color","attrs","encodeURIComponent","svg","marginLeft","display","borderLeft","borderRadius","opacity","backgroundPosition","backgroundRepeat","paddingBottom","backgroundImage","left","borderRight","borderBottom","borderBottomColor","maxHeight","overflowY","textDecoration","background_fallback","color_fallback","background","compute","hoverTooltip","hideOn","tooltip","touchesRange","basicSetup","lineNumbers","highlightActiveLineGutter","highlightSpecialChars","history","foldGutter","drawSelection","dropCursor","allowMultipleSelections","indentOnInput","syntaxHighlighting","defaultHighlightStyle","bracketMatching","closeBrackets","autocompletion","rectangularSelection","crosshairCursor","highlightActiveLine","keymap","closeBracketsKeymap","defaultKeymap","historyKeymap","foldKeymap","completionKeymap","minimalSetup"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}