{"version":3,"file":"codemirror_lang-python-Cxoc-ydj.js","sources":["../node_modules/@lezer/lr/dist/index.js","../node_modules/@lezer/python/dist/index.js","../node_modules/@codemirror/lang-python/dist/index.js"],"sourcesContent":["import { Parser, NodeProp, NodeSet, NodeType, DefaultBufferLength, Tree, IterMode } from '@lezer/common';\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parse that this stack is part of @internal\n    */\n    p, \n    /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */\n    stack, \n    /**\n    The current parse state @internal\n    */\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */\n    reducePos, \n    /**\n    The input position up to which this stack has parsed.\n    */\n    pos, \n    /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */\n    bufferBase, \n    /**\n    @internal\n    */\n    curContext, \n    /**\n    @internal\n    */\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */\n    shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */\n    apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */\n    restart() {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */\n    get parser() { return this.p.parser; }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    input, \n    /**\n    @internal\n    */\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */\n        this.chunk = \"\";\n        /**\n        @internal\n        */\n        this.chunkOff = 0;\n        /**\n        Backup chunk\n        */\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */\n        this.next = -1;\n        /**\n        @internal\n        */\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsing—when looking forward—or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */\n    acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (!atEof)\n                skipped++;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Safety.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */)\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n    /**\n    Define a context tracker.\n    */\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends Parser {\n    /**\n    @internal\n    */\n    constructor(spec) {\n        super();\n        /**\n        @internal\n        */\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /**\n    @internal\n    */\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /**\n    @internal\n    */\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /**\n    @internal\n    */\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */\n    get eofTerm() { return this.maxNode + 1; }\n    /**\n    The type of top node produced by the parser.\n    */\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /**\n    @internal\n    */\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, LocalTokenGroup, Stack };\n","import { ExternalTokenizer, ContextTracker, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst printKeyword = 1,\n  indent = 206,\n  dedent = 207,\n  newline$1 = 208,\n  blankLineStart = 209,\n  newlineBracketed = 210,\n  eof = 211,\n  formatString1Content = 212,\n  formatString1Brace = 2,\n  formatString1End = 213,\n  formatString2Content = 214,\n  formatString2Brace = 3,\n  formatString2End = 215,\n  formatString1lContent = 216,\n  formatString1lBrace = 4,\n  formatString1lEnd = 217,\n  formatString2lContent = 218,\n  formatString2lBrace = 5,\n  formatString2lEnd = 219,\n  ParenL = 26,\n  ParenthesizedExpression = 27,\n  TupleExpression = 51,\n  ComprehensionExpression = 52,\n  BracketL = 57,\n  ArrayExpression = 58,\n  ArrayComprehensionExpression = 59,\n  BraceL = 61,\n  DictionaryExpression = 62,\n  DictionaryComprehensionExpression = 63,\n  SetExpression = 64,\n  SetComprehensionExpression = 65,\n  ArgList = 67,\n  subscript = 256,\n  FormatString = 74,\n  importList = 275,\n  TypeParamList = 120,\n  ParamList = 138,\n  SequencePattern = 159,\n  MappingPattern = 160,\n  PatternArgList = 163;\n\nconst newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46,\n      braceOpen = 123, singleQuote = 39, doubleQuote = 34, backslash = 92;\n\nconst bracketed = new Set([\n  ParenthesizedExpression, TupleExpression, ComprehensionExpression, importList, ArgList, ParamList,\n  ArrayExpression, ArrayComprehensionExpression, subscript,\n  SetExpression, SetComprehensionExpression, FormatString,\n  DictionaryExpression, DictionaryComprehensionExpression,\n  SequencePattern, MappingPattern, PatternArgList, TypeParamList\n]);\n\nfunction isLineBreak(ch) {\n  return ch == newline || ch == carriageReturn\n}\n\nconst newlines = new ExternalTokenizer((input, stack) => {\n  let prev;\n  if (input.next < 0) {\n    input.acceptToken(eof);\n  } else if (stack.context.depth < 0) {\n    if (isLineBreak(input.next)) input.acceptToken(newlineBracketed, 1);\n  } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) &&\n             stack.canShift(blankLineStart)) {\n    let spaces = 0;\n    while (input.next == space || input.next == tab) { input.advance(); spaces++; }\n    if (input.next == newline || input.next == carriageReturn || input.next == hash)\n      input.acceptToken(blankLineStart, -spaces);\n  } else if (isLineBreak(input.next)) {\n    input.acceptToken(newline$1, 1);\n  }\n}, {contextual: true});\n\nconst indentation = new ExternalTokenizer((input, stack) => {\n  let cDepth = stack.context.depth;\n  if (cDepth < 0) return\n  let prev = input.peek(-1);\n  if (prev == newline || prev == carriageReturn) {\n    let depth = 0, chars = 0;\n    for (;;) {\n      if (input.next == space) depth++;\n      else if (input.next == tab) depth += 8 - (depth % 8);\n      else break\n      input.advance();\n      chars++;\n    }\n    if (depth != cDepth &&\n        input.next != newline && input.next != carriageReturn && input.next != hash) {\n      if (depth < cDepth) input.acceptToken(dedent, -chars);\n      else input.acceptToken(indent);\n    }\n  }\n});\n\nfunction IndentLevel(parent, depth) {\n  this.parent = parent;\n  // -1 means this is not an actual indent level but a set of brackets\n  this.depth = depth;\n  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);\n}\n\nconst topIndent = new IndentLevel(null, 0);\n\nfunction countIndent(space) {\n  let depth = 0;\n  for (let i = 0; i < space.length; i++)\n    depth += space.charCodeAt(i) == tab ? 8 - (depth % 8) : 1;\n  return depth\n}\n\nconst trackIndent = new ContextTracker({\n  start: topIndent,\n  reduce(context, term) {\n    return context.depth < 0 && bracketed.has(term) ? context.parent : context\n  },\n  shift(context, term, stack, input) {\n    if (term == indent) return new IndentLevel(context, countIndent(input.read(input.pos, stack.pos)))\n    if (term == dedent) return context.parent\n    if (term == ParenL || term == BracketL || term == BraceL) return new IndentLevel(context, -1)\n    return context\n  },\n  hash(context) { return context.hash }\n});\n\nconst legacyPrint = new ExternalTokenizer(input => {\n  for (let i = 0; i < 5; i++) {\n    if (input.next != \"print\".charCodeAt(i)) return\n    input.advance();\n  }\n  if (/\\w/.test(String.fromCharCode(input.next))) return\n  for (let off = 0;; off++) {\n    let next = input.peek(off);\n    if (next == space || next == tab) continue\n    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)\n      input.acceptToken(printKeyword);\n    return\n  }\n});\n\nfunction formatString(quote, len, content, brace, end) {\n  return new ExternalTokenizer(input => {\n    let start = input.pos;\n    for (;;) {\n      if (input.next < 0) {\n        break\n      } else if (input.next == braceOpen) {\n        if (input.peek(1) == braceOpen) {\n          input.advance(2);\n        } else {\n          if (input.pos == start) {\n            input.acceptToken(brace, 1);\n            return\n          }\n          break\n        }\n      } else if (input.next == backslash) {\n        input.advance();\n        if (input.next >= 0) input.advance();\n      } else if (input.next == quote && (len == 1 || input.peek(1) == quote && input.peek(2) == quote)) {\n        if (input.pos == start) {\n          input.acceptToken(end, len);\n          return\n        }\n        break\n      } else {\n        input.advance();\n      }\n    }\n    if (input.pos > start) input.acceptToken(content);\n  })\n}\n\nconst formatString1 = formatString(singleQuote, 1, formatString1Content, formatString1Brace, formatString1End);\nconst formatString2 = formatString(doubleQuote, 1, formatString2Content, formatString2Brace, formatString2End);\nconst formatString1l = formatString(singleQuote, 3, formatString1lContent, formatString1lBrace, formatString1lEnd);\nconst formatString2l = formatString(doubleQuote, 3, formatString2lContent, formatString2lBrace, formatString2lEnd);\n\nconst pythonHighlighting = styleTags({\n  \"async \\\"*\\\" \\\"**\\\" FormatConversion FormatSpec\": tags.modifier,\n  \"for while if elif else try except finally return raise break continue with pass assert await yield match case\": tags.controlKeyword,\n  \"in not and or is del\": tags.operatorKeyword,\n  \"from def class global nonlocal lambda\": tags.definitionKeyword,\n  import: tags.moduleKeyword,\n  \"with as print\": tags.keyword,\n  Boolean: tags.bool,\n  None: tags.null,\n  VariableName: tags.variableName,\n  \"CallExpression/VariableName\": tags.function(tags.variableName),\n  \"FunctionDefinition/VariableName\": tags.function(tags.definition(tags.variableName)),\n  \"ClassDefinition/VariableName\": tags.definition(tags.className),\n  PropertyName: tags.propertyName,\n  \"CallExpression/MemberExpression/PropertyName\": tags.function(tags.propertyName),\n  Comment: tags.lineComment,\n  Number: tags.number,\n  String: tags.string,\n  FormatString: tags.special(tags.string),\n  UpdateOp: tags.updateOperator,\n  \"ArithOp!\": tags.arithmeticOperator,\n  BitOp: tags.bitwiseOperator,\n  CompareOp: tags.compareOperator,\n  AssignOp: tags.definitionOperator,\n  Ellipsis: tags.punctuation,\n  At: tags.meta,\n  \"( )\": tags.paren,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace,\n  \".\": tags.derefOperator,\n  \", ;\": tags.separator\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,await:48, or:58, and:60, in:64, not:66, is:68, if:74, else:76, lambda:80, yield:98, from:100, async:106, for:108, None:178, True:180, False:180, del:194, pass:198, break:202, continue:206, return:210, raise:218, import:222, as:224, global:228, nonlocal:230, assert:234, type:239, elif:252, while:256, try:262, except:264, finally:266, with:270, def:274, class:284, match:295, case:301};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"#)WO`Q#yOOP$bOSOOO%kQ&nO'#HhOOQS'#Cq'#CqOOQS'#Cr'#CrO'ZQ#xO'#CpO(|Q&nO'#HgOOQS'#Hh'#HhOOQS'#DW'#DWOOQS'#Hg'#HgO)jQ#xO'#DaO)}Q#xO'#DhO*_Q#xO'#DlOOQS'#Dw'#DwO*rO,UO'#DwO*zO7[O'#DwO+SOWO'#DxO+_O`O'#DxO+jOpO'#DxO+uO!bO'#DxO-wQ&nO'#HXOOQS'#HX'#HXO'ZQ#xO'#HWO/ZQ&nO'#HWOOQS'#Ej'#EjO/rQ#xO'#EkOOQS'#HV'#HVO/|Q#xO'#HUOOQV'#HU'#HUO0XQ#xO'#FbOOQS'#Gj'#GjO0^Q#xO'#FaOOQV'#I_'#I_OOQV'#HT'#HTOOQV'#Fy'#FyQ`Q#yOOO'ZQ#xO'#CsO0lQ#xO'#DPO0sQ#xO'#DTO1RQ#xO'#HlO1cQ&nO'#E_O'ZQ#xO'#E`OOQS'#Eb'#EbOOQS'#Ed'#EdOOQS'#Ef'#EfO1wQ#xO'#EhO2_Q#xO'#ElO0XQ#xO'#EnO2rQ&nO'#EnO0XQ#xO'#EqO/rQ#xO'#EtO0XQ#xO'#EvO/rQ#xO'#E|O/rQ#xO'#FPO2}Q#xO'#FRO3UQ#xO'#FWO3aQ#xO'#FSO/rQ#xO'#FWO0XQ#xO'#FYO0XQ#xO'#F_O3fQ#xO'#FdP3mO#xO'#HSPOOO)CBv)CBvOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO3xQ#xO'#DqOOQS,5:[,5:[O4]Q#xO'#HvOOQS,5:_,5:_O4jQMlO,5:_O4oQ&nO,59[O0lQ#xO,59dO0lQ#xO,59dO0lQ#xO,59dO7_Q#xO,59dO7dQ#xO,59dO7kQ#xO,59lO7rQ#xO'#HgO8xQ#xO'#HfOOQS'#Hf'#HfOOQS'#D^'#D^O9aQ#xO,59cO'ZQ#xO,59cO9oQ#xO,59cOOQS,59{,59{O9tQ#xO,5:TO'ZQ#xO,5:TOOQS,5:S,5:SO:SQ#xO,5:SO:XQ#xO,5:ZO'ZQ#xO,5:ZO'ZQ#xO,5:XOOQS,5:W,5:WO:jQ#xO,5:WO:oQ#xO,5:YOOOO'#GR'#GRO:tO,UO,5:cOOQS,5:c,5:cOOOO'#GS'#GSO:|O7[O,5:cO;UQ#xO'#DyOOOW'#GT'#GTO;fOWO,5:dOOQS,5:d,5:dO;UQ#xO'#EPOOO`'#GW'#GWO;qO`O,5:dO;UQ#xO'#EROOOp'#GX'#GXO;|OpO,5:dO;UQ#xO'#ETOOO!b'#GY'#GYO<XO!bO,5:dOOQS'#GZ'#GZO<dQ&nO,5:qO?UQ&nO,5=rO?oQ!LUO,5=rO@`Q&nO,5=rOOQS,5;V,5;VO@wQ#yO'#GdOBZQ#xO,5;fOOQV,5=p,5=pOBfQ&nO'#IYOB}Q#xO,5;|OOQS-E:h-E:hOOQV,5;{,5;{O3[Q#xO'#FYOOQV-E9w-E9wOCVQ&nO,59_OE^Q&nO,59kOEwQ#xO'#HiOFSQ#xO'#HiO0XQ#xO'#HiOF_Q#xO'#DVOFgQ#xO,59oOFlQ#xO'#HmO'ZQ#xO'#HmO/rQ#xO,5>WOOQS,5>W,5>WO/rQ#xO'#EZOOQS'#E['#E[OGZQ#xO'#G]OGkQ#xO,59OOGkQ#xO,59OO)pQ#xO,5:wOGyQ&nO'#HoOOQS,5:z,5:zOOQS,5;S,5;SOH^Q#xO,5;WOHoQ#xO,5;YOOQS'#G`'#G`OH}Q&nO,5;YOI]Q#xO,5;YOIbQ#xO'#I]OOQS,5;],5;]OIpQ#xO'#IXOOQS,5;`,5;`OJRQ#xO,5;bO3aQ#xO,5;hO3aQ#xO,5;kOJZQ&nO'#I`O'ZQ#xO'#I`OJeQ#xO,5;mO2}Q#xO,5;mO/rQ#xO,5;rO0XQ#xO,5;tOJjQ#yO'#E}OKvQ#{O,5;nO! [Q#xO'#IaO3aQ#xO,5;rO! gQ#xO,5;tO! oQ#xO,5;yO! zQ&nO,5<OO'ZQ#xO,5<OPOOO,5=n,5=nP!!ROSO,5=nP!!WO#xO,5=nO!${Q&nO1G.lO!%SQ&nO1G.lO!'sQ&nO1G.lO!'}Q&nO1G.lO!*hQ&nO1G.lO!*{Q&nO1G.lO!+`Q#xO'#HuO!+nQ&nO'#HXO/rQ#xO'#HuO!+xQ#xO'#HtOOQS,5:],5:]O!,QQ#xO,5:]O!,VQ#xO'#HwO!,bQ#xO'#HwO!,uQ#xO,5>bOOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-uQ&nO1G/OO!-|Q&nO1G/OO0lQ#xO1G/OO!.iQ#xO1G/WOOQS'#D]'#D]O/rQ#xO,59vOOQS1G.}1G.}O!.pQ#xO1G/gO!/QQ#xO1G/gO!/YQ#xO1G/hO'ZQ#xO'#HnO!/_Q#xO'#HnO!/dQ&nO1G.}O!/tQ#xO,59kO!0zQ#xO,5>^O!1[Q#xO,5>^O!1dQ#xO1G/oO!1iQ&nO1G/oOOQS1G/n1G/nO!1yQ#xO,5>XO!2pQ#xO,5>XO/rQ#xO1G/sO!3_Q#xO1G/uO!3dQ&nO1G/uO!3tQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E:P-E:POOQS1G/}1G/}OOOO-E:Q-E:QO!4UQ#xO'#IRO/rQ#xO'#IRO!4gQ#xO,5:eOOOW-E:R-E:ROOQS1G0O1G0OO!4uQ#xO,5:kOOO`-E:U-E:UO!5TQ#xO,5:mOOOp-E:V-E:VO!5cQ#xO,5:oOOO!b-E:W-E:WOOQS-E:X-E:XO!5qQ!LUO1G3^O!6bQ&nO1G3^O'ZQ#xO,5<vOOQS,5<v,5<vOOQS-E:Y-E:YOOQS,5=O,5=OOOQS-E:b-E:bOOQV1G1Q1G1QO0XQ#xO'#G_O!6yQ&nO,5>tOOQS1G1h1G1hO!7bQ#xO1G1hOOQS'#DX'#DXO/rQ#xO,5>TOOQS,5>T,5>TO!7gQ#xO'#FzO!7rQ#xO,59qO!7zQ#xO1G/ZO!8UQ&nO,5>XOOQS1G3r1G3rOOQS,5:u,5:uO!8uQ#xO'#HWOOQS,5<w,5<wOOQS-E:Z-E:ZO!9WQ#xO1G.jOOQS1G0c1G0cO!9fQ#xO,5>ZO!9vQ#xO,5>ZO/rQ#xO1G0rO/rQ#xO1G0rO0XQ#xO1G0tOOQS-E:^-E:^O!:XQ#xO1G0tO!:dQ#xO1G0tO!:iQ#xO,5>wO!:wQ#xO,5>wO!;VQ#xO,5>sO!;mQ#xO,5>sO!<OQ#xO'#ExO/rQ#xO1G0|O!<ZQ#xO1G0|O!<`Q#{O1G1SO!?qQ#{O1G1VO!CPQ#xO,5>zO!CZQ#xO,5>zO!CcQ&nO,5>zO/rQ#xO1G1XO!CmQ#xO1G1XO3aQ#xO1G1^O! gQ#xO1G1`OOQV,5;i,5;iO!CrQ#zO,5;iO!CwQ#{O1G1YO!G]Q#xO'#GgO3aQ#xO1G1YO3aQ#xO1G1YO!GmQ#xO,5>{O!GzQ#xO,5>{O0XQ#xO,5>{OOQV1G1^1G1^O!HSQ#xO'#F[O!HeQMlO1G1`O!HmQ#xO1G1`OOQV1G1e1G1eO3aQ#xO1G1eO!HrQ#xO1G1eO!HzQ#xO'#FfOOQV1G1j1G1jO! zQ&nO1G1jPOOO1G3Y1G3YP!IPOSO1G3YOOQS,5>a,5>aOOQS'#Dr'#DrO/rQ#xO,5>aO!IUQ#xO,5>`O!IiQ#xO,5>`OOQS1G/w1G/wO!IqQ#xO,5>cO!JRQ#xO,5>cO!JZQ#xO,5>cO!JnQ#xO,5>cO!KOQ#xO,5>cOOQS1G3|1G3|OOQS7+$j7+$jO!7zQ#xO7+$rO!LqQ#xO1G/OO!LxQ#xO1G/OOOQS1G/b1G/bOOQS,5<h,5<hO'ZQ#xO,5<hOOQS7+%R7+%RO!MPQ#xO7+%ROOQS-E9z-E9zOOQS7+%S7+%SO!MaQ#xO,5>YO'ZQ#xO,5>YOOQS7+$i7+$iO!MfQ#xO7+%RO!MnQ#xO7+%SO!MsQ#xO1G3xOOQS7+%Z7+%ZO!NTQ#xO1G3xO!N]Q#xO7+%ZOOQS,5<g,5<gO'ZQ#xO,5<gO!NbQ#xO1G3sOOQS-E9y-E9yO# XQ#xO7+%_OOQS7+%a7+%aO# gQ#xO1G3sO#!UQ#xO7+%aO#!ZQ#xO1G3yO#!kQ#xO1G3yO#!sQ#xO7+%_O#!xQ#xO,5>mO##cQ#xO,5>mO##cQ#xO,5>mOOQS'#Dz'#DzO##tO$ISO'#D|O#$PO#tO'#ISOOOW1G0P1G0PO#$UQ#xO1G0PO#$^Q#xO1G0POOQS'#EQ'#EQOOO`1G0V1G0VO#$iQ#xO1G0VO#$qQ#xO1G0VOOQS'#ES'#ESOOOp1G0X1G0XO#$|Q#xO1G0XO#%UQ#xO1G0XOOQS'#EU'#EUOOO!b1G0Z1G0ZO#%aQ#xO1G0ZO#%iQ#xO1G0ZO#%tQ!LUO7+(xO#&eQ&nO1G2bP#'OQ#xO'#G[OOQS,5<y,5<yOOQS-E:]-E:]OOQS7+'S7+'SOOQS1G3o1G3oOOQS,5<f,5<fOOQS-E9x-E9xOOQS7+$u7+$uO#']Q#xO,5=rO#'vQ#xO,5=rO#(XQ&nO,5<iO#(lQ#xO1G3uOOQS-E9{-E9{OOQS7+&^7+&^O#(|Q#xO7+&^OOQS7+&`7+&`O#)[Q#xO'#I[O0XQ#xO'#IZO#)pQ#xO7+&`OOQS,5<|,5<|O#){Q#xO1G4cOOQS-E:`-E:`OOQS,5<x,5<xO#*ZQ#xO1G4_OOQS-E:[-E:[O0XQ#xO'#EyO#*qQ#xO'#EyO#*|Q#xO'#I^O#+UQ#xO,5;dOOQS7+&h7+&hO/rQ#xO7+&hO#+ZQ#{O7+&nO!G`Q#xO'#GeO3aQ#xO7+&nO3aQ#xO7+&qO#.lQ&nO,5=QO'ZQ#xO,5=QO#.vQ#xO1G4fOOQS-E:d-E:dO#/QQ#xO1G4fO3aQ#xO7+&sO/rQ#xO7+&sOOQV7+&x7+&xO!HeQMlO7+&zO!HmQ#xO7+&zO`Q#yO1G1TOOQV-E:e-E:eO3aQ#xO7+&tO3aQ#xO7+&tOOQV,5=R,5=RO#/YQ#xO,5=RO!G`Q#xO,5=ROOQV7+&t7+&tO#/eQ#{O7+&tO#2sQ#xO,5=SO#3OQ#xO1G4gOOQS-E:f-E:fO#3]Q#xO1G4gO#3eQ#xO'#IcO#3sQ#xO'#IcO0XQ#xO'#IcOOQS'#Ic'#IcO#4OQ#xO'#IbOOQS,5;v,5;vO#4WQ#xO,5;vO/rQ#xO'#F^OOQV7+&z7+&zO3aQ#xO7+&zOOQV7+'P7+'PO3aQ#xO7+'PO#4]Q#zO,5<QOOQV7+'U7+'UPOOO7+(t7+(tO#4bQ#xO1G3{OOQS,5<k,5<kO#4pQ#xO1G3zOOQS-E9}-E9}O#5TQ#xO,5<lO#5`Q#xO,5<lO#5sQ#xO1G3}OOQS-E:O-E:OO#6TQ#xO1G3}O#6]Q#xO1G3}O#6mQ#xO1G3}O#6TQ#xO1G3}OOQS<<H^<<H^O#6xQ&nO1G2SOOQS<<Hm<<HmP#7VQ#xO'#F|O7kQ#xO1G3tO#7dQ#xO1G3tO#7iQ#xO<<HmOOQS<<Hn<<HnO#7yQ#xO7+)dOOQS<<Hu<<HuO#8ZQ&nO1G2RP#8zQ#xO'#F{O#9XQ#xO7+)eO#9iQ#xO7+)eO#9qQ#xO<<HyO#9vQ#xO7+)_OOQS<<H{<<H{O#:mQ#xO,5<jO'ZQ#xO,5<jOOQS-E9|-E9|OOQS<<Hy<<HyOOQS,5<p,5<pO/rQ#xO,5<pO#:rQ#xO1G4XOOQS-E:S-E:SO#;]Q#xO1G4XO;UQ#xO'#D}OOOO'#GV'#GVO#;nO$ISO,5:hOOO#l,5>n,5>nOOOW7+%k7+%kO#;yQ#xO7+%kOOO`7+%q7+%qO#<RQ#xO7+%qOOOp7+%s7+%sO#<ZQ#xO7+%sOOO!b7+%u7+%uO#<cQ#xO7+%uO#<kQ#xO1G3^O#=UQ#xO1G3^P'ZQ#xO'#F}O/rQ#xO<<IxO#=gQ#xO,5>vO#=xQ#xO,5>vO0XQ#xO,5>vO#>ZQ#xO,5>uOOQS<<Iz<<IzP0XQ#xO'#GbP/rQ#xO'#G^OOQS,5;e,5;eO#>`Q#xO,5>xO#>nQ#xO,5>xOOQS1G1O1G1OOOQS<<JS<<JSOOQV-E:c-E:cO3aQ#xO<<JYOOQV,5=P,5=PO3aQ#xO,5=POOQV<<JY<<JYOOQV<<J]<<J]O#>vQ&nO1G2lP#?QQ#xO'#GfO#?XQ#xO7+*QO#?cQ#{O<<J_O3aQ#xO<<J_OOQV<<Jf<<JfO3aQ#xO<<JfO!HeQMlO<<JfO#BqQ#{O7+&oOOQV<<J`<<J`O#B{Q#{O<<J`OOQV1G2m1G2mO0XQ#xO1G2mO#FZQ#xO1G2mO3aQ#xO<<J`O0XQ#xO1G2nP/rQ#xO'#GhO#FfQ#xO7+*RO#FsQ#xO7+*ROOQS'#F]'#F]O/rQ#xO,5>}O#F{Q#xO,5>}OOQS,5>},5>}O#GWQ#xO,5>|O#GiQ#xO,5>|OOQS1G1b1G1bOOQS,5;x,5;xOOQV<<Jk<<JkO#GqQ#xO1G1lOOQS7+)g7+)gP#GvQ#xO'#GPO#HWQ#xO1G2WO#HkQ#xO1G2WO#H{Q#xO1G2WP#IWQ#xO'#GQO#IeQ#xO7+)iO#IuQ#xO7+)iO#IuQ#xO7+)iO#I}Q#xO7+)iO#J_Q#xO7+)`O7kQ#xO7+)`OOQSAN>XAN>XO#JxQ#xO<<MPOOQSAN>eAN>eO/rQ#xO1G2UO#KYQ&nO1G2UP#KdQ#xO'#GOOOQS1G2[1G2[P#KqQ#xO'#GUO#LOQ#xO7+)sO#LiQ#xO,5:iOOOO-E:T-E:TOOOW<<IV<<IVOOO`<<I]<<I]OOOp<<I_<<I_OOO!b<<Ia<<IaO#LwQ#xO7+(xOOQSAN?dAN?dO#MbQ#xO,5<{O#MvQ#xO1G4bOOQS-E:_-E:_O#NXQ#xO1G4bOOQS1G4a1G4aOOQS,5<},5<}O#NjQ#xO1G4dOOQS-E:a-E:aOOQVAN?tAN?tOOQV1G2k1G2kO3aQ#xOAN?yO#NxQ#{OAN?yOOQVAN@QAN@QO3aQ#xOAN@QOOQV<<JZ<<JZO3aQ#xOAN?zO3aQ#xO7+(XOOQV7+(X7+(XO0XQ#xO7+(XOOQVAN?zAN?zOOQS7+(Y7+(YO$$WQ#xO<<MmOOQS1G4i1G4iO/rQ#xO1G4iOOQS,5=T,5=TO$$eQ#xO1G4hOOQS-E:g-E:gOOQU'#Gk'#GkO$$vQ#zO7+'WO$%RQ#xO'#FgO$%yQ#xO7+'rO$&ZQ#xO7+'rOOQS7+'r7+'rO$&fQ#xO<<MTO$&vQ#xO<<MTO$&vQ#xO<<MTO$'OQ#xO'#HpOOQS<<Lz<<LzO$'YQ#xO<<LzOOQS7+'p7+'pOOQS'#EO'#EOOOOO1G0T1G0TO$'sQ#xO1G0TO$'{Q#xO1G0TO0XQ#xO1G2gP0XQ#xO'#GaO$(WQ#xO7+)|O$(iQ#xO7+)|P!<OQ#xO'#GcOOQVG25eG25eO3aQ#xOG25eOOQVG25lG25lOOQVG25fG25fOOQV<<Ks<<KsO3aQ#xO<<KsOOQS7+*T7+*TP$(zQ#xO'#GiOOQU-E:i-E:iOOQV<<Jr<<JrO$)nQ&nO'#FiOOQS'#Fk'#FkO$*OQ#xO'#FjO$*pQ#xO'#FjOOQS'#Fj'#FjO$*uQ#xO'#IeO$%RQ#xO'#FqO$%RQ#xO'#FqO$+^Q#xO'#FrO$%RQ#xO'#FsO$+eQ#xO'#IfOOQS'#If'#IfO$,SQ#xO,5<ROOQS<<K^<<K^O$,[Q#xO<<K^O$,lQ#xOANBoO$,|Q#xOANBoO$-UQ#xO'#HqOOQS'#Hq'#HqO0sQ#xO'#DeO$-oQ#xO,5>[OOQSANBfANBfOOOO7+%o7+%oO$.WQ#xO7+%oOOQS7+(R7+(RO$.`Q#xO<<MhOOQVLD+PLD+POOQVANA_ANA_O4jQMlO'#GmO$.qQ&nO,5<[O$%RQ#xO'#FuOOQS,5<`,5<`OOQS'#Fl'#FlO$/cQ#xO,5<UO$/hQ#xO,5<UOOQS'#Fo'#FoO$%RQ#xO'#GlO$0YQ#xO,5<YO$0tQ#xO,5?PO$1UQ#xO,5?PO0XQ#xO,5<XO$1gQ#xO,5<]O$1lQ#xO,5<]O$%RQ#xO'#IgO$1qQ#xO'#IgO$1vQ#xO,5<^OOQS,5<_,5<_O'ZQ#xO'#FxOOQU1G1m1G1mO3aQ#xO1G1mOOQSAN@xAN@xO$1{Q#xOG28ZO$2]Q#xO,5:POOQS1G3v1G3vOOOO<<IZ<<IZOOQS,5=X,5=XOOQS-E:k-E:kO$2bQ&nO'#FiO$2iQ#xO'#IhO$2wQ#xO'#IhO$3PQ#xO,5<aOOQS1G1p1G1pO$3UQ#xO1G1pO$3ZQ#xO,5=WOOQS-E:j-E:jO$3uQ#xO,5=[O$4^Q#xO1G4kOOQS-E:n-E:nOOQS1G1s1G1sOOQS1G1w1G1wO$4nQ#xO,5?RO$%RQ#xO,5?ROOQS1G1x1G1xO$4|Q&nO,5<dOOQU7+'X7+'XO$'OQ#xO1G/kO$%RQ#xO,5<bO$5TQ#xO,5?SO$5[Q#xO,5?SOOQS1G1{1G1{OOQS7+'[7+'[P$%RQ#xO'#GpO$5dQ#xO1G4mO$5nQ#xO1G4mO$5vQ#xO1G4mOOQS7+%V7+%VO$6UQ#xO1G1|O$6dQ&nO'#FiO$6kQ#xO,5=ZOOQS,5=Z,5=ZO$6yQ#xO1G4nOOQS-E:m-E:mO$%RQ#xO,5=YO$7QQ#xO,5=YO$7VQ#xO7+*XOOQS-E:l-E:lO$7aQ#xO7+*XO$%RQ#xO,5<cP$%RQ#xO'#GoO$7iQ#xO1G2tO$%RQ#xO1G2tP$7wQ#xO'#GnO$8OQ#xO<<MsO$8YQ#xO1G1}O$8hQ#xO7+(`O7kQ#xO'#DPO7kQ#xO,59dO7kQ#xO,59dO7kQ#xO,59dO$8vQ&nO,5=rO7kQ#xO1G/OO/rQ#xO1G/ZO/rQ#xO7+$rP$9ZQ#xO'#G[O'ZQ#xO'#HWO$9hQ#xO,59dO$9mQ#xO,59dO$9tQ#xO,59oO$9yQ#xO1G/WO0sQ#xO'#DTO7kQ#xO,59l\",\n  stateData: \"$:[~O%uOS%jOSUOS%iPQ~OPiOXfOhtOjYOquOu!UOxvO!RwO!S!QO!V!XO!W!WO!ZZO!_[O!jeO!zeO!{eO!|eO#TyO#VzO#X{O#Z|O#]}O#a!OO#c!PO#f!RO#g!RO#i!SO#k!TO#t!VO#w!YO#{!ZO#}![O$S!]O$VmO$X!^O&RRO&SRO&WSO&XWO&m]O&n^O&q_O&t`O&xaO&ybO&zcO~O%i!_O~OX!fOa!fOc!gOj!nO!Z!pO!h!rO%|!aO%}!bO&O!cO&P!dO&Q!dO&R!eO&S!eO&T!fO&U!fO&V!fO~Om&[Xn&[Xo&[Xp&[Xq&[Xr&[Xu&[X|&[X}&[X#Q&[X#o&[X%h&[X%k&[X&^&[Xi&[X!V&[X!W&[X&_&[X!Y&[X!^&[X!S&[X#d&[Xv&[X!o&[X~P$gOhtOjYO!ZZO!_[O!jeO!zeO!{eO!|eO&RRO&SRO&WSO&XWO&m]O&n^O&q_O&t`O&xaO&ybO&zcO~O|&ZX}&ZX#o&ZX%h&ZX%k&ZX&^&ZX~Om!uOn!vOo!tOp!tOq!wOr!xOu!yO#Q&ZX~P(hOX#POi#ROq1`Ox1nO!RwO~P'ZOX#TOq1`Ox1nO!Y#UO~P'ZOX#XOc#YOq1`Ox1nO!^#ZO~P'ZO&o#^O&p#`O~O&r#aO&s#`O~OQ#cO%l#dO%m#fO~OR#gO%n#hO%o#fO~OS#jO%p#kO%q#fO~OT#mO%r#nO%s#fO~OX%{Xa%{Xc%{Xj%{Xm%{Xn%{Xo%{Xp%{Xq%{Xr%{Xu%{X|%{X!Z%{X!h%{X%|%{X%}%{X&O%{X&P%{X&Q%{X&R%{X&S%{X&T%{X&U%{X&V%{Xi%{X!V%{X!W%{X~O&m]O&n^O&q_O&t`O&xaO&ybO&zcO}%{X#Q%{X#o%{X%h%{X%k%{X&^%{X&_%{X!Y%{X!^%{X!S%{X#d%{Xv%{X!o%{X~P,QO|#sO}%zX#Q%zX#o%zX%h%zX%k%zX&^%zX~Oq1`Ox1nO~P'ZO#o#vO%h#xO%k#xO~O&XWO~O!V#}O#}![O$S!]O$VmO~OquO~P'ZOX$SOc$TO&XWO}yP~OX$XOq1`Ox1nO!S$YO~P'ZO}$[O#Q$aO&^$]O#o#RX%h#RX%k#RX~OX$XOq1`Ox1nO#o#[X%h#[X%k#[X~P'ZOq1`Ox1nO#o#`X%h#`X%k#`X~P'ZO!h$gO!z$gO&XWO~OX$rO~P'ZO!W$tO#{$uO#}$vO~O}$wO~OX%OO~P'ZOU%QO%h%PO%u%RO~OX%[Oc%[Oi%^Oq1`Ox1nO~P'ZOq1`Ox1nO}%aO~P'ZO&l%cO~Oc!gOj!nO!Z!pO!h!rOXdaadamdandaodapdaqdardauda|da}da#Qda#oda%hda%kda%|da%}da&Oda&Pda&Qda&Rda&Sda&Tda&Uda&Vda&^daida!Vda!Wda&_da!Yda!^da!Sda#ddavda!oda~Op%hO~Oq%hO~P'ZOq1`O~P'ZOm1bOn1cOo1aOp1aOq1jOr1kOu1oOi&ZX!V&ZX!W&ZX&_&ZX!Y&ZX!^&ZX!S&ZX#d&ZX!o&ZX~P(hO&_%jOi&YX|&YX!V&YX!W&YX!Y&YX}&YX~Oi%lO|%mO!V%qO!W%pO~Oi%lO~O|%tO!V%qO!W%pO!Y&fX~O!Y%xO~O|%yO}%{O!V%qO!W%pO!^&aX~O!^&PO~O!^&QO~O&o#^O&p&SO~O&r#aO&s&SO~OX&VOq1`Ox1nO!RwO~P'ZOQ#cO%l#dO%m&YO~OR#gO%n#hO%o&YO~OS#jO%p#kO%q&YO~OT#mO%r#nO%s&YO~OX!yaa!yac!yaj!yam!yan!yao!yap!yaq!yar!yau!ya|!ya}!ya!Z!ya!h!ya#Q!ya#o!ya%h!ya%k!ya%|!ya%}!ya&O!ya&P!ya&Q!ya&R!ya&S!ya&T!ya&U!ya&V!ya&^!yai!ya!V!ya!W!ya&_!ya!Y!ya!^!ya!S!ya#d!yav!ya!o!ya~P#yO|&bO}%za#Q%za#o%za%h%za%k%za&^%za~P$gOX&dOquOxvO}%za#Q%za#o%za%h%za%k%za&^%za~P'ZO|&bO}%za#Q%za#o%za%h%za%k%za&^%za~OPiOXfOquOxvO!RwO!S!QO#TyO#VzO#X{O#Z|O#]}O#a!OO#c!PO#f!RO#g!RO#i!SO#k!TO#o%WX%h%WX%k%WX~P'ZO#o#vO%h&iO%k&iO~O!h&jOj&|X%h&|X#d&|X#o&|X%k&|X#c&|X~Oj!nO%h&lO~Omgangaogapgaqgargauga|ga}ga#Qga#oga%hga%kga&^gaiga!Vga!Wga&_ga!Yga!^ga!Sga#dgavga!oga~P$gOusa|sa}sa#osa%hsa%ksa&^sa~Om!uOn!vOo!tOp!tOq!wOr!xO#Qsa~PDuO&^&nO|&]X}&]X~O&XWO|&]X}&]X~O|&qO}yX~O}&sO~O|%yO#o&aX%h&aX%k&aXi&aX}&aX!^&aX!o&aX&^&aX~OX1iOq1`Ox1nO!RwO~P'ZO&^$]O#oWa%hWa%kWa~O|&|O#o&cX%h&cX%k&cXp&cX~P$gO|'PO!S'OO#o#`a%h#`a%k#`a~O#d'QO#o#ba%h#ba%k#ba~O!h$gO!z$gO#c'SO&XWO~O#c'SO~O|'UO#o'PX%h'PX%k'PX~O|'WO#o&{X%h&{X%k&{X}&{X~O!Z'YO&^'ZO~O|'_Op'SX~P$gOp'bO~OPiOXfOquOxvO!RwO!S!QO#TyO#VzO#X{O#Z|O#]}O#a!OO#c!PO#f!RO#g!RO#i!SO#k!TO%h'gO~P'ZOv'kO#x'iO#y'jOP#vaX#vah#vaj#vaq#vau#vax#va!R#va!S#va!V#va!W#va!Z#va!_#va!j#va!z#va!{#va!|#va#T#va#V#va#X#va#Z#va#]#va#a#va#c#va#f#va#g#va#i#va#k#va#t#va#w#va#{#va#}#va$S#va$V#va$X#va%e#va&R#va&S#va&W#va&X#va&m#va&n#va&q#va&t#va&x#va&y#va&z#va%g#va%k#va~O|'lO#d'nO}'TX~Oj'pO!Z'YO~Oj!nO}$wO!Z'YO~O}'vO~P$gO%h'yO~OU'zO%h'yO~OX!fOa!fOc!gOj!nO!Z!pO!h!rO&O!cO&P!dO&Q!dO&R!eO&S!eO&T!fO&U!fO&V!fOmYinYioYipYiqYirYiuYi|Yi}Yi#QYi#oYi%hYi%kYi%|Yi&^YiiYi!VYi!WYi&_Yi!YYi!^Yi!SYi#dYivYi!oYi~O%}!bO~P!!`O%}Yi~P!!`OX!fOa!fOc!gOj!nO!Z!pO!h!rO&R!eO&S!eO&T!fO&U!fO&V!fOmYinYioYipYiqYirYiuYi|Yi}Yi#QYi#oYi%hYi%kYi%|Yi%}Yi&OYi&^YiiYi!VYi!WYi&_Yi!YYi!^Yi!SYi#dYivYi!oYi~O&P!dO&Q!dO~P!%ZO&PYi&QYi~P!%ZOc!gOj!nO!Z!pO!h!rOmYinYioYipYiqYirYiuYi|Yi}Yi#QYi#oYi%hYi%kYi%|Yi%}Yi&OYi&PYi&QYi&RYi&SYi&^YiiYi!VYi!WYi&_Yi!YYi!^Yi!SYi#dYivYi!oYi~OX!fOa!fO&T!fO&U!fO&V!fO~P!(XOXYiaYi&TYi&UYi&VYi~P!(XO!V%qO!W%pOi&iX|&iX~O&^'|O&_'|O~P,QO|(OOi&hX~Oi(QO~O|(RO}(TO!Y&kX~Oq1`Ox1nO|(RO}(UO!Y&kX~P'ZO!Y(WO~Oo!tOp!tOq!wOr!xOmliuli|li}li#Qli#oli%hli%kli&^li~On!vO~P!,zOnli~P!,zOm1bOn1cOo1aOp1aOq1jOr1kO~Ov(YO~P!.TOX(_Oi(`Oq1`Ox1nO~P'ZOi(`O|(aO~Oi(cO~O!W(eO~Oi(fO|(aO!V%qO!W%pO~P$gOm1bOn1cOo1aOp1aOq1jOr1kOisa!Vsa!Wsa&_sa!Ysa!^sa!Ssa#dsavsa!osa~PDuOX(_Oq1`Ox1nO!Y&fa~P'ZO|(iO!Y&fa~O!Y(jO~O|(iO!V%qO!W%pO!Y&fa~P$gOX(nOq1`Ox1nO!^&aa#o&aa%h&aa%k&aai&aa}&aa!o&aa&^&aa~P'ZO|(oO!^&aa#o&aa%h&aa%k&aai&aa}&aa!o&aa&^&aa~O!^(rO~O|(oO!V%qO!W%pO!^&aa~P$gO|(uO!V%qO!W%pO!^&ga~P$gO|(xO}&uX!^&uX!o&uX&^&uX~O}(|O!^)OO!o)PO&^({O~O}(|O!^)SO!o)TO&^)RO~O}(|O!^)WO!o)XO&^)VO~O}(|O!^)[O!o)]O&^)ZO~OX&dOquOxvO}%zi#Q%zi#o%zi%h%zi%k%zi&^%zi~P'ZO|)_O}%zi#Q%zi#o%zi%h%zi%k%zi&^%zi~O!h&jOj&|a%h&|a#d&|a#o&|a%k&|a#c&|a~O%h)dO~OX$SOc$TO&XWO~O|&qO}ya~OquOxvO~P'ZO|(oO#o&aa%h&aa%k&aai&aa}&aa!^&aa!o&aa&^&aa~P$gO|)iO#o%zX%h%zX%k%zX&^%zX~O&^$]O#oWi%hWi%kWi~O#o&ca%h&ca%k&cap&ca~P'ZO|)lO#o&ca%h&ca%k&cap&ca~OX)pOj)rO&XWO~O#c)sO~O&XWO#o'Pa%h'Pa%k'Pa~O|)uO#o'Pa%h'Pa%k'Pa~Oq1`Ox1nO#o&{a%h&{a%k&{a}&{a~P'ZO|)xO#o&{a%h&{a%k&{a}&{a~OX)zOc)zO&XWO~O&^*PO~Ov*SO#r*ROP#piX#pih#pij#piq#piu#pix#pi!R#pi!S#pi!V#pi!W#pi!Z#pi!_#pi!j#pi!z#pi!{#pi!|#pi#T#pi#V#pi#X#pi#Z#pi#]#pi#a#pi#c#pi#f#pi#g#pi#i#pi#k#pi#t#pi#w#pi#{#pi#}#pi$S#pi$V#pi$X#pi%e#pi&R#pi&S#pi&W#pi&X#pi&m#pi&n#pi&q#pi&t#pi&x#pi&y#pi&z#pi%g#pi%k#pi~Ov*TOP#siX#sih#sij#siq#siu#six#si!R#si!S#si!V#si!W#si!Z#si!_#si!j#si!z#si!{#si!|#si#T#si#V#si#X#si#Z#si#]#si#a#si#c#si#f#si#g#si#i#si#k#si#t#si#w#si#{#si#}#si$S#si$V#si$X#si%e#si&R#si&S#si&W#si&X#si&m#si&n#si&q#si&t#si&x#si&y#si&z#si%g#si%k#si~OX*VOp'Sa~P'ZO|*WOp'Sa~O|*WOp'Sa~P$gOp*[O~O%f*`O~Ov*cO#x'iO#y*bOP#viX#vih#vij#viq#viu#vix#vi!R#vi!S#vi!V#vi!W#vi!Z#vi!_#vi!j#vi!z#vi!{#vi!|#vi#T#vi#V#vi#X#vi#Z#vi#]#vi#a#vi#c#vi#f#vi#g#vi#i#vi#k#vi#t#vi#w#vi#{#vi#}#vi$S#vi$V#vi$X#vi%e#vi&R#vi&S#vi&W#vi&X#vi&m#vi&n#vi&q#vi&t#vi&x#vi&y#vi&z#vi%g#vi%k#vi~OX*fOq1`Ox1nO}$wO~P'ZOq1`Ox1nO}'Ta~P'ZO|*jO}'Ta~OX*nOc*oOi*rO&T*pO&XWO~O}$wO'W*tO~Oj'pO~Oj!nO}$wO~O%h*yO~O%h*{O~OX%[Oc%[Oq1`Ox1nOi&ha~P'ZO|+OOi&ha~Oq1`Ox1nO}+RO!Y&ka~P'ZO|+SO!Y&ka~Oq1`Ox1nO|+SO}+VO!Y&ka~P'ZOq1`Ox1nO|+SO!Y&ka~P'ZO|+SO}+VO!Y&ka~Oo1aOp1aOq1jOr1kOilimliuli|li!Vli!Wli&_li!Yli}li!^li#oli%hli%kli!Sli#dlivli!oli&^li~On1cO~P!KZOnli~P!KZOX(_Oi+[Oq1`Ox1nO~P'ZOp+^O~Oi+[O|+`O~Oi+aO~OX(_Oq1`Ox1nO!Y&fi~P'ZO|+bO!Y&fi~O!Y+cO~OX(nOq1`Ox1nO!^&ai#o&ai%h&ai%k&aii&ai}&ai!o&ai&^&ai~P'ZO|+fO!V%qO!W%pO!^&gi~O|+iO!^&ai#o&ai%h&ai%k&aii&ai}&ai!o&ai&^&ai~O!^+jO~Oc+lOq1`Ox1nO!^&gi~P'ZO|+fO!^&gi~O!^+nO~OX+pOq1`Ox1nO}&ua!^&ua!o&ua&^&ua~P'ZO|+qO}&ua!^&ua!o&ua&^&ua~O!_+tO&w+uO!^!pX~O!^+wO~O}(|O!^+xO~O}(|O!^+xO!o+yO~O}(|O!^+zO~O}(|O!^+zO!o+{O~O}(|O!^+|O~O}(|O!^+|O!o+}O~O}(|O!^,OO~O}(|O!^,OO!o,PO~OX&dOquOxvO}%zq#Q%zq#o%zq%h%zq%k%zq&^%zq~P'ZO|%Oi}%Oi#Q%Oi#o%Oi%h%Oi%k%Oi&^%Oi~P$gOX&dOquOxvO~P'ZOX&dOq1`Ox1nO#o%za%h%za%k%za&^%za~P'ZO|,QO#o%za%h%za%k%za&^%za~O|$qa#o$qa%h$qa%k$qap$qa~P$gO#o&ci%h&ci%k&cip&ci~P'ZO|,TO#o#`q%h#`q%k#`q~O|,UO#d,WO#o'OX%h'OX%k'OXi'OX~OX,YOj)rO&XWO~O&XWO#o'Pi%h'Pi%k'Pi~Oq1`Ox1nO#o&{i%h&{i%k&{i}&{i~P'ZO}$[O|#mX!Y#mX~O|,^O!Y'QX~O!Y,`O~Ov,cO#r*ROP#pqX#pqh#pqj#pqq#pqu#pqx#pq!R#pq!S#pq!V#pq!W#pq!Z#pq!_#pq!j#pq!z#pq!{#pq!|#pq#T#pq#V#pq#X#pq#Z#pq#]#pq#a#pq#c#pq#f#pq#g#pq#i#pq#k#pq#t#pq#w#pq#{#pq#}#pq$S#pq$V#pq$X#pq%e#pq&R#pq&S#pq&W#pq&X#pq&m#pq&n#pq&q#pq&t#pq&x#pq&y#pq&z#pq%g#pq%k#pq~Op%Ya|%Ya~P$gOX*VOp'Si~P'ZO|,jOp'Si~O|,tO}$wO#d,tO~O#y,vOP#vqX#vqh#vqj#vqq#vqu#vqx#vq!R#vq!S#vq!V#vq!W#vq!Z#vq!_#vq!j#vq!z#vq!{#vq!|#vq#T#vq#V#vq#X#vq#Z#vq#]#vq#a#vq#c#vq#f#vq#g#vq#i#vq#k#vq#t#vq#w#vq#{#vq#}#vq$S#vq$V#vq$X#vq%e#vq&R#vq&S#vq&W#vq&X#vq&m#vq&n#vq&q#vq&t#vq&x#vq&y#vq&z#vq%g#vq%k#vq~O#d,wO|%[a}%[a~Oq1`Ox1nO}'Ti~P'ZO|,yO}'Ti~O}$[O&^,{Oi'VX|'VX~O&XWOi'VX|'VX~O|-POi'UX~Oi-RO~O%f-UO~O!V%qO!W%pOi&ii|&ii~OX%[Oc%[Oq1`Ox1nOi&hi~P'ZO}-XO|$ta!Y$ta~Oq1`Ox1nO}-YO|$ta!Y$ta~P'ZOq1`Ox1nO}+RO!Y&ki~P'ZO|-]O!Y&ki~Oq1`Ox1nO|-]O!Y&ki~P'ZO|-]O}-`O!Y&ki~Oi$pi|$pi!Y$pi~P$gOX(_Oq1`Ox1nO~P'ZOp-bO~OX(_Oi-cOq1`Ox1nO~P'ZOX(_Oq1`Ox1nO!Y&fq~P'ZO|$oi!^$oi#o$oi%h$oi%k$oii$oi}$oi!o$oi&^$oi~P$gOX(nOq1`Ox1nO~P'ZOc+lOq1`Ox1nO!^&gq~P'ZO|-dO!^&gq~O!^-eO~OX(nOq1`Ox1nO!^&aq#o&aq%h&aq%k&aqi&aq}&aq!o&aq&^&aq~P'ZO}-fO~OX+pOq1`Ox1nO}&ui!^&ui!o&ui&^&ui~P'ZO|-kO}&ui!^&ui!o&ui&^&ui~O!_+tO&w+uO!^!pa~O}(|O!^-nO~O}(|O!^-oO~O}(|O!^-pO~O}(|O!^-qO~OX&dOq1`Ox1nO#o%zi%h%zi%k%zi&^%zi~P'ZO|-rO#o%zi%h%zi%k%zi&^%zi~O&XWO#o'Oa%h'Oa%k'Oai'Oa~O|-uO#o'Oa%h'Oa%k'Oai'Oa~Oi-xO~OX)zOc)zO&XWO!Y'Qa~O|-zO!Y'Qa~Op%Yi|%Yi~P$gOX*VO~P'ZOX*VOp'Sq~P'ZOv.OOP#uyX#uyh#uyj#uyq#uyu#uyx#uy!R#uy!S#uy!V#uy!W#uy!Z#uy!_#uy!j#uy!z#uy!{#uy!|#uy#T#uy#V#uy#X#uy#Z#uy#]#uy#a#uy#c#uy#f#uy#g#uy#i#uy#k#uy#t#uy#w#uy#{#uy#}#uy$S#uy$V#uy$X#uy%e#uy&R#uy&S#uy&W#uy&X#uy&m#uy&n#uy&q#uy&t#uy&x#uy&y#uy&z#uy%g#uy%k#uy~O%g.SO%k.SO~P`O#y.TOP#vyX#vyh#vyj#vyq#vyu#vyx#vy!R#vy!S#vy!V#vy!W#vy!Z#vy!_#vy!j#vy!z#vy!{#vy!|#vy#T#vy#V#vy#X#vy#Z#vy#]#vy#a#vy#c#vy#f#vy#g#vy#i#vy#k#vy#t#vy#w#vy#{#vy#}#vy$S#vy$V#vy$X#vy%e#vy&R#vy&S#vy&W#vy&X#vy&m#vy&n#vy&q#vy&t#vy&x#vy&y#vy&z#vy%g#vy%k#vy~O|.WO}$wO#d.WO~Oq1`Ox1nO}'Tq~P'ZO|.ZO}'Tq~O&^,{Oi'Va|'Va~OX*nOc*oO&T*pO&XWOi'Ua~O|._Oi'Ua~O$[.cO~OX%[Oc%[Oq1`Ox1nO~P'ZOq1`Ox1nO}.dO|$ti!Y$ti~P'ZOq1`Ox1nO|$ti!Y$ti~P'ZO}.dO|$ti!Y$ti~Oq1`Ox1nO}+RO~P'ZOq1`Ox1nO}+RO!Y&kq~P'ZO|.gO!Y&kq~Oq1`Ox1nO|.gO!Y&kq~P'ZOu.jO!V%qO!W%pOi&bq!Y&bq!^&bq|&bq~P!.TOc+lOq1`Ox1nO!^&gy~P'ZO|$ri!^$ri~P$gOc+lOq1`Ox1nO~P'ZOX+pOq1`Ox1nO~P'ZOX+pOq1`Ox1nO}&uq!^&uq!o&uq&^&uq~P'ZO}(|O!^.oO!o.pO&^.nO~OX&dOq1`Ox1nO#o%zq%h%zq%k%zq&^%zq~P'ZO#d.rO|%Ta#o%Ta%h%Ta%k%Tai%Ta~O&XWO#o'Oi%h'Oi%k'Oii'Oi~O|.tO#o'Oi%h'Oi%k'Oii'Oi~OX)zOc)zO&XWO!Y'Qi~Ov.xOP#u!RX#u!Rh#u!Rj#u!Rq#u!Ru#u!Rx#u!R!R#u!R!S#u!R!V#u!R!W#u!R!Z#u!R!_#u!R!j#u!R!z#u!R!{#u!R!|#u!R#T#u!R#V#u!R#X#u!R#Z#u!R#]#u!R#a#u!R#c#u!R#f#u!R#g#u!R#i#u!R#k#u!R#t#u!R#w#u!R#{#u!R#}#u!R$S#u!R$V#u!R$X#u!R%e#u!R&R#u!R&S#u!R&W#u!R&X#u!R&m#u!R&n#u!R&q#u!R&t#u!R&x#u!R&y#u!R&z#u!R%g#u!R%k#u!R~Oq1`Ox1nO}'Ty~P'ZOX*nOc*oO&T*pO&XWOi'Ui~O$[.cO%g/QO%k/QO~OX/[Oj/YO!Z/XO!_/ZO!j/TO!{/VO!|/VO&S/SO&XWO&m]O&n^O&q_O~Oq1`Ox1nO|$tq!Y$tq~P'ZO}/aO|$tq!Y$tq~Oq1`Ox1nO}+RO!Y&ky~P'ZO|/bO!Y&ky~Oq1`Ox/fO~P'ZOu.jO!V%qO!W%pOi&by!Y&by!^&by|&by~P!.TO}(|O!^/iO~O}(|O!^/iO!o/jO~O&XWO#o'Oq%h'Oq%k'Oqi'Oq~O|/lO#o'Oq%h'Oq%k'Oqi'Oq~OX*nOc*oO&T*pO&XWO~Oj/qO!h/oO|$]X#d$]X%|$]Xi$]X~Ou$]X}$]X!Y$]X!^$]X~P$)YO&R/sO&S/sOu$^X|$^X}$^X#d$^X%|$^X!Y$^Xi$^X!^$^X~O!j/uO~O|/yO#d/{O%|/vOu'XX}'XX!Y'XXi'XX~Oc0OO~P$%_Oj/qOu'YX|'YX}'YX#d'YX%|'YX!Y'YXi'YX!^'YX~Ou0SO}$wO~Oq1`Ox1nO|$ty!Y$ty~P'ZOq1`Ox1nO}+RO!Y&k!R~P'ZO|0WO!Y&k!R~Oi&eXu&eX!V&eX!W&eX!Y&eX!^&eX|&eX~P!.TOu.jO!V%qO!W%pOi&da!Y&da!^&da|&da~O}(|O!^0ZO~O&XWO#o'Oy%h'Oy%k'Oyi'Oy~O!h/oOj$dau$da|$da}$da#d$da%|$da!Y$dai$da!^$da~O!j0bO~O&R/sO&S/sOu$^a|$^a}$^a#d$^a%|$^a!Y$^ai$^a!^$^a~O%|/vOu$ba|$ba}$ba#d$ba!Y$bai$ba!^$ba~Ou'Xa}'Xa!Y'Xai'Xa~P$%RO|0gOu'Xa}'Xa!Y'Xai'Xa~O!Y0jO~Oi0jO~O}0lO~O!^0mO~Oq1`Ox1nO}+RO!Y&k!Z~P'ZO}0pO~O&^0qO~P$)YO|0rO#d/{O%|/vOi'[X~O|0rOi'[X~Oi0tO~O!j0uO~O#d/{Ou%`a|%`a}%`a%|%`a!Y%`ai%`a!^%`a~O#d/{O%|/vOu%da|%da}%da!Y%dai%da~Ou'Xi}'Xi!Y'Xii'Xi~P$%RO|0wO#d/{O%|/vO!^'Za~O}$la~P$gOi'[a~P$%RO|1POi'[a~Oc1RO!^'Zi~P$%_O|1TO!^'Zi~O|1TO#d/{O%|/vO!^'Zi~O#d/{O%|/vOi$ji|$ji~O&^1WO~P$)YO#d/{O%|/vOi%ca|%ca~Oi'[i~P$%RO}1ZO~Oc1RO!^'Zq~P$%_O|1]O!^'Zq~O#d/{O%|/vO|%bi!^%bi~Oc1RO~P$%_Oc1RO!^'Zy~P$%_O#d/{O%|/vOi$ki|$ki~O#d/{O%|/vO|%bq!^%bq~O|,QO#o%za%h%za%k%za&^%za~P$gOX&dOq1`Ox1nO~P'ZOp1eO~Oq1eO~P'ZO}1fO~Ov1gO~P!.TO&n&q&y&z&m&t&x&X&m~\",\n  goto: \"!@f']PPPPPPPP'^P'f+R+k,U,p-]-yP.hP'f/X/X'fPPP'f2tPPPPPP2t5kPP5kP8O8X>kPP>n?`?cPP'f'fPP?{PP'f'fPP'f'f'f'f'f@P@y'fP@|PASE^H}IRPIUIlIpIsIwIzJOJRJV'fPPPJYJc'^P'^'^P'^P'^P'^P'^P'^'^'^P'^PP'^PP'^P'^PJiJuJ}PKUK[PKUPKUKUPPPKUPMjPMsM}NTMjPKUN^PKUPNeNkPNo! T! r!!]NoNo!!c!!pNoNoNoNo!#U!#[!#_!#d!#g!#q!#w!$T!$g!$m!$w!$}!%k!%q!%w!%}!&X!&_!&e!&k!&q!&w!'Z!'e!'k!'q!'w!(R!(X!(_!(e!(k!(u!({!)V!)]!)f!)l!){!*T!*_!*fPPPPPPPPPPPPPPPPP!*l!*o!*u!+O!+Y!+ePPPPPPPPPPPP!0[!1p!5s!9WPP!9`!9r!9{!:t!:k!:}!;T!;W!;Z!;^!;f!<VPPPPPPPPP!<Y!<iPPPP!=m!=y!>V!>]!>f!>i!>l!>r!>x!?O!?RP!?Z!?d!@`!@c]jOs#v$w*`,p(TeOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1o}!hQ#r$P$b$q$}%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!P!iQ#r$P$b$q$}%S%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!R!jQ#r$P$b$q$}%S%T%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!T!kQ#r$P$b$q$}%S%T%U%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!V!lQ#r$P$b$q$}%S%T%U%V%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!X!mQ#r$P$b$q$}%S%T%U%V%W%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!]!mQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d(TTOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1o&iVOYZ[isuw}!O!S!U!V!Z!n!p!t!u!v!x!y#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%h%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)_)a)i)x*P*R*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+p+q+t,Q,T,[,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0W0p1`1a1b1c1e1f1g1h1k1o%sXOYZ[isw}!O!S!U!V!Z!n!p#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)_)a)i)x*P*R*[*`*f*j*t+O+R+S+V+]+`+b+e+f+i+p+q+t,Q,T,[,p,x,y,|-W-X-Y-[-]-`-d-f-h-j-k-r.Z.].d.g/a/b0W1f1g1hQ$VvQ0X/fR1l1n'zeOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1oW#ym!P!Q$hW$Rv&q/f1nQ$j!RQ$n!TQ${![Q$|!]W%Z!n(O+O-WS&p$S$TQ'e$vQ)b&jQ)p'QU)q'S)r)sU)t'U)u,ZW){'Y,^-z.vQ*l'nW*m'p-P._/OQ,])zS-O*n*oY-t,U-u.s.t/lQ-w,WQ.U,tQ.Y,wQ.|.Wl/R.c/X/Y/[/w/y0O0g0l0q0v1R1W1ZQ/k.rQ0P/ZQ0^/qQ0i/{U0|0r1P1XX1S0w1T1[1]R&o$R!_!|YZ!U!V!p%a%m%t(R(T(U(a(i*R+R+S+V+]+`+b-X-Y-[-]-`.d.g/a/b0WR%k!{Q#QYQ&W#cQ&Z#gQ&]#jQ&_#mQ&x$^Q&{$aR-l+tT/e.j0p![!oQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1dQ&m#zQ't$|R*x'uR'}%ZQ%d!rR0[/o(SdOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1oS#pd#q!P/V.c/X/Y/Z/[/q/w/y0O0g0l0q0r0v0w1P1R1T1W1X1Z1[1](SdOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1oT#pd#qT#d`#eR)Q&Wy(}&W&Z&]&_)P)Q)T)U)X)Y)])^+y+{+},P-l.p.q/jT+u(|+vR.q-lT#ha#iR)U&ZT#kb#lR)Y&]T#nc#oR)^&_Q$`xQ,]){R,}*mX$^x$_$`&zQ'[$nQ'r${Q'u$|R*_'eQ)|'YV-y,^-z.vZlOs$w*`,pXpOs*`,pQ$x!YQ']$oQ'^$pQ'o$zQ's$|Q*]'dQ*d'iQ*g'jQ*h'kQ*u'qS*w't'uQ,d*RQ,f*SQ,g*TQ,k*ZS,m*^*vQ,q*bQ,r*cS,s*e*fQ-T*xQ-|,cQ-},eQ.P,lS.Q,n,oQ.V,uQ.X,vQ.w.OQ.y.RQ.z.TQ.{.UQ/m.xQ/n.|Q0T/_R0o0UWpOs*`,pR#|oQ'q${S*^'e'rR,o*_Q,|*mR.],}Q*v'qQ,n*^R.R,oZnOos*`,pQ'w$}R*z'xT.a-U.bu/^.c/X/Y/[/q/w/y0O0g0l0q0r0v1P1R1W1X1Zt/^.c/X/Y/[/q/w/y0O0g0l0q0r0v1P1R1W1X1ZQ0P/ZX1S0w1T1[1]!P/U.c/X/Y/Z/[/q/w/y0O0g0l0q0r0v0w1P1R1T1W1X1Z1[1]Q/t/TR0c/ug/w/W/x0_0f0k0y0{0}1Y1^1_u/].c/X/Y/[/q/w/y0O0g0l0q0r0v1P1R1W1X1ZX/r/R/]0^0|R0`/qV1O0r1P1XR0U/_QsOS$Os,pR,p*`Q&r$UR)g&rS%z#W$WS(p%z(sT(s%}&tQ%n#OQ%u#SW(b%n%u(g(kQ(g%rR(k%wQ&}$bR)m&}Q(v&OQ+g(qT+m(v+gQ(P%]R+P(PS(S%`%aY+T(S+U-^.h/cU+U(T(U(VU-^+V+W+XS.h-_-`R/c.iQ#_^R&R#_Q#b_R&T#bQ#e`R&X#eQ(y&US+r(y+sR+s(zQ+v(|R-m+vQ#iaR&[#iQ#lbR&^#lQ#ocR&`#oQ#qdR&a#qQ#tgQ&c#rW&f#t&c)j,RQ)j&wR,R1dQ$_xS&y$_&zR&z$`Q'X$lR)y'XQ&k#yR)c&kQ$h!QR'R$hQ,V)qS-v,V.uR.u-wQ'V$jR)v'VQ,_)|R-{,_Q#wkR&h#wQ*Q']R,b*QQ'`$qS*X'`*YR*Y'aQ'h$xR*a'hQ'm$yS*k'm,zR,z*lQ-Q*qR.`-QWoOs*`,pR#{oQ.b-UR/P.bd/x/W0_0f0k0y0{0}1Y1^1_R0e/xU/p/R0^0|R0]/pQ0x0kS1U0x1VR1V0yS0s0_0`R1Q0sQ/z/WR0h/zR!`PXrOs*`,pWqOs*`,pR'f$wYkOs$w*`,pR&g#v[xOs#v$w*`,pR&x$^&hQOYZ[isuw}!O!S!U!V!Z!n!p!t!u!v!x!y#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%h%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)_)a)i)x*P*R*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+p+q+t,Q,T,[,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0W0p1`1a1b1c1e1f1g1h1k1oQ!sTQ#rfQ$PtU$by%p(eS$q!W$tQ$}!^Q%S!hQ%T!iQ%U!jQ%V!kQ%W!lQ%X!mQ%r#PQ%w#TQ%}#XQ&O#YQ&t$XQ'a$rQ'x%OQ)`&dU)k&|)l,SW*U'_*W,i,jQ+Z(_Q+d(nQ,h*VQ-g+lQ0n0SR1d1iQ#OYQ#SZQ$o!UQ$p!VQ%`!pQ(V%a^(^%m%t(a(i+]+`+b^+Q(R+S-[-].g/b0WQ+W(TQ+X(UQ,e*RQ-Z+RQ-_+VQ.e-XQ.f-YQ.i-`Q/`.dR0V/a[gOs#v$w*`,p!^!{YZ!U!V!p%a%m%t(R(T(U(a(i*R+R+S+V+]+`+b-X-Y-[-]-`.d.g/a/b0WQ#W[Q#uiS$Ww}Q$e!OW$l!S$a'b*[S$y!Z$uW%Y!n(O+O-WY&U#c#g#j#m+t`&e#s&b)_)a)i,Q-r1hQ&u$YQ&v$[Q&w$^Q'{%[Q(]%kW(m%y(o+e+iQ(q%{Q(z&VQ)e&oS)h&s1fQ)n'OQ)o'PU)w'W)x,[Q*O'ZQ*e'iY*i'l*j,x,y.ZQ*|'}S+Y(Y1gW+k(u+f-d-hW+o(x+q-j-kQ,a*PQ,u*fQ-S*tQ-i+pQ-s,TQ.[,|Q.m-fR.}.]hUOs#s#v$w&b&s(Y)_)a*`,p%Y!zYZ[iw}!O!S!U!V!Z!n!p#c#g#j#m$Y$[$^$a$u%[%a%k%m%t%y%{&V&o'O'P'W'Z'b'i'l'}(O(R(T(U(a(i(o(u(x)i)x*P*R*[*f*j*t+O+R+S+V+]+`+b+e+f+i+p+q+t,Q,T,[,x,y,|-W-X-Y-[-]-`-d-f-h-j-k-r.Z.].d.g/a/b0W1f1g1hQ$QuW%e!t!x1a1kQ%f!uQ%g!vQ%i!yQ%s1`S(X%h1eQ(Z1bQ([1cQ-a+^Q.l-bS/d.j0pR1m1oU$Uv/f1nR)f&q[hOs#v$w*`,pa!}Y#c#g#j#m$^$a+tQ#][Q$ZwR$d}Q%o#OQ%v#SQ%|#WQ'{%YQ(h%rQ(l%wQ(t%}Q(w&OQ+h(qQ-V*|Q.k-aQ/h.lR0Y/gQ$cyQ(d%pR+_(eQ/g.jR0z0pR#VZR#[[R%_!nQ%]!nV*}(O+O-W!]!qQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1dR%b!pQ&W#cQ&Z#gQ&]#jQ&_#mR-l+tQ)O&WQ)S&ZQ)W&]Q)[&_S+x)P)QS+z)T)US+|)X)YS,O)])^Q-n+yQ-o+{Q-p+}Q-q,PQ.o-lS/i.p.qR0Z/jQ$m!SQ&{$aQ*Z'bR,l*[Q#zmQ$f!PQ$i!QR'T$hQ)p'SR,Y)sQ)p'SQ,X)rR,Y)sR$k!RR)}'YXqOs*`,pQ$s!WR'c$tQ$z!ZR'd$uR*s'pQ*q'pV.^-P._/OQ/_.cQ/|/XR/}/YU/W.c/X/YQ0R/[Q0_/qQ0d/wU0f/y0g0vQ0k0OQ0y0lQ0{0qU0}0r1P1XQ1Y1RQ1^1WR1_1ZR0Q/ZR0a/q\",\n  nodeNames: \"⚠ print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc FormatReplacement FormatSelfDoc FormatReplacement FormatSelfDoc FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard\",\n  maxTerm: 288,\n  context: trackIndent,\n  nodeProps: [\n    [\"isolate\", -8,6,73,74,75,79,81,83,85,\"\"],\n    [\"group\", -15,8,93,95,96,98,100,102,104,106,107,108,110,113,116,118,\"Statement Statement\",-22,10,20,23,27,42,51,52,58,59,62,63,64,65,66,69,72,73,74,87,88,89,90,\"Expression\",-10,122,124,127,129,130,134,136,141,143,146,\"Statement\",-9,151,152,155,156,158,159,160,161,162,\"Pattern\"],\n    [\"openedBy\", 25,\"(\",56,\"[\",60,\"{\"],\n    [\"closedBy\", 26,\")\",57,\"]\",61,\"}\"]\n  ],\n  propSources: [pythonHighlighting],\n  skippedNodes: [0,6],\n  repeatNodeCount: 38,\n  tokenData: \"%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&w!b&oSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&w!b&oSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&w!b&oSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&w!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&w!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&w!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&w!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&w!b&rWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&w!b&rWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&w!b&rWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&w!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&w!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&w!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&w!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&oSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&oSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&rWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&rWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&w!b&oS&rW%u!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&w!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!oR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&w!b&oS&msOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&w!b&oS&rW&msOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&w!b&oS&msOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&w!b&rW&msOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&w!b&rW&msOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&w!b&rW&msOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&w!b&msOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&w!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&rW&msOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&msOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&rW&msOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&rW&msOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&w!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&oS&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&oS&msOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&oS&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&oS&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&w!b&oS&msOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&sW&w!b&oS&qsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&w!b&oS&rWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&w!b&oSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&w!b&oSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&w!b&oSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&w!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&w!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&w!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&w!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&oSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&w!b&rWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&w!b&rWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&w!b&rWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&w!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&w!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&w!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&rWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&w!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&oS&rWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&oSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&oSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&rWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&rWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_&UQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]#Qr&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_&OQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&w!b&rW&msOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&w!b&oS&rW&msOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&w!b&oS&msOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&w!b&oS&msOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&w!b&oS&msOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&w!b&msOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&w!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&oS&msOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&msOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&oS&msOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&oS&msOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&w!b&rW&msOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&w!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&oS&rW&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&oS&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&oS&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&rW&msOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&oS&rW&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&oS&rW&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&w!b&rW&msOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&pS&w!b&rW&nsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&w!b&oS&rWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_&Rs&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`&Ss&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]'W`&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!zs&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&w!b&oS&rWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja&TR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_&VQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&_R&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#os&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_&PQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&^s&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_&QQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ$VP&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&w!b&oS&rW&l`&XsOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&w!b&oS&rW&l`&XsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&w!b&oS&msOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&w!b&oS&msOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&w!b&oS&qsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&w!b&rW&msOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&w!b&rW&msOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&w!b&rW&nsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&w!b&oS&rW&l`&XsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&w!b&oS&rW&l`&XsOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&w!b&oS&xsOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&w!b&oSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&w!b&oS&zsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&w!b&rW&tsOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&w!b&rWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&w!b&rW&ysOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&w!b&oS&rW&l`&XsOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&w!b&oS&rW&l`&XsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%}Q&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%|R&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]&Wq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T\",\n  tokenizers: [legacyPrint, indentation, newlines, formatString1, formatString2, formatString1l, formatString2l, 0, 1, 2, 3, 4, 5, 6],\n  topRules: {\"Script\":[0,7]},\n  specialized: [{term: 239, get: (value) => spec_identifier[value] || -1}],\n  tokenPrec: 7500\n});\n\nexport { parser };\n","import { parser } from '@lezer/python';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Body\",\n    \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\",\n    \"ForStatement\", \"MatchClause\"\n]);\nfunction defID(type) {\n    return (node, def, outer) => {\n        if (outer)\n            return false;\n        let id = node.node.getChild(\"VariableName\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst gatherCompletions = {\n    FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n    ClassDefinition: /*@__PURE__*/defID(\"class\"),\n    ForStatement(node, def, outer) {\n        if (outer)\n            for (let child = node.node.firstChild; child; child = child.nextSibling) {\n                if (child.name == \"VariableName\")\n                    def(child, \"variable\");\n                else if (child.name == \"in\")\n                    break;\n            }\n    },\n    ImportStatement(_node, def) {\n        var _a, _b;\n        let { node } = _node;\n        let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n        for (let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n            if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\")\n                def(ch, isFrom ? \"variable\" : \"namespace\");\n        }\n    },\n    AssignStatement(node, def) {\n        for (let child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\")\n                def(child, \"variable\");\n            else if (child.name == \":\" || child.name == \"AssignOp\")\n                break;\n        }\n    },\n    ParamList(node, def) {\n        for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name)))\n                def(child, \"variable\");\n            prev = child;\n        }\n    },\n    CapturePattern: /*@__PURE__*/defID(\"variable\"),\n    AsPattern: /*@__PURE__*/defID(\"variable\"),\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name))\n                return false;\n            top = false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nconst globals = /*@__PURE__*/[\n    \"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\",\n    \"__loader__\", \"__package__\", \"__spec__\",\n    \"False\", \"None\", \"True\"\n].map(n => ({ label: n, type: \"constant\" })).concat(/*@__PURE__*/[\n    \"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\",\n    \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\",\n    \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\",\n    \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\",\n    \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\",\n    \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\",\n    \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\",\n    \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\",\n    \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\",\n    \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\",\n    \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\",\n    \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\",\n    \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\",\n    \"ValueError\", \"Warning\", \"ZeroDivisionError\"\n].map(n => ({ label: n, type: \"type\" }))).concat(/*@__PURE__*/[\n    \"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\",\n    \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"\n].map(n => ({ label: n, type: \"class\" }))).concat(/*@__PURE__*/[\n    \"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\",\n    \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\",\n    \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\",\n    \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\",\n    \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\",\n    \"sorted\", \"sum\", \"vars\", \"zip\"\n].map(n => ({ label: n, type: \"function\" })));\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"def ${name}(${params}):\\n\\t${}\", {\n        label: \"def\",\n        detail: \"function\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for ${name} in ${collection}:\\n\\t${}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while ${}:\\n\\t${}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n        label: \"try\",\n        detail: \"/ except block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t\\n\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${module}\", {\n        label: \"import\",\n        detail: \"statement\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"from ${module} import ${names}\", {\n        label: \"from\",\n        detail: \"import\",\n        type: \"keyword\"\n    })\n];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nconst globalCompletion = /*@__PURE__*/ifNotIn(dontComplete, /*@__PURE__*/completeFromList(/*@__PURE__*/globals.concat(snippets)));\n\nfunction innerBody(context) {\n    let { node, pos } = context;\n    let lineIndent = context.lineIndent(pos, -1);\n    let found = null;\n    for (;;) {\n        let before = node.childBefore(pos);\n        if (!before) {\n            break;\n        }\n        else if (before.name == \"Comment\") {\n            pos = before.from;\n        }\n        else if (before.name == \"Body\") {\n            if (context.baseIndentFor(before) + context.unit <= lineIndent)\n                found = before;\n            node = before;\n        }\n        else if (before.type.is(\"Statement\")) {\n            node = before;\n        }\n        else {\n            break;\n        }\n    }\n    return found;\n}\nfunction indentBody(context, node) {\n    let base = context.baseIndentFor(node);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (/^\\s*($|#)/.test(line.text) &&\n        context.node.to < to + 100 &&\n        !/\\S/.test(context.state.sliceDoc(to, context.node.to)) &&\n        context.lineIndent(context.pos, -1) <= base)\n        return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)\n        return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"python\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Body: context => {\n                    var _a;\n                    let inner = innerBody(context);\n                    return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();\n                },\n                IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"ForStatement WhileStatement\": cx => /^\\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: cx => /^\\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({ closing: \")\" }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"]\" }),\n                \"String FormatString\": () => null,\n                Script: context => {\n                    var _a;\n                    let inner = innerBody(context);\n                    return (_a = (inner && indentBody(context, inner))) !== null && _a !== void 0 ? _a : context.continue();\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n                Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n            stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\",\n                \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n        },\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n    }\n});\n/**\nPython language support.\n*/\nfunction python() {\n    return new LanguageSupport(pythonLanguage, [\n        pythonLanguage.data.of({ autocomplete: localCompletionSource }),\n        pythonLanguage.data.of({ autocomplete: globalCompletion }),\n    ]);\n}\n\nexport { globalCompletion, localCompletionSource, python, pythonLanguage };\n"],"names":["Stack","constructor","p","stack","state","reducePos","pos","score","buffer","bufferBase","curContext","lookAhead","parent","this","toString","filter","_","i","concat","start","cx","parser","context","StackContext","pushState","push","length","reduce","action","_a","depth","type","dPrec","dynamicPrecedence","getGoto","minRepeatTerm","storeNode","reduceContext","base","ranges","from","size","nodeSet","types","isAnonymous","lastBigReductionStart","bigReductionCount","lastBigReductionSize","count","stateFlag","baseStateID","pop","term","end","isReduce","cur","top","index","shift","nextState","maxNode","shiftContext","apply","next","nextStart","nextEnd","useNode","value","reused","updateContext","tracker","reuse","stream","reset","split","off","slice","recoverByDelete","isNode","canShift","sim","SimulatedStack","stateSlot","hasAction","recoverByInsert","nextStates","best","s","some","v","result","forceReduce","validAction","target","backup","findForcedReduction","seen","explore","includes","allActions","rDepth","found","forceAll","deadEnd","data","restart","sameState","other","dialectEnabled","dialectID","dialect","flags","emitContext","last","hash","emitLookAhead","newCx","setLookAhead","close","strict","goto","StackBufferCursor","maybeNext","create","id","fork","decodeArray","input","Type","Uint16Array","array","out","charCodeAt","stop","digit","CachedToken","extended","mask","nullToken","InputStream","chunk","chunkOff","chunk2","chunk2Pos","token","rangeIndex","chunkPos","range","to","readNext","resolveOffset","offset","assoc","clipPos","Math","max","peek","idx","resolved","acceptToken","endOffset","RangeError","acceptTokenTo","endPos","getChunk","nextChunk","advance","n","setDone","read","r","min","TokenGroup","group","precTable","precOffset","groupMask","scan","accEnd","allows","overrides","low","high","mid","readToken","tokenPrecTable","prototype","contextual","fallback","extend","ExternalTokenizer","options","findOffset","prev","tableData","tableOffset","iPrev","verbose","process","env","test","LOG","stackIDs","cutAt","tree","side","cursor","IterMode","IncludeAnonymous","moveTo","childBefore","childAfter","isError","prevSibling","nextSibling","FragmentCursor","fragments","fragment","safeFrom","safeTo","trees","nextFragment","fr","openStart","openEnd","nodeAt","children","positions","Tree","prop","NodeProp","TokenCache","tokens","mainToken","actions","tokenizers","map","getActions","actionIndex","main","tokenizer","updateCachedToken","startIndex","addActions","eofTerm","getMainToken","specialized","specializers","putAction","set","pair","Parse","recovering","nextStackID","minStackPos","stoppedAt","topTerm","stacks","bufferLength","parsedPos","stopped","stoppedTokens","newStacks","advanceStack","tok","finished","findFinished","console","log","stackID","stackToTree","getName","SyntaxError","runRecovery","maxRemaining","sort","a","b","outer","j","splice","stopAt","strictCx","cxHash","cached","match","contextHash","inner","defaultReduce","localStack","advanceFully","pushStackDedup","restarted","tokenEnd","force","forceBase","insert","build","topID","maxBufferLength","minRepeatType","WeakMap","get","String","fromCodePoint","Dialect","source","disabled","x","LRParser","Parser","spec","super","wrappers","version","nodeNames","repeatNodeCount","topTerms","Object","keys","topRules","nodeProps","setProp","nodeID","deserialize","propSpec","NodeSet","name","NodeType","define","undefined","props","indexOf","error","skipped","skippedNodes","propSources","DefaultBufferLength","tokenArray","tokenData","specializerSpecs","getSpecializer","states","Uint32Array","stateData","maxTerm","dialects","dynamicPrecedences","tokenPrec","termNames","parseDialect","createParse","parse","w","loose","table","groupTag","terminal","slot","flag","deflt","configure","config","copy","assign","info","t","find","external","contextTracker","wrap","hasWrappers","topNode","prec","values","part","Uint8Array","bracketed","Set","isLineBreak","ch","newlines","spaces","indentation","cDepth","chars","IndentLevel","topIndent","trackIndent","has","space","countIndent","legacyPrint","fromCharCode","formatString","quote","len","content","brace","formatString1","formatString2","formatString1l","formatString2l","pythonHighlighting","styleTags","tags","modifier","controlKeyword","operatorKeyword","definitionKeyword","import","moduleKeyword","keyword","Boolean","bool","None","null","VariableName","variableName","function","definition","className","PropertyName","propertyName","Comment","lineComment","Number","number","string","FormatString","special","UpdateOp","updateOperator","arithmeticOperator","BitOp","bitwiseOperator","CompareOp","compareOperator","AssignOp","definitionOperator","Ellipsis","punctuation","At","meta","paren","squareBracket","derefOperator","separator","spec_identifier","__proto__","await","or","and","in","not","is","if","else","lambda","yield","async","for","True","False","del","pass","break","continue","return","raise","as","global","nonlocal","assert","elif","while","try","except","finally","with","def","class","case","Script","cache","NodeWeakMap","ScopeNodes","defID","node","getChild","gatherCompletions","FunctionDefinition","ClassDefinition","ForStatement","child","firstChild","ImportStatement","_node","_b","isFrom","AssignStatement","ParamList","CapturePattern","AsPattern","getScope","doc","completions","sliceString","label","iterate","gather","c","Identifier","dontComplete","localCompletionSource","syntaxTree","resolveInner","isWord","sliceDoc","explicit","validFor","globals","snippets","snippetCompletion","detail","globalCompletion","ifNotIn","completeFromList","innerBody","lineIndent","before","baseIndentFor","unit","indentBody","line","lineAt","text","textAfter","pythonLanguage","LRLanguage","indentNodeProp","add","Body","IfStatement","baseIndent","TryStatement","delimitedIndent","closing","foldNodeProp","foldInside","languageData","closeBrackets","brackets","stringPrefixes","commentTokens","indentOnInput","python","LanguageSupport","of","autocomplete"],"mappings":"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","x_google_ignoreList":[0,1,2]}