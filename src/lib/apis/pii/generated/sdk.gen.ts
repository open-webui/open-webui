// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type {
	HealthCheckHealthGetData,
	HealthCheckHealthGetResponses,
	CacheHealthCheckHealthCacheGetData,
	CacheHealthCheckHealthCacheGetResponses,
	CreateSessionSessionsPostData,
	CreateSessionSessionsPostResponses,
	CreateSessionSessionsPostErrors,
	DeleteSessionSessionsSessionIdDeleteData,
	DeleteSessionSessionsSessionIdDeleteResponses,
	DeleteSessionSessionsSessionIdDeleteErrors,
	GetSessionSessionsSessionIdGetData,
	GetSessionSessionsSessionIdGetResponses,
	GetSessionSessionsSessionIdGetErrors,
	MaskTextTextMaskPostData,
	MaskTextTextMaskPostResponses,
	MaskTextTextMaskPostErrors,
	UnmaskTextTextUnmaskPostData,
	UnmaskTextTextUnmaskPostResponses,
	UnmaskTextTextUnmaskPostErrors,
	MaskFileFileMaskPostData,
	MaskFileFileMaskPostResponses,
	MaskFileFileMaskPostErrors,
	GetTaskProgressFileMaskTaskTaskIdGetData,
	GetTaskProgressFileMaskTaskTaskIdGetResponses,
	GetTaskProgressFileMaskTaskTaskIdGetErrors,
	MaskTextWithSessionSessionsSessionIdTextMaskPostData,
	MaskTextWithSessionSessionsSessionIdTextMaskPostResponses,
	MaskTextWithSessionSessionsSessionIdTextMaskPostErrors,
	UnmaskTextWithSessionSessionsSessionIdTextUnmaskPostData,
	UnmaskTextWithSessionSessionsSessionIdTextUnmaskPostResponses,
	UnmaskTextWithSessionSessionsSessionIdTextUnmaskPostErrors,
	MaskFileWithSessionSessionsSessionIdFileMaskPostData,
	MaskFileWithSessionSessionsSessionIdFileMaskPostResponses,
	MaskFileWithSessionSessionsSessionIdFileMaskPostErrors,
	RedocHtmlRedocGetData,
	RedocHtmlRedocGetResponses,
	DocsHtmlDocsGetData,
	DocsHtmlDocsGetResponses
} from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<
	TData extends TDataShape = TDataShape,
	ThrowOnError extends boolean = boolean
> = ClientOptions<TData, ThrowOnError> & {
	/**
	 * You can provide a client instance returned by `createClient()` instead of
	 * individual options. This might be also useful if you want to implement a
	 * custom client.
	 */
	client?: Client;
	/**
	 * You can pass arbitrary values through the `meta` object. This can be
	 * used to access values that aren't defined as part of the SDK function.
	 */
	meta?: Record<string, unknown>;
};

/**
 * Health Check
 * Health check endpoint that doesn't require authentication.
 */
export const healthCheckHealthGet = <ThrowOnError extends boolean = false>(
	options?: Options<HealthCheckHealthGetData, ThrowOnError>
) => {
	return (options?.client ?? _heyApiClient).get<
		HealthCheckHealthGetResponses,
		unknown,
		ThrowOnError
	>({
		url: '/health',
		...options
	});
};

/**
 * Cache Health Check
 * Health check endpoint that includes cache statistics.
 */
export const cacheHealthCheckHealthCacheGet = <ThrowOnError extends boolean = false>(
	options?: Options<CacheHealthCheckHealthCacheGetData, ThrowOnError>
) => {
	return (options?.client ?? _heyApiClient).get<
		CacheHealthCheckHealthCacheGetResponses,
		unknown,
		ThrowOnError
	>({
		url: '/health/cache',
		...options
	});
};

/**
 * Create Session
 * Create a new session for consistent PII masking and unmasking operations.
 *
 * Sessions allow you to maintain consistent PII labeling across multiple API calls.
 * For example, if you mask a document and later want to unmask specific parts,
 * the session ensures that masked entities are properly tracked and can be unmasked
 * correctly.
 *
 * - **TTL (Time To Live)**: Specify how long the session should remain active
 * ("24h", "7d", etc.)
 * - **Description**: Optional note to help identify the session's purpose
 */
export const createSessionSessionsPost = <ThrowOnError extends boolean = false>(
	options: Options<CreateSessionSessionsPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		CreateSessionSessionsPostResponses,
		CreateSessionSessionsPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/sessions',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Delete Session
 * Delete a session and all associated data.
 *
 * When you're done with a session, it's a good practice to delete it to free up
 * resources and ensure sensitive data isn't retained unnecessarily. This operation
 * permanently removes the session and any PII entities stored within it.
 */
export const deleteSessionSessionsSessionIdDelete = <ThrowOnError extends boolean = false>(
	options: Options<DeleteSessionSessionsSessionIdDeleteData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).delete<
		DeleteSessionSessionsSessionIdDeleteResponses,
		DeleteSessionSessionsSessionIdDeleteErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/sessions/{session_id}',
		...options
	});
};

/**
 * Get Session
 * Retrieve session information and status.
 *
 * Get details about an active session including its creation time and expiration.
 * Use this to check if a session is still valid before attempting to use it for
 * mask/unmask operations.
 */
export const getSessionSessionsSessionIdGet = <ThrowOnError extends boolean = false>(
	options: Options<GetSessionSessionsSessionIdGetData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).get<
		GetSessionSessionsSessionIdGetResponses,
		GetSessionSessionsSessionIdGetErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/sessions/{session_id}',
		...options
	});
};

/**
 * Mask Text
 * Mask PII from text immediately without creating a session.
 *
 * Ideal for one-time anonymization needs where you don't need to unmask later.
 * Quickly process text data to identify and mask PII elements like names, phone
 * numbers, addresses, and more.
 *
 * - Set **quiet=true** to receive only masked text without detailed PII information
 * - Set **create_session=true** if you might need to unmask this data later
 *
 * **Example request**:
 * ```json
 * {
 * "text": ["John Doe's phone number is +49 718 222 222"],
 * "pii_labels": {"detect": ["ALL"], "ignore": ["EMAIL"]},
 * "known_entities": [
 * {"id": 1, "label": "PERSON", "name": "Mary Jane"}
 * ],
 * "modifiers": [
 * {'action': 'word-mask', 'entity': 'deer hunter', 'type': 'PERSON'},
 * {'action': 'ignore', 'entity': 'Mister'},
 * ]
 * }
 * ```
 *
 * **Example response format for text "John Doe's phone is +49 718 222 222"**:
 * ```json
 * {
 * "text": ["[{PERSON_1}]'s phone number is [{PHONE_NUMBER_2}]"],
 * "pii": [
 * {
 * "id": 1,
 * "type": "PHONENUMBER",
 * "label": "PHONENUMBER_1",
 * "text": "+49 718 222 222",
 * "raw_text": "+49 718 222 222",
 * "occurrences": [
 * {
 * "start_idx": 27,
 * "end_idx": 42
 * }
 * ]
 * },
 * {
 * "id": 2,
 * "type": "PERSON",
 * "label": "PERSON_2",
 * "text": "john doe",
 * "raw_text": "John Doe",
 * "occurrences": [
 * {
 * "start_idx": 0,
 * "end_idx": 8
 * }
 * ]
 * }
 * ]
 * }
 * ```
 */
export const maskTextTextMaskPost = <ThrowOnError extends boolean = false>(
	options: Options<MaskTextTextMaskPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		MaskTextTextMaskPostResponses,
		MaskTextTextMaskPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/text/mask',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Unmask Text
 * Unmask previously masked text without using a session.
 *
 * Use this when you need to reveal original PII in masked text without a session.
 * Since ephemeral calls don't store context, you must provide the entities
 * for unmasking in your request.
 *
 * **Note**: For consistent unmasking, especially across multiple calls,
 * session-based endpoints are recommended.
 *
 * **Example request**:
 * ```json
 * {
 * "text": ["[{PERSON_1}]'s phone is [{PHONENUMBER_2}]"],
 * "entities": [
 * {"label": "PERSON_1", "text": "John Doe"},
 * {"label": "PHONENUMBER_2", "text": "+49 718 222 222"}
 * ]
 * }
 * ```
 */
export const unmaskTextTextUnmaskPost = <ThrowOnError extends boolean = false>(
	options: Options<UnmaskTextTextUnmaskPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		UnmaskTextTextUnmaskPostResponses,
		UnmaskTextTextUnmaskPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/text/unmask',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Mask File
 * Mask PII from a document file without creating a session.
 *
 * Process PDF or DOCX files to identify and mask sensitive information.
 * Ideal for document anonymization where you don't need to keep track of masked
 * items.
 *
 * Supports:
 * - Document text masking
 * - Optional image redaction
 * - Configurable PII detection types
 *
 * The file should be provided as base64-encoded content in the request.
 * The API supports PDF and DOCX files up to 100MB in size.
 *
 * Returns a task ID that can be used to track the progress of the file masking task and receive the redacted file.
 *
 * - Set **create_session=true** if you might need to unmask this data later
 *
 * **Example request**:
 * ```json
 * {
 * "file": {
 * "file_name": "document.pdf",
 * "file_content_type": "application/pdf",
 * "file_content_base64": "..."
 * },
 * "pii_labels": {"detect": ["ALL"], "ignore": ["EMAIL"]},
 * "known_entities": [
 * {"id": 1, "label": "PERSON", "name": "Mary Jane"}
 * ],
 * "modifiers": [
 * {'action': 'word-mask', 'entity': 'deer hunter', 'type': 'PERSON'},
 * {'action': 'ignore', 'entity': 'Mister'},
 * ],
 * "redact_images": true
 * }
 * ```
 *
 * **Example response format for file "document.pdf"**:
 * ```json
 * {
 * "task_id": "123e4567-e89b-12d3-a456-426614174000"
 * }
 * ```
 */
export const maskFileFileMaskPost = <ThrowOnError extends boolean = false>(
	options: Options<MaskFileFileMaskPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		MaskFileFileMaskPostResponses,
		MaskFileFileMaskPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/file/mask',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Get Task Progress
 * Retrieve the progress and result of a file masking task.
 *
 * This endpoint provides the current status, progress, and result of an
 * asynchronous file masking task identified by the given task ID. It returns
 * a detailed response including the task's status, progress percentage, any
 * result or error message associated with the task, and the finished file
 * if the task is completed successfully.
 *
 * Use this endpoint to monitor the progress of file masking operations and
 * to access the finished file once the task has completed.
 *
 * **Note**: Set **quiet=true** to receive only masked text without detailed PII information
 *
 * **Example response**:
 * ```json
 * {
 * "task_id": "123e4567-e89b-12d3-a456-426614174000",
 * "status": "SUCCESS",
 * "progress_percentage": 100,
 * "result": {
 * "content_base64": "...",
 * "content_type": "application/pdf",
 * },
 * "pii": [
 * {
 * "id": 1,
 * "type": "PHONENUMBER",
 * "label": "PHONENUMBER_1",
 * "text": "+49 718 222 222",
 * "raw_text": "+49 718 222 222",
 * "occurrences": [
 * {
 * "start_idx": 10,
 * "end_idx": 20
 * }
 * ]
 * }
 * ]
 * }
 * ```
 */
export const getTaskProgressFileMaskTaskTaskIdGet = <ThrowOnError extends boolean = false>(
	options: Options<GetTaskProgressFileMaskTaskTaskIdGetData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).get<
		GetTaskProgressFileMaskTaskTaskIdGetResponses,
		GetTaskProgressFileMaskTaskTaskIdGetErrors,
		ThrowOnError
	>({
		url: '/file/mask/task/{task_id}',
		...options
	});
};

/**
 * Mask Text With Session
 * Mask PII from text using a persistent session.
 *
 * This endpoint masks sensitive information in text data and stores the context
 * within the specified session. Use session-based masking when you need to:
 *
 * - Maintain consistent PII labels across multiple texts
 * - Unmask the data later using the same session
 * - Process data as part of a multi-step workflow
 *
 * The session keeps track of all masked entities, allowing for precise unmasking
 * even across different API calls.
 */
export const maskTextWithSessionSessionsSessionIdTextMaskPost = <
	ThrowOnError extends boolean = false
>(
	options: Options<MaskTextWithSessionSessionsSessionIdTextMaskPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		MaskTextWithSessionSessionsSessionIdTextMaskPostResponses,
		MaskTextWithSessionSessionsSessionIdTextMaskPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/sessions/{session_id}/text/mask',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Unmask Text With Session
 * Unmask previously masked text using a session.
 *
 * This endpoint restores original information in text that was previously masked
 * using the same session. The session maintains the mapping between masked tokens
 * and their original values, enabling accurate unmasking.
 *
 * When using a session for unmasking:
 * - You don't need to provide the entities list (unlike ephemeral unmasking)
 * - The same entity IDs will consistently map to the same original values
 * - The operation is faster and more reliable for complex texts
 */
export const unmaskTextWithSessionSessionsSessionIdTextUnmaskPost = <
	ThrowOnError extends boolean = false
>(
	options: Options<UnmaskTextWithSessionSessionsSessionIdTextUnmaskPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		UnmaskTextWithSessionSessionsSessionIdTextUnmaskPostResponses,
		UnmaskTextWithSessionSessionsSessionIdTextUnmaskPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/sessions/{session_id}/text/unmask',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Mask File With Session
 * Mask PII from a document file using a persistent session.
 *
 * Process PDF or DOCX files to identify and mask sensitive information while
 * maintaining context within the specified session. This is ideal for:
 *
 * - Document processing workflows where you'll need to unmask later
 * - Multi-page documents where consistent labeling is critical
 * - Maintaining an audit trail of masked entities
 *
 * The file should be provided as base64-encoded content in the request.
 * The session stores all detected PII entities for later reference.
 */
export const maskFileWithSessionSessionsSessionIdFileMaskPost = <
	ThrowOnError extends boolean = false
>(
	options: Options<MaskFileWithSessionSessionsSessionIdFileMaskPostData, ThrowOnError>
) => {
	return (options.client ?? _heyApiClient).post<
		MaskFileWithSessionSessionsSessionIdFileMaskPostResponses,
		MaskFileWithSessionSessionsSessionIdFileMaskPostErrors,
		ThrowOnError
	>({
		security: [
			{
				name: 'X-API-Key',
				type: 'apiKey'
			}
		],
		url: '/sessions/{session_id}/file/mask',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Redoc Html
 */
export const redocHtmlRedocGet = <ThrowOnError extends boolean = false>(
	options?: Options<RedocHtmlRedocGetData, ThrowOnError>
) => {
	return (options?.client ?? _heyApiClient).get<RedocHtmlRedocGetResponses, unknown, ThrowOnError>({
		url: '/redoc',
		...options
	});
};

/**
 * Docs Html
 */
export const docsHtmlDocsGet = <ThrowOnError extends boolean = false>(
	options?: Options<DocsHtmlDocsGetData, ThrowOnError>
) => {
	return (options?.client ?? _heyApiClient).get<DocsHtmlDocsGetResponses, unknown, ThrowOnError>({
		url: '/docs',
		...options
	});
};
