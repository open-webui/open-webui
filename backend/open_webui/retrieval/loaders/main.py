import requests
import logging
import ftfy
import sys
import json

from langchain_community.document_loaders import (
    AzureAIDocumentIntelligenceLoader,
    BSHTMLLoader,
    CSVLoader,
    Docx2txtLoader,
    OutlookMessageLoader,
    PyPDFLoader,
    TextLoader,
    UnstructuredEPubLoader,
    UnstructuredExcelLoader,
    UnstructuredODTLoader,
    UnstructuredPowerPointLoader,
    UnstructuredRSTLoader,
    UnstructuredXMLLoader,
    YoutubeLoader,
)
from langchain_core.documents import Document

from open_webui.retrieval.loaders.external_document import ExternalDocumentLoader

from open_webui.retrieval.loaders.mistral import MistralLoader
from open_webui.retrieval.loaders.datalab_marker import DatalabMarkerLoader


from open_webui.env import SRC_LOG_LEVELS, GLOBAL_LOG_LEVEL

logging.basicConfig(stream=sys.stdout, level=GLOBAL_LOG_LEVEL)
log = logging.getLogger(__name__)
log.setLevel(SRC_LOG_LEVELS["RAG"])

# Created from https://github.com/github-linguist/linguist/blob/main/lib/linguist/languages.yml
known_source_ext = [
    'Dsr',
    'JSON-tmLanguage',
    'OutJob',
    'PcbDoc',
    'PrjPCB',
    'SchDoc',
    'TextGrid',
    '_coffee',
    '_js',
    '_ls',
    'a51',
    'abap',
    'abnf',
    'ada',
    'adb',
    'adml',
    'admx',
    'ado',
    'adoc',
    'adp',
    'ads',
    'afm',
    'agc',
    'agda',
    'ahk',
    'ahkl',
    'aidl',
    'aj',
    'ak',
    'al',
    'als',
    'ampl',
    'angelscript',
    'anim',
    'ant',
    'antlers.html',
    'antlers.php',
    'antlers.xml',
    'apacheconf',
    'apex',
    'apib',
    'apl',
    'app',
    'app.src',
    'applescript',
    'arc',
    'arpa',
    'arr',
    'as',
    'asax',
    'asc',
    'asciidoc',
    'ascx',
    'asd',
    'asddls',
    'ash',
    'ashx',
    'asl',
    'asm',
    'asmx',
    'asn',
    'asn1',
    'asp',
    'aspx',
    'asset',
    'astro',
    'asy',
    'au3',
    'aug',
    'auk',
    'aux',
    'avdl',
    'avsc',
    'aw',
    'awk',
    'axaml',
    'axd',
    'axi',
    'axi.erb',
    'axml',
    'arxml',
    'axs',
    'axs.erb',
    'b',
    'bal',
    'bas',
    'bash',
    'bat',
    'bats',
    'bb',
    'bbappend',
    'bbclass',
    'bbx',
    'bdf',
    'bdy',
    'be',
    'befunge',
    'bf',
    'bi',
    'bib',
    'bibtex',
    'bicep',
    'bicepparam',
    'bison',
    'blade',
    'blade.php',
    'bmx',
    'bones',
    'boo',
    'boot',
    'bpl',
    'bqn',
    'brd',
    'bro',
    'brs',
    'bs',
    'bsl',
    'bst',
    'bsv',
    'builder',
    'builds',
    'bzl',
    'c',
    'c++',
    'c++-objdump',
    'c++objdump',
    'c-objdump',
    'cabal',
    'caddyfile',
    'cairo',
    'cake',
    'capnp',
    'carbon',
    'cats',
    'cbl',
    'cbx',
    'cc',
    'ccp',
    'ccproj',
    'ccxml',
    'cdc',
    'cdf',
    'cds',
    'ceylon',
    'cfc',
    'cfg',
    'cfm',
    'cfml',
    'cgi',
    'cginc',
    'ch',
    'chem',
    'chpl',
    'chs',
    'cil',
    'circom',
    'cirru',
    'cjs',
    'cjsx',
    'ck',
    'cl',
    'cl2',
    'clar',
    'click',
    'clixml',
    'clj',
    'cljc',
    'cljs',
    'cljs.hl',
    'cljscm',
    'cljx',
    'clp',
    'cls',
    'clue',
    'clw',
    'cmake',
    'cmake.in',
    'cmd',
    'cmp',
    'cnc',
    'cnf',
    'cob',
    'cobol',
    'cocci',
    'code-snippets',
    'code-workspace',
    'coffee',
    'coffee.md',
    'com',
    'command',
    'conll',
    'conllu',
    'containerfile',
    'coq',
    'cp',
    'cpp',
    'cpp-objdump',
    'cppm',
    'cppobjdump',
    'cproject',
    'cps',
    'cpy',
    'cql',
    'cr',
    'crc32',
    'creole',
    'cs',
    'cs.pp',
    'csc',
    'cscfg',
    'csd',
    'csdef',
    'csh',
    'cshtml',
    'csl',
    'cson',
    'csproj',
    'css',
    'csv',
    'csx',
    'ct',
    'ctl',
    'ctp',
    'cts',
    'cu',
    'cue',
    'cuh',
    'curry',
    'cw',
    'cwl',
    'cxx',
    'cxx-objdump',
    'cy',
    'cylc',
    'cyp',
    'cypher',
    'd',
    'd-objdump',
    'd2',
    'dae',
    'darcspatch',
    'dart',
    'das',
    'dats',
    'db2',
    'dcl',
    'ddl',
    'decls',
    'depproj',
    'desktop',
    'desktop.in',
    'dfm',
    'dfy',
    'dhall',
    'di',
    'diff',
    'dircolors',
    'dita',
    'ditamap',
    'ditaval',
    'djs',
    'dll.config',
    'dlm',
    'dm',
    'do',
    'dockerfile',
    'dof',
    'doh',
    'dot',
    'dotsettings',
    'dpatch',
    'dpr',
    'druby',
    'dsc',
    'dsl',
    'dsp',
    'dtx',
    'duby',
    'dwl',
    'dyalog',
    'dyl',
    'dylan',
    'dzn',
    'e',
    'eam.fs',
    'eb',
    'ebnf',
    'ebuild',
    'ec',
    'ecl',
    'eclass',
    'eclxml',
    'ecr',
    'ect',
    'edc',
    'edge',
    'edgeql',
    'editorconfig',
    'edn',
    'eh',
    'ejs',
    'ejs.t',
    'el',
    'eliom',
    'eliomi',
    'elm',
    'elv',
    'em',
    'emacs',
    'emacs.desktop',
    'emberscript',
    'eml',
    'env',
    'epj',
    'eps',
    'epsi',
    'eq',
    'erb',
    'erb.deface',
    'erl',
    'es',
    'es6',
    'escript',
    'esdl',
    'ex',
    'exs',
    'eye',
    'f',
    'f03',
    'f08',
    'f77',
    'f90',
    'f95',
    'factor',
    'fan',
    'fancypack',
    'fcgi',
    'fea',
    'feature',
    'filters',
    'fir',
    'fish',
    'flex',
    'flf',
    'flux',
    'fnc',
    'fnl',
    'for',
    'forth',
    'fp',
    'fpp',
    'fr',
    'frag',
    'frg',
    'frm',
    'frt',
    'fs',
    'fsh',
    'fshader',
    'fsi',
    'fsproj',
    'fst',
    'fsti',
    'fsx',
    'fth',
    'ftl',
    'fun',
    'fut',
    'fx',
    'fxh',
    'fxml',
    'fy',
    'g',
    'g4',
    'gaml',
    'gap',
    'gawk',
    'gbl',
    'gbo',
    'gbp',
    'gbr',
    'gbs',
    'gco',
    'gcode',
    'gd',
    'gdb',
    'gdbinit',
    'gdnlib',
    'gdns',
    'gdshader',
    'gdshaderinc',
    'ged',
    'gemspec',
    'geo',
    'geojson',
    'geom',
    'gf',
    'gi',
    'gitconfig',
    'gitignore',
    'gjs',
    'gko',
    'glade',
    'gleam',
    'glf',
    'glsl',
    'glslf',
    'glslv',
    'gltf',
    'glyphs',
    'gmi',
    'gml',
    'gms',
    'gmx',
    'gn',
    'gni',
    'gnu',
    'gnuplot',
    'go',
    'god',
    'golo',
    'gp',
    'gpb',
    'gpt',
    'gpx',
    'gql',
    'grace',
    'gradle',
    'gradle.kts',
    'graphql',
    'graphqls',
    'groovy',
    'grt',
    'grxml',
    'gs',
    'gsc',
    'gsh',
    'gshader',
    'gsp',
    'gst',
    'gsx',
    'gtl',
    'gto',
    'gtp',
    'gtpl',
    'gts',
    'gv',
    'gvy',
    'gyp',
    'gypi',
    'h',
    'h++',
    'h.in',
    'ha',
    'hack',
    'haml',
    'haml.deface',
    'handlebars',
    'har',
    'hats',
    'hb',
    'hbs',
    'hc',
    'hcl',
    'heex',
    'hh',
    'hhi',
    'hic',
    'hip',
    'hlean',
    'hlsl',
    'hlsli',
    'hocon',
    'hoon',
    'hpp',
    'hqf',
    'hql',
    'hrl',
    'hs',
    'hs-boot',
    'hsc',
    'hta',
    'htm',
    'html',
    'html.eex',
    'html.hl',
    'http',
    'hx',
    'hxml',
    'hxsl',
    'hxx',
    'hy',
    'hzp',
    'i',
    'i3',
    'i7x',
    'ical',
    'ice',
    'iced',
    'icl',
    'ics',
    'idc',
    'idr',
    'ig',
    'ihlp',
    'ijm',
    'ijs',
    'ik',
    'ily',
    'imba',
    'iml',
    'inc',
    'ini',
    'ink',
    'inl',
    'ino',
    'ins',
    'intr',
    'io',
    'iol',
    'ipf',
    'ipp',
    'ipynb',
    'irclog',
    'isl',
    'ispc',
    'iss',
    'iuml',
    'ivy',
    'ixx',
    'j',
    'j2',
    'jade',
    'jai',
    'jake',
    'janet',
    'jav',
    'java',
    'javascript',
    'jbuilder',
    'jcl',
    'jelly',
    'jflex',
    'jinja',
    'jinja2',
    'jison',
    'jisonlex',
    'jl',
    'jq',
    'js',
    'js.erb',
    'jsb',
    'jscad',
    'jsfl',
    'jsh',
    'jslib',
    'jsm',
    'json',
    'json.example',
    'json5',
    'jsonc',
    'jsonl',
    'jsonld',
    'jsonnet',
    'jsp',
    'jspre',
    'jsproj',
    'jss',
    'jst',
    'jsx',
    'jte',
    'just',
    'kak',
    'kdl',
    'kicad_mod',
    'kicad_pcb',
    'kicad_sch',
    'kicad_sym',
    'kicad_wks',
    'kid',
    'kit',
    'kk',
    'kml',
    'kojo',
    'kql',
    'krl',
    'ks',
    'ksh',
    'ksy',
    'kt',
    'ktm',
    'kts',
    'kv',
    'l',
    'lagda',
    'lark',
    'las',
    'lasso',
    'lasso8',
    'lasso9',
    'latte',
    'launch',
    'lbx',
    'ld',
    'lds',
    'lean',
    'leex',
    'lektorproject',
    'leo',
    'less',
    'lex',
    'lfe',
    'lgt',
    'lhs',
    'libsonnet',
    'lid',
    'lidr',
    'ligo',
    'linq',
    'liquid',
    'lisp',
    'litcoffee',
    'livecodescript',
    'livemd',
    'lkml',
    'll',
    'lmi',
    'logtalk',
    'lol',
    'lookml',
    'lp',
    'lpr',
    'ls',
    'lsl',
    'lslp',
    'lsp',
    'ltx',
    'lua',
    'luau',
    'lvclass',
    'lvlib',
    'lvproj',
    'ly',
    'm',
    'm2',
    'm3',
    'm3u',
    'm3u8',
    'm4',
    'ma',
    'mak',
    'make',
    'makefile',
    'mako',
    'man',
    'mao',
    'markdown',
    'marko',
    'mask',
    'mat',
    'mata',
    'matah',
    'mathematica',
    'matlab',
    'mawk',
    'maxhelp',
    'maxpat',
    'maxproj',
    'mbox',
    'mbt',
    'mc',
    'mcfunction',
    'mcmeta',
    'mcr',
    'md',
    'md2',
    'md4',
    'md5',
    'mdoc',
    'mdown',
    'mdpolicy',
    'mdwn',
    'mdx',
    'me',
    'mediawiki',
    'mermaid',
    'meta',
    'metal',
    'mg',
    'minid',
    'mint',
    'mir',
    'mirah',
    'mjml',
    'mjs',
    'mk',
    'mkd',
    'mkdn',
    'mkdown',
    'mkfile',
    'mkii',
    'mkiv',
    'mkvi',
    'ml',
    'ml4',
    'mli',
    'mligo',
    'mlir',
    'mll',
    'mly',
    'mm',
    'mmd',
    'mmk',
    'mms',
    'mo',
    'mod',
    'mojo',
    'monkey',
    'monkey2',
    'moo',
    'moon',
    'move',
    'mpl',
    'mps',
    'mq4',
    'mq5',
    'mqh',
    'mrc',
    'ms',
    'msd',
    'msg',
    'mspec',
    'mss',
    'mt',
    'mtl',
    'mtml',
    'mts',
    'mu',
    'mud',
    'muf',
    'mumps',
    'muse',
    'mustache',
    'mxml',
    'mxt',
    'mysql',
    'myt',
    'mzn',
    'n',
    'nanorc',
    'nas',
    'nasl',
    'nasm',
    'natvis',
    'nawk',
    'nb',
    'nbp',
    'nc',
    'ncl',
    'ndproj',
    'ne',
    'nearley',
    'ned',
    'neon',
    'nf',
    'nginx',
    'nginxconf',
    'ni',
    'nim',
    'nim.cfg',
    'nimble',
    'nimrod',
    'nims',
    'ninja',
    'nit',
    'nix',
    'njk',
    'njs',
    'nl',
    'nlogo',
    'no',
    'nomad',
    'nproj',
    'nqp',
    'nr',
    'nse',
    'nsh',
    'nsi',
    'nss',
    'nu',
    'numpy',
    'numpyw',
    'numsc',
    'nuspec',
    'nut',
    'ny',
    'ob2',
    'obj',
    'objdump',
    'odd',
    'odin',
    'ol',
    'omgrofl',
    'ooc',
    'opa',
    'opal',
    'opencl',
    'orc',
    'org',
    'os',
    'osm',
    'overpassql',
    'owl',
    'ox',
    'oxh',
    'oxo',
    'oxygene',
    'oz',
    'p',
    'p4',
    'p6',
    'p6l',
    'p6m',
    'p8',
    'pac',
    'pact',
    'pan',
    'parrot',
    'pas',
    'pascal',
    'pasm',
    'pat',
    'patch',
    'pb',
    'pbi',
    'pbt',
    'pbtxt',
    'pck',
    'pcss',
    'pd',
    'pd_lua',
    'pddl',
    'pde',
    'peggy',
    'pegjs',
    'pep',
    'per',
    'perl',
    'pfa',
    'pgsql',
    'ph',
    'php',
    'php3',
    'php4',
    'php5',
    'phps',
    'phpt',
    'phtml',
    'pic',
    'pig',
    'pike',
    'pir',
    'pkb',
    'pkgproj',
    'pkl',
    'pks',
    'pl',
    'pl6',
    'plantuml',
    'plb',
    'plist',
    'plot',
    'pls',
    'plsql',
    'plt',
    'pluginspec',
    'plx',
    'pm',
    'pm6',
    'pml',
    'pmod',
    'po',
    'pod',
    'pod6',
    'podsl',
    'podspec',
    'pogo',
    'polar',
    'pony',
    'por',
    'postcss',
    'pot',
    'pov',
    'pp',
    'pprx',
    'praat',
    'prawn',
    'prc',
    'prefab',
    'prefs',
    'prg',
    'pri',
    'prisma',
    'pro',
    'proj',
    'prolog',
    'properties',
    'props',
    'proto',
    'prw',
    'ps',
    'ps1',
    'ps1xml',
    'psc',
    'psc1',
    'psd1',
    'psgi',
    'psm1',
    'pt',
    'pub',
    'pug',
    'puml',
    'purs',
    'pwn',
    'pxd',
    'pxi',
    'py',
    'py3',
    'pyde',
    'pyi',
    'pyp',
    'pyt',
    'pytb',
    'pyw',
    'pyx',
    'q',
    'qasm',
    'qbs',
    'qhelp',
    'ql',
    'qll',
    'qmd',
    'qml',
    'qs',
    'r',
    'r2',
    'r3',
    'rabl',
    'rake',
    'raku',
    'rakumod',
    'raml',
    'raw',
    'razor',
    'rb',
    'rbbas',
    'rbfrm',
    'rbi',
    'rbmnu',
    'rbres',
    'rbs',
    'rbtbar',
    'rbuild',
    'rbuistate',
    'rbw',
    'rbx',
    'rbxs',
    'rchit',
    'rd',
    'rdf',
    'rdoc',
    're',
    'reb',
    'rebol',
    'red',
    'reds',
    'reek',
    'reg',
    'regex',
    'regexp',
    'rego',
    'rei',
    'religo',
    'res',
    'resi',
    'resource',
    'rest',
    'rest.txt',
    'resx',
    'rex',
    'rexx',
    'rg',
    'rhtml',
    'ring',
    'riot',
    'rkt',
    'rktd',
    'rktl',
    'rl',
    'rmd',
    'rmiss',
    'rnh',
    'rno',
    'rnw',
    'robot',
    'roc',
    'rockspec',
    'roff',
    'ron',
    'ronn',
    'rpgle',
    'rpy',
    'rq',
    'rs',
    'rs.in',
    'rsc',
    'rsh',
    'rss',
    'rst',
    'rst.txt',
    'rsx',
    'rtf',
    'ru',
    'ruby',
    'rviz',
    's',
    'sage',
    'sagews',
    'sail',
    'sarif',
    'sas',
    'sass',
    'sats',
    'sbt',
    'sc',
    'scad',
    'scala',
    'scaml',
    'scd',
    'sce',
    'scenic',
    'sch',
    'sci',
    'scm',
    'sco',
    'scpt',
    'scrbl',
    'scss',
    'scxml',
    'sdc',
    'sed',
    'self',
    'service',
    'sexp',
    'sfd',
    'sfproj',
    'sfv',
    'sh',
    'sh-session',
    'sh.in',
    'sha1',
    'sha2',
    'sha224',
    'sha256',
    'sha256sum',
    'sha3',
    'sha384',
    'sha512',
    'shader',
    'shen',
    'shproj',
    'sieve',
    'sig',
    'sj',
    'sjs',
    'sl',
    'slang',
    'sld',
    'slim',
    'slint',
    'sln',
    'slnx',
    'sls',
    'sma',
    'smali',
    'smithy',
    'smk',
    'sml',
    'smt',
    'smt2',
    'snakefile',
    'snap',
    'snip',
    'snippet',
    'snippets',
    'sol',
    'soy',
    'sp',
    'sparql',
    'spc',
    'spec',
    'spin',
    'sps',
    'sqf',
    'sql',
    'sqlrpgle',
    'sra',
    'srdf',
    'srt',
    'sru',
    'srw',
    'ss',
    'ssjs',
    'sss',
    'st',
    'stTheme',
    'stan',
    'star',
    'sthlp',
    'stl',
    'ston',
    'story',
    'storyboard',
    'sty',
    'styl',
    'sublime-build',
    'sublime-color-scheme',
    'sublime-commands',
    'sublime-completions',
    'sublime-keymap',
    'sublime-macro',
    'sublime-menu',
    'sublime-mousemap',
    'sublime-project',
    'sublime-settings',
    'sublime-snippet',
    'sublime-syntax',
    'sublime-theme',
    'sublime-workspace',
    'sublime_metrics',
    'sublime_session',
    'sv',
    'svelte',
    'svg',
    'svh',
    'svx',
    'sw',
    'swg',
    'swift',
    'swig',
    'syntax',
    't',
    'tab',
    'tac',
    'tact',
    'tag',
    'talon',
    'targets',
    'tcc',
    'tcl',
    'tcl.in',
    'tcsh',
    'te',
    'tea',
    'templ',
    'tesc',
    'tese',
    'tex',
    'texi',
    'texinfo',
    'textile',
    'textproto',
    'tf',
    'tfstate',
    'tfstate.backup',
    'tftpl',
    'tfvars',
    'thor',
    'thrift',
    'thy',
    'tl',
    'tla',
    'tlv',
    'tm',
    'tmCommand',
    'tmLanguage',
    'tmPreferences',
    'tmSnippet',
    'tmTheme',
    'tmac',
    'tml',
    'tmux',
    'toc',
    'toit',
    'toml',
    'tool',
    'topojson',
    'tpb',
    'tpl',
    'tpp',
    'tps',
    'tres',
    'trg',
    'trigger',
    'ts',
    'tscn',
    'tsp',
    'tst',
    'tsv',
    'tsx',
    'ttl',
    'tu',
    'twig',
    'txi',
    'txl',
    'txt',
    'txx',
    'typ',
    'uc',
    'udf',
    'udo',
    'ui',
    'unity',
    'uno',
    'upc',
    'uplc',
    'ur',
    'urdf',
    'url',
    'urs',
    'ux',
    'v',
    'vala',
    'vapi',
    'vark',
    'vb',
    'vba',
    'vbhtml',
    'vbproj',
    'vbs',
    'vcf',
    'vcl',
    'vcxproj',
    'vdf',
    'veo',
    'vert',
    'vh',
    'vhd',
    'vhdl',
    'vhf',
    'vhi',
    'vho',
    'vhost',
    'vhs',
    'vht',
    'vhw',
    'vim',
    'vimrc',
    'viw',
    'vmb',
    'volt',
    'vrx',
    'vs',
    'vsh',
    'vshader',
    'vsixmanifest',
    'vssettings',
    'vstemplate',
    'vtl',
    'vto',
    'vtt',
    'vue',
    'vw',
    'vxml',
    'vy',
    'w',
    'wast',
    'wat',
    'watchr',
    'wdl',
    'webapp',
    'webidl',
    'webmanifest',
    'weechatlog',
    'wgsl',
    'whiley',
    'wiki',
    'wikitext',
    'wisp',
    'wit',
    'wixproj',
    'wl',
    'wlk',
    'wlt',
    'wlua',
    'workbook',
    'workflow',
    'wren',
    'ws',
    'wsdl',
    'wsf',
    'wsgi',
    'wxi',
    'wxl',
    'wxs',
    'x',
    'x10',
    'x3d',
    'x68',
    'xacro',
    'xaml',
    'xbm',
    'xc',
    'xdc',
    'xht',
    'xhtml',
    'xi',
    'xib',
    'xlf',
    'xliff',
    'xm',
    'xmi',
    'xml',
    'xml.dist',
    'xmp',
    'xojo_code',
    'xojo_menu',
    'xojo_report',
    'xojo_script',
    'xojo_toolbar',
    'xojo_window',
    'xpl',
    'xpm',
    'xproc',
    'xproj',
    'xpy',
    'xq',
    'xql',
    'xqm',
    'xquery',
    'xqy',
    'xrl',
    'xs',
    'xsd',
    'xsh',
    'xsjs',
    'xsjslib',
    'xsl',
    'xslt',
    'xsp-config',
    'xsp.metadata',
    'xspec',
    'xtend',
    'xul',
    'xzap',
    'y',
    'yacc',
    'yaml',
    'yaml-tmlanguage',
    'yaml.sed',
    'yang',
    'yap',
    'yar',
    'yara',
    'yasnippet',
    'yml',
    'yml.mysql',
    'yrl',
    'yul',
    'yy',
    'yyp',
    'z3',
    'zap',
    'zcml',
    'zeek',
    'zep',
    'zig',
    'zig.zon',
    'zil',
    'zimpl',
    'zmodel',
    'zmpl',
    'zone',
    'zpl',
    'zs',
    'zsh',
    'zsh-theme',
]

class TikaLoader:
    def __init__(self, url, file_path, mime_type=None, extract_images=None):
        self.url = url
        self.file_path = file_path
        self.mime_type = mime_type

        self.extract_images = extract_images

    def load(self) -> list[Document]:
        with open(self.file_path, "rb") as f:
            data = f.read()

        if self.mime_type is not None:
            headers = {"Content-Type": self.mime_type}
        else:
            headers = {}

        if self.extract_images == True:
            headers["X-Tika-PDFextractInlineImages"] = "true"

        endpoint = self.url
        if not endpoint.endswith("/"):
            endpoint += "/"
        endpoint += "tika/text"

        r = requests.put(endpoint, data=data, headers=headers)

        if r.ok:
            raw_metadata = r.json()
            text = raw_metadata.get("X-TIKA:content", "<No text content found>").strip()

            if "Content-Type" in raw_metadata:
                headers["Content-Type"] = raw_metadata["Content-Type"]

            log.debug("Tika extracted text: %s", text)

            return [Document(page_content=text, metadata=headers)]
        else:
            raise Exception(f"Error calling Tika: {r.reason}")


class DoclingLoader:
    def __init__(self, url, file_path=None, mime_type=None, params=None):
        self.url = url.rstrip("/")
        self.file_path = file_path
        self.mime_type = mime_type

        self.params = params or {}

    def load(self) -> list[Document]:
        with open(self.file_path, "rb") as f:
            files = {
                "files": (
                    self.file_path,
                    f,
                    self.mime_type or "application/octet-stream",
                )
            }

            params = {"image_export_mode": "placeholder", "table_mode": "accurate"}

            if self.params:
                if self.params.get("do_picture_description"):
                    params["do_picture_description"] = self.params.get(
                        "do_picture_description"
                    )

                    picture_description_mode = self.params.get(
                        "picture_description_mode", ""
                    ).lower()

                    if picture_description_mode == "local" and self.params.get(
                        "picture_description_local", {}
                    ):
                        params["picture_description_local"] = json.dumps(
                            self.params.get("picture_description_local", {})
                        )

                    elif picture_description_mode == "api" and self.params.get(
                        "picture_description_api", {}
                    ):
                        params["picture_description_api"] = json.dumps(
                            self.params.get("picture_description_api", {})
                        )

                if self.params.get("ocr_engine") and self.params.get("ocr_lang"):
                    params["ocr_engine"] = self.params.get("ocr_engine")
                    params["ocr_lang"] = [
                        lang.strip()
                        for lang in self.params.get("ocr_lang").split(",")
                        if lang.strip()
                    ]

            endpoint = f"{self.url}/v1/convert/file"
            r = requests.post(endpoint, files=files, data=params)

        if r.ok:
            result = r.json()
            document_data = result.get("document", {})
            text = document_data.get("md_content", "<No text content found>")

            metadata = {"Content-Type": self.mime_type} if self.mime_type else {}

            log.debug("Docling extracted text: %s", text)

            return [Document(page_content=text, metadata=metadata)]
        else:
            error_msg = f"Error calling Docling API: {r.reason}"
            if r.text:
                try:
                    error_data = r.json()
                    if "detail" in error_data:
                        error_msg += f" - {error_data['detail']}"
                except Exception:
                    error_msg += f" - {r.text}"
            raise Exception(f"Error calling Docling: {error_msg}")


class Loader:
    def __init__(self, engine: str = "", **kwargs):
        self.engine = engine
        self.kwargs = kwargs

    def load(
        self, filename: str, file_content_type: str, file_path: str
    ) -> list[Document]:
        loader = self._get_loader(filename, file_content_type, file_path)
        docs = loader.load()

        return [
            Document(
                page_content=ftfy.fix_text(doc.page_content), metadata=doc.metadata
            )
            for doc in docs
        ]

    def _is_text_file(self, file_ext: str, file_content_type: str) -> bool:
        return file_ext in known_source_ext or (
            file_content_type
            and file_content_type.find("text/") >= 0
            # Avoid text/html files being detected as text
            and not file_content_type.find("html") >= 0
        )

    def _get_loader(self, filename: str, file_content_type: str, file_path: str):
        file_ext = filename.split(".")[-1].lower()

        if (
            self.engine == "external"
            and self.kwargs.get("EXTERNAL_DOCUMENT_LOADER_URL")
            and self.kwargs.get("EXTERNAL_DOCUMENT_LOADER_API_KEY")
        ):
            loader = ExternalDocumentLoader(
                file_path=file_path,
                url=self.kwargs.get("EXTERNAL_DOCUMENT_LOADER_URL"),
                api_key=self.kwargs.get("EXTERNAL_DOCUMENT_LOADER_API_KEY"),
                mime_type=file_content_type,
            )
        elif self.engine == "tika" and self.kwargs.get("TIKA_SERVER_URL"):
            if self._is_text_file(file_ext, file_content_type):
                loader = TextLoader(file_path, autodetect_encoding=True)
            else:
                loader = TikaLoader(
                    url=self.kwargs.get("TIKA_SERVER_URL"),
                    file_path=file_path,
                    mime_type=file_content_type,
                    extract_images=self.kwargs.get("PDF_EXTRACT_IMAGES"),
                )
        elif (
            self.engine == "datalab_marker"
            and self.kwargs.get("DATALAB_MARKER_API_KEY")
            and file_ext
            in [
                "pdf",
                "xls",
                "xlsx",
                "ods",
                "doc",
                "docx",
                "odt",
                "ppt",
                "pptx",
                "odp",
                "html",
                "epub",
                "png",
                "jpeg",
                "jpg",
                "webp",
                "gif",
                "tiff",
            ]
        ):
            loader = DatalabMarkerLoader(
                file_path=file_path,
                api_key=self.kwargs["DATALAB_MARKER_API_KEY"],
                langs=self.kwargs.get("DATALAB_MARKER_LANGS"),
                use_llm=self.kwargs.get("DATALAB_MARKER_USE_LLM", False),
                skip_cache=self.kwargs.get("DATALAB_MARKER_SKIP_CACHE", False),
                force_ocr=self.kwargs.get("DATALAB_MARKER_FORCE_OCR", False),
                paginate=self.kwargs.get("DATALAB_MARKER_PAGINATE", False),
                strip_existing_ocr=self.kwargs.get(
                    "DATALAB_MARKER_STRIP_EXISTING_OCR", False
                ),
                disable_image_extraction=self.kwargs.get(
                    "DATALAB_MARKER_DISABLE_IMAGE_EXTRACTION", False
                ),
                output_format=self.kwargs.get(
                    "DATALAB_MARKER_OUTPUT_FORMAT", "markdown"
                ),
            )
        elif self.engine == "docling" and self.kwargs.get("DOCLING_SERVER_URL"):
            if self._is_text_file(file_ext, file_content_type):
                loader = TextLoader(file_path, autodetect_encoding=True)
            else:
                # Build params for DoclingLoader
                params = self.kwargs.get("DOCLING_PARAMS", {})
                if not isinstance(params, dict):
                    try:
                        params = json.loads(params)
                    except json.JSONDecodeError:
                        log.error("Invalid DOCLING_PARAMS format, expected JSON object")
                        params = {}

                loader = DoclingLoader(
                    url=self.kwargs.get("DOCLING_SERVER_URL"),
                    file_path=file_path,
                    mime_type=file_content_type,
                    params=params,
                )
        elif (
            self.engine == "document_intelligence"
            and self.kwargs.get("DOCUMENT_INTELLIGENCE_ENDPOINT") != ""
            and self.kwargs.get("DOCUMENT_INTELLIGENCE_KEY") != ""
            and (
                file_ext in ["pdf", "xls", "xlsx", "docx", "ppt", "pptx"]
                or file_content_type
                in [
                    "application/vnd.ms-excel",
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    "application/vnd.ms-powerpoint",
                    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                ]
            )
        ):
            loader = AzureAIDocumentIntelligenceLoader(
                file_path=file_path,
                api_endpoint=self.kwargs.get("DOCUMENT_INTELLIGENCE_ENDPOINT"),
                api_key=self.kwargs.get("DOCUMENT_INTELLIGENCE_KEY"),
            )
        elif (
            self.engine == "mistral_ocr"
            and self.kwargs.get("MISTRAL_OCR_API_KEY") != ""
            and file_ext
            in ["pdf"]  # Mistral OCR currently only supports PDF and images
        ):
            loader = MistralLoader(
                api_key=self.kwargs.get("MISTRAL_OCR_API_KEY"), file_path=file_path
            )
        elif (
            self.engine == "external"
            and self.kwargs.get("MISTRAL_OCR_API_KEY") != ""
            and file_ext
            in ["pdf"]  # Mistral OCR currently only supports PDF and images
        ):
            loader = MistralLoader(
                api_key=self.kwargs.get("MISTRAL_OCR_API_KEY"), file_path=file_path
            )
        else:
            if file_ext == "pdf":
                loader = PyPDFLoader(
                    file_path, extract_images=self.kwargs.get("PDF_EXTRACT_IMAGES")
                )
            elif file_ext == "csv":
                loader = CSVLoader(file_path, autodetect_encoding=True)
            elif file_ext == "rst":
                loader = UnstructuredRSTLoader(file_path, mode="elements")
            elif file_ext == "xml":
                loader = UnstructuredXMLLoader(file_path)
            elif file_ext in ["htm", "html"]:
                loader = BSHTMLLoader(file_path, open_encoding="unicode_escape")
            elif file_ext == "md":
                loader = TextLoader(file_path, autodetect_encoding=True)
            elif file_content_type == "application/epub+zip":
                loader = UnstructuredEPubLoader(file_path)
            elif (
                file_content_type
                == "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                or file_ext == "docx"
            ):
                loader = Docx2txtLoader(file_path)
            elif file_content_type in [
                "application/vnd.ms-excel",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            ] or file_ext in ["xls", "xlsx"]:
                loader = UnstructuredExcelLoader(file_path)
            elif file_content_type in [
                "application/vnd.ms-powerpoint",
                "application/vnd.openxmlformats-officedocument.presentationml.presentation",
            ] or file_ext in ["ppt", "pptx"]:
                loader = UnstructuredPowerPointLoader(file_path)
            elif file_ext == "msg":
                loader = OutlookMessageLoader(file_path)
            elif file_ext == "odt":
                loader = UnstructuredODTLoader(file_path)
            elif self._is_text_file(file_ext, file_content_type):
                loader = TextLoader(file_path, autodetect_encoding=True)
            else:
                loader = TextLoader(file_path, autodetect_encoding=True)

        return loader
