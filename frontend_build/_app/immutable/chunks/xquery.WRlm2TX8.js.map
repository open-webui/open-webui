{"version":3,"file":"xquery.WRlm2TX8.js","sources":["../../../../../../node_modules/@codemirror/legacy-modes/mode/xquery.js"],"sourcesContent":["// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return chain(stream, state, tokenString(ch));\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n\n    if(isInString(state) && stream.current() == quote) {\n      popStateStack(state);\n      if(f) state.tokenize = f;\n      return \"string\";\n    }\n\n    pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n    // if we're in a string and in an XML block, allow an embedded code block\n    if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n      state.tokenize = tokenBase;\n      return \"string\";\n    }\n\n\n    while (ch = stream.next()) {\n      if (ch ==  quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        break;\n      }\n      else {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n      }\n    }\n\n    return \"string\";\n  };\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return chain(stream, state, tokenString(ch, tokenAttribute));\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nexport const xQuery = {\n  name: \"xquery\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n"],"names":["keywords","kw","type","operator","atom","punctuation","qualifier","kwObj","basic","i","l","types","operators","axis_specifiers","chain","stream","state","f","tokenBase","ch","mightBeFunction","isEQName","isEQNameAhead","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","tokenComment","tokenString","tokenVariable","known","foundColon","word","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","quote","isInString","isInXmlAttributeBlock","isVariableChar","name","tokenAttribute","isIn","newState","reinstateTokenize","xQuery","style"],"mappings":"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","x_google_ignoreList":[0]}