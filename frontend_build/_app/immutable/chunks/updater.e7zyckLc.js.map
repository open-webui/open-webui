{"version":3,"file":"updater.e7zyckLc.js","sources":["../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/style.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/attr.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/makeElement.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/is.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/event.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/lifecycle.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/object.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/withGet.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/hidden-input/create.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/calendar/create.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/date-picker/create.js","../../../../../../node_modules/bits-ui/dist/internal/attrs.js","../../../../../../node_modules/bits-ui/dist/internal/events.js","../../../../../../node_modules/bits-ui/dist/internal/object.js","../../../../../../node_modules/bits-ui/dist/internal/updater.js"],"sourcesContent":["/**\n * A utility function that converts a style object to a string.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, '');\n}\n","import { styleToString } from './style.js';\nexport function disabledAttr(disabled) {\n    return disabled ? true : undefined;\n}\nexport const hiddenInputAttrs = {\n    type: 'hidden',\n    'aria-hidden': true,\n    hidden: true,\n    tabIndex: -1,\n    style: styleToString({\n        position: 'absolute',\n        opacity: 0,\n        'pointer-events': 'none',\n        margin: 0,\n        transform: 'translateX(-100%)',\n    }),\n};\n/**\n * @param portal The value of the `portal` option store.\n * @returns the value of the `data-portal` attribute.\n */\nexport function portalAttr(portal) {\n    if (portal !== null) {\n        return '';\n    }\n    return undefined;\n}\n","export function lightable(value) {\n    function subscribe(run) {\n        run(value);\n        return () => {\n            // don't need to unsub from anything\n        };\n    }\n    return { subscribe };\n}\n","import { derived } from 'svelte/store';\nimport { isBrowser, isHTMLElement, noop } from './index.js';\nimport { lightable } from './store/lightable.js';\nexport function getElementByMeltId(id) {\n    if (!isBrowser)\n        return null;\n    const el = document.querySelector(`[data-melt-id=\"${id}\"]`);\n    return isHTMLElement(el) ? el : null;\n}\nexport const hiddenAction = (obj) => {\n    return new Proxy(obj, {\n        get(target, prop, receiver) {\n            return Reflect.get(target, prop, receiver);\n        },\n        ownKeys(target) {\n            return Reflect.ownKeys(target).filter((key) => key !== 'action');\n        },\n    });\n};\nconst isFunctionWithParams = (fn) => {\n    return typeof fn === 'function';\n};\nexport const emptyMeltElement = makeElement('empty');\nexport function makeElement(name, args) {\n    const { stores, action, returned } = args ?? {};\n    const derivedStore = (() => {\n        if (stores && returned) {\n            // If stores are provided, create a derived store from them\n            return derived(stores, (values) => {\n                const result = returned(values);\n                if (isFunctionWithParams(result)) {\n                    const fn = (...args) => {\n                        return hiddenAction({\n                            ...result(...args),\n                            [`data-melt-${name}`]: '',\n                            action: action ?? noop,\n                        });\n                    };\n                    fn.action = action ?? noop;\n                    return fn;\n                }\n                return hiddenAction({\n                    ...result,\n                    [`data-melt-${name}`]: '',\n                    action: action ?? noop,\n                });\n            });\n        }\n        else {\n            // If stores are not provided, return a lightable store, for consistency\n            const returnedFn = returned;\n            const result = returnedFn?.();\n            if (isFunctionWithParams(result)) {\n                const resultFn = (...args) => {\n                    return hiddenAction({\n                        ...result(...args),\n                        [`data-melt-${name}`]: '',\n                        action: action ?? noop,\n                    });\n                };\n                resultFn.action = action ?? noop;\n                return lightable(resultFn);\n            }\n            return lightable(hiddenAction({\n                ...result,\n                [`data-melt-${name}`]: '',\n                action: action ?? noop,\n            }));\n        }\n    })();\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = derivedStore.subscribe;\n    return actionFn;\n}\nexport function makeElementArray(name, args) {\n    const { stores, returned, action } = args;\n    const { subscribe } = derived(stores, (values) => returned(values).map((value) => hiddenAction({\n        ...value,\n        [`data-melt-${name}`]: '',\n        action: action ?? noop,\n    })));\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = subscribe;\n    return actionFn;\n}\nexport function createElHelpers(prefix) {\n    const name = (part) => (part ? `${prefix}-${part}` : prefix);\n    const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ''}`;\n    const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ''}]`;\n    const getEl = (part) => document.querySelector(selector(part));\n    return {\n        name,\n        attribute,\n        selector,\n        getEl,\n    };\n}\n","export const isBrowser = typeof document !== 'undefined';\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = (v) => typeof v === 'function';\nexport const isLetter = (key) => /^[a-z]$/i.test(key);\nexport function isDocument(element) {\n    return element instanceof Document;\n}\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isHTMLInputElement(element) {\n    return element instanceof HTMLInputElement;\n}\nexport function isHTMLLabelElement(element) {\n    return element instanceof HTMLLabelElement;\n}\nexport function isHTMLButtonElement(element) {\n    return element instanceof HTMLButtonElement;\n}\nexport function isElementDisabled(element) {\n    const ariaDisabled = element.getAttribute('aria-disabled');\n    const disabled = element.getAttribute('disabled');\n    const dataDisabled = element.hasAttribute('data-disabled');\n    if (ariaDisabled === 'true' || disabled !== null || dataDisabled) {\n        return true;\n    }\n    return false;\n}\nexport function isTouch(event) {\n    return event.pointerType === 'touch';\n}\nexport function isLeftClick(event) {\n    return event.button === 0 && event.ctrlKey === false && event.metaKey === false;\n}\nexport function isFocusVisible(element) {\n    return element.matches(':focus-visible');\n}\nexport function isContentEditable(element) {\n    if (!isHTMLElement(element))\n        return false;\n    return element.isContentEditable;\n}\nexport function isNull(value) {\n    return value === null;\n}\nexport function isNumberString(value) {\n    if (isNaN(parseInt(value)))\n        return false;\n    return true;\n}\nexport function isObject(value) {\n    return value !== null && typeof value === 'object';\n}\nexport function isReadable(value) {\n    return isObject(value) && 'subscribe' in value;\n}\nexport function isWritable(value) {\n    return isReadable(value) && 'set' in value;\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\n/**\n * A no operation function (does nothing)\n */\nexport function noop() {\n    //\n}\n","import { noop } from './callbacks.js';\nimport { isHTMLElement } from './is.js';\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\nexport function addMeltEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    if (typeof handler === 'function') {\n        const handlerWithMelt = withMelt((_event) => handler(_event));\n        // Add the event listener to each specified event for the target element(s).\n        events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));\n        // Return a function that removes the event listener from the target element(s).\n        return () => {\n            events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));\n        };\n    }\n    return () => noop();\n}\nexport function dispatchMeltEvent(originalEvent) {\n    const node = originalEvent.currentTarget;\n    if (!isHTMLElement(node))\n        return null;\n    const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {\n        detail: {\n            originalEvent,\n        },\n        cancelable: true,\n    });\n    node.dispatchEvent(customMeltEvent);\n    return customMeltEvent;\n}\nexport function withMelt(handler) {\n    return (event) => {\n        const customEvent = dispatchMeltEvent(event);\n        if (customEvent?.defaultPrevented)\n            return;\n        return handler(event);\n    };\n}\n","import { onDestroy, onMount } from 'svelte';\nexport const safeOnMount = (fn) => {\n    try {\n        onMount(fn);\n    }\n    catch {\n        return fn;\n    }\n};\nexport const safeOnDestroy = (fn) => {\n    try {\n        onDestroy(fn);\n    }\n    catch {\n        return fn;\n    }\n};\n","import { dequal } from 'dequal';\nexport function omit(obj, ...keys) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\nexport function stripValues(inputObject, toStrip, recursive) {\n    return Object.fromEntries(Object.entries(inputObject).filter(([_, value]) => !dequal(value, toStrip)));\n}\nexport function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","import { get, writable } from 'svelte/store';\n/**\n * Transforms an existing store into a store with a `get` method.\n * Uses subscriptions to keep the value up to date, so make sure to call `destroy` when you're done with it.\n * @date 20/01/2024 - 16:38:39\n *\n * @export\n * @template {Readable<unknown>} T\n * @param {T} store\n * @returns {WithGet<T>}\n */\nexport function withGet(store) {\n    return {\n        ...store,\n        get: () => get(store),\n    };\n}\nwithGet.writable = function (initial) {\n    const internal = writable(initial);\n    let value = initial;\n    return {\n        subscribe: internal.subscribe,\n        set(newValue) {\n            internal.set(newValue);\n            value = newValue;\n        },\n        update(updater) {\n            const newValue = updater(value);\n            internal.set(newValue);\n            value = newValue;\n        },\n        get() {\n            return value;\n        },\n    };\n};\nwithGet.derived = function (stores, fn) {\n    const subscribers = new Map();\n    const get = () => {\n        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();\n        return fn(values);\n    };\n    const subscribe = (subscriber) => {\n        const unsubscribers = [];\n        const storesArr = Array.isArray(stores) ? stores : [stores];\n        storesArr.forEach((store) => {\n            unsubscribers.push(store.subscribe(() => {\n                subscriber(get());\n            }));\n        });\n        subscriber(get());\n        subscribers.set(subscriber, unsubscribers);\n        return () => {\n            const unsubscribers = subscribers.get(subscriber);\n            if (unsubscribers) {\n                for (const unsubscribe of unsubscribers) {\n                    unsubscribe();\n                }\n            }\n            subscribers.delete(subscriber);\n        };\n    };\n    return {\n        get,\n        subscribe,\n    };\n};\nexport function addGetToStores(stores) {\n    return Object.keys(stores).reduce((acc, key) => {\n        return {\n            ...acc,\n            [key]: withGet(stores[key]),\n        };\n    }, {});\n}\n","import { withGet } from './withGet.js';\nexport const overridable = (_store, onChange) => {\n    const store = withGet(_store);\n    const update = (updater, sideEffect) => {\n        store.update((curr) => {\n            const next = updater(curr);\n            let res = next;\n            if (onChange) {\n                res = onChange({ curr, next });\n            }\n            sideEffect?.(res);\n            return res;\n        });\n    };\n    const set = (curr) => {\n        update(() => curr);\n    };\n    return {\n        ...store,\n        update,\n        set,\n    };\n};\n","/**\n * A constant object that maps commonly used keyboard keys to their corresponding string values.\n * This object can be used in other parts of the application to handle keyboard input and prevent\n * hard-coded strings throughout.\n */\nexport const kbd = {\n    ALT: 'Alt',\n    ARROW_DOWN: 'ArrowDown',\n    ARROW_LEFT: 'ArrowLeft',\n    ARROW_RIGHT: 'ArrowRight',\n    ARROW_UP: 'ArrowUp',\n    BACKSPACE: 'Backspace',\n    CAPS_LOCK: 'CapsLock',\n    CONTROL: 'Control',\n    DELETE: 'Delete',\n    END: 'End',\n    ENTER: 'Enter',\n    ESCAPE: 'Escape',\n    F1: 'F1',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    HOME: 'Home',\n    META: 'Meta',\n    PAGE_DOWN: 'PageDown',\n    PAGE_UP: 'PageUp',\n    SHIFT: 'Shift',\n    SPACE: ' ',\n    TAB: 'Tab',\n    CTRL: 'Control',\n    ASTERISK: '*',\n    A: 'a',\n    P: 'p',\n};\n/** Key sets for navigation within lists, such as select, menu, and combobox. */\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const getNextKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n};\nexport const getPrevKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n};\nexport const getDirectionalKeys = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n};\n","import { derived } from 'svelte/store';\nimport { noop } from '../index.js';\nimport { safeOnDestroy } from '../lifecycle.js';\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function effect(stores, fn) {\n    let cb = undefined;\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const destroy = derived(stores, (stores) => {\n        cb?.();\n        cb = fn(stores);\n    }).subscribe(noop);\n    const unsub = () => {\n        destroy();\n        cb?.();\n    };\n    // Automatically unsubscribe the effect when the component is destroyed\n    safeOnDestroy(unsub);\n    return unsub;\n}\n","import { writable } from 'svelte/store';\nimport { withGet } from '../withGet.js';\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = withGet(writable(value));\n    });\n    return result;\n}\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/clickOutside/clickOutside.ts\nimport { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction } from '../../helpers/is.js';\n/**\n * Creates a readable store that tracks the latest PointerEvent that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking pointer events.\n */\nconst documentClickStore = readable(undefined, (set) => {\n    /**\n     * Event handler for pointerdown events on the document.\n     * Updates the store's value with the latest PointerEvent and then resets it to undefined.\n     */\n    function clicked(event) {\n        set(event);\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a pointerdown event listener to the document, calling the clicked function when triggered.\n    const unsubscribe = addEventListener(document, 'pointerup', clicked, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking pointer events.\n    return unsubscribe;\n});\nexport const useClickOutside = (node, config = {}) => {\n    let options = { enabled: true, ...config };\n    // Returns true if the click outside handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle document clicks\n    const unsubscribe = documentClickStore.subscribe((e) => {\n        // If the click outside handler is disabled, or if the event is null or the node itself, return early\n        if (!isEnabled() || !e || e.target === node) {\n            return;\n        }\n        const composedPath = e.composedPath();\n        // If the target is in the node, return early\n        if (composedPath.includes(node))\n            return;\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n","import { addEventListener } from '../../helpers/event.js';\nimport { isFunction, isHTMLElement, isReadable } from '../../helpers/is.js';\nimport { get, readable } from 'svelte/store';\nimport { effect, executeCallbacks, kbd, noop } from '../../helpers/index.js';\n/**\n * Creates a readable store that tracks the latest Escape Keydown that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking keydown events.\n */\nconst documentEscapeKeyStore = readable(undefined, (set) => {\n    /**\n     * Event handler for keydown events on the document.\n     * Updates the store's value with the latest Escape Keydown event and then resets it to undefined.\n     */\n    function keydown(event) {\n        if (event && event.key === kbd.ESCAPE) {\n            set(event);\n        }\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a keydown event listener to the document, calling the keydown function when triggered.\n    const unsubscribe = addEventListener(document, 'keydown', keydown, {\n        passive: false,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking keydown events.\n    return unsubscribe;\n});\nexport const useEscapeKeydown = (node, config = {}) => {\n    let unsub = noop;\n    function update(config = {}) {\n        unsub();\n        const options = { enabled: true, ...config };\n        const enabled = (isReadable(options.enabled) ? options.enabled : readable(options.enabled));\n        unsub = executeCallbacks(\n        // Handle escape keydowns\n        documentEscapeKeyStore.subscribe((e) => {\n            if (!e || !get(enabled))\n                return;\n            const target = e.target;\n            if (!isHTMLElement(target) || target.closest('[data-escapee]') !== node) {\n                return;\n            }\n            e.preventDefault();\n            // If an ignore function is passed, check if it returns true\n            if (options.ignore) {\n                if (isFunction(options.ignore)) {\n                    if (options.ignore(e))\n                        return;\n                }\n                // If an ignore array is passed, check if any elements in the array match the target\n                else if (Array.isArray(options.ignore)) {\n                    if (options.ignore.length > 0 &&\n                        options.ignore.some((ignoreEl) => {\n                            return ignoreEl && target === ignoreEl;\n                        }))\n                        return;\n                }\n            }\n            // If none of the above conditions are met, call the handler\n            options.handler?.(e);\n        }), effect(enabled, ($enabled) => {\n            if ($enabled) {\n                node.dataset.escapee = '';\n            }\n            else {\n                delete node.dataset.escapee;\n            }\n        }));\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            node.removeAttribute('data-escapee');\n            unsub();\n        },\n    };\n};\n","import { createElHelpers, makeElement } from '../../internal/helpers/makeElement.js';\nimport { readable } from 'svelte/store';\nimport { styleToString } from '../../internal/helpers/style.js';\nimport { toReadableStores } from '../../internal/helpers/store/toReadableStores.js';\nimport { omit } from '../../internal/helpers/object.js';\nimport { removeUndefined } from '../../internal/helpers/object.js';\nconst defaults = {\n    prefix: '',\n    disabled: readable(false),\n    required: readable(false),\n    name: readable(undefined),\n};\nexport function createHiddenInput(props) {\n    const withDefaults = {\n        ...defaults,\n        ...removeUndefined(props),\n    };\n    const { name: elName } = createElHelpers(withDefaults.prefix);\n    const { value, name, disabled, required } = toReadableStores(omit(withDefaults, 'prefix'));\n    const nameStore = name; // TODO: Remove this cast when types are fixed\n    const hiddenInput = makeElement(elName('hidden-input'), {\n        stores: [value, nameStore, disabled, required],\n        returned: ([$value, $name, $disabled, $required]) => {\n            return {\n                name: $name,\n                value: $value?.toString(),\n                'aria-hidden': 'true',\n                hidden: true,\n                disabled: $disabled,\n                required: $required,\n                tabIndex: -1,\n                style: styleToString({\n                    position: 'absolute',\n                    opacity: 0,\n                    'pointer-events': 'none',\n                    margin: 0,\n                    transform: 'translateX(-100%)',\n                }),\n            };\n        },\n        action: (node) => {\n            // When value changes, emit a change event\n            const unsub = value.subscribe((newValue) => {\n                node.value = newValue;\n                node.dispatchEvent(new Event('change', { bubbles: true }));\n            });\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    return hiddenInput;\n}\n","import { addMeltEventListener, makeElement, createElHelpers, effect, executeCallbacks, generateIds, isBrowser, isHTMLElement, isValidIndex, kbd, omit, overridable, styleToString, toWritableStores, withGet, } from '../../internal/helpers/index.js';\nimport { createFormatter, createMonths, dateStore, getAnnouncer, getDefaultDate, getSelectableCells, isAfter, isBefore, isCalendarCell, parseStringToDateValue, setPlaceholderToNodeValue, toDate, } from '../../internal/helpers/date/index.js';\nimport { getLocalTimeZone, isSameDay, isSameMonth, isToday, } from '@internationalized/date';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nexport const defaults = {\n    isDateDisabled: undefined,\n    isDateUnavailable: undefined,\n    value: undefined,\n    preventDeselect: false,\n    numberOfMonths: 1,\n    pagedNavigation: false,\n    weekStartsOn: 0,\n    fixedWeeks: false,\n    calendarLabel: 'Event Date',\n    locale: 'en',\n    minValue: undefined,\n    maxValue: undefined,\n    disabled: false,\n    readonly: false,\n    weekdayFormat: 'narrow',\n};\nconst { name } = createElHelpers('calendar');\nexport const calendarIdParts = ['calendar', 'accessibleHeading'];\nexport function createCalendar(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores({\n        ...omit(withDefaults, 'value', 'placeholder', 'multiple', 'ids'),\n        multiple: withDefaults.multiple ?? false,\n    });\n    const { preventDeselect, numberOfMonths, pagedNavigation, weekStartsOn, fixedWeeks, calendarLabel, locale, minValue, maxValue, multiple, isDateUnavailable, disabled, readonly, weekdayFormat, } = options;\n    const ids = toWritableStores({ ...generateIds(calendarIdParts), ...withDefaults.ids });\n    const defaultDate = getDefaultDate({\n        defaultPlaceholder: withDefaults.defaultPlaceholder,\n        defaultValue: withDefaults.defaultValue,\n    });\n    const formatter = createFormatter(withDefaults.locale);\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults.onValueChange);\n    const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);\n    const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);\n    /**\n     * A store containing the months to display in the calendar.\n     */\n    const months = withGet(writable(createMonths({\n        dateObj: placeholder.get(),\n        weekStartsOn: withDefaults.weekStartsOn,\n        locale: withDefaults.locale,\n        fixedWeeks: withDefaults.fixedWeeks,\n        numberOfMonths: withDefaults.numberOfMonths,\n    })));\n    /**\n     * A derived store that maintains the currently visible months in the calendar,\n     * which we use to determine how keyboard navigation and if we should apply\n     * `data-outside-month` to cells.\n     */\n    const visibleMonths = withGet.derived([months], ([$months]) => {\n        return $months.map((month) => {\n            return month.value;\n        });\n    });\n    const isOutsideVisibleMonths = derived([visibleMonths], ([$visibleMonths]) => {\n        return (date) => {\n            return !$visibleMonths.some((month) => isSameMonth(date, month));\n        };\n    });\n    const isNextButtonDisabled = withGet.derived([months, maxValue, disabled], ([$months, $maxValue, $disabled]) => {\n        if (!$maxValue || !$months.length)\n            return false;\n        if ($disabled)\n            return true;\n        const lastMonthInView = $months[$months.length - 1].value;\n        const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });\n        return isAfter(firstMonthOfNextPage, $maxValue);\n    });\n    const isPrevButtonDisabled = withGet.derived([months, minValue, disabled], ([$months, $minValue, $disabled]) => {\n        if (!$minValue || !$months.length)\n            return false;\n        if ($disabled)\n            return true;\n        const firstMonthInView = $months[0].value;\n        const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });\n        return isBefore(lastMonthOfPrevPage, $minValue);\n    });\n    /**\n     * A derived store function that determines if a date is disabled based\n     * on the `isDateDisabled` prop, `minValue`, and `maxValue` props.\n     */\n    const isDateDisabled = withGet.derived([options.isDateDisabled, minValue, maxValue, disabled], ([$isDateDisabled, $minValue, $maxValue, $disabled]) => {\n        return (date) => {\n            if ($isDateDisabled?.(date) || $disabled)\n                return true;\n            if ($minValue && isBefore(date, $minValue))\n                return true;\n            if ($maxValue && isBefore($maxValue, date))\n                return true;\n            return false;\n        };\n    });\n    const isDateSelected = derived([value], ([$value]) => {\n        return (date) => {\n            if (Array.isArray($value)) {\n                return $value.some((d) => isSameDay(d, date));\n            }\n            else if (!$value) {\n                return false;\n            }\n            else {\n                return isSameDay($value, date);\n            }\n        };\n    });\n    /**\n     * A derived helper store that evaluates to true if a currently selected date is invalid.\n     */\n    const isInvalid = derived([value, isDateDisabled, options.isDateUnavailable], ([$value, $isDateDisabled, $isDateUnavailable]) => {\n        if (Array.isArray($value)) {\n            if (!$value.length)\n                return false;\n            for (const date of $value) {\n                if ($isDateDisabled?.(date))\n                    return true;\n                if ($isDateUnavailable?.(date))\n                    return true;\n            }\n        }\n        else {\n            if (!$value)\n                return false;\n            if ($isDateDisabled?.($value))\n                return true;\n            if ($isDateUnavailable?.($value))\n                return true;\n        }\n        return false;\n    });\n    /**\n     * Initialize the announcer, which currently remains inactive in this context since it will\n     * be server-side rendered, but we'll initialize it in the calendar's action.\n     *\n     * The announcer is in charge of providing `aria-live` announcements for the calendar,\n     * such as when a date is selected.\n     */\n    let announcer = getAnnouncer();\n    /**\n     * The current heading value for the calendar, meant to be utilized with\n     * the {@link heading} builder.\n     * It renders the current displayed month and year, formatted for the current locale.\n     * This value updates automatically as the user navigates the calendar, even when\n     * displaying multiple months using the `numberOfMonths` prop.\n     */\n    const headingValue = withGet.derived([months, locale], ([$months, $locale]) => {\n        if (!$months.length)\n            return '';\n        if ($locale !== formatter.getLocale()) {\n            formatter.setLocale($locale);\n        }\n        if ($months.length === 1) {\n            const month = $months[0].value;\n            return `${formatter.fullMonthAndYear(toDate(month))}`;\n        }\n        const startMonth = toDate($months[0].value);\n        const endMonth = toDate($months[$months.length - 1].value);\n        const startMonthName = formatter.fullMonth(startMonth);\n        const endMonthName = formatter.fullMonth(endMonth);\n        const startMonthYear = formatter.fullYear(startMonth);\n        const endMonthYear = formatter.fullYear(endMonth);\n        const content = startMonthYear === endMonthYear\n            ? `${startMonthName} - ${endMonthName} ${endMonthYear}`\n            : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;\n        return content;\n    });\n    /**\n     * The accessible heading label for the calendar, generated by combining the `calendarLabel`\n     * prop and the `headingValue` store to create a label like `Event Date, January 2021`.\n     */\n    const fullCalendarLabel = withGet.derived([headingValue, calendarLabel], ([$headingValue, $calendarLabel]) => {\n        return `${$calendarLabel}, ${$headingValue}`;\n    });\n    /**\n     * The root element of the calendar, capable of housing multiple grids/months\n     * when using paged navigation.\n     */\n    const calendar = makeElement(name(), {\n        stores: [fullCalendarLabel, isInvalid, disabled, readonly, ids.calendar],\n        returned: ([$fullCalendarLabel, $isInvalid, $disabled, $readonly, $calendarId]) => {\n            return {\n                id: $calendarId,\n                role: 'application',\n                'aria-label': $fullCalendarLabel,\n                'data-invalid': $isInvalid ? '' : undefined,\n                'data-disabled': $disabled ? '' : undefined,\n                'data-readonly': $readonly ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            /**\n             * Generates the accessible calendar heading when the grid is mounted.\n             * The label is dynamically updated through an effect whenever there\n             * are changes in the active date or label.\n             */\n            createAccessibleHeading(node, fullCalendarLabel.get());\n            announcer = getAnnouncer();\n            const unsubKb = addMeltEventListener(node, 'keydown', handleCalendarKeydown);\n            return {\n                destroy() {\n                    unsubKb();\n                },\n            };\n        },\n    });\n    /**\n     * The calendar heading, visually displaying the current month and year. This heading\n     * is hidden from screen readers as an accessible heading is automatically generated\n     * for the calendar.\n     *\n     * To customize the accessible heading's prefix, use the `calendarLabel` prop. By default,\n     * the accessible heading reads as `Event Date, January 2021` for January 2021. If you set\n     * the `calendarLabel` prop to 'Booking Date', the accessible heading will be 'Booking Date,\n     * January 2021' for the same month and year.\n     */\n    const heading = makeElement(name('heading'), {\n        stores: [disabled],\n        returned: ([$disabled]) => {\n            return {\n                'aria-hidden': true,\n                'data-disabled': $disabled ? '' : undefined,\n            };\n        },\n    });\n    /**\n     * A grid element that serves as a container for a single month in the calendar.\n     * Grids should be rendered for each month present in the `months` store returned\n     * by the `createCalendar` builder.\n     *\n     * For more details about the structure of the month object, refer to {@link Month}.\n     */\n    const grid = makeElement(name('grid'), {\n        stores: [readonly, disabled],\n        returned: ([$readonly, $disabled]) => {\n            return {\n                tabindex: -1,\n                role: 'grid',\n                'aria-readonly': $readonly ? 'true' : undefined,\n                'aria-disabled': $disabled ? 'true' : undefined,\n                'data-readonly': $readonly ? '' : undefined,\n                'data-disabled': $disabled ? '' : undefined,\n            };\n        },\n    });\n    /**\n     * The 'prev' button for the calendar, enabling navigation to the\n     * previous page. In paged navigation mode, it moves the calendar\n     * back by the number of months specified in the `numberOfMonths` prop.\n     * In non-paged mode, it shifts the calendar back by one month.\n     */\n    const prevButton = makeElement(name('prevButton'), {\n        stores: [isPrevButtonDisabled],\n        returned: ([$isPrevButtonDisabled]) => {\n            const disabled = $isPrevButtonDisabled;\n            return {\n                role: 'button',\n                type: 'button',\n                'aria-label': 'Previous',\n                'aria-disabled': disabled ? 'true' : undefined,\n                'data-disabled': disabled ? '' : undefined,\n                disabled: disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                if (isPrevButtonDisabled.get())\n                    return;\n                prevPage();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * A button element designed for navigating to the next page of the calendar.\n     * If using paged navigation, it advances the calendar by the number of months\n     * specified in the `numberOfMonths` prop. If not using paged navigation, it\n     * moves the calendar forward by one month.\n     */\n    const nextButton = makeElement(name('nextButton'), {\n        stores: [isNextButtonDisabled],\n        returned: ([$isNextButtonDisabled]) => {\n            const disabled = $isNextButtonDisabled;\n            return {\n                role: 'button',\n                type: 'button',\n                'aria-label': 'Next',\n                'aria-disabled': disabled ? 'true' : undefined,\n                'data-disabled': disabled ? '' : undefined,\n                disabled: disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                if (isNextButtonDisabled.get())\n                    return;\n                nextPage();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * Represents an individual date cell in the calendar grid,\n     * signifying a single day within the month. Configured with\n     * essential attributes and event handlers for accessibility\n     * and interactivity.\n     */\n    const cell = makeElement(name('cell'), {\n        stores: [\n            isDateSelected,\n            isDateDisabled,\n            isDateUnavailable,\n            isOutsideVisibleMonths,\n            placeholder,\n        ],\n        returned: ([$isDateSelected, $isDateDisabled, $isDateUnavailable, $isOutsideVisibleMonths, $placeholder,]) => {\n            /**\n             * Applies the appropriate attributes to each date cell in the calendar.\n             *\n             * @params cellValue - The `DateValue` for the current cell.\n             * @params monthValue - The `DateValue` for the current month, which is used\n             * to determine if the current cell is outside the current month.\n             */\n            return (cellValue, monthValue) => {\n                const cellDate = toDate(cellValue);\n                const isDisabled = $isDateDisabled?.(cellValue);\n                const isUnavailable = $isDateUnavailable?.(cellValue);\n                const isDateToday = isToday(cellValue, getLocalTimeZone());\n                const isOutsideMonth = !isSameMonth(cellValue, monthValue);\n                const isOutsideVisibleMonths = $isOutsideVisibleMonths(cellValue);\n                const isFocusedDate = isSameDay(cellValue, $placeholder);\n                const isSelectedDate = $isDateSelected(cellValue);\n                const labelText = formatter.custom(cellDate, {\n                    weekday: 'long',\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric',\n                });\n                return {\n                    role: 'button',\n                    'aria-label': labelText,\n                    'aria-selected': isSelectedDate ? true : undefined,\n                    'aria-disabled': isOutsideMonth || isDisabled || isUnavailable ? true : undefined,\n                    'data-selected': isSelectedDate ? true : undefined,\n                    'data-value': cellValue.toString(),\n                    'data-disabled': isDisabled || isOutsideMonth ? '' : undefined,\n                    'data-unavailable': isUnavailable ? '' : undefined,\n                    'data-today': isDateToday ? '' : undefined,\n                    'data-outside-month': isOutsideMonth ? '' : undefined,\n                    'data-outside-visible-months': isOutsideVisibleMonths ? '' : undefined,\n                    'data-focused': isFocusedDate ? '' : undefined,\n                    tabindex: isFocusedDate ? 0 : isOutsideMonth || isDisabled ? undefined : -1,\n                };\n            };\n        },\n        action: (node) => {\n            const getElArgs = () => {\n                const value = node.getAttribute('data-value');\n                const label = node.getAttribute('data-label');\n                const disabled = node.hasAttribute('data-disabled');\n                return {\n                    value,\n                    label: label ?? node.textContent ?? null,\n                    disabled: disabled ? true : false,\n                };\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const args = getElArgs();\n                if (args.disabled)\n                    return;\n                if (!args.value)\n                    return;\n                handleCellClick(parseStringToDateValue(args.value, placeholder.get()));\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * Synchronize the locale used within the formatter to ensure\n     * dynamic updates are reflected in the calendar.\n     */\n    effect([locale], ([$locale]) => {\n        if (formatter.getLocale() === $locale)\n            return;\n        formatter.setLocale($locale);\n    });\n    /**\n     * Updates the displayed months based on changes in the placeholder value,\n     * which determines the months to show in the calendar.\n     */\n    effect([placeholder], ([$placeholder]) => {\n        if (!isBrowser || !$placeholder)\n            return;\n        const $visibleMonths = visibleMonths.get();\n        /**\n         * If the placeholder's month is already in the visible months,\n         * we don't need to do anything.\n         */\n        if ($visibleMonths.some((month) => isSameMonth(month, $placeholder))) {\n            return;\n        }\n        const $weekStartsOn = weekStartsOn.get();\n        const $locale = locale.get();\n        const $fixedWeeks = fixedWeeks.get();\n        const $numberOfMonths = numberOfMonths.get();\n        const defaultMonthProps = {\n            weekStartsOn: $weekStartsOn,\n            locale: $locale,\n            fixedWeeks: $fixedWeeks,\n            numberOfMonths: $numberOfMonths,\n        };\n        months.set(createMonths({\n            ...defaultMonthProps,\n            dateObj: $placeholder,\n        }));\n    });\n    /**\n     * Updates the displayed months based on changes in the the options values,\n     * which determines the months to show in the calendar.\n     */\n    effect([weekStartsOn, locale, fixedWeeks, numberOfMonths], ([$weekStartsOn, $locale, $fixedWeeks, $numberOfMonths]) => {\n        const $placeholder = placeholder.get();\n        if (!isBrowser || !$placeholder)\n            return;\n        const defaultMonthProps = {\n            weekStartsOn: $weekStartsOn,\n            locale: $locale,\n            fixedWeeks: $fixedWeeks,\n            numberOfMonths: $numberOfMonths,\n        };\n        months.set(createMonths({\n            ...defaultMonthProps,\n            dateObj: $placeholder,\n        }));\n    });\n    /**\n     * Update the accessible heading's text content when the\n     * `fullCalendarLabel` store changes.\n     */\n    effect([fullCalendarLabel], ([$fullCalendarLabel]) => {\n        if (!isBrowser)\n            return;\n        const node = document.getElementById(ids.accessibleHeading.get());\n        if (!isHTMLElement(node))\n            return;\n        node.textContent = $fullCalendarLabel;\n    });\n    /**\n     * Synchronizing the placeholder value with the current value.\n     */\n    effect([value], ([$value]) => {\n        if (Array.isArray($value) && $value.length) {\n            const lastValue = $value[$value.length - 1];\n            if (lastValue && placeholder.get() !== lastValue) {\n                placeholder.set(lastValue);\n            }\n        }\n        else if (!Array.isArray($value) && $value && placeholder.get() !== $value) {\n            placeholder.set($value);\n        }\n    });\n    /**\n     * This derived store holds an array of localized day names for the current\n     * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,\n     * updating its content when the option changes. Using this store to render the\n     * calendar's days of the week is strongly recommended, as it guarantees that\n     * the days are correctly formatted for the current locale and calendar view.\n     *\n     * @example\n     * ```svelte\n     * <table use:melt={$grid} class=\"w-full\">\n     * \t<thead aria-hidden=\"true\">\n     * \t\t<tr>\n     * \t\t\t{#each $weekdays as day}\n     * \t\t\t\t<th class=\"text-sm font-semibold text-magnum-800\">\n     * \t\t\t\t\t<div class=\"flex h-6 w-6 items-center justify-center p-4\">\n     * \t\t\t\t\t\t{day}\n     * \t\t\t\t\t</div>\n     * \t\t\t\t</th>\n     * \t\t\t{/each}\n     * \t\t</tr>\n     * \t</thead>\n     * \t<!-- ... -->\n     * </table>\n     * ```\n     *\n     * If you prefer to format/render the days of the week yourself,\n     * you can do so by accessing the first week of the first month,\n     * and mapping over the dates to get/format each day of the week.\n     *\n     * @example\n     * ```svelte\n     * {#each $months as month}\n     * \t<table use:melt={$grid} class=\"w-full\">\n     * \t\t<thead aria-hidden=\"true\">\n     * \t\t\t<tr>\n     * \t\t\t\t{#each month.weeks[0] as dayOfWeek}\n     * \t\t\t\t\t<th class=\"text-sm font-semibold text-magnum-800\">\n     * \t\t\t\t\t\t<div class=\"flex h-6 w-6 items-center justify-center p-4\">\n     * \t\t\t\t\t\t\t{new Intl.DateTimeFormat('en', { weekday: 'long' }).format\n     * \t\t\t\t\t\t\t(dayOfWeek)}\n     * \t\t\t\t\t\t</div>\n     * \t\t\t\t\t</th>\n     * \t\t\t\t{/each}\n     * \t\t\t</tr>\n     * \t\t</thead>\n     * \t\t<!-- ... -->\n     * \t</table>\n     * {/each}\n     * ```\n     *\n     */\n    const weekdays = derived([months, weekdayFormat, locale], ([$months, $weekdayFormat, _]) => {\n        if (!$months.length)\n            return [];\n        return $months[0].weeks[0].map((date) => {\n            return formatter.dayOfWeek(toDate(date), $weekdayFormat);\n        });\n    });\n    /**\n     * Creates an accessible heading for the calendar, ensuring that\n     * when it is focused by a screen reader, the displayed date range\n     * is announced. This approach maintains accessibility for screen\n     * readers while keeping the heading hidden from the visual design\n     * of the calendar.\n     */\n    function createAccessibleHeading(node, label) {\n        if (!isBrowser)\n            return;\n        const div = document.createElement('div');\n        div.style.cssText = styleToString({\n            border: '0px',\n            clip: 'rect(0px, 0px, 0px, 0px)',\n            'clip-path': 'inset(50%)',\n            height: '1px',\n            margin: '-1px',\n            overflow: 'hidden',\n            padding: '0px',\n            position: 'absolute',\n            'white-space': 'nowrap',\n            width: '1px',\n        });\n        const h2 = document.createElement('div');\n        h2.textContent = label;\n        h2.id = ids.accessibleHeading.get();\n        h2.role = 'heading';\n        h2.ariaLevel = '2';\n        node.insertBefore(div, node.firstChild);\n        div.appendChild(h2);\n    }\n    /**\n     * Navigate to the next page of the calendar.\n     *\n     * @remarks\n     * If using paged navigation, this will move the calendar forward\n     * by the number of months specified in the `numberOfMonths` prop.\n     * If not using paged navigation, this will move the calendar forward\n     * by one month.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextPage } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={nextPage} aria-label=\"Next page\"></button>\n     * ```\n     */\n    function nextPage() {\n        const $months = months.get();\n        const $numberOfMonths = numberOfMonths.get();\n        if (pagedNavigation.get()) {\n            const firstMonth = $months[0].value;\n            placeholder.set(firstMonth.add({ months: $numberOfMonths }));\n        }\n        else {\n            const firstMonth = $months[0].value;\n            const newMonths = createMonths({\n                dateObj: firstMonth.add({ months: 1 }),\n                weekStartsOn: weekStartsOn.get(),\n                locale: locale.get(),\n                fixedWeeks: fixedWeeks.get(),\n                numberOfMonths: $numberOfMonths,\n            });\n            months.set(newMonths);\n            placeholder.set(newMonths[0].value.set({ day: 1 }));\n        }\n    }\n    /**\n     * Navigate to the previous page of the calendar.\n     *\n     * @remarks\n     * A helper function to navigate to the previous page of the calendar.\n     * If using paged navigation, this will move the calendar backwards\n     * by the number of months specified in the `numberOfMonths` prop.\n     * If not using paged navigation, this will move the calendar backwards\n     * by one month.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { prevPage } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevPage} aria-label=\"Previous page\"></button>\n     * ```\n     */\n    function prevPage() {\n        const $months = months.get();\n        const $numberOfMonths = numberOfMonths.get();\n        if (pagedNavigation.get()) {\n            const firstMonth = $months[0].value;\n            placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));\n        }\n        else {\n            const firstMonth = $months[0].value;\n            const newMonths = createMonths({\n                dateObj: firstMonth.subtract({ months: 1 }),\n                weekStartsOn: weekStartsOn.get(),\n                locale: locale.get(),\n                fixedWeeks: fixedWeeks.get(),\n                numberOfMonths: $numberOfMonths,\n            });\n            months.set(newMonths);\n            placeholder.set(newMonths[0].value.set({ day: 1 }));\n        }\n    }\n    /**\n     * Navigate to the next year in the calendar.\n     *\n     * @remarks\n     * A helper function to navigate to the next year in the calendar,\n     * which is useful if you want to extend the calendar to have buttons\n     * to navigate to the next/prev year.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextYear, prevYear } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevYear} aria-label=\"Previous year\"></button>\n     * <button on:click={nextYear} aria-label=\"Next year\"></button>\n     *\n     * ```\n     */\n    function nextYear() {\n        placeholder.add({ years: 1 });\n    }\n    /**\n     * A helper function to navigate to the previous year in the calendar,\n     * which is useful if you want to extend the calendar to have buttons\n     * to navigate to the next/prev year.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextYear, prevYear } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevYear} aria-label=\"Previous year\"></button>\n     * <button on:click={nextYear} aria-label=\"Next year\"></button>\n     *\n     * ```\n     */\n    function prevYear() {\n        placeholder.subtract({ years: 1 });\n    }\n    const ARROW_KEYS = [kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.ARROW_LEFT, kbd.ARROW_RIGHT];\n    /**\n     * Set the year of the calendar to the specified year.\n     *\n     * @remarks\n     * This is useful if you want to extend the calendar to have\n     * alternative ways to change the year, such as a select input.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { setYear } } = createCalendar()\n     *\n     * \tlet selectValue = 2023;\n     * \t$: setYear(selectValue);\n     * </script>\n     *\n     * <select bind:value={selectValue} aria-label='Select a year'>\n     * \t<option value={2023}>2023</option>\n     * \t<option value={2024}>2024</option>\n     * \t<option value={2025}>2025</option>\n     * \t<!-- ... -->\n     * </select>\n     * ```\n     */\n    function setYear(year) {\n        placeholder.setDate({ year: year });\n    }\n    /**\n     * Set the month of the calendar to the specified month.\n     *\n     * @remarks\n     * This is useful if you want to extend the calendar to have\n     * alternative ways to change the month, such as a select input.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { setMonth } } = createCalendar()\n     *\n     * \tlet selectValue = 1;\n     * \t$: setMonth(selectValue);\n     * </script>\n     *\n     * <select bind:value={selectValue} aria-label='Select a month'>\n     * \t<option value={1}>January</option>\n     * \t<option value={2}>February</option>\n     * \t<option value={3}>March</option>\n     * \t<!-- ... -->\n     * </select>\n     * ```\n     */\n    function setMonth(month) {\n        placeholder.setDate({ month: month });\n    }\n    function handleCellClick(date) {\n        const $readonly = readonly.get();\n        if ($readonly)\n            return;\n        const $isDateDisabled = isDateDisabled.get();\n        const $isUnavailable = options.isDateUnavailable.get();\n        if ($isDateDisabled?.(date) || $isUnavailable?.(date))\n            return;\n        value.update((prev) => {\n            const $multiple = multiple.get();\n            if ($multiple) {\n                return handleMultipleUpdate(prev, date);\n            }\n            else {\n                const next = handleSingleUpdate(prev, date);\n                if (!next) {\n                    announcer.announce('Selected date is now empty.', 'polite', 5000);\n                }\n                else {\n                    announcer.announce(`Selected Date: ${formatter.selectedDate(next, false)}`, 'polite');\n                }\n                return next;\n            }\n        });\n    }\n    function handleSingleUpdate(prev, date) {\n        if (Array.isArray(prev))\n            throw new Error('Invalid value for multiple prop.');\n        if (!prev)\n            return date;\n        const $preventDeselect = preventDeselect.get();\n        if (!$preventDeselect && isSameDay(prev, date)) {\n            placeholder.set(date);\n            return undefined;\n        }\n        return date;\n    }\n    function handleMultipleUpdate(prev, date) {\n        if (!prev)\n            return [date];\n        if (!Array.isArray(prev))\n            throw new Error('Invalid value for multiple prop.');\n        const index = prev.findIndex((d) => isSameDay(d, date));\n        const $preventDeselect = preventDeselect.get();\n        if (index === -1) {\n            return [...prev, date];\n        }\n        else if ($preventDeselect) {\n            return prev;\n        }\n        else {\n            const next = prev.filter((d) => !isSameDay(d, date));\n            if (!next.length) {\n                placeholder.set(date);\n                return undefined;\n            }\n            return next;\n        }\n    }\n    const SELECT_KEYS = [kbd.ENTER, kbd.SPACE];\n    function handleCalendarKeydown(e) {\n        const currentCell = e.target;\n        if (!isCalendarCell(currentCell))\n            return;\n        if (!ARROW_KEYS.includes(e.key) && !SELECT_KEYS.includes(e.key))\n            return;\n        e.preventDefault();\n        // the cell that is currently focused\n        if (e.key === kbd.ARROW_DOWN) {\n            shiftFocus(currentCell, 7);\n        }\n        if (e.key === kbd.ARROW_UP) {\n            shiftFocus(currentCell, -7);\n        }\n        if (e.key === kbd.ARROW_LEFT) {\n            shiftFocus(currentCell, -1);\n        }\n        if (e.key === kbd.ARROW_RIGHT) {\n            shiftFocus(currentCell, 1);\n        }\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            const cellValue = currentCell.getAttribute('data-value');\n            if (!cellValue)\n                return;\n            handleCellClick(parseStringToDateValue(cellValue, placeholder.get()));\n        }\n    }\n    function shiftFocus(node, add) {\n        const candidateCells = getSelectableCells(ids.calendar.get());\n        if (!candidateCells.length)\n            return;\n        const index = candidateCells.indexOf(node);\n        const nextIndex = index + add;\n        /**\n         * If the next cell is within the bounds of the\n         * displayed/rendered cells, easy day, just focus it.\n         */\n        if (isValidIndex(nextIndex, candidateCells)) {\n            const nextCell = candidateCells[nextIndex];\n            setPlaceholderToNodeValue(nextCell, placeholder);\n            return nextCell.focus();\n        }\n        /**\n         * When the next cell falls outside the displayed/rendered cells range,\n         * we update the focus to the previous or next month based on the direction,\n         * and then focus on the relevant cell.\n         */\n        if (nextIndex < 0) {\n            /**\n             * To handle negative index values, we rewind by one month,\n             * retrieve candidate cells for that month, and shift the focus\n             * by the difference between the nextIndex starting from the end\n             * of the array.\n             */\n            // shift the calendar back a month unless previous month is disabled\n            if (isPrevButtonDisabled.get())\n                return;\n            const $months = months.get();\n            const firstMonth = $months[0].value;\n            const $numberOfMonths = numberOfMonths.get();\n            placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));\n            // Without a tick here, it seems to be too fast for\n            // the DOM to update, with the tick it works great\n            tick().then(() => {\n                const newCandidateCells = getSelectableCells(ids.calendar.get());\n                if (!newCandidateCells.length) {\n                    return;\n                }\n                /**\n                 * Starting at the end of the array, shift focus by the\n                 * difference between the nextIndex and the length of the\n                 * array, since the nextIndex is negative.\n                 */\n                const newIndex = newCandidateCells.length - Math.abs(nextIndex);\n                if (isValidIndex(newIndex, newCandidateCells)) {\n                    const newCell = newCandidateCells[newIndex];\n                    setPlaceholderToNodeValue(newCell, placeholder);\n                    return newCell.focus();\n                }\n            });\n        }\n        if (nextIndex >= candidateCells.length) {\n            /**\n             * Since we're in the positive index range, we need to\n             * go forward a month, refetch the candidate cells within that\n             * month, and then starting at the beginning of that array,\n             * shift focus by the nextIndex amount.\n             */\n            // shift the calendar forward a month unless next month is disabled\n            if (isNextButtonDisabled.get())\n                return;\n            const $months = months.get();\n            const firstMonth = $months[0].value;\n            const $numberOfMonths = numberOfMonths.get();\n            placeholder.set(firstMonth.add({ months: $numberOfMonths }));\n            tick().then(() => {\n                const newCandidateCells = getSelectableCells(ids.calendar.get());\n                if (!newCandidateCells.length) {\n                    return;\n                }\n                /**\n                 * We need to determine how far into the next month we need to go\n                 * to get the next index. So if we only went over the previous\n                 * month by 1, we need to go into the next month by 1 to get the\n                 * right index.\n                 */\n                const newIndex = nextIndex - candidateCells.length;\n                if (isValidIndex(newIndex, newCandidateCells)) {\n                    const nextCell = newCandidateCells[newIndex];\n                    return nextCell.focus();\n                }\n            });\n        }\n    }\n    /**\n     * A helper function to determine if a date cell is disabled,\n     * which uses the `Matcher`(s) provided via the `isDisabled`\n     * prop, as well as other internal logic, such as if it's\n     * outside of the month, or if it's before/after the min/max\n     * values.\n     *\n     * Although we set attributes on the cells themselves, for\n     * easy styling this function is useful when you want to\n     * conditionally handle something outside of the cell,\n     * such as its wrapping element.\n     *\n     * @example\n     * ```svelte\n     * {#each dates as date}\n     * \t<td role=\"gridcell\" aria-disabled={$isDisabled(date)}>\n     * \t\t<!-- ... -->\n     * \t</td>\n     * {/each}\n     * ```\n     *\n     * @param date - The `DateValue` to check\n     * @returns `true` if the date is disabled, `false` otherwise\n     */\n    const _isDateDisabled = derived([isDateDisabled, placeholder, minValue, maxValue, disabled], ([$isDateDisabled, $placeholder, $minValue, $maxValue, $disabled]) => {\n        return (date) => {\n            if ($isDateDisabled?.(date) || $disabled)\n                return true;\n            if ($minValue && isBefore(date, $minValue))\n                return true;\n            if ($maxValue && isAfter(date, $maxValue))\n                return true;\n            if (!isSameMonth(date, $placeholder))\n                return true;\n            return false;\n        };\n    });\n    /**\n     * A helper function to determine if a date is unavailable,\n     * which uses the `Matcher`(s) provided via the `unavailable`\n     * prop.\n     *\n     * Although we set attributes on the cells themselves, this\n     * function is useful when you want to conditionally handle\n     * something outside of the cell, such as its wrapping element.\n     *\n     * @example\n     * ```svelte\n     * {#each dates as date}\n     * \t<td role=\"gridcell\">\n     * \t\t{#if $isUnavailable(date)}\n     * \t\t\t<span>X</span>\n     * \t\t{/if}\n     * \t\t<!-- ... -->\n     * \t</td>\n     * {/each}\n     * ```\n     *\n     * @param date - The `DateValue` to check\n     * @returns `true` if the date is disabled, `false` otherwise\n     */\n    const _isDateUnavailable = derived(isDateUnavailable, ($isDateUnavailable) => {\n        return (date) => $isDateUnavailable?.(date);\n    });\n    return {\n        elements: {\n            calendar,\n            heading,\n            grid,\n            cell,\n            nextButton,\n            prevButton,\n        },\n        states: {\n            placeholder: placeholder.toWritable(),\n            months,\n            value,\n            weekdays,\n            headingValue,\n        },\n        helpers: {\n            nextPage,\n            prevPage,\n            nextYear,\n            prevYear,\n            setYear,\n            setMonth,\n            isDateDisabled: _isDateDisabled,\n            isDateSelected,\n            isDateUnavailable: _isDateUnavailable,\n        },\n        options,\n        ids,\n    };\n}\n","import { createCalendar, createDateField, createPopover } from '../index.js';\nimport { handleSegmentNavigation, isSegmentNavigationKey, } from '../../internal/helpers/date/index.js';\nimport { addMeltEventListener, makeElement, effect, omit, toWritableStores, } from '../../internal/helpers/index.js';\nimport { pickerOpenFocus } from '../../internal/helpers/date/focus.js';\nimport { createFormatter, dateStore, getDefaultDate } from '../../internal/helpers/date/index.js';\nimport { defaults as calendarDefaults } from '../calendar/create.js';\nconst defaults = {\n    isDateDisabled: undefined,\n    isDateUnavailable: undefined,\n    value: undefined,\n    positioning: {\n        placement: 'bottom',\n    },\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    onOutsideClick: undefined,\n    preventScroll: false,\n    forceVisible: false,\n    locale: 'en',\n    granularity: undefined,\n    disabled: false,\n    readonly: false,\n    minValue: undefined,\n    maxValue: undefined,\n    weekdayFormat: 'narrow',\n    ...omit(calendarDefaults, 'isDateDisabled', 'isDateUnavailable', 'value', 'locale', 'disabled', 'readonly', 'minValue', 'maxValue', 'weekdayFormat'),\n};\nexport function createDatePicker(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value', 'placeholder'));\n    const dateField = createDateField({\n        ...withDefaults,\n        ids: withDefaults.dateFieldIds,\n    });\n    const { states: { value, placeholder: dfPlaceholder }, } = dateField;\n    const calendar = createCalendar({\n        ...omit(withDefaults, 'onValueChange'),\n        placeholder: dfPlaceholder,\n        value: value,\n        ids: withDefaults.calendarIds,\n    });\n    const popover = createPopover({\n        positioning: withDefaults.positioning,\n        arrowSize: withDefaults.arrowSize,\n        defaultOpen: withDefaults.defaultOpen,\n        open: withDefaults.open,\n        disableFocusTrap: withDefaults.disableFocusTrap,\n        closeOnEscape: withDefaults.closeOnEscape,\n        preventScroll: withDefaults.preventScroll,\n        onOpenChange: withDefaults.onOpenChange,\n        closeOnOutsideClick: withDefaults.closeOnOutsideClick,\n        portal: withDefaults.portal,\n        forceVisible: withDefaults.forceVisible,\n        openFocus: pickerOpenFocus,\n        ids: withDefaults.popoverIds,\n        onOutsideClick: withDefaults.onOutsideClick,\n    });\n    const trigger = makeElement('popover-trigger', {\n        stores: [popover.elements.trigger, options.disabled],\n        returned: ([$trigger, $disabled]) => {\n            return {\n                ...omit($trigger, 'action'),\n                'aria-label': 'Open date picker',\n                'data-segment': 'trigger',\n                disabled: $disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsubKeydown = addMeltEventListener(node, 'keydown', handleTriggerKeydown);\n            const { destroy } = popover.elements.trigger(node);\n            return {\n                destroy() {\n                    destroy?.();\n                    unsubKeydown();\n                },\n            };\n        },\n    });\n    const formatter = createFormatter(options.locale.get());\n    effect([options.locale], ([$locale]) => {\n        dateField.options.locale.set($locale);\n        calendar.options.locale.set($locale);\n        if (formatter.getLocale() === $locale)\n            return;\n        formatter.setLocale($locale);\n    });\n    effect([options.weekdayFormat], ([$weekdayFormat]) => {\n        calendar.options.weekdayFormat.set($weekdayFormat);\n    });\n    effect([options.disabled], ([$disabled]) => {\n        dateField.options.disabled.set($disabled);\n        calendar.options.disabled.set($disabled);\n    });\n    effect([options.readonly], ([$readonly]) => {\n        dateField.options.readonly.set($readonly);\n        calendar.options.readonly.set($readonly);\n    });\n    effect([options.minValue], ([$minValue]) => {\n        dateField.options.minValue.set($minValue);\n        calendar.options.minValue.set($minValue);\n    });\n    effect([options.maxValue], ([$maxValue]) => {\n        dateField.options.maxValue.set($maxValue);\n        calendar.options.maxValue.set($maxValue);\n    });\n    effect([options.numberOfMonths], ([$numberOfMonths]) => {\n        calendar.options.numberOfMonths.set($numberOfMonths);\n    });\n    effect([options.fixedWeeks], ([$fixedWeeks]) => {\n        calendar.options.fixedWeeks.set($fixedWeeks);\n    });\n    effect([options.weekStartsOn], ([$weekStartsOn]) => {\n        calendar.options.weekStartsOn.set($weekStartsOn);\n    });\n    const dateFieldOptions = omit(dateField.options, 'locale', 'disabled', 'readonly', 'minValue', 'maxValue');\n    const calendarOptions = omit(calendar.options, 'locale', 'disabled', 'readonly', 'minValue', 'maxValue');\n    const { states: { open }, } = popover;\n    const defaultDate = getDefaultDate({\n        defaultPlaceholder: withDefaults.defaultPlaceholder,\n        defaultValue: withDefaults.defaultValue,\n        granularity: withDefaults.granularity,\n    });\n    const placeholder = dateStore(dfPlaceholder, withDefaults.defaultPlaceholder ?? defaultDate);\n    effect([open], ([$open]) => {\n        if (!$open) {\n            const $value = value.get();\n            if ($value) {\n                placeholder.set($value);\n            }\n            else {\n                placeholder.reset();\n            }\n        }\n    });\n    function handleTriggerKeydown(e) {\n        if (isSegmentNavigationKey(e.key)) {\n            e.preventDefault();\n            handleSegmentNavigation(e, dateField.ids.field.get());\n        }\n    }\n    return {\n        elements: {\n            ...calendar.elements,\n            ...dateField.elements,\n            ...popover.elements,\n            trigger,\n        },\n        states: {\n            ...dateField.states,\n            ...calendar.states,\n            placeholder: placeholder.toWritable(),\n            value,\n            ...popover.states,\n        },\n        helpers: {\n            ...calendar.helpers,\n        },\n        options: {\n            ...dateFieldOptions,\n            ...calendarOptions,\n            ...options,\n            ...popover.options,\n        },\n        ids: {\n            dateField: dateField.ids,\n            calendar: calendar.ids,\n            popover: popover.ids,\n        },\n    };\n}\n","export function createBitAttrs(bit, parts) {\n    const attrs = {};\n    parts.forEach((part) => {\n        attrs[part] = {\n            [`data-${bit}-${part}`]: \"\",\n        };\n    });\n    return (part) => attrs[part];\n}\nexport function disabledAttrs(disabled) {\n    return disabled\n        ? { \"aria-disabled\": \"true\", \"data-disabled\": \"\" }\n        : { \"aria-disabled\": undefined, \"data-disabled\": undefined };\n}\n","import { createEventDispatcher } from \"svelte\";\nexport function createDispatcher() {\n    const dispatch = createEventDispatcher();\n    return (e) => {\n        const { originalEvent } = e.detail;\n        const { cancelable } = e;\n        const type = originalEvent.type;\n        const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });\n        if (!shouldContinue) {\n            e.preventDefault();\n        }\n    };\n}\n","export function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","export function getOptionUpdater(options) {\n    return function (key, value) {\n        if (value === undefined)\n            return;\n        const store = options[key];\n        if (store) {\n            store.set(value);\n        }\n    };\n}\n"],"names":["styleToString","style","str","key","disabledAttr","disabled","portalAttr","portal","lightable","value","subscribe","run","hiddenAction","obj","target","prop","receiver","isFunctionWithParams","fn","makeElement","name","args","stores","action","returned","derivedStore","derived","values","result","noop","returnedFn","resultFn","actionFn","createElHelpers","prefix","part","attribute","selector","isBrowser","isFunction","v","isElement","element","isHTMLElement","isElementDisabled","ariaDisabled","dataDisabled","isObject","isReadable","executeCallbacks","callbacks","callback","addEventListener","event","handler","options","events","_event","addMeltEventListener","handlerWithMelt","withMelt","dispatchMeltEvent","originalEvent","node","customMeltEvent","customEvent","safeOnMount","onMount","safeOnDestroy","onDestroy","omit","keys","withGet","store","get","initial","internal","writable","newValue","updater","subscribers","subscriber","unsubscribers","unsubscribe","overridable","_store","onChange","update","sideEffect","curr","next","res","kbd","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SELECTION_KEYS","effect","cb","destroy","unsub","toWritableStores","properties","propertyKey","readable","set","clicked","documentEscapeKeyStore","keydown","useEscapeKeydown","config","enabled","e","ignoreEl","_a","$enabled","defaults","calendarDefaults","createBitAttrs","bit","parts","attrs","disabledAttrs","createDispatcher","dispatch","createEventDispatcher","cancelable","type","removeUndefined","getOptionUpdater"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}