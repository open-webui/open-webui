var BP=Object.defineProperty;var LP=(e,r,i)=>r in e?BP(e,r,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[r]=i;var _r=(e,r,i)=>LP(e,typeof r!="symbol"?r+"":r,i);import{s as safe_not_equal,e as element,t as text,k as space,c as claim_element,a as children,b as claim_text,d as detach,o as claim_space,f as attr,i as insert_hydration,g as append_hydration,h as set_data,j as component_subscribe,p as getContext,q as onMount,C as set_input_value,u as listen,H as run_all,T as src_url_equal,n as noop,E as svg_element,F as claim_svg_element,y as binding_callbacks,A as add_flush_callback,B as createEventDispatcher,r as create_slot,v as update_slot_base,w as get_all_dirty_from_scope,x as get_slot_changes,l as empty,I as get_svelte_dataset}from"../chunks/scheduler.Dg_Xn4WQ.js";import{S as SvelteComponent,i as init,b as create_component,d as claim_component,m as mount_component,t as transition_in,g as group_outros,a as transition_out,c as check_outros,e as destroy_component,f as bind}from"../chunks/index.gNonUo3Z.js";import{t as toast}from"../chunks/Toaster.svelte_svelte_type_style_lang.CM0nbnqF.js";import{g as globals}from"../chunks/globals.D0QH3NT1.js";import{e as ensure_array_like,u as update_keyed_each,d as destroy_block,o as outro_and_destroy_block}from"../chunks/each.dwVHsGX8.js";import{m as models}from"../chunks/index.C2zJs1dP.js";import{S as Spinner}from"../chunks/Spinner.C_k6OlPC.js";import{T as Tooltip}from"../chunks/Tooltip.FP-CxtJW.js";import{M as MagnifyingGlass}from"../chunks/MagnifyingGlass.CVR_fwbs.js";import{f as fileSaver}from"../chunks/FileSaver.min.CimDdHIv.js";import{d as dayjs,r as relativeTime}from"../chunks/relativeTime.BDz4fsXT.js";import{d as deleteFeedbackById,e as exportAllFeedbacks,g as getAllFeedbacks}from"../chunks/index.DDUbMGLd.js";import{A as ArrowDownTray}from"../chunks/ArrowDownTray.B6lNvHfw.js";import{B as Badge}from"../chunks/Badge.DCgPuNVo.js";import{P as Pagination_1}from"../chunks/Pagination.B9OTMUpA.js";import"../chunks/updater.B0HmoELl.js";import{D as Dropdown,M as Menu_item}from"../chunks/Dropdown.TmwXbC8a.js";import{b as Menu_content}from"../chunks/menu-trigger.qJyZyepX.js";import{f as flyAndScale}from"../chunks/index.BFuekP1B.js";import{G as GarbageBin}from"../chunks/GarbageBin.C8M1SI2a.js";import{E as EllipsisHorizontal}from"../chunks/EllipsisHorizontal.Dc0c2jlw.js";/*!
 * ONNX Runtime Web v1.20.0-dev.20241016-2b8fc5529b
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Hd=Object.create,an=Object.defineProperty,qd=Object.getOwnPropertyDescriptor,jd=Object.getOwnPropertyNames,Xd=Object.getPrototypeOf,Kd=Object.prototype.hasOwnProperty,Co=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,i)=>(typeof require<"u"?require:r)[i]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),O=(e,r)=>()=>(e&&(r=e(e=0)),r),mt=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),Or=(e,r)=>{for(var i in r)an(e,i,{get:r[i],enumerable:!0})},Qa=(e,r,i,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let c of jd(r))!Kd.call(e,c)&&c!==i&&an(e,c,{get:()=>r[c],enumerable:!(s=qd(r,c))||s.enumerable});return e},rr=(e,r,i)=>(i=e!=null?Hd(Xd(e)):{},Qa(!e||!e.__esModule?an(i,"default",{value:e,enumerable:!0}):i,e)),sn=e=>Qa(an({},"__esModule",{value:!0}),e),un,ke,nr,Jd,ln,fn=O(()=>{un=new Map,ke=[],nr=(e,r,i)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let s=un.get(e);if(s===void 0)un.set(e,{backend:r,priority:i});else{if(s.priority>i)return;if(s.priority===i&&s.backend!==r)throw new Error(`cannot register backend "${e}" using priority ${i}`)}if(i>=0){let c=ke.indexOf(e);c!==-1&&ke.splice(c,1);for(let n=0;n<ke.length;n++)if(un.get(ke[n]).priority<=i){ke.splice(n,0,e);return}ke.push(e)}return}throw new TypeError("not a valid backend")},Jd=async e=>{let r=un.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let i=!!r.initPromise;try{return i||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(s){return i||(r.error=`${s}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},ln=async e=>{let r=e.executionProviders||[],i=r.map(p=>typeof p=="string"?p:p.name),s=i.length===0?ke:i,c,n=[],a=new Set;for(let p of s){let t=await Jd(p);typeof t=="string"?n.push({name:p,err:t}):(c||(c=t),c===t&&a.add(p))}if(!c)throw new Error(`no available backend found. ERR: ${n.map(p=>`[${p.name}] ${p.err}`).join(", ")}`);for(let{name:p,err:t}of n)i.includes(p)&&console.warn(`removing requested execution provider "${p}" from session options because it is not available: ${t}`);let h=r.filter(p=>a.has(typeof p=="string"?p:p.name));return[c,new Proxy(e,{get:(p,t)=>t==="executionProviders"?h:Reflect.get(p,t)})]}}),ts=O(()=>{fn()}),es,rs=O(()=>{es="1.20.0-dev.20241016-2b8fc5529b"}),ns,Gt,No=O(()=>{rs(),ns="warning",Gt={wasm:{},webgl:{},webgpu:{},versions:{common:es},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);ns=e}},get logLevel(){return ns}},Object.defineProperty(Gt,"logLevel",{enumerable:!0})}),z,os=O(()=>{No(),z=Gt}),is,as,ss=O(()=>{is=(e,r)=>{let i=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);i.width=e.dims[3],i.height=e.dims[2];let s=i.getContext("2d");if(s!=null){let c,n;(r==null?void 0:r.tensorLayout)!==void 0&&r.tensorLayout==="NHWC"?(c=e.dims[2],n=e.dims[3]):(c=e.dims[3],n=e.dims[2]);let a=(r==null?void 0:r.format)!==void 0?r.format:"RGB",h=r==null?void 0:r.norm,p,t;h===void 0||h.mean===void 0?p=[255,255,255,255]:typeof h.mean=="number"?p=[h.mean,h.mean,h.mean,h.mean]:(p=[h.mean[0],h.mean[1],h.mean[2],0],h.mean[3]!==void 0&&(p[3]=h.mean[3])),h===void 0||h.bias===void 0?t=[0,0,0,0]:typeof h.bias=="number"?t=[h.bias,h.bias,h.bias,h.bias]:(t=[h.bias[0],h.bias[1],h.bias[2],0],h.bias[3]!==void 0&&(t[3]=h.bias[3]));let u=n*c,l=0,f=u,x=u*2,I=-1;a==="RGBA"?(l=0,f=u,x=u*2,I=u*3):a==="RGB"?(l=0,f=u,x=u*2):a==="RBG"&&(l=0,x=u,f=u*2);for(let R=0;R<n;R++)for(let A=0;A<c;A++){let Z=(e.data[l++]-t[0])*p[0],K=(e.data[f++]-t[1])*p[1],Q=(e.data[x++]-t[2])*p[2],re=I===-1?255:(e.data[I++]-t[3])*p[3];s.fillStyle="rgba("+Z+","+K+","+Q+","+re+")",s.fillRect(A,R,1,1)}if("toDataURL"in i)return i.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},as=(e,r)=>{let i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(i!=null){let c,n,a;(r==null?void 0:r.tensorLayout)!==void 0&&r.tensorLayout==="NHWC"?(c=e.dims[2],n=e.dims[1],a=e.dims[3]):(c=e.dims[3],n=e.dims[2],a=e.dims[1]);let h=r!==void 0&&r.format!==void 0?r.format:"RGB",p=r==null?void 0:r.norm,t,u;p===void 0||p.mean===void 0?t=[255,255,255,255]:typeof p.mean=="number"?t=[p.mean,p.mean,p.mean,p.mean]:(t=[p.mean[0],p.mean[1],p.mean[2],255],p.mean[3]!==void 0&&(t[3]=p.mean[3])),p===void 0||p.bias===void 0?u=[0,0,0,0]:typeof p.bias=="number"?u=[p.bias,p.bias,p.bias,p.bias]:(u=[p.bias[0],p.bias[1],p.bias[2],0],p.bias[3]!==void 0&&(u[3]=p.bias[3]));let l=n*c;if(r!==void 0&&(r.format!==void 0&&a===4&&r.format!=="RGBA"||a===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let f=4,x=0,I=1,R=2,A=3,Z=0,K=l,Q=l*2,re=-1;h==="RGBA"?(Z=0,K=l,Q=l*2,re=l*3):h==="RGB"?(Z=0,K=l,Q=l*2):h==="RBG"&&(Z=0,Q=l,K=l*2),s=i.createImageData(c,n);for(let se=0;se<n*c;x+=f,I+=f,R+=f,A+=f,se++)s.data[x]=(e.data[Z++]-u[0])*t[0],s.data[I]=(e.data[K++]-u[1])*t[1],s.data[R]=(e.data[Q++]-u[2])*t[2],s.data[A]=re===-1?255:(e.data[re++]-u[3])*t[3]}else throw new Error("Can not access image data");return s}}),Ro,us,ls,fs,cs,ps,ds=O(()=>{cn(),Ro=(e,r)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:i,width:s}=r,c=r.norm??{mean:255,bias:0},n,a;typeof c.mean=="number"?n=[c.mean,c.mean,c.mean,c.mean]:n=[c.mean[0],c.mean[1],c.mean[2],c.mean[3]??255],typeof c.bias=="number"?a=[c.bias,c.bias,c.bias,c.bias]:a=[c.bias[0],c.bias[1],c.bias[2],c.bias[3]??0];let h=r.format!==void 0?r.format:"RGBA",p=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",t=i*s,u=p==="RGBA"?new Float32Array(t*4):new Float32Array(t*3),l=4,f=0,x=1,I=2,R=3,A=0,Z=t,K=t*2,Q=-1;h==="RGB"&&(l=3,f=0,x=1,I=2,R=-1),p==="RGBA"?Q=t*3:p==="RBG"?(A=0,K=t,Z=t*2):p==="BGR"&&(K=0,Z=t,A=t*2);for(let re=0;re<t;re++,f+=l,I+=l,x+=l,R+=l)u[A++]=(e[f]+a[0])/n[0],u[Z++]=(e[x]+a[1])/n[1],u[K++]=(e[I]+a[2])/n[2],Q!==-1&&R!==-1&&(u[Q++]=(e[R]+a[3])/n[3]);return p==="RGBA"?new St("float32",u,[1,4,i,s]):new St("float32",u,[1,3,i,s])},us=async(e,r)=>{let i=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,c=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,n=typeof e=="string",a,h=r??{},p=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},t=u=>typeof HTMLCanvasElement<"u"&&u instanceof HTMLCanvasElement||u instanceof OffscreenCanvas?u.getContext("2d"):null;if(i){let u=p();u.width=e.width,u.height=e.height;let l=t(u);if(l!=null){let f=e.height,x=e.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(f=r.resizedHeight,x=r.resizedWidth),r!==void 0){if(h=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");h.tensorFormat="RGBA",h.height=f,h.width=x}else h.tensorFormat="RGBA",h.height=f,h.width=x;l.drawImage(e,0,0),a=l.getImageData(0,0,x,f).data}else throw new Error("Can not access image data")}else if(s){let u,l;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(u=r.resizedHeight,l=r.resizedWidth):(u=e.height,l=e.width),r!==void 0&&(h=r),h.format="RGBA",h.height=u,h.width=l,r!==void 0){let f=p();f.width=l,f.height=u;let x=t(f);if(x!=null)x.putImageData(e,0,0),a=x.getImageData(0,0,l,u).data;else throw new Error("Can not access image data")}else a=e.data}else if(c){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=p();u.width=e.width,u.height=e.height;let l=t(u);if(l!=null){let f=e.height,x=e.width;return l.drawImage(e,0,0,x,f),a=l.getImageData(0,0,x,f).data,h.height=f,h.width=x,Ro(a,h)}else throw new Error("Can not access image data")}else{if(n)return new Promise((u,l)=>{let f=p(),x=t(f);if(!e||!x)return l();let I=new Image;I.crossOrigin="Anonymous",I.src=e,I.onload=()=>{f.width=I.width,f.height=I.height,x.drawImage(I,0,0,f.width,f.height);let R=x.getImageData(0,0,f.width,f.height);h.height=f.height,h.width=f.width,u(Ro(R.data,h))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return Ro(a,h);throw new Error("Input data provided is not supported - aborted tensor creation")},ls=(e,r)=>{let{width:i,height:s,download:c,dispose:n}=r,a=[1,s,i,4];return new St({location:"texture",type:"float32",texture:e,dims:a,download:c,dispose:n})},fs=(e,r)=>{let{dataType:i,dims:s,download:c,dispose:n}=r;return new St({location:"gpu-buffer",type:i??"float32",gpuBuffer:e,dims:s,download:c,dispose:n})},cs=(e,r)=>{let{dataType:i,dims:s,download:c,dispose:n}=r;return new St({location:"ml-tensor",type:i??"float32",mlTensor:e,dims:s,download:c,dispose:n})},ps=(e,r,i)=>new St({location:"cpu-pinned",type:e,data:r,dims:i??[r.length]})}),Be,Sr,hs,ms,bs=O(()=>{Be=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Sr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),hs=!1,ms=()=>{if(!hs){hs=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,r=typeof BigUint64Array<"u"&&BigUint64Array.from,i=typeof Float16Array<"u"&&Float16Array.from;e&&(Be.set("int64",BigInt64Array),Sr.set(BigInt64Array,"int64")),r&&(Be.set("uint64",BigUint64Array),Sr.set(BigUint64Array,"uint64")),i?(Be.set("float16",Float16Array),Sr.set(Float16Array,"float16")):Be.set("float16",Uint16Array)}}}),gs,ys,xs=O(()=>{cn(),gs=e=>{let r=1;for(let i=0;i<e.length;i++){let s=e[i];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${i}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${s}`);r*=s}return r},ys=(e,r)=>{switch(e.location){case"cpu":return new St(e.type,e.data,r);case"cpu-pinned":return new St({location:"cpu-pinned",data:e.data,type:e.type,dims:r});case"texture":return new St({location:"texture",texture:e.texture,type:e.type,dims:r});case"gpu-buffer":return new St({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:r});case"ml-tensor":return new St({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),St,cn=O(()=>{ss(),ds(),bs(),xs(),St=class{constructor(e,r,i){ms();let s,c;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,s=e.type,c=e.dims,e.location){case"cpu-pinned":{let a=Be.get(s);if(!a)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,h;if(typeof e=="string")if(s=e,h=i,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");a=r}else{let p=Be.get(e);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&p===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${p.name} as data.`);e==="uint64"||e==="int64"?a=p.from(r,BigInt):a=p.from(r)}else if(r instanceof p)a=r;else if(r instanceof Uint8ClampedArray)if(e==="uint8")a=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${s} tensor's data must be type of ${p}`)}else if(h=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let p=typeof e[0];if(p==="string")s="string",a=e;else if(p==="boolean")s="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(e instanceof Uint8ClampedArray)s="uint8",a=Uint8Array.from(e);else{let p=Sr.get(e.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);s=p,a=e}if(h===void 0)h=[a.length];else if(!Array.isArray(h))throw new TypeError("A tensor's dims must be a number array");c=h,this.cpuData=a,this.dataLocation="cpu"}let n=gs(c);if(this.cpuData&&n!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(n/2)===this.cpuData.length))throw new Error(`Tensor's size(${n}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=c,this.size=n}static async fromImage(e,r){return us(e,r)}static fromTexture(e,r){return ls(e,r)}static fromGpuBuffer(e,r){return fs(e,r)}static fromMLTensor(e,r){return cs(e,r)}static fromPinnedBuffer(e,r,i){return ps(e,r,i)}toDataURL(e){return is(this,e)}toImageData(e){return as(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ys(this,e)}}}),yt,pn=O(()=>{cn(),yt=St}),Ts,ws,Fe,Ce,Go=O(()=>{No(),Ts=(e,r)=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||console.timeStamp(`${e}::ORT::${r}`)},ws=(e,r)=>{var c;let i=((c=new Error().stack)==null?void 0:c.split(/\r\n|\r|\n/g))||[],s=!1;for(let n=0;n<i.length;n++){if(s&&!i[n].includes("TRACE_FUNC")){let a=`FUNC_${e}::${i[n].trim().split(" ")[1]}`;r&&(a+=`::${r}`),Ts("CPU",a);return}i[n].includes("TRACE_FUNC")&&(s=!0)}},Fe=e=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||ws("BEGIN",e)},Ce=e=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||ws("END",e)}}),dn,vs=O(()=>{fn(),pn(),Go(),dn=class Z2{constructor(r){this.handler=r}async run(r,i,s){Fe();let c={},n={};if(typeof r!="object"||r===null||r instanceof yt||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof yt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let t of i){if(typeof t!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(t)===-1)throw new RangeError(`'fetches' contains invalid output name: ${t}.`);c[t]=null}if(typeof s=="object"&&s!==null)n=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let t=!1,u=Object.getOwnPropertyNames(i);for(let l of this.outputNames)if(u.indexOf(l)!==-1){let f=i[l];(f===null||f instanceof yt)&&(t=!0,a=!1,c[l]=f)}if(t){if(typeof s=="object"&&s!==null)n=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else n=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof r[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let t of this.outputNames)c[t]=null;let h=await this.handler.run(r,c,n),p={};for(let t in h)if(Object.hasOwnProperty.call(h,t)){let u=h[t];u instanceof yt?p[t]=u:p[t]=new yt(u.type,u.data,u.dims)}return Ce(),p}async release(){return this.handler.dispose()}static async create(r,i,s,c){Fe();let n,a={};if(typeof r=="string"){if(n=r,typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(n=r,typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let u=r,l=0,f=r.byteLength;if(typeof i=="object"&&i!==null)a=i;else if(typeof i=="number"){if(l=i,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=u.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${u.byteLength}).`);if(f=r.byteLength-l,typeof s=="number"){if(f=s,!Number.isSafeInteger(f))throw new RangeError("'byteLength' must be an integer.");if(f<=0||l+f>u.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${u.byteLength-l}].`);if(typeof c=="object"&&c!==null)a=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof i<"u")throw new TypeError("'options' must be an object.");n=new Uint8Array(u,l,f)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[h,p]=await ln(a),t=await h.createInferenceSessionHandler(n,p);return Ce(),new Z2(t)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Yd,Is=O(()=>{vs(),Yd=dn}),_s=O(()=>{}),Os=O(()=>{}),Ss=O(()=>{}),As=O(()=>{}),Zd,hn,Ps=O(()=>{fn(),pn(),Zd="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",hn=class J2{constructor(r,i,s){this.handler=r,this.hasOptimizerModel=i,this.hasEvalModel=s}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(r,i){let s=r.evalModel||"",c=r.optimizerModel||"",n=i||{},[a,h]=await ln(n);if(a.createTrainingSessionHandler){let p=await a.createTrainingSessionHandler(r.checkpointState,r.trainModel,s,c,h);return new J2(p,!!r.optimizerModel,!!r.evalModel)}else throw new Error(Zd)}typeNarrowingForRunStep(r,i,s,c,n){let a={},h={};if(typeof s!="object"||s===null||s instanceof yt||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let p=!0;if(typeof c=="object"){if(c===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(c instanceof yt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(c)){if(c.length===0)throw new TypeError("'fetches' cannot be an empty array.");p=!1;for(let t of c){if(typeof t!="string")throw new TypeError("'fetches' must be a string array or an object.");if(i.indexOf(t)===-1)throw new RangeError(`'fetches' contains invalid output name: ${t}.`);a[t]=null}if(typeof n=="object"&&n!==null)h=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let t=!1,u=Object.getOwnPropertyNames(c);for(let l of i)if(u.indexOf(l)!==-1){let f=c[l];(f===null||f instanceof yt)&&(t=!0,p=!1,a[l]=f)}if(t){if(typeof n=="object"&&n!==null)h=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else h=c}}else if(typeof c<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of r)if(typeof s[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(p)for(let t of i)a[t]=null;return[a,h]}convertHandlerReturnTypeToMapOfTensors(r){let i={};for(let s in r)if(Object.hasOwnProperty.call(r,s)){let c=r[s];c instanceof yt?i[s]=c:i[s]=new yt(c.type,c.data,c.dims)}return i}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(r,i,s){let[c,n]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,r,i,s),a=await this.handler.runTrainStep(r,c,n);return this.convertHandlerReturnTypeToMapOfTensors(a)}async runOptimizerStep(r){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(r||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(r,i,s){if(this.hasEvalModel){let[c,n]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,r,i,s),a=await this.handler.runEvalStep(r,c,n);return this.convertHandlerReturnTypeToMapOfTensors(a)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,i=!0){let s=await this.getParametersSize(i);if(r.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,i)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}}),Qd,Es=O(()=>{Ps(),Qd=hn}),Mo={};Or(Mo,{InferenceSession:()=>Yd,TRACE:()=>Ts,TRACE_FUNC_BEGIN:()=>Fe,TRACE_FUNC_END:()=>Ce,Tensor:()=>yt,TrainingSession:()=>Qd,env:()=>z,registerBackend:()=>nr});var Yt=O(()=>{ts(),os(),Is(),pn(),_s(),Os(),Go(),Ss(),As(),Es()});function _e(e,r,i,s){if(r===void 0)return eh(e);if(i===void 0)mn(e,r);else if(typeof i=="number"&&s===void 0)mn(e,r);else if(typeof i=="string"&&s===void 0)mn(e,i,1,r);else if(typeof i=="string"&&typeof s=="number")mn(e,i,s,r);else throw new TypeError("input is valid")}function eh(e){return{verbose:_e.verbose.bind(null,e),info:_e.info.bind(null,e),warning:_e.warning.bind(null,e),error:_e.error.bind(null,e),fatal:_e.fatal.bind(null,e)}}function mn(e,r,i,s){let c=Ar[s||""]||Ar[""];Ls[e]<Ls[c.minimalSeverity]||(c.logDateTime&&(r=`${new Date().toISOString()}|${r}`),c.logSourceLocation,th[c.provider].log(e,r,s))}var Uo,Vo,Ls,th,$s,Ar,tt,gn,yn,xn,bn,Ut=O(()=>{Uo=class{log(e,r,i){}},Vo=class{log(e,r,i){console.log(`${this.color(e)} ${i?"\x1B[35m"+i+"\x1B[0m ":""}${r}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Ls={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},th={none:new Uo,console:new Vo},$s={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Ar={"":$s},(e=>{function r(t,u){e("verbose",t,u)}e.verbose=r;function i(t,u){e("info",t,u)}e.info=i;function s(t,u){e("warning",t,u)}e.warning=s;function c(t,u){e("error",t,u)}e.error=c;function n(t,u){e("fatal",t,u)}e.fatal=n;function a(t){Ar={},h("",t||{})}e.reset=a;function h(t,u){if(t==="*")a(u);else{let l=Ar[t]||$s;Ar[t]={provider:u.provider||l.provider,minimalSeverity:u.minimalSeverity||l.minimalSeverity,logDateTime:u.logDateTime===void 0?l.logDateTime:u.logDateTime,logSourceLocation:u.logSourceLocation===void 0?l.logSourceLocation:u.logSourceLocation}}}e.set=h;function p(t){let u={};t.logLevel&&(u.minimalSeverity=t.logLevel),h("",u)}e.setWithEnv=p})(_e||(_e={})),tt=_e,gn=class{constructor(e,r,i,s,c,n){this.category=e,this.name=r,this.startTime=i,this.endCallback=s,this.timer=c,this.ctx=n}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},yn=class{constructor(e,r,i,s){this.category=e,this.name=r,this.startTime=i,this.endTime=s}},xn=class{constructor(e,r,i){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=i===void 0?5e3:i}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=bn(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,r,i,s){let c=this._started?this.begin(e,r,s):void 0,n=!1,a=i();if(a&&typeof a.then=="function")return n=!0,new Promise((h,p)=>{a.then(async t=>{c&&await c.end(),h(t)},async t=>{c&&await c.end(),p(t)})});if(!n&&c){let h=c.end();if(h&&typeof h.then=="function")return new Promise((p,t)=>{h.then(()=>{p(a)},u=>{t(u)})})}return a}begin(e,r,i){if(!this._started)throw new Error("profiler is not started yet");if(i===void 0){let s=bn();return this.flush(s),new gn(e,r,s,c=>this.endSync(c))}else{let s=i.beginTimer();return new gn(e,r,0,async c=>this.end(c),s,i)}}async end(e){let r=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new yn(e.category,e.name,e.startTime,r)),this.flush(r))}endSync(e){let r=bn();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new yn(e.category,e.name,e.startTime,r)),this.flush(r))}logOneEvent(e){tt.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=bn()}}get started(){return this._started}},bn=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function ks(e,r,i){for(let s of i){let c=s[0],n=s[1],a=s[2],h=s[3],p=s[4];if(e.opType===c){for(let t of r)if((t.domain===n||t.domain==="ai.onnx"&&n==="")&&rh(t.version,a))return{opImpl:h,opInit:p}}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${r.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}function rh(e,r){if(r.endsWith("+")){let i=Number.parseInt(r.substring(0,r.length-1),10);return!isNaN(i)&&i<=e}else if(r.split("-").length===2){let i=r.split("-"),s=Number.parseInt(i[0],10),c=Number.parseInt(i[1],10);return!isNaN(s)&&!isNaN(c)&&s<=e&&e<=c}else return Number.parseInt(r,10)===e}var Bs=O(()=>{}),Fs=mt(e=>{e.__esModule=!0;var r=function(){function i(s){if(!s)throw new TypeError("Invalid argument; `value` has no value.");this.value=i.EMPTY,s&&i.isGuid(s)&&(this.value=s)}return i.isGuid=function(s){var c=s.toString();return s&&(s instanceof i||i.validator.test(c))},i.create=function(){return new i([i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-"))},i.createEmpty=function(){return new i("emptyguid")},i.parse=function(s){return new i(s)},i.raw=function(){return[i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-")},i.gen=function(s){for(var c="",n=0;n<s;n++)c+=((1+Math.random())*65536|0).toString(16).substring(1);return c},i.prototype.equals=function(s){return i.isGuid(s)&&this.value===s.toString()},i.prototype.isEmpty=function(){return this.value===i.EMPTY},i.prototype.toString=function(){return this.value},i.prototype.toJSON=function(){return{value:this.value}},i.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),i.EMPTY="00000000-0000-0000-0000-000000000000",i}();e.Guid=r});function rt(e,r,i){this.low=e|0,this.high=r|0,this.unsigned=!!i}function Et(e){return(e&&e.__isLong__)===!0}function Cs(e){var r=Math.clz32(e&-e);return e?31-r:r}function Ne(e,r){var i,s,c;return r?(e>>>=0,(c=0<=e&&e<256)&&(s=Rs[e],s)?s:(i=J(e,0,!0),c&&(Rs[e]=i),i)):(e|=0,(c=-128<=e&&e<128)&&(s=Ns[e],s)?s:(i=J(e,e<0?-1:0,!1),c&&(Ns[e]=i),i))}function zt(e,r){if(isNaN(e))return r?ye:Zt;if(r){if(e<0)return ye;if(e>=Vs)return Hs}else{if(e<=-Ms)return Ct;if(e+1>=Ms)return Ws}return e<0?zt(-e,r).neg():J(e%ir|0,e/ir|0,r)}function J(e,r,i){return new rt(e,r,i)}function Ho(e,r,i){if(e.length===0)throw Error("empty string");if(typeof r=="number"?(i=r,r=!1):r=!!r,e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return r?ye:Zt;if(i=i||10,i<2||36<i)throw RangeError("radix");var s;if((s=e.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Ho(e.substring(1),r,i).neg();for(var c=zt(Tn(i,8)),n=Zt,a=0;a<e.length;a+=8){var h=Math.min(8,e.length-a),p=parseInt(e.substring(a,a+h),i);if(h<8){var t=zt(Tn(i,h));n=n.mul(t).add(zt(p))}else n=n.mul(c),n=n.add(zt(p))}return n.unsigned=r,n}function Qt(e,r){return typeof e=="number"?zt(e,r):typeof e=="string"?Ho(e,r):J(e.low,e.high,typeof r=="boolean"?r:e.unsigned)}var Vt,Ns,Rs,Tn,Gs,oh,ir,Vs,Ms,Us,Zt,ye,or,zs,Wo,Ws,Hs,Ct,D,xe,qo=O(()=>{Vt=null;try{Vt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}rt.prototype.__isLong__,Object.defineProperty(rt.prototype,"__isLong__",{value:!0}),rt.isLong=Et,Ns={},Rs={},rt.fromInt=Ne,rt.fromNumber=zt,rt.fromBits=J,Tn=Math.pow,rt.fromString=Ho,rt.fromValue=Qt,Gs=65536,oh=1<<24,ir=Gs*Gs,Vs=ir*ir,Ms=Vs/2,Us=Ne(oh),Zt=Ne(0),rt.ZERO=Zt,ye=Ne(0,!0),rt.UZERO=ye,or=Ne(1),rt.ONE=or,zs=Ne(1,!0),rt.UONE=zs,Wo=Ne(-1),rt.NEG_ONE=Wo,Ws=J(-1,2147483647,!1),rt.MAX_VALUE=Ws,Hs=J(-1,-1,!0),rt.MAX_UNSIGNED_VALUE=Hs,Ct=J(0,-2147483648,!1),rt.MIN_VALUE=Ct,D=rt.prototype,D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*ir+(this.low>>>0):this.high*ir+(this.low>>>0)},D.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ct)){var r=zt(e),i=this.div(r),s=i.mul(r).sub(this);return i.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var c=zt(Tn(e,6),this.unsigned),n=this,a="";;){var h=n.div(c),p=n.sub(h.mul(c)).toInt()>>>0,t=p.toString(e);if(n=h,n.isZero())return t+a;for(;t.length<6;)t="0"+t;a=""+t+a}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ct)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,r=31;r>0&&!(e&1<<r);r--);return this.high!=0?r+33:r+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(e){return Et(e)||(e=Qt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low},D.eq=D.equals,D.notEquals=function(e){return!this.eq(e)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(e){return this.comp(e)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(e){return this.comp(e)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(e){return this.comp(e)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(e){return this.comp(e)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(e){if(Et(e)||(e=Qt(e)),this.eq(e))return 0;var r=this.isNegative(),i=e.isNegative();return r&&!i?-1:!r&&i?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(Ct)?Ct:this.not().add(or)},D.neg=D.negate,D.add=function(e){Et(e)||(e=Qt(e));var r=this.high>>>16,i=this.high&65535,s=this.low>>>16,c=this.low&65535,n=e.high>>>16,a=e.high&65535,h=e.low>>>16,p=e.low&65535,t=0,u=0,l=0,f=0;return f+=c+p,l+=f>>>16,f&=65535,l+=s+h,u+=l>>>16,l&=65535,u+=i+a,t+=u>>>16,u&=65535,t+=r+n,t&=65535,J(l<<16|f,t<<16|u,this.unsigned)},D.subtract=function(e){return Et(e)||(e=Qt(e)),this.add(e.neg())},D.sub=D.subtract,D.multiply=function(e){if(this.isZero())return this;if(Et(e)||(e=Qt(e)),Vt){var r=Vt.mul(this.low,this.high,e.low,e.high);return J(r,Vt.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?ye:Zt;if(this.eq(Ct))return e.isOdd()?Ct:Zt;if(e.eq(Ct))return this.isOdd()?Ct:Zt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Us)&&e.lt(Us))return zt(this.toNumber()*e.toNumber(),this.unsigned);var i=this.high>>>16,s=this.high&65535,c=this.low>>>16,n=this.low&65535,a=e.high>>>16,h=e.high&65535,p=e.low>>>16,t=e.low&65535,u=0,l=0,f=0,x=0;return x+=n*t,f+=x>>>16,x&=65535,f+=c*t,l+=f>>>16,f&=65535,f+=n*p,l+=f>>>16,f&=65535,l+=s*t,u+=l>>>16,l&=65535,l+=c*p,u+=l>>>16,l&=65535,l+=n*h,u+=l>>>16,l&=65535,u+=i*t+s*p+c*h+n*a,u&=65535,J(f<<16|x,u<<16|l,this.unsigned)},D.mul=D.multiply,D.divide=function(e){if(Et(e)||(e=Qt(e)),e.isZero())throw Error("division by zero");if(Vt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var r=(this.unsigned?Vt.div_u:Vt.div_s)(this.low,this.high,e.low,e.high);return J(r,Vt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ye:Zt;var i,s,c;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ye;if(e.gt(this.shru(1)))return zs;c=ye}else{if(this.eq(Ct)){if(e.eq(or)||e.eq(Wo))return Ct;if(e.eq(Ct))return or;var n=this.shr(1);return i=n.div(e).shl(1),i.eq(Zt)?e.isNegative()?or:Wo:(s=this.sub(e.mul(i)),c=i.add(s.div(e)),c)}else if(e.eq(Ct))return this.unsigned?ye:Zt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();c=Zt}for(s=this;s.gte(e);){i=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(i)/Math.LN2),h=a<=48?1:Tn(2,a-48),p=zt(i),t=p.mul(e);t.isNegative()||t.gt(s);)i-=h,p=zt(i,this.unsigned),t=p.mul(e);p.isZero()&&(p=or),c=c.add(p),s=s.sub(t)}return c},D.div=D.divide,D.modulo=function(e){if(Et(e)||(e=Qt(e)),Vt){var r=(this.unsigned?Vt.rem_u:Vt.rem_s)(this.low,this.high,e.low,e.high);return J(r,Vt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return J(~this.low,~this.high,this.unsigned)},D.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},D.clz=D.countLeadingZeros,D.countTrailingZeros=function(){return this.low?Cs(this.low):Cs(this.high)+32},D.ctz=D.countTrailingZeros,D.and=function(e){return Et(e)||(e=Qt(e)),J(this.low&e.low,this.high&e.high,this.unsigned)},D.or=function(e){return Et(e)||(e=Qt(e)),J(this.low|e.low,this.high|e.high,this.unsigned)},D.xor=function(e){return Et(e)||(e=Qt(e)),J(this.low^e.low,this.high^e.high,this.unsigned)},D.shiftLeft=function(e){return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):J(0,this.low<<e-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(e){return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):J(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(e){return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?J(this.high,0,this.unsigned):J(this.high>>>e-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.rotateLeft=function(e){var r;return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?J(this.high,this.low,this.unsigned):e<32?(r=32-e,J(this.low<<e|this.high>>>r,this.high<<e|this.low>>>r,this.unsigned)):(e-=32,r=32-e,J(this.high<<e|this.low>>>r,this.low<<e|this.high>>>r,this.unsigned))},D.rotl=D.rotateLeft,D.rotateRight=function(e){var r;return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?J(this.high,this.low,this.unsigned):e<32?(r=32-e,J(this.high<<r|this.low>>>e,this.low<<r|this.high>>>e,this.unsigned)):(e-=32,r=32-e,J(this.low<<r|this.high>>>e,this.high<<r|this.low>>>e,this.unsigned))},D.rotr=D.rotateRight,D.toSigned=function(){return this.unsigned?J(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:J(this.low,this.high,!0)},D.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var e=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]},D.toBytesBE=function(){var e=this.high,r=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,r>>>24,r>>>16&255,r>>>8&255,r&255]},rt.fromBytes=function(e,r,i){return i?rt.fromBytesLE(e,r):rt.fromBytesBE(e,r)},rt.fromBytesLE=function(e,r){return new rt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,r)},rt.fromBytesBE=function(e,r){return new rt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],r)},xe=rt}),w,wn=O(()=>{w={},w.Offset,w.Table,w.SIZEOF_SHORT=2,w.SIZEOF_INT=4,w.FILE_IDENTIFIER_LENGTH=4,w.SIZE_PREFIX_LENGTH=4,w.Encoding={UTF8_BYTES:1,UTF16_STRING:2},w.int32=new Int32Array(2),w.float32=new Float32Array(w.int32.buffer),w.float64=new Float64Array(w.int32.buffer),w.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,w.Long=function(e,r){this.low=e|0,this.high=r|0},w.Long.create=function(e,r){return e==0&&r==0?w.Long.ZERO:new w.Long(e,r)},w.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},w.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},w.Long.ZERO=new w.Long(0,0),w.Builder=function(e){if(e)var r=e;else var r=1024;this.bb=w.ByteBuffer.allocate(r),this.space=r,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},w.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},w.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},w.Builder.prototype.dataBuffer=function(){return this.bb},w.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},w.Builder.prototype.prep=function(e,r){e>this.minalign&&(this.minalign=e);for(var i=~(this.bb.capacity()-this.space+r)+1&e-1;this.space<i+e+r;){var s=this.bb.capacity();this.bb=w.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(i)},w.Builder.prototype.pad=function(e){for(var r=0;r<e;r++)this.bb.writeInt8(--this.space,0)},w.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},w.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},w.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},w.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},w.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},w.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},w.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},w.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},w.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},w.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},w.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},w.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},w.Builder.prototype.addFieldInt8=function(e,r,i){(this.force_defaults||r!=i)&&(this.addInt8(r),this.slot(e))},w.Builder.prototype.addFieldInt16=function(e,r,i){(this.force_defaults||r!=i)&&(this.addInt16(r),this.slot(e))},w.Builder.prototype.addFieldInt32=function(e,r,i){(this.force_defaults||r!=i)&&(this.addInt32(r),this.slot(e))},w.Builder.prototype.addFieldInt64=function(e,r,i){(this.force_defaults||!r.equals(i))&&(this.addInt64(r),this.slot(e))},w.Builder.prototype.addFieldFloat32=function(e,r,i){(this.force_defaults||r!=i)&&(this.addFloat32(r),this.slot(e))},w.Builder.prototype.addFieldFloat64=function(e,r,i){(this.force_defaults||r!=i)&&(this.addFloat64(r),this.slot(e))},w.Builder.prototype.addFieldOffset=function(e,r,i){(this.force_defaults||r!=i)&&(this.addOffset(r),this.slot(e))},w.Builder.prototype.addFieldStruct=function(e,r,i){r!=i&&(this.nested(r),this.slot(e))},w.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},w.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},w.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},w.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},w.Builder.growByteBuffer=function(e){var r=e.capacity();if(r&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var i=r<<1,s=w.ByteBuffer.allocate(i);return s.setPosition(i-r),s.bytes().set(e.bytes(),i-r),s},w.Builder.prototype.addOffset=function(e){this.prep(w.SIZEOF_INT,0),this.writeInt32(this.offset()-e+w.SIZEOF_INT)},w.Builder.prototype.startObject=function(e){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=e;for(var r=0;r<e;r++)this.vtable[r]=0;this.isNested=!0,this.object_start=this.offset()},w.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),r=this.vtable_in_use-1;r>=0&&this.vtable[r]==0;r--);for(var i=r+1;r>=0;r--)this.addInt16(this.vtable[r]!=0?e-this.vtable[r]:0);var s=2;this.addInt16(e-this.object_start);var c=(i+s)*w.SIZEOF_SHORT;this.addInt16(c);var n=0,a=this.space;e:for(r=0;r<this.vtables.length;r++){var h=this.bb.capacity()-this.vtables[r];if(c==this.bb.readInt16(h)){for(var p=w.SIZEOF_SHORT;p<c;p+=w.SIZEOF_SHORT)if(this.bb.readInt16(a+p)!=this.bb.readInt16(h+p))continue e;n=this.vtables[r];break}}return n?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,n-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},w.Builder.prototype.finish=function(e,r,i){var s=i?w.SIZE_PREFIX_LENGTH:0;if(r){var c=r;if(this.prep(this.minalign,w.SIZEOF_INT+w.FILE_IDENTIFIER_LENGTH+s),c.length!=w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+w.FILE_IDENTIFIER_LENGTH);for(var n=w.FILE_IDENTIFIER_LENGTH-1;n>=0;n--)this.writeInt8(c.charCodeAt(n))}this.prep(this.minalign,w.SIZEOF_INT+s),this.addOffset(e),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},w.Builder.prototype.finishSizePrefixed=function(e,r){this.finish(e,r,!0)},w.Builder.prototype.requiredField=function(e,r){var i=this.bb.capacity()-e,s=i-this.bb.readInt32(i),c=this.bb.readInt16(s+r)!=0;if(!c)throw new Error("FlatBuffers: field "+r+" must be set")},w.Builder.prototype.startVector=function(e,r,i){this.notNested(),this.vector_num_elems=r,this.prep(w.SIZEOF_INT,e*r),this.prep(i,e*r)},w.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},w.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var r=e;else for(var r=[],i=0;i<e.length;){var s,c=e.charCodeAt(i++);if(c<55296||c>=56320)s=c;else{var n=e.charCodeAt(i++);s=(c<<10)+n+-56613888}s<128?r.push(s):(s<2048?r.push(s>>6&31|192):(s<65536?r.push(s>>12&15|224):r.push(s>>18&7|240,s>>12&63|128),r.push(s>>6&63|128)),r.push(s&63|128))}this.addInt8(0),this.startVector(1,r.length,1),this.bb.setPosition(this.space-=r.length);for(var i=0,a=this.space,h=this.bb.bytes();i<r.length;i++)h[a++]=r[i];return this.endVector()},w.Builder.prototype.createLong=function(e,r){return w.Long.create(e,r)},w.ByteBuffer=function(e){this.bytes_=e,this.position_=0},w.ByteBuffer.allocate=function(e){return new w.ByteBuffer(new Uint8Array(e))},w.ByteBuffer.prototype.clear=function(){this.position_=0},w.ByteBuffer.prototype.bytes=function(){return this.bytes_},w.ByteBuffer.prototype.position=function(){return this.position_},w.ByteBuffer.prototype.setPosition=function(e){this.position_=e},w.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},w.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},w.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},w.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},w.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},w.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},w.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},w.ByteBuffer.prototype.readInt64=function(e){return new w.Long(this.readInt32(e),this.readInt32(e+4))},w.ByteBuffer.prototype.readUint64=function(e){return new w.Long(this.readUint32(e),this.readUint32(e+4))},w.ByteBuffer.prototype.readFloat32=function(e){return w.int32[0]=this.readInt32(e),w.float32[0]},w.ByteBuffer.prototype.readFloat64=function(e){return w.int32[w.isLittleEndian?0:1]=this.readInt32(e),w.int32[w.isLittleEndian?1:0]=this.readInt32(e+4),w.float64[0]},w.ByteBuffer.prototype.writeInt8=function(e,r){this.bytes_[e]=r},w.ByteBuffer.prototype.writeUint8=function(e,r){this.bytes_[e]=r},w.ByteBuffer.prototype.writeInt16=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8},w.ByteBuffer.prototype.writeUint16=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8},w.ByteBuffer.prototype.writeInt32=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8,this.bytes_[e+2]=r>>16,this.bytes_[e+3]=r>>24},w.ByteBuffer.prototype.writeUint32=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8,this.bytes_[e+2]=r>>16,this.bytes_[e+3]=r>>24},w.ByteBuffer.prototype.writeInt64=function(e,r){this.writeInt32(e,r.low),this.writeInt32(e+4,r.high)},w.ByteBuffer.prototype.writeUint64=function(e,r){this.writeUint32(e,r.low),this.writeUint32(e+4,r.high)},w.ByteBuffer.prototype.writeFloat32=function(e,r){w.float32[0]=r,this.writeInt32(e,w.int32[0])},w.ByteBuffer.prototype.writeFloat64=function(e,r){w.float64[0]=r,this.writeInt32(e,w.int32[w.isLittleEndian?0:1]),this.writeInt32(e+4,w.int32[w.isLittleEndian?1:0])},w.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+w.SIZEOF_INT+w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",r=0;r<w.FILE_IDENTIFIER_LENGTH;r++)e+=String.fromCharCode(this.readInt8(this.position_+w.SIZEOF_INT+r));return e},w.ByteBuffer.prototype.__offset=function(e,r){var i=e-this.readInt32(e);return r<this.readInt16(i)?this.readInt16(i+r):0},w.ByteBuffer.prototype.__union=function(e,r){return e.bb_pos=r+this.readInt32(r),e.bb=this,e},w.ByteBuffer.prototype.__string=function(e,r){e+=this.readInt32(e);var i=this.readInt32(e),s="",c=0;if(e+=w.SIZEOF_INT,r===w.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+i);for(;c<i;){var n,a=this.readUint8(e+c++);if(a<192)n=a;else{var h=this.readUint8(e+c++);if(a<224)n=(a&31)<<6|h&63;else{var p=this.readUint8(e+c++);if(a<240)n=(a&15)<<12|(h&63)<<6|p&63;else{var t=this.readUint8(e+c++);n=(a&7)<<18|(h&63)<<12|(p&63)<<6|t&63}}}n<65536?s+=String.fromCharCode(n):(n-=65536,s+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return s},w.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},w.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+w.SIZEOF_INT},w.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},w.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+w.FILE_IDENTIFIER_LENGTH);for(var r=0;r<w.FILE_IDENTIFIER_LENGTH;r++)if(e.charCodeAt(r)!=this.readInt8(this.position_+w.SIZEOF_INT+r))return!1;return!0},w.ByteBuffer.prototype.createLong=function(e,r){return w.Long.create(e,r)}}),F,Pr=O(()=>{wn(),(e=>{(r=>{(i=>{(s=>(s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.INT=2]="INT",s[s.STRING=3]="STRING",s[s.TENSOR=4]="TENSOR",s[s.GRAPH=5]="GRAPH",s[s.FLOATS=6]="FLOATS",s[s.INTS=7]="INTS",s[s.STRINGS=8]="STRINGS",s[s.TENSORS=9]="TENSORS",s[s.GRAPHS=10]="GRAPHS",s[s.SPARSE_TENSOR=11]="SPARSE_TENSOR",s[s.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(i.AttributeType||(i.AttributeType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{(s=>(s[s.UNKNOWN=0]="UNKNOWN",s[s.VALUE=1]="VALUE",s[s.PARAM=2]="PARAM"))(i.DimensionValueType||(i.DimensionValueType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{(s=>(s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.UINT8=2]="UINT8",s[s.INT8=3]="INT8",s[s.UINT16=4]="UINT16",s[s.INT16=5]="INT16",s[s.INT32=6]="INT32",s[s.INT64=7]="INT64",s[s.STRING=8]="STRING",s[s.BOOL=9]="BOOL",s[s.FLOAT16=10]="FLOAT16",s[s.DOUBLE=11]="DOUBLE",s[s.UINT32=12]="UINT32",s[s.UINT64=13]="UINT64",s[s.COMPLEX64=14]="COMPLEX64",s[s.COMPLEX128=15]="COMPLEX128",s[s.BFLOAT16=16]="BFLOAT16",s[s.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",s[s.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",s[s.FLOAT8E5M2=19]="FLOAT8E5M2",s[s.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(i.TensorDataType||(i.TensorDataType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{(s=>(s[s.Primitive=0]="Primitive",s[s.Fused=1]="Fused"))(i.NodeType||(i.NodeType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{(s=>(s[s.NONE=0]="NONE",s[s.tensor_type=1]="tensor_type",s[s.sequence_type=2]="sequence_type",s[s.map_type=3]="map_type"))(i.TypeInfoValue||(i.TypeInfoValue={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsShape(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}dim(n,a){let h=this.bb.__offset(this.bb_pos,4);return h?(a||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,a){n.addFieldOffset(0,a,0)}static createDimVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startDimVector(n,a){n.startVector(4,a,4)}static endShape(n){return n.endObject()}static createShape(n,a){return s.startShape(n),s.addDim(n,a),s.endShape(n)}}i.Shape=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimension(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}value(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}denotation(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimension(n){n.startObject(2)}static addValue(n,a){n.addFieldOffset(0,a,0)}static addDenotation(n,a){n.addFieldOffset(1,a,0)}static endDimension(n){return n.endObject()}static createDimension(n,a,h){return s.startDimension(n),s.addValue(n,a),s.addDenotation(n,h),s.endDimension(n)}}i.Dimension=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsDimensionValue(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):0}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,a){n.addFieldInt8(0,a,0)}static addDimValue(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static addDimParam(n,a){n.addFieldOffset(2,a,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,a,h,p){return s.startDimensionValue(n),s.addDimType(n,a),s.addDimValue(n,h),s.addDimParam(n,p),s.endDimensionValue(n)}}i.DimensionValue=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensorTypeAndShape(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}shape(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,a){n.addFieldInt32(0,a,0)}static addShape(n,a){n.addFieldOffset(1,a,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,a,h){return s.startTensorTypeAndShape(n),s.addElemType(n,a),s.addShape(n,h),s.endTensorTypeAndShape(n)}}i.TensorTypeAndShape=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsMapType(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}valueType(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,a){n.addFieldInt32(0,a,0)}static addValueType(n,a){n.addFieldOffset(1,a,0)}static endMapType(n){return n.endObject()}static createMapType(n,a,h){return s.startMapType(n),s.addKeyType(n,a),s.addValueType(n,h),s.endMapType(n)}}i.MapType=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSequenceType(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,a){n.addFieldOffset(0,a,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,a){return s.startSequenceType(n),s.addElemType(n,a),s.endSequenceType(n)}}i.SequenceType=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(n,a,h,p){return n.prep(4,12),n.writeInt32(p),n.writeInt32(h),n.writeInt32(a),n.offset()}}i.EdgeEnd=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNodeEdge(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,a){let h=this.bb.__offset(this.bb_pos,6);return h?(a||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+h)+n*12,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,a){let h=this.bb.__offset(this.bb_pos,8);return h?(a||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+h)+n*12,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,a){n.addFieldInt32(0,a,0)}static addInputEdges(n,a){n.addFieldOffset(1,a,0)}static startInputEdgesVector(n,a){n.startVector(12,a,4)}static addOutputEdges(n,a){n.addFieldOffset(2,a,0)}static startOutputEdgesVector(n,a){n.startVector(12,a,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,a,h,p){return s.startNodeEdge(n),s.addNodeIndex(n,a),s.addInputEdges(n,h),s.addOutputEdges(n,p),s.endNodeEdge(n)}}i.NodeEdge=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsNode(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):0}executionProviderType(n){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__string(this.bb_pos+a,n):null}inputs(n,a){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let h=this.bb.__offset(this.bb_pos,22);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,a){let h=this.bb.__offset(this.bb_pos,24);return h?(a||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.readInt32(this.bb.__vector(this.bb_pos+a)+n*4):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,a){let h=this.bb.__offset(this.bb_pos,28);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDomain(n,a){n.addFieldOffset(2,a,0)}static addSinceVersion(n,a){n.addFieldInt32(3,a,0)}static addIndex(n,a){n.addFieldInt32(4,a,0)}static addOpType(n,a){n.addFieldOffset(5,a,0)}static addType(n,a){n.addFieldInt32(6,a,0)}static addExecutionProviderType(n,a){n.addFieldOffset(7,a,0)}static addInputs(n,a){n.addFieldOffset(8,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(9,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addAttributes(n,a){n.addFieldOffset(10,a,0)}static createAttributesVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startAttributesVector(n,a){n.startVector(4,a,4)}static addInputArgCounts(n,a){n.addFieldOffset(11,a,0)}static createInputArgCountsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addInt32(a[h]);return n.endVector()}static startInputArgCountsVector(n,a){n.startVector(4,a,4)}static addImplicitInputs(n,a){n.addFieldOffset(12,a,0)}static createImplicitInputsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startImplicitInputsVector(n,a){n.startVector(4,a,4)}static endNode(n){return n.endObject()}static createNode(n,a,h,p,t,u,l,f,x,I,R,A,Z,K){return s.startNode(n),s.addName(n,a),s.addDocString(n,h),s.addDomain(n,p),s.addSinceVersion(n,t),s.addIndex(n,u),s.addOpType(n,l),s.addType(n,f),s.addExecutionProviderType(n,x),s.addInputs(n,I),s.addOutputs(n,R),s.addAttributes(n,A),s.addInputArgCounts(n,Z),s.addImplicitInputs(n,K),s.endNode(n)}}i.Node=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsValueInfo(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldOffset(2,a,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,a,h,p){return s.startValueInfo(n),s.addName(n,a),s.addDocString(n,h),s.addType(n,p),s.endValueInfo(n)}}i.ValueInfo=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTypeInfo(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):0}value(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__union(n,this.bb_pos+a):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,a){n.addFieldOffset(0,a,0)}static addValueType(n,a){n.addFieldInt8(1,a,0)}static addValue(n,a){n.addFieldOffset(2,a,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,a,h,p){return s.startTypeInfo(n),s.addDenotation(n,a),s.addValueType(n,h),s.addValue(n,p),s.endTypeInfo(n)}}i.TypeInfo=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsOperatorSetId(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,a){n.addFieldOffset(0,a,0)}static addVersion(n,a){n.addFieldInt64(1,a,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,a,h){return s.startOperatorSetId(n),s.addDomain(n,a),s.addVersion(n,h),s.endOperatorSetId(n)}}i.OperatorSetId=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsTensor(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}rawData(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint8(this.bb.__vector(this.bb_pos+a)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,a){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let h=a.length-1;h>=0;h--)n.addInt64(a[h]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static addDataType(n,a){n.addFieldInt32(3,a,0)}static addRawData(n,a){n.addFieldOffset(4,a,0)}static createRawDataVector(n,a){n.startVector(1,a.length,1);for(let h=a.length-1;h>=0;h--)n.addInt8(a[h]);return n.endVector()}static startRawDataVector(n,a){n.startVector(1,a,1)}static addStringData(n,a){n.addFieldOffset(5,a,0)}static createStringDataVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startStringDataVector(n,a){n.startVector(4,a,4)}static endTensor(n){return n.endObject()}static createTensor(n,a,h,p,t,u,l){return s.startTensor(n),s.addName(n,a),s.addDocString(n,h),s.addDims(n,p),s.addDataType(n,t),s.addRawData(n,u),s.addStringData(n,l),s.endTensor(n)}}i.Tensor=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSparseTensor(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}values(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}indices(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}dims(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,a){n.addFieldOffset(0,a,0)}static addIndices(n,a){n.addFieldOffset(1,a,0)}static addDims(n,a){n.addFieldOffset(2,a,0)}static createDimsVector(n,a){n.startVector(8,a.length,8);for(let h=a.length-1;h>=0;h--)n.addInt64(a[h]);return n.endVector()}static startDimsVector(n,a){n.startVector(8,a,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,a,h,p){return s.startSparseTensor(n),s.addValues(n,a),s.addIndices(n,h),s.addDims(n,p),s.endSparseTensor(n)}}i.SparseTensor=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsAttribute(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}name(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}docString(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__string(this.bb_pos+a,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):0}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__string(this.bb_pos+a,n):null}t(n){let a=this.bb.__offset(this.bb_pos,16);return a?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}g(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}floats(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.readFloat32(this.bb.__vector(this.bb_pos+a)+n*4):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.readInt64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,a){let h=this.bb.__offset(this.bb_pos,24);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,a){let h=this.bb.__offset(this.bb_pos,26);return h?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,a){let h=this.bb.__offset(this.bb_pos,28);return h?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,a){n.addFieldOffset(0,a,0)}static addDocString(n,a){n.addFieldOffset(1,a,0)}static addType(n,a){n.addFieldInt32(2,a,0)}static addF(n,a){n.addFieldFloat32(3,a,0)}static addI(n,a){n.addFieldInt64(4,a,n.createLong(0,0))}static addS(n,a){n.addFieldOffset(5,a,0)}static addT(n,a){n.addFieldOffset(6,a,0)}static addG(n,a){n.addFieldOffset(7,a,0)}static addFloats(n,a){n.addFieldOffset(8,a,0)}static createFloatsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addFloat32(a[h]);return n.endVector()}static startFloatsVector(n,a){n.startVector(4,a,4)}static addInts(n,a){n.addFieldOffset(9,a,0)}static createIntsVector(n,a){n.startVector(8,a.length,8);for(let h=a.length-1;h>=0;h--)n.addInt64(a[h]);return n.endVector()}static startIntsVector(n,a){n.startVector(8,a,8)}static addStrings(n,a){n.addFieldOffset(10,a,0)}static createStringsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startStringsVector(n,a){n.startVector(4,a,4)}static addTensors(n,a){n.addFieldOffset(11,a,0)}static createTensorsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startTensorsVector(n,a){n.startVector(4,a,4)}static addGraphs(n,a){n.addFieldOffset(12,a,0)}static createGraphsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startGraphsVector(n,a){n.startVector(4,a,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,a,h,p,t,u,l,f,x,I,R,A,Z,K){return s.startAttribute(n),s.addName(n,a),s.addDocString(n,h),s.addType(n,p),s.addF(n,t),s.addI(n,u),s.addS(n,l),s.addT(n,f),s.addG(n,x),s.addFloats(n,I),s.addInts(n,R),s.addStrings(n,A),s.addTensors(n,Z),s.addGraphs(n,K),s.endAttribute(n)}}i.Attribute=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsGraph(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,a){let h=this.bb.__offset(this.bb_pos,4);return h?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,a){let h=this.bb.__offset(this.bb_pos,6);return h?(a||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,a){let h=this.bb.__offset(this.bb_pos,8);return h?(a||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,a){let h=this.bb.__offset(this.bb_pos,12);return h?(a||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,a){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,a){let h=this.bb.__offset(this.bb_pos,16);return h?this.bb.__string(this.bb.__vector(this.bb_pos+h)+n*4,a):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,a){let h=this.bb.__offset(this.bb_pos,18);return h?(a||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,a){n.addFieldOffset(0,a,0)}static createInitializersVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startInitializersVector(n,a){n.startVector(4,a,4)}static addNodeArgs(n,a){n.addFieldOffset(1,a,0)}static createNodeArgsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startNodeArgsVector(n,a){n.startVector(4,a,4)}static addNodes(n,a){n.addFieldOffset(2,a,0)}static createNodesVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startNodesVector(n,a){n.startVector(4,a,4)}static addMaxNodeIndex(n,a){n.addFieldInt32(3,a,0)}static addNodeEdges(n,a){n.addFieldOffset(4,a,0)}static createNodeEdgesVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startNodeEdgesVector(n,a){n.startVector(4,a,4)}static addInputs(n,a){n.addFieldOffset(5,a,0)}static createInputsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startInputsVector(n,a){n.startVector(4,a,4)}static addOutputs(n,a){n.addFieldOffset(6,a,0)}static createOutputsVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startOutputsVector(n,a){n.startVector(4,a,4)}static addSparseInitializers(n,a){n.addFieldOffset(7,a,0)}static createSparseInitializersVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startSparseInitializersVector(n,a){n.startVector(4,a,4)}static endGraph(n){return n.endObject()}static createGraph(n,a,h,p,t,u,l,f,x){return s.startGraph(n),s.addInitializers(n,a),s.addNodeArgs(n,h),s.addNodes(n,p),s.addMaxNodeIndex(n,t),s.addNodeEdges(n,u),s.addInputs(n,l),s.addOutputs(n,f),s.addSparseInitializers(n,x),s.endGraph(n)}}i.Graph=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsModel(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,a){let h=this.bb.__offset(this.bb_pos,6);return h?(a||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__string(this.bb_pos+a,n):null}producerVersion(n){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.__string(this.bb_pos+a,n):null}domain(n){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__string(this.bb_pos+a,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__string(this.bb_pos+a,n):null}graph(n){let a=this.bb.__offset(this.bb_pos,18);return a?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}graphDocString(n){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__string(this.bb_pos+a,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,a){n.addFieldInt64(0,a,n.createLong(0,0))}static addOpsetImport(n,a){n.addFieldOffset(1,a,0)}static createOpsetImportVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startOpsetImportVector(n,a){n.startVector(4,a,4)}static addProducerName(n,a){n.addFieldOffset(2,a,0)}static addProducerVersion(n,a){n.addFieldOffset(3,a,0)}static addDomain(n,a){n.addFieldOffset(4,a,0)}static addModelVersion(n,a){n.addFieldInt64(5,a,n.createLong(0,0))}static addDocString(n,a){n.addFieldOffset(6,a,0)}static addGraph(n,a){n.addFieldOffset(7,a,0)}static addGraphDocString(n,a){n.addFieldOffset(8,a,0)}static endModel(n){return n.endObject()}static createModel(n,a,h,p,t,u,l,f,x,I){return s.startModel(n),s.addIrVersion(n,a),s.addOpsetImport(n,h),s.addProducerName(n,p),s.addProducerVersion(n,t),s.addDomain(n,u),s.addModelVersion(n,l),s.addDocString(n,f),s.addGraph(n,x),s.addGraphDocString(n,I),s.endModel(n)}}i.Model=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsKernelCreateInfos(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb.__vector(this.bb_pos+a)+n*4):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint64(this.bb.__vector(this.bb_pos+a)+n*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,a){n.addFieldOffset(0,a,0)}static createNodeIndicesVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addInt32(a[h]);return n.endVector()}static startNodeIndicesVector(n,a){n.startVector(4,a,4)}static addKernelDefHashes(n,a){n.addFieldOffset(1,a,0)}static createKernelDefHashesVector(n,a){n.startVector(8,a.length,8);for(let h=a.length-1;h>=0;h--)n.addInt64(a[h]);return n.endVector()}static startKernelDefHashesVector(n,a){n.startVector(8,a,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,a,h){return s.startKernelCreateInfos(n),s.addNodeIndices(n,a),s.addKernelDefHashes(n,h),s.endKernelCreateInfos(n)}}i.KernelCreateInfos=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSubGraphSessionState(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,a){n.addFieldOffset(0,a,0)}static addSessionState(n,a){n.addFieldOffset(1,a,0)}static endSubGraphSessionState(n){let a=n.endObject();return n.requiredField(a,4),a}static createSubGraphSessionState(n,a,h){return s.startSubGraphSessionState(n),s.addGraphId(n,a),s.addSessionState(n,h),s.endSubGraphSessionState(n)}}i.SubGraphSessionState=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsSessionState(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let a=this.bb.__offset(this.bb_pos,4);return a?(n||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}subGraphSessionStates(n,a){let h=this.bb.__offset(this.bb_pos,6);return h?(a||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+h)+n*4),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,a){n.addFieldOffset(0,a,0)}static addSubGraphSessionStates(n,a){n.addFieldOffset(1,a,0)}static createSubGraphSessionStatesVector(n,a){n.startVector(4,a.length,4);for(let h=a.length-1;h>=0;h--)n.addOffset(a[h]);return n.endVector()}static startSubGraphSessionStatesVector(n,a){n.startVector(4,a,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,a,h){return s.startSessionState(n),s.addKernels(n,a),s.addSubGraphSessionStates(n,h),s.endSessionState(n)}}i.SessionState=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(r=>{(i=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(n,a){return this.bb_pos=n,this.bb=a,this}static getRootAsInferenceSession(n,a){return(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,a){return n.setPosition(n.position()+w.SIZE_PREFIX_LENGTH),(a||new s).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__string(this.bb_pos+a,n):null}model(n){let a=this.bb.__offset(this.bb_pos,6);return a?(n||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}sessionState(n){let a=this.bb.__offset(this.bb_pos,8);return a?(n||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+a),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,a){n.addFieldOffset(0,a,0)}static addModel(n,a){n.addFieldOffset(1,a,0)}static addSessionState(n,a){n.addFieldOffset(2,a,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,a){n.finish(a,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,a){n.finish(a,"ORTM",!0)}static createInferenceSession(n,a,h,p){return s.startInferenceSession(n),s.addOrtVersion(n,a),s.addModel(n,h),s.addSessionState(n,p),s.endInferenceSession(n)}}i.InferenceSession=s})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={}))}),js=mt((e,r)=>{r.exports=i;function i(s,c){for(var n=new Array(arguments.length-1),a=0,h=2,p=!0;h<arguments.length;)n[a++]=arguments[h++];return new Promise(function(t,u){n[a]=function(l){if(p)if(p=!1,l)u(l);else{for(var f=new Array(arguments.length-1),x=0;x<f.length;)f[x++]=arguments[x];t.apply(null,f)}};try{s.apply(c||null,n)}catch(l){p&&(p=!1,u(l))}})}}),Ys=mt(e=>{var r=e;r.length=function(a){var h=a.length;if(!h)return 0;for(var p=0;--h%4>1&&a.charAt(h)==="=";)++p;return Math.ceil(a.length*3)/4-p};var i=new Array(64),s=new Array(123);for(c=0;c<64;)s[i[c]=c<26?c+65:c<52?c+71:c<62?c-4:c-59|43]=c++;var c;r.encode=function(a,h,p){for(var t=null,u=[],l=0,f=0,x;h<p;){var I=a[h++];switch(f){case 0:u[l++]=i[I>>2],x=(I&3)<<4,f=1;break;case 1:u[l++]=i[x|I>>4],x=(I&15)<<2,f=2;break;case 2:u[l++]=i[x|I>>6],u[l++]=i[I&63],f=0;break}l>8191&&((t||(t=[])).push(String.fromCharCode.apply(String,u)),l=0)}return f&&(u[l++]=i[x],u[l++]=61,f===1&&(u[l++]=61)),t?(l&&t.push(String.fromCharCode.apply(String,u.slice(0,l))),t.join("")):String.fromCharCode.apply(String,u.slice(0,l))};var n="invalid encoding";r.decode=function(a,h,p){for(var t=p,u=0,l,f=0;f<a.length;){var x=a.charCodeAt(f++);if(x===61&&u>1)break;if((x=s[x])===void 0)throw Error(n);switch(u){case 0:l=x,u=1;break;case 1:h[p++]=l<<2|(x&48)>>4,l=x,u=2;break;case 2:h[p++]=(l&15)<<4|(x&60)>>2,l=x,u=3;break;case 3:h[p++]=(l&3)<<6|x,u=0;break}}if(u===1)throw Error(n);return p-t},r.test=function(a){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)}}),Qs=mt((e,r)=>{r.exports=i;function i(){this._listeners={}}i.prototype.on=function(s,c,n){return(this._listeners[s]||(this._listeners[s]=[])).push({fn:c,ctx:n||this}),this},i.prototype.off=function(s,c){if(s===void 0)this._listeners={};else if(c===void 0)this._listeners[s]=[];else for(var n=this._listeners[s],a=0;a<n.length;)n[a].fn===c?n.splice(a,1):++a;return this},i.prototype.emit=function(s){var c=this._listeners[s];if(c){for(var n=[],a=1;a<arguments.length;)n.push(arguments[a++]);for(a=0;a<c.length;)c[a].fn.apply(c[a++].ctx,n)}return this}}),au=mt((e,r)=>{r.exports=i(i);function i(h){return typeof Float32Array<"u"?function(){var p=new Float32Array([-0]),t=new Uint8Array(p.buffer),u=t[3]===128;function l(R,A,Z){p[0]=R,A[Z]=t[0],A[Z+1]=t[1],A[Z+2]=t[2],A[Z+3]=t[3]}function f(R,A,Z){p[0]=R,A[Z]=t[3],A[Z+1]=t[2],A[Z+2]=t[1],A[Z+3]=t[0]}h.writeFloatLE=u?l:f,h.writeFloatBE=u?f:l;function x(R,A){return t[0]=R[A],t[1]=R[A+1],t[2]=R[A+2],t[3]=R[A+3],p[0]}function I(R,A){return t[3]=R[A],t[2]=R[A+1],t[1]=R[A+2],t[0]=R[A+3],p[0]}h.readFloatLE=u?x:I,h.readFloatBE=u?I:x}():function(){function p(u,l,f,x){var I=l<0?1:0;if(I&&(l=-l),l===0)u(1/l>0?0:2147483648,f,x);else if(isNaN(l))u(2143289344,f,x);else if(l>34028234663852886e22)u((I<<31|2139095040)>>>0,f,x);else if(l<11754943508222875e-54)u((I<<31|Math.round(l/1401298464324817e-60))>>>0,f,x);else{var R=Math.floor(Math.log(l)/Math.LN2),A=Math.round(l*Math.pow(2,-R)*8388608)&8388607;u((I<<31|R+127<<23|A)>>>0,f,x)}}h.writeFloatLE=p.bind(null,s),h.writeFloatBE=p.bind(null,c);function t(u,l,f){var x=u(l,f),I=(x>>31)*2+1,R=x>>>23&255,A=x&8388607;return R===255?A?NaN:I*(1/0):R===0?I*1401298464324817e-60*A:I*Math.pow(2,R-150)*(A+8388608)}h.readFloatLE=t.bind(null,n),h.readFloatBE=t.bind(null,a)}(),typeof Float64Array<"u"?function(){var p=new Float64Array([-0]),t=new Uint8Array(p.buffer),u=t[7]===128;function l(R,A,Z){p[0]=R,A[Z]=t[0],A[Z+1]=t[1],A[Z+2]=t[2],A[Z+3]=t[3],A[Z+4]=t[4],A[Z+5]=t[5],A[Z+6]=t[6],A[Z+7]=t[7]}function f(R,A,Z){p[0]=R,A[Z]=t[7],A[Z+1]=t[6],A[Z+2]=t[5],A[Z+3]=t[4],A[Z+4]=t[3],A[Z+5]=t[2],A[Z+6]=t[1],A[Z+7]=t[0]}h.writeDoubleLE=u?l:f,h.writeDoubleBE=u?f:l;function x(R,A){return t[0]=R[A],t[1]=R[A+1],t[2]=R[A+2],t[3]=R[A+3],t[4]=R[A+4],t[5]=R[A+5],t[6]=R[A+6],t[7]=R[A+7],p[0]}function I(R,A){return t[7]=R[A],t[6]=R[A+1],t[5]=R[A+2],t[4]=R[A+3],t[3]=R[A+4],t[2]=R[A+5],t[1]=R[A+6],t[0]=R[A+7],p[0]}h.readDoubleLE=u?x:I,h.readDoubleBE=u?I:x}():function(){function p(u,l,f,x,I,R){var A=x<0?1:0;if(A&&(x=-x),x===0)u(0,I,R+l),u(1/x>0?0:2147483648,I,R+f);else if(isNaN(x))u(0,I,R+l),u(2146959360,I,R+f);else if(x>17976931348623157e292)u(0,I,R+l),u((A<<31|2146435072)>>>0,I,R+f);else{var Z;if(x<22250738585072014e-324)Z=x/5e-324,u(Z>>>0,I,R+l),u((A<<31|Z/4294967296)>>>0,I,R+f);else{var K=Math.floor(Math.log(x)/Math.LN2);K===1024&&(K=1023),Z=x*Math.pow(2,-K),u(Z*4503599627370496>>>0,I,R+l),u((A<<31|K+1023<<20|Z*1048576&1048575)>>>0,I,R+f)}}}h.writeDoubleLE=p.bind(null,s,0,4),h.writeDoubleBE=p.bind(null,c,4,0);function t(u,l,f,x,I){var R=u(x,I+l),A=u(x,I+f),Z=(A>>31)*2+1,K=A>>>20&2047,Q=4294967296*(A&1048575)+R;return K===2047?Q?NaN:Z*(1/0):K===0?Z*5e-324*Q:Z*Math.pow(2,K-1075)*(Q+4503599627370496)}h.readDoubleLE=t.bind(null,n,0,4),h.readDoubleBE=t.bind(null,a,4,0)}(),h}function s(h,p,t){p[t]=h&255,p[t+1]=h>>>8&255,p[t+2]=h>>>16&255,p[t+3]=h>>>24}function c(h,p,t){p[t]=h>>>24,p[t+1]=h>>>16&255,p[t+2]=h>>>8&255,p[t+3]=h&255}function n(h,p){return(h[p]|h[p+1]<<8|h[p+2]<<16|h[p+3]<<24)>>>0}function a(h,p){return(h[p]<<24|h[p+1]<<16|h[p+2]<<8|h[p+3])>>>0}}),su=mt((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}}),lu=mt(e=>{var r=e;r.length=function(i){for(var s=0,c=0,n=0;n<i.length;++n)c=i.charCodeAt(n),c<128?s+=1:c<2048?s+=2:(c&64512)===55296&&(i.charCodeAt(n+1)&64512)===56320?(++n,s+=4):s+=3;return s},r.read=function(i,s,c){var n=c-s;if(n<1)return"";for(var a=null,h=[],p=0,t;s<c;)t=i[s++],t<128?h[p++]=t:t>191&&t<224?h[p++]=(t&31)<<6|i[s++]&63:t>239&&t<365?(t=((t&7)<<18|(i[s++]&63)<<12|(i[s++]&63)<<6|i[s++]&63)-65536,h[p++]=55296+(t>>10),h[p++]=56320+(t&1023)):h[p++]=(t&15)<<12|(i[s++]&63)<<6|i[s++]&63,p>8191&&((a||(a=[])).push(String.fromCharCode.apply(String,h)),p=0);return a?(p&&a.push(String.fromCharCode.apply(String,h.slice(0,p))),a.join("")):String.fromCharCode.apply(String,h.slice(0,p))},r.write=function(i,s,c){for(var n=c,a,h,p=0;p<i.length;++p)a=i.charCodeAt(p),a<128?s[c++]=a:a<2048?(s[c++]=a>>6|192,s[c++]=a&63|128):(a&64512)===55296&&((h=i.charCodeAt(p+1))&64512)===56320?(a=65536+((a&1023)<<10)+(h&1023),++p,s[c++]=a>>18|240,s[c++]=a>>12&63|128,s[c++]=a>>6&63|128,s[c++]=a&63|128):(s[c++]=a>>12|224,s[c++]=a>>6&63|128,s[c++]=a&63|128);return c-n}}),cu=mt((e,r)=>{r.exports=i;function i(s,c,n){var a=n||8192,h=a>>>1,p=null,t=a;return function(u){if(u<1||u>h)return s(u);t+u>a&&(p=s(a),t=0);var l=c.call(p,t,t+=u);return t&7&&(t=(t|7)+1),l}}}),du=mt((e,r)=>{r.exports=s;var i=Se();function s(h,p){this.lo=h>>>0,this.hi=p>>>0}var c=s.zero=new s(0,0);c.toNumber=function(){return 0},c.zzEncode=c.zzDecode=function(){return this},c.length=function(){return 1};var n=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(h){if(h===0)return c;var p=h<0;p&&(h=-h);var t=h>>>0,u=(h-t)/4294967296>>>0;return p&&(u=~u>>>0,t=~t>>>0,++t>4294967295&&(t=0,++u>4294967295&&(u=0))),new s(t,u)},s.from=function(h){if(typeof h=="number")return s.fromNumber(h);if(i.isString(h))if(i.Long)h=i.Long.fromString(h);else return s.fromNumber(parseInt(h,10));return h.low||h.high?new s(h.low>>>0,h.high>>>0):c},s.prototype.toNumber=function(h){if(!h&&this.hi>>>31){var p=~this.lo+1>>>0,t=~this.hi>>>0;return p||(t=t+1>>>0),-(p+t*4294967296)}return this.lo+this.hi*4294967296},s.prototype.toLong=function(h){return i.Long?new i.Long(this.lo|0,this.hi|0,!!h):{low:this.lo|0,high:this.hi|0,unsigned:!!h}};var a=String.prototype.charCodeAt;s.fromHash=function(h){return h===n?c:new s((a.call(h,0)|a.call(h,1)<<8|a.call(h,2)<<16|a.call(h,3)<<24)>>>0,(a.call(h,4)|a.call(h,5)<<8|a.call(h,6)<<16|a.call(h,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var h=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^h)>>>0,this.lo=(this.lo<<1^h)>>>0,this},s.prototype.zzDecode=function(){var h=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^h)>>>0,this.hi=(this.hi>>>1^h)>>>0,this},s.prototype.length=function(){var h=this.lo,p=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?p===0?h<16384?h<128?1:2:h<2097152?3:4:p<16384?p<128?5:6:p<2097152?7:8:t<128?9:10}}),Se=mt(e=>{var r=e;r.asPromise=js(),r.base64=Ys(),r.EventEmitter=Qs(),r.float=au(),r.inquire=su(),r.utf8=lu(),r.pool=cu(),r.LongBits=du(),r.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||e,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(c){return typeof c=="number"&&isFinite(c)&&Math.floor(c)===c},r.isString=function(c){return typeof c=="string"||c instanceof String},r.isObject=function(c){return c&&typeof c=="object"},r.isset=r.isSet=function(c,n){var a=c[n];return a!=null&&c.hasOwnProperty(n)?typeof a!="object"||(Array.isArray(a)?a.length:Object.keys(a).length)>0:!1},r.Buffer=function(){try{var c=r.inquire("buffer").Buffer;return c.prototype.utf8Write?c:null}catch{return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(c){return typeof c=="number"?r.Buffer?r._Buffer_allocUnsafe(c):new r.Array(c):r.Buffer?r._Buffer_from(c):typeof Uint8Array>"u"?c:new Uint8Array(c)},r.Array=typeof Uint8Array<"u"?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(c){return c?r.LongBits.from(c).toHash():r.LongBits.zeroHash},r.longFromHash=function(c,n){var a=r.LongBits.fromHash(c);return r.Long?r.Long.fromBits(a.lo,a.hi,n):a.toNumber(!!n)};function i(c,n,a){for(var h=Object.keys(n),p=0;p<h.length;++p)(c[h[p]]===void 0||!a)&&(c[h[p]]=n[h[p]]);return c}r.merge=i,r.lcFirst=function(c){return c.charAt(0).toLowerCase()+c.substring(1)};function s(c){function n(a,h){if(!(this instanceof n))return new n(a,h);Object.defineProperty(this,"message",{get:function(){return a}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:new Error().stack||""}),h&&i(this,h)}return n.prototype=Object.create(Error.prototype,{constructor:{value:n,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return c},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),n}r.newError=s,r.ProtocolError=s("ProtocolError"),r.oneOfGetter=function(c){for(var n={},a=0;a<c.length;++a)n[c[a]]=1;return function(){for(var h=Object.keys(this),p=h.length-1;p>-1;--p)if(n[h[p]]===1&&this[h[p]]!==void 0&&this[h[p]]!==null)return h[p]}},r.oneOfSetter=function(c){return function(n){for(var a=0;a<c.length;++a)c[a]!==n&&delete this[c[a]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var c=r.Buffer;if(!c){r._Buffer_from=r._Buffer_allocUnsafe=null;return}r._Buffer_from=c.from!==Uint8Array.from&&c.from||function(n,a){return new c(n,a)},r._Buffer_allocUnsafe=c.allocUnsafe||function(n){return new c(n)}}}),ei=mt((e,r)=>{r.exports=u;var i=Se(),s,c=i.LongBits,n=i.base64,a=i.utf8;function h(K,Q,re){this.fn=K,this.len=Q,this.next=void 0,this.val=re}function p(){}function t(K){this.head=K.head,this.tail=K.tail,this.len=K.len,this.next=K.states}function u(){this.len=0,this.head=new h(p,0,0),this.tail=this.head,this.states=null}var l=function(){return i.Buffer?function(){return(u.create=function(){return new s})()}:function(){return new u}};u.create=l(),u.alloc=function(K){return new i.Array(K)},i.Array!==Array&&(u.alloc=i.pool(u.alloc,i.Array.prototype.subarray)),u.prototype._push=function(K,Q,re){return this.tail=this.tail.next=new h(K,Q,re),this.len+=Q,this};function f(K,Q,re){Q[re]=K&255}function x(K,Q,re){for(;K>127;)Q[re++]=K&127|128,K>>>=7;Q[re]=K}function I(K,Q){this.len=K,this.next=void 0,this.val=Q}I.prototype=Object.create(h.prototype),I.prototype.fn=x,u.prototype.uint32=function(K){return this.len+=(this.tail=this.tail.next=new I((K=K>>>0)<128?1:K<16384?2:K<2097152?3:K<268435456?4:5,K)).len,this},u.prototype.int32=function(K){return K<0?this._push(R,10,c.fromNumber(K)):this.uint32(K)},u.prototype.sint32=function(K){return this.uint32((K<<1^K>>31)>>>0)};function R(K,Q,re){for(;K.hi;)Q[re++]=K.lo&127|128,K.lo=(K.lo>>>7|K.hi<<25)>>>0,K.hi>>>=7;for(;K.lo>127;)Q[re++]=K.lo&127|128,K.lo=K.lo>>>7;Q[re++]=K.lo}u.prototype.uint64=function(K){var Q=c.from(K);return this._push(R,Q.length(),Q)},u.prototype.int64=u.prototype.uint64,u.prototype.sint64=function(K){var Q=c.from(K).zzEncode();return this._push(R,Q.length(),Q)},u.prototype.bool=function(K){return this._push(f,1,K?1:0)};function A(K,Q,re){Q[re]=K&255,Q[re+1]=K>>>8&255,Q[re+2]=K>>>16&255,Q[re+3]=K>>>24}u.prototype.fixed32=function(K){return this._push(A,4,K>>>0)},u.prototype.sfixed32=u.prototype.fixed32,u.prototype.fixed64=function(K){var Q=c.from(K);return this._push(A,4,Q.lo)._push(A,4,Q.hi)},u.prototype.sfixed64=u.prototype.fixed64,u.prototype.float=function(K){return this._push(i.float.writeFloatLE,4,K)},u.prototype.double=function(K){return this._push(i.float.writeDoubleLE,8,K)};var Z=i.Array.prototype.set?function(K,Q,re){Q.set(K,re)}:function(K,Q,re){for(var se=0;se<K.length;++se)Q[re+se]=K[se]};u.prototype.bytes=function(K){var Q=K.length>>>0;if(!Q)return this._push(f,1,0);if(i.isString(K)){var re=u.alloc(Q=n.length(K));n.decode(K,re,0),K=re}return this.uint32(Q)._push(Z,Q,K)},u.prototype.string=function(K){var Q=a.length(K);return Q?this.uint32(Q)._push(a.write,Q,K):this._push(f,1,0)},u.prototype.fork=function(){return this.states=new t(this),this.head=this.tail=new h(p,0,0),this.len=0,this},u.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new h(p,0,0),this.len=0),this},u.prototype.ldelim=function(){var K=this.head,Q=this.tail,re=this.len;return this.reset().uint32(re),re&&(this.tail.next=K.next,this.tail=Q,this.len+=re),this},u.prototype.finish=function(){for(var K=this.head.next,Q=this.constructor.alloc(this.len),re=0;K;)K.fn(K.val,Q,re),re+=K.len,K=K.next;return Q},u._configure=function(K){s=K,u.create=l(),s._configure()}}),vu=mt((e,r)=>{r.exports=c;var i=ei();(c.prototype=Object.create(i.prototype)).constructor=c;var s=Se();function c(){i.call(this)}c._configure=function(){c.alloc=s._Buffer_allocUnsafe,c.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&s.Buffer.prototype.set.name==="set"?function(a,h,p){h.set(a,p)}:function(a,h,p){if(a.copy)a.copy(h,p,0,a.length);else for(var t=0;t<a.length;)h[p++]=a[t++]}},c.prototype.bytes=function(a){s.isString(a)&&(a=s._Buffer_from(a,"base64"));var h=a.length>>>0;return this.uint32(h),h&&this._push(c.writeBytesBuffer,h,a),this};function n(a,h,p){a.length<40?s.utf8.write(a,h,p):h.utf8Write?h.utf8Write(a,p):h.write(a,p)}c.prototype.string=function(a){var h=s.Buffer.byteLength(a);return this.uint32(h),h&&this._push(n,h,a),this},c._configure()}),oi=mt((e,r)=>{r.exports=h;var i=Se(),s,c=i.LongBits,n=i.utf8;function a(x,I){return RangeError("index out of range: "+x.pos+" + "+(I||1)+" > "+x.len)}function h(x){this.buf=x,this.pos=0,this.len=x.length}var p=typeof Uint8Array<"u"?function(x){if(x instanceof Uint8Array||Array.isArray(x))return new h(x);throw Error("illegal buffer")}:function(x){if(Array.isArray(x))return new h(x);throw Error("illegal buffer")},t=function(){return i.Buffer?function(x){return(h.create=function(I){return i.Buffer.isBuffer(I)?new s(I):p(I)})(x)}:p};h.create=t(),h.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,h.prototype.uint32=function(){var x=4294967295;return function(){if(x=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(x=(x|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(x=(x|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(x=(x|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(x=(x|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return x;if((this.pos+=5)>this.len)throw this.pos=this.len,a(this,10);return x}}(),h.prototype.int32=function(){return this.uint32()|0},h.prototype.sint32=function(){var x=this.uint32();return x>>>1^-(x&1)|0};function u(){var x=new c(0,0),I=0;if(this.len-this.pos>4){for(;I<4;++I)if(x.lo=(x.lo|(this.buf[this.pos]&127)<<I*7)>>>0,this.buf[this.pos++]<128)return x;if(x.lo=(x.lo|(this.buf[this.pos]&127)<<28)>>>0,x.hi=(x.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return x;I=0}else{for(;I<3;++I){if(this.pos>=this.len)throw a(this);if(x.lo=(x.lo|(this.buf[this.pos]&127)<<I*7)>>>0,this.buf[this.pos++]<128)return x}return x.lo=(x.lo|(this.buf[this.pos++]&127)<<I*7)>>>0,x}if(this.len-this.pos>4){for(;I<5;++I)if(x.hi=(x.hi|(this.buf[this.pos]&127)<<I*7+3)>>>0,this.buf[this.pos++]<128)return x}else for(;I<5;++I){if(this.pos>=this.len)throw a(this);if(x.hi=(x.hi|(this.buf[this.pos]&127)<<I*7+3)>>>0,this.buf[this.pos++]<128)return x}throw Error("invalid varint encoding")}h.prototype.bool=function(){return this.uint32()!==0};function l(x,I){return(x[I-4]|x[I-3]<<8|x[I-2]<<16|x[I-1]<<24)>>>0}h.prototype.fixed32=function(){if(this.pos+4>this.len)throw a(this,4);return l(this.buf,this.pos+=4)},h.prototype.sfixed32=function(){if(this.pos+4>this.len)throw a(this,4);return l(this.buf,this.pos+=4)|0};function f(){if(this.pos+8>this.len)throw a(this,8);return new c(l(this.buf,this.pos+=4),l(this.buf,this.pos+=4))}h.prototype.float=function(){if(this.pos+4>this.len)throw a(this,4);var x=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,x},h.prototype.double=function(){if(this.pos+8>this.len)throw a(this,4);var x=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,x},h.prototype.bytes=function(){var x=this.uint32(),I=this.pos,R=this.pos+x;if(R>this.len)throw a(this,x);if(this.pos+=x,Array.isArray(this.buf))return this.buf.slice(I,R);if(I===R){var A=i.Buffer;return A?A.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,I,R)},h.prototype.string=function(){var x=this.bytes();return n.read(x,0,x.length)},h.prototype.skip=function(x){if(typeof x=="number"){if(this.pos+x>this.len)throw a(this,x);this.pos+=x}else do if(this.pos>=this.len)throw a(this);while(this.buf[this.pos++]&128);return this},h.prototype.skipType=function(x){switch(x){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(x=this.uint32()&7)!==4;)this.skipType(x);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+x+" at offset "+this.pos)}return this},h._configure=function(x){s=x,h.create=t(),s._configure();var I=i.Long?"toLong":"toNumber";i.merge(h.prototype,{int64:function(){return u.call(this)[I](!1)},uint64:function(){return u.call(this)[I](!0)},sint64:function(){return u.call(this).zzDecode()[I](!1)},fixed64:function(){return f.call(this)[I](!0)},sfixed64:function(){return f.call(this)[I](!1)}})}}),Lu=mt((e,r)=>{r.exports=c;var i=oi();(c.prototype=Object.create(i.prototype)).constructor=c;var s=Se();function c(n){i.call(this,n)}c._configure=function(){s.Buffer&&(c.prototype._slice=s.Buffer.prototype.slice)},c.prototype.string=function(){var n=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+n,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+n,this.len))},c._configure()}),ku=mt((e,r)=>{r.exports=s;var i=Se();(s.prototype=Object.create(i.EventEmitter.prototype)).constructor=s;function s(c,n,a){if(typeof c!="function")throw TypeError("rpcImpl must be a function");i.EventEmitter.call(this),this.rpcImpl=c,this.requestDelimited=!!n,this.responseDelimited=!!a}s.prototype.rpcCall=function c(n,a,h,p,t){if(!p)throw TypeError("request must be specified");var u=this;if(!t)return i.asPromise(c,u,n,a,h,p);if(!u.rpcImpl){setTimeout(function(){t(Error("already ended"))},0);return}try{return u.rpcImpl(n,a[u.requestDelimited?"encodeDelimited":"encode"](p).finish(),function(l,f){if(l)return u.emit("error",l,n),t(l);if(f===null){u.end(!0);return}if(!(f instanceof h))try{f=h[u.responseDelimited?"decodeDelimited":"decode"](f)}catch(x){return u.emit("error",x,n),t(x)}return u.emit("data",f,n),t(null,f)})}catch(l){u.emit("error",l,n),setTimeout(function(){t(l)},0);return}},s.prototype.end=function(c){return this.rpcImpl&&(c||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Fu=mt(e=>{var r=e;r.Service=ku()}),Nu=mt((e,r)=>{r.exports={}}),Mu=mt(e=>{var r=e;r.build="minimal",r.Writer=ei(),r.BufferWriter=vu(),r.Reader=oi(),r.BufferReader=Lu(),r.util=Se(),r.rpc=Fu(),r.roots=Nu(),r.configure=i;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}i()}),Vu=mt((e,r)=>{r.exports=Mu()}),sr=mt((e,r)=>{var i=Vu(),s=i.Reader,c=i.Writer,n=i.util,a=i.roots.default||(i.roots.default={});a.onnx=function(){var h={};return h.Version=function(){var p={},t=Object.create(p);return t[p[0]="_START_VERSION"]=0,t[p[1]="IR_VERSION_2017_10_10"]=1,t[p[2]="IR_VERSION_2017_10_30"]=2,t[p[3]="IR_VERSION_2017_11_3"]=3,t[p[4]="IR_VERSION_2019_1_22"]=4,t[p[5]="IR_VERSION_2019_3_18"]=5,t[p[6]="IR_VERSION_2019_9_19"]=6,t[p[7]="IR_VERSION_2020_5_8"]=7,t[p[8]="IR_VERSION_2021_7_30"]=8,t[p[9]="IR_VERSION"]=9,t}(),h.AttributeProto=function(){function p(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.name="",p.prototype.refAttrName="",p.prototype.docString="",p.prototype.type=0,p.prototype.f=0,p.prototype.i=n.Long?n.Long.fromBits(0,0,!1):0,p.prototype.s=n.newBuffer([]),p.prototype.t=null,p.prototype.g=null,p.prototype.sparseTensor=null,p.prototype.tp=null,p.prototype.floats=n.emptyArray,p.prototype.ints=n.emptyArray,p.prototype.strings=n.emptyArray,p.prototype.tensors=n.emptyArray,p.prototype.graphs=n.emptyArray,p.prototype.sparseTensors=n.emptyArray,p.prototype.typeProtos=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&u.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&u.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&u.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&a.onnx.TensorProto.encode(t.t,u.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&a.onnx.GraphProto.encode(t.g,u.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){u.uint32(58).fork();for(var l=0;l<t.floats.length;++l)u.float(t.floats[l]);u.ldelim()}if(t.ints!=null&&t.ints.length){u.uint32(66).fork();for(var l=0;l<t.ints.length;++l)u.int64(t.ints[l]);u.ldelim()}if(t.strings!=null&&t.strings.length)for(var l=0;l<t.strings.length;++l)u.uint32(74).bytes(t.strings[l]);if(t.tensors!=null&&t.tensors.length)for(var l=0;l<t.tensors.length;++l)a.onnx.TensorProto.encode(t.tensors[l],u.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var l=0;l<t.graphs.length;++l)a.onnx.GraphProto.encode(t.graphs[l],u.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&a.onnx.TypeProto.encode(t.tp,u.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var l=0;l<t.typeProtos.length;++l)a.onnx.TypeProto.encode(t.typeProtos[l],u.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&u.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&u.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&a.onnx.SparseTensorProto.encode(t.sparseTensor,u.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var l=0;l<t.sparseTensors.length;++l)a.onnx.SparseTensorProto.encode(t.sparseTensors[l],u.uint32(186).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.AttributeProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.name=t.string();break}case 21:{f.refAttrName=t.string();break}case 13:{f.docString=t.string();break}case 20:{f.type=t.int32();break}case 2:{f.f=t.float();break}case 3:{f.i=t.int64();break}case 4:{f.s=t.bytes();break}case 5:{f.t=a.onnx.TensorProto.decode(t,t.uint32());break}case 6:{f.g=a.onnx.GraphProto.decode(t,t.uint32());break}case 22:{f.sparseTensor=a.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{f.tp=a.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(f.floats&&f.floats.length||(f.floats=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.floats.push(t.float());else f.floats.push(t.float());break}case 8:{if(f.ints&&f.ints.length||(f.ints=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.ints.push(t.int64());else f.ints.push(t.int64());break}case 9:{f.strings&&f.strings.length||(f.strings=[]),f.strings.push(t.bytes());break}case 10:{f.tensors&&f.tensors.length||(f.tensors=[]),f.tensors.push(a.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{f.graphs&&f.graphs.length||(f.graphs=[]),f.graphs.push(a.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{f.sparseTensors&&f.sparseTensors.length||(f.sparseTensors=[]),f.sparseTensors.push(a.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{f.typeProtos&&f.typeProtos.length||(f.typeProtos=[]),f.typeProtos.push(a.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!n.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!n.isInteger(t.i)&&!(t.i&&n.isInteger(t.i.low)&&n.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||n.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var u=a.onnx.TensorProto.verify(t.t);if(u)return"t."+u}if(t.g!=null&&t.hasOwnProperty("g")){var u=a.onnx.GraphProto.verify(t.g);if(u)return"g."+u}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var u=a.onnx.SparseTensorProto.verify(t.sparseTensor);if(u)return"sparseTensor."+u}if(t.tp!=null&&t.hasOwnProperty("tp")){var u=a.onnx.TypeProto.verify(t.tp);if(u)return"tp."+u}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var l=0;l<t.floats.length;++l)if(typeof t.floats[l]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var l=0;l<t.ints.length;++l)if(!n.isInteger(t.ints[l])&&!(t.ints[l]&&n.isInteger(t.ints[l].low)&&n.isInteger(t.ints[l].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var l=0;l<t.strings.length;++l)if(!(t.strings[l]&&typeof t.strings[l].length=="number"||n.isString(t.strings[l])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var l=0;l<t.tensors.length;++l){var u=a.onnx.TensorProto.verify(t.tensors[l]);if(u)return"tensors."+u}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var l=0;l<t.graphs.length;++l){var u=a.onnx.GraphProto.verify(t.graphs[l]);if(u)return"graphs."+u}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var l=0;l<t.sparseTensors.length;++l){var u=a.onnx.SparseTensorProto.verify(t.sparseTensors[l]);if(u)return"sparseTensors."+u}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var l=0;l<t.typeProtos.length;++l){var u=a.onnx.TypeProto.verify(t.typeProtos[l]);if(u)return"typeProtos."+u}}return null},p.fromObject=function(t){if(t instanceof a.onnx.AttributeProto)return t;var u=new a.onnx.AttributeProto;switch(t.name!=null&&(u.name=String(t.name)),t.refAttrName!=null&&(u.refAttrName=String(t.refAttrName)),t.docString!=null&&(u.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){u.type=t.type;break}break;case"UNDEFINED":case 0:u.type=0;break;case"FLOAT":case 1:u.type=1;break;case"INT":case 2:u.type=2;break;case"STRING":case 3:u.type=3;break;case"TENSOR":case 4:u.type=4;break;case"GRAPH":case 5:u.type=5;break;case"SPARSE_TENSOR":case 11:u.type=11;break;case"TYPE_PROTO":case 13:u.type=13;break;case"FLOATS":case 6:u.type=6;break;case"INTS":case 7:u.type=7;break;case"STRINGS":case 8:u.type=8;break;case"TENSORS":case 9:u.type=9;break;case"GRAPHS":case 10:u.type=10;break;case"SPARSE_TENSORS":case 12:u.type=12;break;case"TYPE_PROTOS":case 14:u.type=14;break}if(t.f!=null&&(u.f=Number(t.f)),t.i!=null&&(n.Long?(u.i=n.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?u.i=parseInt(t.i,10):typeof t.i=="number"?u.i=t.i:typeof t.i=="object"&&(u.i=new n.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?n.base64.decode(t.s,u.s=n.newBuffer(n.base64.length(t.s)),0):t.s.length>=0&&(u.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");u.t=a.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");u.g=a.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");u.sparseTensor=a.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");u.tp=a.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");u.floats=[];for(var l=0;l<t.floats.length;++l)u.floats[l]=Number(t.floats[l])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");u.ints=[];for(var l=0;l<t.ints.length;++l)n.Long?(u.ints[l]=n.Long.fromValue(t.ints[l])).unsigned=!1:typeof t.ints[l]=="string"?u.ints[l]=parseInt(t.ints[l],10):typeof t.ints[l]=="number"?u.ints[l]=t.ints[l]:typeof t.ints[l]=="object"&&(u.ints[l]=new n.LongBits(t.ints[l].low>>>0,t.ints[l].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");u.strings=[];for(var l=0;l<t.strings.length;++l)typeof t.strings[l]=="string"?n.base64.decode(t.strings[l],u.strings[l]=n.newBuffer(n.base64.length(t.strings[l])),0):t.strings[l].length>=0&&(u.strings[l]=t.strings[l])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");u.tensors=[];for(var l=0;l<t.tensors.length;++l){if(typeof t.tensors[l]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");u.tensors[l]=a.onnx.TensorProto.fromObject(t.tensors[l])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");u.graphs=[];for(var l=0;l<t.graphs.length;++l){if(typeof t.graphs[l]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");u.graphs[l]=a.onnx.GraphProto.fromObject(t.graphs[l])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");u.sparseTensors=[];for(var l=0;l<t.sparseTensors.length;++l){if(typeof t.sparseTensors[l]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");u.sparseTensors[l]=a.onnx.SparseTensorProto.fromObject(t.sparseTensors[l])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");u.typeProtos=[];for(var l=0;l<t.typeProtos.length;++l){if(typeof t.typeProtos[l]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");u.typeProtos[l]=a.onnx.TypeProto.fromObject(t.typeProtos[l])}}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.floats=[],l.ints=[],l.strings=[],l.tensors=[],l.graphs=[],l.typeProtos=[],l.sparseTensors=[]),u.defaults){if(l.name="",l.f=0,n.Long){var f=new n.Long(0,0,!1);l.i=u.longs===String?f.toString():u.longs===Number?f.toNumber():f}else l.i=u.longs===String?"0":0;u.bytes===String?l.s="":(l.s=[],u.bytes!==Array&&(l.s=n.newBuffer(l.s))),l.t=null,l.g=null,l.docString="",l.tp=null,l.type=u.enums===String?"UNDEFINED":0,l.refAttrName="",l.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(l.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(l.f=u.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?l.i=u.longs===String?String(t.i):t.i:l.i=u.longs===String?n.Long.prototype.toString.call(t.i):u.longs===Number?new n.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(l.s=u.bytes===String?n.base64.encode(t.s,0,t.s.length):u.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(l.t=a.onnx.TensorProto.toObject(t.t,u)),t.g!=null&&t.hasOwnProperty("g")&&(l.g=a.onnx.GraphProto.toObject(t.g,u)),t.floats&&t.floats.length){l.floats=[];for(var x=0;x<t.floats.length;++x)l.floats[x]=u.json&&!isFinite(t.floats[x])?String(t.floats[x]):t.floats[x]}if(t.ints&&t.ints.length){l.ints=[];for(var x=0;x<t.ints.length;++x)typeof t.ints[x]=="number"?l.ints[x]=u.longs===String?String(t.ints[x]):t.ints[x]:l.ints[x]=u.longs===String?n.Long.prototype.toString.call(t.ints[x]):u.longs===Number?new n.LongBits(t.ints[x].low>>>0,t.ints[x].high>>>0).toNumber():t.ints[x]}if(t.strings&&t.strings.length){l.strings=[];for(var x=0;x<t.strings.length;++x)l.strings[x]=u.bytes===String?n.base64.encode(t.strings[x],0,t.strings[x].length):u.bytes===Array?Array.prototype.slice.call(t.strings[x]):t.strings[x]}if(t.tensors&&t.tensors.length){l.tensors=[];for(var x=0;x<t.tensors.length;++x)l.tensors[x]=a.onnx.TensorProto.toObject(t.tensors[x],u)}if(t.graphs&&t.graphs.length){l.graphs=[];for(var x=0;x<t.graphs.length;++x)l.graphs[x]=a.onnx.GraphProto.toObject(t.graphs[x],u)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(l.tp=a.onnx.TypeProto.toObject(t.tp,u)),t.typeProtos&&t.typeProtos.length){l.typeProtos=[];for(var x=0;x<t.typeProtos.length;++x)l.typeProtos[x]=a.onnx.TypeProto.toObject(t.typeProtos[x],u)}if(t.type!=null&&t.hasOwnProperty("type")&&(l.type=u.enums===String?a.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:a.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(l.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(l.sparseTensor=a.onnx.SparseTensorProto.toObject(t.sparseTensor,u)),t.sparseTensors&&t.sparseTensors.length){l.sparseTensors=[];for(var x=0;x<t.sparseTensors.length;++x)l.sparseTensors[x]=a.onnx.SparseTensorProto.toObject(t.sparseTensors[x],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},p.AttributeType=function(){var t={},u=Object.create(t);return u[t[0]="UNDEFINED"]=0,u[t[1]="FLOAT"]=1,u[t[2]="INT"]=2,u[t[3]="STRING"]=3,u[t[4]="TENSOR"]=4,u[t[5]="GRAPH"]=5,u[t[11]="SPARSE_TENSOR"]=11,u[t[13]="TYPE_PROTO"]=13,u[t[6]="FLOATS"]=6,u[t[7]="INTS"]=7,u[t[8]="STRINGS"]=8,u[t[9]="TENSORS"]=9,u[t[10]="GRAPHS"]=10,u[t[12]="SPARSE_TENSORS"]=12,u[t[14]="TYPE_PROTOS"]=14,u}(),p}(),h.ValueInfoProto=function(){function p(t){if(t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.name="",p.prototype.type=null,p.prototype.docString="",p.create=function(t){return new p(t)},p.encode=function(t,u){return u||(u=c.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&a.onnx.TypeProto.encode(t.type,u.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(26).string(t.docString),u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.ValueInfoProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.name=t.string();break}case 2:{f.type=a.onnx.TypeProto.decode(t,t.uint32());break}case 3:{f.docString=t.string();break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var u=a.onnx.TypeProto.verify(t.type);if(u)return"type."+u}return t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString)?"docString: string expected":null},p.fromObject=function(t){if(t instanceof a.onnx.ValueInfoProto)return t;var u=new a.onnx.ValueInfoProto;if(t.name!=null&&(u.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");u.type=a.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(u.docString=String(t.docString)),u},p.toObject=function(t,u){u||(u={});var l={};return u.defaults&&(l.name="",l.type=null,l.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(l.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(l.type=a.onnx.TypeProto.toObject(t.type,u)),t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},p}(),h.NodeProto=function(){function p(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.input=n.emptyArray,p.prototype.output=n.emptyArray,p.prototype.name="",p.prototype.opType="",p.prototype.domain="",p.prototype.attribute=n.emptyArray,p.prototype.docString="",p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.input!=null&&t.input.length)for(var l=0;l<t.input.length;++l)u.uint32(10).string(t.input[l]);if(t.output!=null&&t.output.length)for(var l=0;l<t.output.length;++l)u.uint32(18).string(t.output[l]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&u.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var l=0;l<t.attribute.length;++l)a.onnx.AttributeProto.encode(t.attribute[l],u.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(58).string(t.domain),u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.NodeProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.input&&f.input.length||(f.input=[]),f.input.push(t.string());break}case 2:{f.output&&f.output.length||(f.output=[]),f.output.push(t.string());break}case 3:{f.name=t.string();break}case 4:{f.opType=t.string();break}case 7:{f.domain=t.string();break}case 5:{f.attribute&&f.attribute.length||(f.attribute=[]),f.attribute.push(a.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{f.docString=t.string();break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var u=0;u<t.input.length;++u)if(!n.isString(t.input[u]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var u=0;u<t.output.length;++u)if(!n.isString(t.output[u]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!n.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var u=0;u<t.attribute.length;++u){var l=a.onnx.AttributeProto.verify(t.attribute[u]);if(l)return"attribute."+l}}return t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString)?"docString: string expected":null},p.fromObject=function(t){if(t instanceof a.onnx.NodeProto)return t;var u=new a.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");u.input=[];for(var l=0;l<t.input.length;++l)u.input[l]=String(t.input[l])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");u.output=[];for(var l=0;l<t.output.length;++l)u.output[l]=String(t.output[l])}if(t.name!=null&&(u.name=String(t.name)),t.opType!=null&&(u.opType=String(t.opType)),t.domain!=null&&(u.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");u.attribute=[];for(var l=0;l<t.attribute.length;++l){if(typeof t.attribute[l]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");u.attribute[l]=a.onnx.AttributeProto.fromObject(t.attribute[l])}}return t.docString!=null&&(u.docString=String(t.docString)),u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.input=[],l.output=[],l.attribute=[]),u.defaults&&(l.name="",l.opType="",l.docString="",l.domain=""),t.input&&t.input.length){l.input=[];for(var f=0;f<t.input.length;++f)l.input[f]=t.input[f]}if(t.output&&t.output.length){l.output=[];for(var f=0;f<t.output.length;++f)l.output[f]=t.output[f]}if(t.name!=null&&t.hasOwnProperty("name")&&(l.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(l.opType=t.opType),t.attribute&&t.attribute.length){l.attribute=[];for(var f=0;f<t.attribute.length;++f)l.attribute[f]=a.onnx.AttributeProto.toObject(t.attribute[f],u)}return t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(l.domain=t.domain),l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},p}(),h.TrainingInfoProto=function(){function p(t){if(this.initializationBinding=[],this.updateBinding=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.initialization=null,p.prototype.algorithm=null,p.prototype.initializationBinding=n.emptyArray,p.prototype.updateBinding=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&a.onnx.GraphProto.encode(t.initialization,u.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&a.onnx.GraphProto.encode(t.algorithm,u.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var l=0;l<t.initializationBinding.length;++l)a.onnx.StringStringEntryProto.encode(t.initializationBinding[l],u.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var l=0;l<t.updateBinding.length;++l)a.onnx.StringStringEntryProto.encode(t.updateBinding[l],u.uint32(34).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.TrainingInfoProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.initialization=a.onnx.GraphProto.decode(t,t.uint32());break}case 2:{f.algorithm=a.onnx.GraphProto.decode(t,t.uint32());break}case 3:{f.initializationBinding&&f.initializationBinding.length||(f.initializationBinding=[]),f.initializationBinding.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{f.updateBinding&&f.updateBinding.length||(f.updateBinding=[]),f.updateBinding.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var u=a.onnx.GraphProto.verify(t.initialization);if(u)return"initialization."+u}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var u=a.onnx.GraphProto.verify(t.algorithm);if(u)return"algorithm."+u}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var l=0;l<t.initializationBinding.length;++l){var u=a.onnx.StringStringEntryProto.verify(t.initializationBinding[l]);if(u)return"initializationBinding."+u}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var l=0;l<t.updateBinding.length;++l){var u=a.onnx.StringStringEntryProto.verify(t.updateBinding[l]);if(u)return"updateBinding."+u}}return null},p.fromObject=function(t){if(t instanceof a.onnx.TrainingInfoProto)return t;var u=new a.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");u.initialization=a.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");u.algorithm=a.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");u.initializationBinding=[];for(var l=0;l<t.initializationBinding.length;++l){if(typeof t.initializationBinding[l]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");u.initializationBinding[l]=a.onnx.StringStringEntryProto.fromObject(t.initializationBinding[l])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");u.updateBinding=[];for(var l=0;l<t.updateBinding.length;++l){if(typeof t.updateBinding[l]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");u.updateBinding[l]=a.onnx.StringStringEntryProto.fromObject(t.updateBinding[l])}}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.initializationBinding=[],l.updateBinding=[]),u.defaults&&(l.initialization=null,l.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(l.initialization=a.onnx.GraphProto.toObject(t.initialization,u)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(l.algorithm=a.onnx.GraphProto.toObject(t.algorithm,u)),t.initializationBinding&&t.initializationBinding.length){l.initializationBinding=[];for(var f=0;f<t.initializationBinding.length;++f)l.initializationBinding[f]=a.onnx.StringStringEntryProto.toObject(t.initializationBinding[f],u)}if(t.updateBinding&&t.updateBinding.length){l.updateBinding=[];for(var f=0;f<t.updateBinding.length;++f)l.updateBinding[f]=a.onnx.StringStringEntryProto.toObject(t.updateBinding[f],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},p}(),h.ModelProto=function(){function p(t){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.irVersion=n.Long?n.Long.fromBits(0,0,!1):0,p.prototype.opsetImport=n.emptyArray,p.prototype.producerName="",p.prototype.producerVersion="",p.prototype.domain="",p.prototype.modelVersion=n.Long?n.Long.fromBits(0,0,!1):0,p.prototype.docString="",p.prototype.graph=null,p.prototype.metadataProps=n.emptyArray,p.prototype.trainingInfo=n.emptyArray,p.prototype.functions=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&u.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&u.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&u.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&u.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&a.onnx.GraphProto.encode(t.graph,u.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var l=0;l<t.opsetImport.length;++l)a.onnx.OperatorSetIdProto.encode(t.opsetImport[l],u.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var l=0;l<t.metadataProps.length;++l)a.onnx.StringStringEntryProto.encode(t.metadataProps[l],u.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var l=0;l<t.trainingInfo.length;++l)a.onnx.TrainingInfoProto.encode(t.trainingInfo[l],u.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var l=0;l<t.functions.length;++l)a.onnx.FunctionProto.encode(t.functions[l],u.uint32(202).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.ModelProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.irVersion=t.int64();break}case 8:{f.opsetImport&&f.opsetImport.length||(f.opsetImport=[]),f.opsetImport.push(a.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{f.producerName=t.string();break}case 3:{f.producerVersion=t.string();break}case 4:{f.domain=t.string();break}case 5:{f.modelVersion=t.int64();break}case 6:{f.docString=t.string();break}case 7:{f.graph=a.onnx.GraphProto.decode(t,t.uint32());break}case 14:{f.metadataProps&&f.metadataProps.length||(f.metadataProps=[]),f.metadataProps.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{f.trainingInfo&&f.trainingInfo.length||(f.trainingInfo=[]),f.trainingInfo.push(a.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{f.functions&&f.functions.length||(f.functions=[]),f.functions.push(a.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!n.isInteger(t.irVersion)&&!(t.irVersion&&n.isInteger(t.irVersion.low)&&n.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var u=0;u<t.opsetImport.length;++u){var l=a.onnx.OperatorSetIdProto.verify(t.opsetImport[u]);if(l)return"opsetImport."+l}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!n.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!n.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!n.isInteger(t.modelVersion)&&!(t.modelVersion&&n.isInteger(t.modelVersion.low)&&n.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var l=a.onnx.GraphProto.verify(t.graph);if(l)return"graph."+l}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var u=0;u<t.metadataProps.length;++u){var l=a.onnx.StringStringEntryProto.verify(t.metadataProps[u]);if(l)return"metadataProps."+l}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var u=0;u<t.trainingInfo.length;++u){var l=a.onnx.TrainingInfoProto.verify(t.trainingInfo[u]);if(l)return"trainingInfo."+l}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var u=0;u<t.functions.length;++u){var l=a.onnx.FunctionProto.verify(t.functions[u]);if(l)return"functions."+l}}return null},p.fromObject=function(t){if(t instanceof a.onnx.ModelProto)return t;var u=new a.onnx.ModelProto;if(t.irVersion!=null&&(n.Long?(u.irVersion=n.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?u.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?u.irVersion=t.irVersion:typeof t.irVersion=="object"&&(u.irVersion=new n.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");u.opsetImport=[];for(var l=0;l<t.opsetImport.length;++l){if(typeof t.opsetImport[l]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");u.opsetImport[l]=a.onnx.OperatorSetIdProto.fromObject(t.opsetImport[l])}}if(t.producerName!=null&&(u.producerName=String(t.producerName)),t.producerVersion!=null&&(u.producerVersion=String(t.producerVersion)),t.domain!=null&&(u.domain=String(t.domain)),t.modelVersion!=null&&(n.Long?(u.modelVersion=n.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?u.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?u.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(u.modelVersion=new n.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(u.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");u.graph=a.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");u.metadataProps=[];for(var l=0;l<t.metadataProps.length;++l){if(typeof t.metadataProps[l]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");u.metadataProps[l]=a.onnx.StringStringEntryProto.fromObject(t.metadataProps[l])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");u.trainingInfo=[];for(var l=0;l<t.trainingInfo.length;++l){if(typeof t.trainingInfo[l]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");u.trainingInfo[l]=a.onnx.TrainingInfoProto.fromObject(t.trainingInfo[l])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");u.functions=[];for(var l=0;l<t.functions.length;++l){if(typeof t.functions[l]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");u.functions[l]=a.onnx.FunctionProto.fromObject(t.functions[l])}}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.opsetImport=[],l.metadataProps=[],l.trainingInfo=[],l.functions=[]),u.defaults){if(n.Long){var f=new n.Long(0,0,!1);l.irVersion=u.longs===String?f.toString():u.longs===Number?f.toNumber():f}else l.irVersion=u.longs===String?"0":0;if(l.producerName="",l.producerVersion="",l.domain="",n.Long){var f=new n.Long(0,0,!1);l.modelVersion=u.longs===String?f.toString():u.longs===Number?f.toNumber():f}else l.modelVersion=u.longs===String?"0":0;l.docString="",l.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?l.irVersion=u.longs===String?String(t.irVersion):t.irVersion:l.irVersion=u.longs===String?n.Long.prototype.toString.call(t.irVersion):u.longs===Number?new n.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(l.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(l.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(l.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?l.modelVersion=u.longs===String?String(t.modelVersion):t.modelVersion:l.modelVersion=u.longs===String?n.Long.prototype.toString.call(t.modelVersion):u.longs===Number?new n.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(l.graph=a.onnx.GraphProto.toObject(t.graph,u)),t.opsetImport&&t.opsetImport.length){l.opsetImport=[];for(var x=0;x<t.opsetImport.length;++x)l.opsetImport[x]=a.onnx.OperatorSetIdProto.toObject(t.opsetImport[x],u)}if(t.metadataProps&&t.metadataProps.length){l.metadataProps=[];for(var x=0;x<t.metadataProps.length;++x)l.metadataProps[x]=a.onnx.StringStringEntryProto.toObject(t.metadataProps[x],u)}if(t.trainingInfo&&t.trainingInfo.length){l.trainingInfo=[];for(var x=0;x<t.trainingInfo.length;++x)l.trainingInfo[x]=a.onnx.TrainingInfoProto.toObject(t.trainingInfo[x],u)}if(t.functions&&t.functions.length){l.functions=[];for(var x=0;x<t.functions.length;++x)l.functions[x]=a.onnx.FunctionProto.toObject(t.functions[x],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},p}(),h.StringStringEntryProto=function(){function p(t){if(t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.key="",p.prototype.value="",p.create=function(t){return new p(t)},p.encode=function(t,u){return u||(u=c.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&u.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&u.uint32(18).string(t.value),u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.StringStringEntryProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.key=t.string();break}case 2:{f.value=t.string();break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!n.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!n.isString(t.value)?"value: string expected":null},p.fromObject=function(t){if(t instanceof a.onnx.StringStringEntryProto)return t;var u=new a.onnx.StringStringEntryProto;return t.key!=null&&(u.key=String(t.key)),t.value!=null&&(u.value=String(t.value)),u},p.toObject=function(t,u){u||(u={});var l={};return u.defaults&&(l.key="",l.value=""),t.key!=null&&t.hasOwnProperty("key")&&(l.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(l.value=t.value),l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},p}(),h.TensorAnnotation=function(){function p(t){if(this.quantParameterTensorNames=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.tensorName="",p.prototype.quantParameterTensorNames=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&u.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var l=0;l<t.quantParameterTensorNames.length;++l)a.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[l],u.uint32(18).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.TensorAnnotation;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.tensorName=t.string();break}case 2:{f.quantParameterTensorNames&&f.quantParameterTensorNames.length||(f.quantParameterTensorNames=[]),f.quantParameterTensorNames.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!n.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var u=0;u<t.quantParameterTensorNames.length;++u){var l=a.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[u]);if(l)return"quantParameterTensorNames."+l}}return null},p.fromObject=function(t){if(t instanceof a.onnx.TensorAnnotation)return t;var u=new a.onnx.TensorAnnotation;if(t.tensorName!=null&&(u.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");u.quantParameterTensorNames=[];for(var l=0;l<t.quantParameterTensorNames.length;++l){if(typeof t.quantParameterTensorNames[l]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");u.quantParameterTensorNames[l]=a.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[l])}}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.quantParameterTensorNames=[]),u.defaults&&(l.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(l.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){l.quantParameterTensorNames=[];for(var f=0;f<t.quantParameterTensorNames.length;++f)l.quantParameterTensorNames[f]=a.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[f],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},p}(),h.GraphProto=function(){function p(t){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.node=n.emptyArray,p.prototype.name="",p.prototype.initializer=n.emptyArray,p.prototype.sparseInitializer=n.emptyArray,p.prototype.docString="",p.prototype.input=n.emptyArray,p.prototype.output=n.emptyArray,p.prototype.valueInfo=n.emptyArray,p.prototype.quantizationAnnotation=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.node!=null&&t.node.length)for(var l=0;l<t.node.length;++l)a.onnx.NodeProto.encode(t.node[l],u.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var l=0;l<t.initializer.length;++l)a.onnx.TensorProto.encode(t.initializer[l],u.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var l=0;l<t.input.length;++l)a.onnx.ValueInfoProto.encode(t.input[l],u.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var l=0;l<t.output.length;++l)a.onnx.ValueInfoProto.encode(t.output[l],u.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var l=0;l<t.valueInfo.length;++l)a.onnx.ValueInfoProto.encode(t.valueInfo[l],u.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var l=0;l<t.quantizationAnnotation.length;++l)a.onnx.TensorAnnotation.encode(t.quantizationAnnotation[l],u.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var l=0;l<t.sparseInitializer.length;++l)a.onnx.SparseTensorProto.encode(t.sparseInitializer[l],u.uint32(122).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.GraphProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.node&&f.node.length||(f.node=[]),f.node.push(a.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{f.name=t.string();break}case 5:{f.initializer&&f.initializer.length||(f.initializer=[]),f.initializer.push(a.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{f.sparseInitializer&&f.sparseInitializer.length||(f.sparseInitializer=[]),f.sparseInitializer.push(a.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{f.docString=t.string();break}case 11:{f.input&&f.input.length||(f.input=[]),f.input.push(a.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{f.output&&f.output.length||(f.output=[]),f.output.push(a.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{f.valueInfo&&f.valueInfo.length||(f.valueInfo=[]),f.valueInfo.push(a.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{f.quantizationAnnotation&&f.quantizationAnnotation.length||(f.quantizationAnnotation=[]),f.quantizationAnnotation.push(a.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var u=0;u<t.node.length;++u){var l=a.onnx.NodeProto.verify(t.node[u]);if(l)return"node."+l}}if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var u=0;u<t.initializer.length;++u){var l=a.onnx.TensorProto.verify(t.initializer[u]);if(l)return"initializer."+l}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var u=0;u<t.sparseInitializer.length;++u){var l=a.onnx.SparseTensorProto.verify(t.sparseInitializer[u]);if(l)return"sparseInitializer."+l}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var u=0;u<t.input.length;++u){var l=a.onnx.ValueInfoProto.verify(t.input[u]);if(l)return"input."+l}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var u=0;u<t.output.length;++u){var l=a.onnx.ValueInfoProto.verify(t.output[u]);if(l)return"output."+l}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var u=0;u<t.valueInfo.length;++u){var l=a.onnx.ValueInfoProto.verify(t.valueInfo[u]);if(l)return"valueInfo."+l}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var u=0;u<t.quantizationAnnotation.length;++u){var l=a.onnx.TensorAnnotation.verify(t.quantizationAnnotation[u]);if(l)return"quantizationAnnotation."+l}}return null},p.fromObject=function(t){if(t instanceof a.onnx.GraphProto)return t;var u=new a.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");u.node=[];for(var l=0;l<t.node.length;++l){if(typeof t.node[l]!="object")throw TypeError(".onnx.GraphProto.node: object expected");u.node[l]=a.onnx.NodeProto.fromObject(t.node[l])}}if(t.name!=null&&(u.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");u.initializer=[];for(var l=0;l<t.initializer.length;++l){if(typeof t.initializer[l]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");u.initializer[l]=a.onnx.TensorProto.fromObject(t.initializer[l])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");u.sparseInitializer=[];for(var l=0;l<t.sparseInitializer.length;++l){if(typeof t.sparseInitializer[l]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");u.sparseInitializer[l]=a.onnx.SparseTensorProto.fromObject(t.sparseInitializer[l])}}if(t.docString!=null&&(u.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");u.input=[];for(var l=0;l<t.input.length;++l){if(typeof t.input[l]!="object")throw TypeError(".onnx.GraphProto.input: object expected");u.input[l]=a.onnx.ValueInfoProto.fromObject(t.input[l])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");u.output=[];for(var l=0;l<t.output.length;++l){if(typeof t.output[l]!="object")throw TypeError(".onnx.GraphProto.output: object expected");u.output[l]=a.onnx.ValueInfoProto.fromObject(t.output[l])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");u.valueInfo=[];for(var l=0;l<t.valueInfo.length;++l){if(typeof t.valueInfo[l]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");u.valueInfo[l]=a.onnx.ValueInfoProto.fromObject(t.valueInfo[l])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");u.quantizationAnnotation=[];for(var l=0;l<t.quantizationAnnotation.length;++l){if(typeof t.quantizationAnnotation[l]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");u.quantizationAnnotation[l]=a.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[l])}}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.node=[],l.initializer=[],l.input=[],l.output=[],l.valueInfo=[],l.quantizationAnnotation=[],l.sparseInitializer=[]),u.defaults&&(l.name="",l.docString=""),t.node&&t.node.length){l.node=[];for(var f=0;f<t.node.length;++f)l.node[f]=a.onnx.NodeProto.toObject(t.node[f],u)}if(t.name!=null&&t.hasOwnProperty("name")&&(l.name=t.name),t.initializer&&t.initializer.length){l.initializer=[];for(var f=0;f<t.initializer.length;++f)l.initializer[f]=a.onnx.TensorProto.toObject(t.initializer[f],u)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),t.input&&t.input.length){l.input=[];for(var f=0;f<t.input.length;++f)l.input[f]=a.onnx.ValueInfoProto.toObject(t.input[f],u)}if(t.output&&t.output.length){l.output=[];for(var f=0;f<t.output.length;++f)l.output[f]=a.onnx.ValueInfoProto.toObject(t.output[f],u)}if(t.valueInfo&&t.valueInfo.length){l.valueInfo=[];for(var f=0;f<t.valueInfo.length;++f)l.valueInfo[f]=a.onnx.ValueInfoProto.toObject(t.valueInfo[f],u)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){l.quantizationAnnotation=[];for(var f=0;f<t.quantizationAnnotation.length;++f)l.quantizationAnnotation[f]=a.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[f],u)}if(t.sparseInitializer&&t.sparseInitializer.length){l.sparseInitializer=[];for(var f=0;f<t.sparseInitializer.length;++f)l.sparseInitializer[f]=a.onnx.SparseTensorProto.toObject(t.sparseInitializer[f],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},p}(),h.TensorProto=function(){function p(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.dims=n.emptyArray,p.prototype.dataType=0,p.prototype.segment=null,p.prototype.floatData=n.emptyArray,p.prototype.int32Data=n.emptyArray,p.prototype.stringData=n.emptyArray,p.prototype.int64Data=n.emptyArray,p.prototype.name="",p.prototype.docString="",p.prototype.rawData=n.newBuffer([]),p.prototype.externalData=n.emptyArray,p.prototype.dataLocation=0,p.prototype.doubleData=n.emptyArray,p.prototype.uint64Data=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.dims!=null&&t.dims.length){u.uint32(10).fork();for(var l=0;l<t.dims.length;++l)u.int64(t.dims[l]);u.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&u.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&a.onnx.TensorProto.Segment.encode(t.segment,u.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){u.uint32(34).fork();for(var l=0;l<t.floatData.length;++l)u.float(t.floatData[l]);u.ldelim()}if(t.int32Data!=null&&t.int32Data.length){u.uint32(42).fork();for(var l=0;l<t.int32Data.length;++l)u.int32(t.int32Data[l]);u.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var l=0;l<t.stringData.length;++l)u.uint32(50).bytes(t.stringData[l]);if(t.int64Data!=null&&t.int64Data.length){u.uint32(58).fork();for(var l=0;l<t.int64Data.length;++l)u.int64(t.int64Data[l]);u.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&u.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){u.uint32(82).fork();for(var l=0;l<t.doubleData.length;++l)u.double(t.doubleData[l]);u.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){u.uint32(90).fork();for(var l=0;l<t.uint64Data.length;++l)u.uint64(t.uint64Data[l]);u.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var l=0;l<t.externalData.length;++l)a.onnx.StringStringEntryProto.encode(t.externalData[l],u.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&u.uint32(112).int32(t.dataLocation),u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.TensorProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{if(f.dims&&f.dims.length||(f.dims=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.dims.push(t.int64());else f.dims.push(t.int64());break}case 2:{f.dataType=t.int32();break}case 3:{f.segment=a.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(f.floatData&&f.floatData.length||(f.floatData=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.floatData.push(t.float());else f.floatData.push(t.float());break}case 5:{if(f.int32Data&&f.int32Data.length||(f.int32Data=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.int32Data.push(t.int32());else f.int32Data.push(t.int32());break}case 6:{f.stringData&&f.stringData.length||(f.stringData=[]),f.stringData.push(t.bytes());break}case 7:{if(f.int64Data&&f.int64Data.length||(f.int64Data=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.int64Data.push(t.int64());else f.int64Data.push(t.int64());break}case 8:{f.name=t.string();break}case 12:{f.docString=t.string();break}case 9:{f.rawData=t.bytes();break}case 13:{f.externalData&&f.externalData.length||(f.externalData=[]),f.externalData.push(a.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{f.dataLocation=t.int32();break}case 10:{if(f.doubleData&&f.doubleData.length||(f.doubleData=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.doubleData.push(t.double());else f.doubleData.push(t.double());break}case 11:{if(f.uint64Data&&f.uint64Data.length||(f.uint64Data=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.uint64Data.push(t.uint64());else f.uint64Data.push(t.uint64());break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var u=0;u<t.dims.length;++u)if(!n.isInteger(t.dims[u])&&!(t.dims[u]&&n.isInteger(t.dims[u].low)&&n.isInteger(t.dims[u].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!n.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var l=a.onnx.TensorProto.Segment.verify(t.segment);if(l)return"segment."+l}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var u=0;u<t.floatData.length;++u)if(typeof t.floatData[u]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var u=0;u<t.int32Data.length;++u)if(!n.isInteger(t.int32Data[u]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var u=0;u<t.stringData.length;++u)if(!(t.stringData[u]&&typeof t.stringData[u].length=="number"||n.isString(t.stringData[u])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var u=0;u<t.int64Data.length;++u)if(!n.isInteger(t.int64Data[u])&&!(t.int64Data[u]&&n.isInteger(t.int64Data[u].low)&&n.isInteger(t.int64Data[u].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||n.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var u=0;u<t.externalData.length;++u){var l=a.onnx.StringStringEntryProto.verify(t.externalData[u]);if(l)return"externalData."+l}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var u=0;u<t.doubleData.length;++u)if(typeof t.doubleData[u]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var u=0;u<t.uint64Data.length;++u)if(!n.isInteger(t.uint64Data[u])&&!(t.uint64Data[u]&&n.isInteger(t.uint64Data[u].low)&&n.isInteger(t.uint64Data[u].high)))return"uint64Data: integer|Long[] expected"}return null},p.fromObject=function(t){if(t instanceof a.onnx.TensorProto)return t;var u=new a.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");u.dims=[];for(var l=0;l<t.dims.length;++l)n.Long?(u.dims[l]=n.Long.fromValue(t.dims[l])).unsigned=!1:typeof t.dims[l]=="string"?u.dims[l]=parseInt(t.dims[l],10):typeof t.dims[l]=="number"?u.dims[l]=t.dims[l]:typeof t.dims[l]=="object"&&(u.dims[l]=new n.LongBits(t.dims[l].low>>>0,t.dims[l].high>>>0).toNumber())}if(t.dataType!=null&&(u.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");u.segment=a.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");u.floatData=[];for(var l=0;l<t.floatData.length;++l)u.floatData[l]=Number(t.floatData[l])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");u.int32Data=[];for(var l=0;l<t.int32Data.length;++l)u.int32Data[l]=t.int32Data[l]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");u.stringData=[];for(var l=0;l<t.stringData.length;++l)typeof t.stringData[l]=="string"?n.base64.decode(t.stringData[l],u.stringData[l]=n.newBuffer(n.base64.length(t.stringData[l])),0):t.stringData[l].length>=0&&(u.stringData[l]=t.stringData[l])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");u.int64Data=[];for(var l=0;l<t.int64Data.length;++l)n.Long?(u.int64Data[l]=n.Long.fromValue(t.int64Data[l])).unsigned=!1:typeof t.int64Data[l]=="string"?u.int64Data[l]=parseInt(t.int64Data[l],10):typeof t.int64Data[l]=="number"?u.int64Data[l]=t.int64Data[l]:typeof t.int64Data[l]=="object"&&(u.int64Data[l]=new n.LongBits(t.int64Data[l].low>>>0,t.int64Data[l].high>>>0).toNumber())}if(t.name!=null&&(u.name=String(t.name)),t.docString!=null&&(u.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?n.base64.decode(t.rawData,u.rawData=n.newBuffer(n.base64.length(t.rawData)),0):t.rawData.length>=0&&(u.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");u.externalData=[];for(var l=0;l<t.externalData.length;++l){if(typeof t.externalData[l]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");u.externalData[l]=a.onnx.StringStringEntryProto.fromObject(t.externalData[l])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){u.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:u.dataLocation=0;break;case"EXTERNAL":case 1:u.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");u.doubleData=[];for(var l=0;l<t.doubleData.length;++l)u.doubleData[l]=Number(t.doubleData[l])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");u.uint64Data=[];for(var l=0;l<t.uint64Data.length;++l)n.Long?(u.uint64Data[l]=n.Long.fromValue(t.uint64Data[l])).unsigned=!0:typeof t.uint64Data[l]=="string"?u.uint64Data[l]=parseInt(t.uint64Data[l],10):typeof t.uint64Data[l]=="number"?u.uint64Data[l]=t.uint64Data[l]:typeof t.uint64Data[l]=="object"&&(u.uint64Data[l]=new n.LongBits(t.uint64Data[l].low>>>0,t.uint64Data[l].high>>>0).toNumber(!0))}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.dims=[],l.floatData=[],l.int32Data=[],l.stringData=[],l.int64Data=[],l.doubleData=[],l.uint64Data=[],l.externalData=[]),u.defaults&&(l.dataType=0,l.segment=null,l.name="",u.bytes===String?l.rawData="":(l.rawData=[],u.bytes!==Array&&(l.rawData=n.newBuffer(l.rawData))),l.docString="",l.dataLocation=u.enums===String?"DEFAULT":0),t.dims&&t.dims.length){l.dims=[];for(var f=0;f<t.dims.length;++f)typeof t.dims[f]=="number"?l.dims[f]=u.longs===String?String(t.dims[f]):t.dims[f]:l.dims[f]=u.longs===String?n.Long.prototype.toString.call(t.dims[f]):u.longs===Number?new n.LongBits(t.dims[f].low>>>0,t.dims[f].high>>>0).toNumber():t.dims[f]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(l.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(l.segment=a.onnx.TensorProto.Segment.toObject(t.segment,u)),t.floatData&&t.floatData.length){l.floatData=[];for(var f=0;f<t.floatData.length;++f)l.floatData[f]=u.json&&!isFinite(t.floatData[f])?String(t.floatData[f]):t.floatData[f]}if(t.int32Data&&t.int32Data.length){l.int32Data=[];for(var f=0;f<t.int32Data.length;++f)l.int32Data[f]=t.int32Data[f]}if(t.stringData&&t.stringData.length){l.stringData=[];for(var f=0;f<t.stringData.length;++f)l.stringData[f]=u.bytes===String?n.base64.encode(t.stringData[f],0,t.stringData[f].length):u.bytes===Array?Array.prototype.slice.call(t.stringData[f]):t.stringData[f]}if(t.int64Data&&t.int64Data.length){l.int64Data=[];for(var f=0;f<t.int64Data.length;++f)typeof t.int64Data[f]=="number"?l.int64Data[f]=u.longs===String?String(t.int64Data[f]):t.int64Data[f]:l.int64Data[f]=u.longs===String?n.Long.prototype.toString.call(t.int64Data[f]):u.longs===Number?new n.LongBits(t.int64Data[f].low>>>0,t.int64Data[f].high>>>0).toNumber():t.int64Data[f]}if(t.name!=null&&t.hasOwnProperty("name")&&(l.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(l.rawData=u.bytes===String?n.base64.encode(t.rawData,0,t.rawData.length):u.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){l.doubleData=[];for(var f=0;f<t.doubleData.length;++f)l.doubleData[f]=u.json&&!isFinite(t.doubleData[f])?String(t.doubleData[f]):t.doubleData[f]}if(t.uint64Data&&t.uint64Data.length){l.uint64Data=[];for(var f=0;f<t.uint64Data.length;++f)typeof t.uint64Data[f]=="number"?l.uint64Data[f]=u.longs===String?String(t.uint64Data[f]):t.uint64Data[f]:l.uint64Data[f]=u.longs===String?n.Long.prototype.toString.call(t.uint64Data[f]):u.longs===Number?new n.LongBits(t.uint64Data[f].low>>>0,t.uint64Data[f].high>>>0).toNumber(!0):t.uint64Data[f]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),t.externalData&&t.externalData.length){l.externalData=[];for(var f=0;f<t.externalData.length;++f)l.externalData[f]=a.onnx.StringStringEntryProto.toObject(t.externalData[f],u)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(l.dataLocation=u.enums===String?a.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:a.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},p.DataType=function(){var t={},u=Object.create(t);return u[t[0]="UNDEFINED"]=0,u[t[1]="FLOAT"]=1,u[t[2]="UINT8"]=2,u[t[3]="INT8"]=3,u[t[4]="UINT16"]=4,u[t[5]="INT16"]=5,u[t[6]="INT32"]=6,u[t[7]="INT64"]=7,u[t[8]="STRING"]=8,u[t[9]="BOOL"]=9,u[t[10]="FLOAT16"]=10,u[t[11]="DOUBLE"]=11,u[t[12]="UINT32"]=12,u[t[13]="UINT64"]=13,u[t[14]="COMPLEX64"]=14,u[t[15]="COMPLEX128"]=15,u[t[16]="BFLOAT16"]=16,u[t[17]="FLOAT8E4M3FN"]=17,u[t[18]="FLOAT8E4M3FNUZ"]=18,u[t[19]="FLOAT8E5M2"]=19,u[t[20]="FLOAT8E5M2FNUZ"]=20,u}(),p.Segment=function(){function t(u){if(u)for(var l=Object.keys(u),f=0;f<l.length;++f)u[l[f]]!=null&&(this[l[f]]=u[l[f]])}return t.prototype.begin=n.Long?n.Long.fromBits(0,0,!1):0,t.prototype.end=n.Long?n.Long.fromBits(0,0,!1):0,t.create=function(u){return new t(u)},t.encode=function(u,l){return l||(l=c.create()),u.begin!=null&&Object.hasOwnProperty.call(u,"begin")&&l.uint32(8).int64(u.begin),u.end!=null&&Object.hasOwnProperty.call(u,"end")&&l.uint32(16).int64(u.end),l},t.encodeDelimited=function(u,l){return this.encode(u,l).ldelim()},t.decode=function(u,l){u instanceof s||(u=s.create(u));for(var f=l===void 0?u.len:u.pos+l,x=new a.onnx.TensorProto.Segment;u.pos<f;){var I=u.uint32();switch(I>>>3){case 1:{x.begin=u.int64();break}case 2:{x.end=u.int64();break}default:u.skipType(I&7);break}}return x},t.decodeDelimited=function(u){return u instanceof s||(u=new s(u)),this.decode(u,u.uint32())},t.verify=function(u){return typeof u!="object"||u===null?"object expected":u.begin!=null&&u.hasOwnProperty("begin")&&!n.isInteger(u.begin)&&!(u.begin&&n.isInteger(u.begin.low)&&n.isInteger(u.begin.high))?"begin: integer|Long expected":u.end!=null&&u.hasOwnProperty("end")&&!n.isInteger(u.end)&&!(u.end&&n.isInteger(u.end.low)&&n.isInteger(u.end.high))?"end: integer|Long expected":null},t.fromObject=function(u){if(u instanceof a.onnx.TensorProto.Segment)return u;var l=new a.onnx.TensorProto.Segment;return u.begin!=null&&(n.Long?(l.begin=n.Long.fromValue(u.begin)).unsigned=!1:typeof u.begin=="string"?l.begin=parseInt(u.begin,10):typeof u.begin=="number"?l.begin=u.begin:typeof u.begin=="object"&&(l.begin=new n.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber())),u.end!=null&&(n.Long?(l.end=n.Long.fromValue(u.end)).unsigned=!1:typeof u.end=="string"?l.end=parseInt(u.end,10):typeof u.end=="number"?l.end=u.end:typeof u.end=="object"&&(l.end=new n.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber())),l},t.toObject=function(u,l){l||(l={});var f={};if(l.defaults){if(n.Long){var x=new n.Long(0,0,!1);f.begin=l.longs===String?x.toString():l.longs===Number?x.toNumber():x}else f.begin=l.longs===String?"0":0;if(n.Long){var x=new n.Long(0,0,!1);f.end=l.longs===String?x.toString():l.longs===Number?x.toNumber():x}else f.end=l.longs===String?"0":0}return u.begin!=null&&u.hasOwnProperty("begin")&&(typeof u.begin=="number"?f.begin=l.longs===String?String(u.begin):u.begin:f.begin=l.longs===String?n.Long.prototype.toString.call(u.begin):l.longs===Number?new n.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber():u.begin),u.end!=null&&u.hasOwnProperty("end")&&(typeof u.end=="number"?f.end=l.longs===String?String(u.end):u.end:f.end=l.longs===String?n.Long.prototype.toString.call(u.end):l.longs===Number?new n.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber():u.end),f},t.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},t.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TensorProto.Segment"},t}(),p.DataLocation=function(){var t={},u=Object.create(t);return u[t[0]="DEFAULT"]=0,u[t[1]="EXTERNAL"]=1,u}(),p}(),h.SparseTensorProto=function(){function p(t){if(this.dims=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.values=null,p.prototype.indices=null,p.prototype.dims=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&a.onnx.TensorProto.encode(t.values,u.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&a.onnx.TensorProto.encode(t.indices,u.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){u.uint32(26).fork();for(var l=0;l<t.dims.length;++l)u.int64(t.dims[l]);u.ldelim()}return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.SparseTensorProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.values=a.onnx.TensorProto.decode(t,t.uint32());break}case 2:{f.indices=a.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(f.dims&&f.dims.length||(f.dims=[]),(x&7)===2)for(var I=t.uint32()+t.pos;t.pos<I;)f.dims.push(t.int64());else f.dims.push(t.int64());break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var u=a.onnx.TensorProto.verify(t.values);if(u)return"values."+u}if(t.indices!=null&&t.hasOwnProperty("indices")){var u=a.onnx.TensorProto.verify(t.indices);if(u)return"indices."+u}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var l=0;l<t.dims.length;++l)if(!n.isInteger(t.dims[l])&&!(t.dims[l]&&n.isInteger(t.dims[l].low)&&n.isInteger(t.dims[l].high)))return"dims: integer|Long[] expected"}return null},p.fromObject=function(t){if(t instanceof a.onnx.SparseTensorProto)return t;var u=new a.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");u.values=a.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");u.indices=a.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");u.dims=[];for(var l=0;l<t.dims.length;++l)n.Long?(u.dims[l]=n.Long.fromValue(t.dims[l])).unsigned=!1:typeof t.dims[l]=="string"?u.dims[l]=parseInt(t.dims[l],10):typeof t.dims[l]=="number"?u.dims[l]=t.dims[l]:typeof t.dims[l]=="object"&&(u.dims[l]=new n.LongBits(t.dims[l].low>>>0,t.dims[l].high>>>0).toNumber())}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.dims=[]),u.defaults&&(l.values=null,l.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(l.values=a.onnx.TensorProto.toObject(t.values,u)),t.indices!=null&&t.hasOwnProperty("indices")&&(l.indices=a.onnx.TensorProto.toObject(t.indices,u)),t.dims&&t.dims.length){l.dims=[];for(var f=0;f<t.dims.length;++f)typeof t.dims[f]=="number"?l.dims[f]=u.longs===String?String(t.dims[f]):t.dims[f]:l.dims[f]=u.longs===String?n.Long.prototype.toString.call(t.dims[f]):u.longs===Number?new n.LongBits(t.dims[f].low>>>0,t.dims[f].high>>>0).toNumber():t.dims[f]}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},p}(),h.TensorShapeProto=function(){function p(t){if(this.dim=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.dim=n.emptyArray,p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.dim!=null&&t.dim.length)for(var l=0;l<t.dim.length;++l)a.onnx.TensorShapeProto.Dimension.encode(t.dim[l],u.uint32(10).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.TensorShapeProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.dim&&f.dim.length||(f.dim=[]),f.dim.push(a.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var u=0;u<t.dim.length;++u){var l=a.onnx.TensorShapeProto.Dimension.verify(t.dim[u]);if(l)return"dim."+l}}return null},p.fromObject=function(t){if(t instanceof a.onnx.TensorShapeProto)return t;var u=new a.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");u.dim=[];for(var l=0;l<t.dim.length;++l){if(typeof t.dim[l]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");u.dim[l]=a.onnx.TensorShapeProto.Dimension.fromObject(t.dim[l])}}return u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.dim=[]),t.dim&&t.dim.length){l.dim=[];for(var f=0;f<t.dim.length;++f)l.dim[f]=a.onnx.TensorShapeProto.Dimension.toObject(t.dim[f],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},p.Dimension=function(){function t(l){if(l)for(var f=Object.keys(l),x=0;x<f.length;++x)l[f[x]]!=null&&(this[f[x]]=l[f[x]])}t.prototype.dimValue=null,t.prototype.dimParam=null,t.prototype.denotation="";var u;return Object.defineProperty(t.prototype,"value",{get:n.oneOfGetter(u=["dimValue","dimParam"]),set:n.oneOfSetter(u)}),t.create=function(l){return new t(l)},t.encode=function(l,f){return f||(f=c.create()),l.dimValue!=null&&Object.hasOwnProperty.call(l,"dimValue")&&f.uint32(8).int64(l.dimValue),l.dimParam!=null&&Object.hasOwnProperty.call(l,"dimParam")&&f.uint32(18).string(l.dimParam),l.denotation!=null&&Object.hasOwnProperty.call(l,"denotation")&&f.uint32(26).string(l.denotation),f},t.encodeDelimited=function(l,f){return this.encode(l,f).ldelim()},t.decode=function(l,f){l instanceof s||(l=s.create(l));for(var x=f===void 0?l.len:l.pos+f,I=new a.onnx.TensorShapeProto.Dimension;l.pos<x;){var R=l.uint32();switch(R>>>3){case 1:{I.dimValue=l.int64();break}case 2:{I.dimParam=l.string();break}case 3:{I.denotation=l.string();break}default:l.skipType(R&7);break}}return I},t.decodeDelimited=function(l){return l instanceof s||(l=new s(l)),this.decode(l,l.uint32())},t.verify=function(l){if(typeof l!="object"||l===null)return"object expected";var f={};if(l.dimValue!=null&&l.hasOwnProperty("dimValue")&&(f.value=1,!n.isInteger(l.dimValue)&&!(l.dimValue&&n.isInteger(l.dimValue.low)&&n.isInteger(l.dimValue.high))))return"dimValue: integer|Long expected";if(l.dimParam!=null&&l.hasOwnProperty("dimParam")){if(f.value===1)return"value: multiple values";if(f.value=1,!n.isString(l.dimParam))return"dimParam: string expected"}return l.denotation!=null&&l.hasOwnProperty("denotation")&&!n.isString(l.denotation)?"denotation: string expected":null},t.fromObject=function(l){if(l instanceof a.onnx.TensorShapeProto.Dimension)return l;var f=new a.onnx.TensorShapeProto.Dimension;return l.dimValue!=null&&(n.Long?(f.dimValue=n.Long.fromValue(l.dimValue)).unsigned=!1:typeof l.dimValue=="string"?f.dimValue=parseInt(l.dimValue,10):typeof l.dimValue=="number"?f.dimValue=l.dimValue:typeof l.dimValue=="object"&&(f.dimValue=new n.LongBits(l.dimValue.low>>>0,l.dimValue.high>>>0).toNumber())),l.dimParam!=null&&(f.dimParam=String(l.dimParam)),l.denotation!=null&&(f.denotation=String(l.denotation)),f},t.toObject=function(l,f){f||(f={});var x={};return f.defaults&&(x.denotation=""),l.dimValue!=null&&l.hasOwnProperty("dimValue")&&(typeof l.dimValue=="number"?x.dimValue=f.longs===String?String(l.dimValue):l.dimValue:x.dimValue=f.longs===String?n.Long.prototype.toString.call(l.dimValue):f.longs===Number?new n.LongBits(l.dimValue.low>>>0,l.dimValue.high>>>0).toNumber():l.dimValue,f.oneofs&&(x.value="dimValue")),l.dimParam!=null&&l.hasOwnProperty("dimParam")&&(x.dimParam=l.dimParam,f.oneofs&&(x.value="dimParam")),l.denotation!=null&&l.hasOwnProperty("denotation")&&(x.denotation=l.denotation),x},t.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},t.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TensorShapeProto.Dimension"},t}(),p}(),h.TypeProto=function(){function p(u){if(u)for(var l=Object.keys(u),f=0;f<l.length;++f)u[l[f]]!=null&&(this[l[f]]=u[l[f]])}p.prototype.tensorType=null,p.prototype.sequenceType=null,p.prototype.mapType=null,p.prototype.optionalType=null,p.prototype.sparseTensorType=null,p.prototype.denotation="";var t;return Object.defineProperty(p.prototype,"value",{get:n.oneOfGetter(t=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:n.oneOfSetter(t)}),p.create=function(u){return new p(u)},p.encode=function(u,l){return l||(l=c.create()),u.tensorType!=null&&Object.hasOwnProperty.call(u,"tensorType")&&a.onnx.TypeProto.Tensor.encode(u.tensorType,l.uint32(10).fork()).ldelim(),u.sequenceType!=null&&Object.hasOwnProperty.call(u,"sequenceType")&&a.onnx.TypeProto.Sequence.encode(u.sequenceType,l.uint32(34).fork()).ldelim(),u.mapType!=null&&Object.hasOwnProperty.call(u,"mapType")&&a.onnx.TypeProto.Map.encode(u.mapType,l.uint32(42).fork()).ldelim(),u.denotation!=null&&Object.hasOwnProperty.call(u,"denotation")&&l.uint32(50).string(u.denotation),u.sparseTensorType!=null&&Object.hasOwnProperty.call(u,"sparseTensorType")&&a.onnx.TypeProto.SparseTensor.encode(u.sparseTensorType,l.uint32(66).fork()).ldelim(),u.optionalType!=null&&Object.hasOwnProperty.call(u,"optionalType")&&a.onnx.TypeProto.Optional.encode(u.optionalType,l.uint32(74).fork()).ldelim(),l},p.encodeDelimited=function(u,l){return this.encode(u,l).ldelim()},p.decode=function(u,l){u instanceof s||(u=s.create(u));for(var f=l===void 0?u.len:u.pos+l,x=new a.onnx.TypeProto;u.pos<f;){var I=u.uint32();switch(I>>>3){case 1:{x.tensorType=a.onnx.TypeProto.Tensor.decode(u,u.uint32());break}case 4:{x.sequenceType=a.onnx.TypeProto.Sequence.decode(u,u.uint32());break}case 5:{x.mapType=a.onnx.TypeProto.Map.decode(u,u.uint32());break}case 9:{x.optionalType=a.onnx.TypeProto.Optional.decode(u,u.uint32());break}case 8:{x.sparseTensorType=a.onnx.TypeProto.SparseTensor.decode(u,u.uint32());break}case 6:{x.denotation=u.string();break}default:u.skipType(I&7);break}}return x},p.decodeDelimited=function(u){return u instanceof s||(u=new s(u)),this.decode(u,u.uint32())},p.verify=function(u){if(typeof u!="object"||u===null)return"object expected";var l={};if(u.tensorType!=null&&u.hasOwnProperty("tensorType")){l.value=1;{var f=a.onnx.TypeProto.Tensor.verify(u.tensorType);if(f)return"tensorType."+f}}if(u.sequenceType!=null&&u.hasOwnProperty("sequenceType")){if(l.value===1)return"value: multiple values";l.value=1;{var f=a.onnx.TypeProto.Sequence.verify(u.sequenceType);if(f)return"sequenceType."+f}}if(u.mapType!=null&&u.hasOwnProperty("mapType")){if(l.value===1)return"value: multiple values";l.value=1;{var f=a.onnx.TypeProto.Map.verify(u.mapType);if(f)return"mapType."+f}}if(u.optionalType!=null&&u.hasOwnProperty("optionalType")){if(l.value===1)return"value: multiple values";l.value=1;{var f=a.onnx.TypeProto.Optional.verify(u.optionalType);if(f)return"optionalType."+f}}if(u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")){if(l.value===1)return"value: multiple values";l.value=1;{var f=a.onnx.TypeProto.SparseTensor.verify(u.sparseTensorType);if(f)return"sparseTensorType."+f}}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!n.isString(u.denotation)?"denotation: string expected":null},p.fromObject=function(u){if(u instanceof a.onnx.TypeProto)return u;var l=new a.onnx.TypeProto;if(u.tensorType!=null){if(typeof u.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");l.tensorType=a.onnx.TypeProto.Tensor.fromObject(u.tensorType)}if(u.sequenceType!=null){if(typeof u.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");l.sequenceType=a.onnx.TypeProto.Sequence.fromObject(u.sequenceType)}if(u.mapType!=null){if(typeof u.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");l.mapType=a.onnx.TypeProto.Map.fromObject(u.mapType)}if(u.optionalType!=null){if(typeof u.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");l.optionalType=a.onnx.TypeProto.Optional.fromObject(u.optionalType)}if(u.sparseTensorType!=null){if(typeof u.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");l.sparseTensorType=a.onnx.TypeProto.SparseTensor.fromObject(u.sparseTensorType)}return u.denotation!=null&&(l.denotation=String(u.denotation)),l},p.toObject=function(u,l){l||(l={});var f={};return l.defaults&&(f.denotation=""),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&(f.tensorType=a.onnx.TypeProto.Tensor.toObject(u.tensorType,l),l.oneofs&&(f.value="tensorType")),u.sequenceType!=null&&u.hasOwnProperty("sequenceType")&&(f.sequenceType=a.onnx.TypeProto.Sequence.toObject(u.sequenceType,l),l.oneofs&&(f.value="sequenceType")),u.mapType!=null&&u.hasOwnProperty("mapType")&&(f.mapType=a.onnx.TypeProto.Map.toObject(u.mapType,l),l.oneofs&&(f.value="mapType")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(f.denotation=u.denotation),u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")&&(f.sparseTensorType=a.onnx.TypeProto.SparseTensor.toObject(u.sparseTensorType,l),l.oneofs&&(f.value="sparseTensorType")),u.optionalType!=null&&u.hasOwnProperty("optionalType")&&(f.optionalType=a.onnx.TypeProto.Optional.toObject(u.optionalType,l),l.oneofs&&(f.value="optionalType")),f},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TypeProto"},p.Tensor=function(){function u(l){if(l)for(var f=Object.keys(l),x=0;x<f.length;++x)l[f[x]]!=null&&(this[f[x]]=l[f[x]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(l){return new u(l)},u.encode=function(l,f){return f||(f=c.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&f.uint32(8).int32(l.elemType),l.shape!=null&&Object.hasOwnProperty.call(l,"shape")&&a.onnx.TensorShapeProto.encode(l.shape,f.uint32(18).fork()).ldelim(),f},u.encodeDelimited=function(l,f){return this.encode(l,f).ldelim()},u.decode=function(l,f){l instanceof s||(l=s.create(l));for(var x=f===void 0?l.len:l.pos+f,I=new a.onnx.TypeProto.Tensor;l.pos<x;){var R=l.uint32();switch(R>>>3){case 1:{I.elemType=l.int32();break}case 2:{I.shape=a.onnx.TensorShapeProto.decode(l,l.uint32());break}default:l.skipType(R&7);break}}return I},u.decodeDelimited=function(l){return l instanceof s||(l=new s(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")&&!n.isInteger(l.elemType))return"elemType: integer expected";if(l.shape!=null&&l.hasOwnProperty("shape")){var f=a.onnx.TensorShapeProto.verify(l.shape);if(f)return"shape."+f}return null},u.fromObject=function(l){if(l instanceof a.onnx.TypeProto.Tensor)return l;var f=new a.onnx.TypeProto.Tensor;if(l.elemType!=null&&(f.elemType=l.elemType|0),l.shape!=null){if(typeof l.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");f.shape=a.onnx.TensorShapeProto.fromObject(l.shape)}return f},u.toObject=function(l,f){f||(f={});var x={};return f.defaults&&(x.elemType=0,x.shape=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(x.elemType=l.elemType),l.shape!=null&&l.hasOwnProperty("shape")&&(x.shape=a.onnx.TensorShapeProto.toObject(l.shape,f)),x},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Tensor"},u}(),p.Sequence=function(){function u(l){if(l)for(var f=Object.keys(l),x=0;x<f.length;++x)l[f[x]]!=null&&(this[f[x]]=l[f[x]])}return u.prototype.elemType=null,u.create=function(l){return new u(l)},u.encode=function(l,f){return f||(f=c.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&a.onnx.TypeProto.encode(l.elemType,f.uint32(10).fork()).ldelim(),f},u.encodeDelimited=function(l,f){return this.encode(l,f).ldelim()},u.decode=function(l,f){l instanceof s||(l=s.create(l));for(var x=f===void 0?l.len:l.pos+f,I=new a.onnx.TypeProto.Sequence;l.pos<x;){var R=l.uint32();switch(R>>>3){case 1:{I.elemType=a.onnx.TypeProto.decode(l,l.uint32());break}default:l.skipType(R&7);break}}return I},u.decodeDelimited=function(l){return l instanceof s||(l=new s(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")){var f=a.onnx.TypeProto.verify(l.elemType);if(f)return"elemType."+f}return null},u.fromObject=function(l){if(l instanceof a.onnx.TypeProto.Sequence)return l;var f=new a.onnx.TypeProto.Sequence;if(l.elemType!=null){if(typeof l.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");f.elemType=a.onnx.TypeProto.fromObject(l.elemType)}return f},u.toObject=function(l,f){f||(f={});var x={};return f.defaults&&(x.elemType=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(x.elemType=a.onnx.TypeProto.toObject(l.elemType,f)),x},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Sequence"},u}(),p.Map=function(){function u(l){if(l)for(var f=Object.keys(l),x=0;x<f.length;++x)l[f[x]]!=null&&(this[f[x]]=l[f[x]])}return u.prototype.keyType=0,u.prototype.valueType=null,u.create=function(l){return new u(l)},u.encode=function(l,f){return f||(f=c.create()),l.keyType!=null&&Object.hasOwnProperty.call(l,"keyType")&&f.uint32(8).int32(l.keyType),l.valueType!=null&&Object.hasOwnProperty.call(l,"valueType")&&a.onnx.TypeProto.encode(l.valueType,f.uint32(18).fork()).ldelim(),f},u.encodeDelimited=function(l,f){return this.encode(l,f).ldelim()},u.decode=function(l,f){l instanceof s||(l=s.create(l));for(var x=f===void 0?l.len:l.pos+f,I=new a.onnx.TypeProto.Map;l.pos<x;){var R=l.uint32();switch(R>>>3){case 1:{I.keyType=l.int32();break}case 2:{I.valueType=a.onnx.TypeProto.decode(l,l.uint32());break}default:l.skipType(R&7);break}}return I},u.decodeDelimited=function(l){return l instanceof s||(l=new s(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.keyType!=null&&l.hasOwnProperty("keyType")&&!n.isInteger(l.keyType))return"keyType: integer expected";if(l.valueType!=null&&l.hasOwnProperty("valueType")){var f=a.onnx.TypeProto.verify(l.valueType);if(f)return"valueType."+f}return null},u.fromObject=function(l){if(l instanceof a.onnx.TypeProto.Map)return l;var f=new a.onnx.TypeProto.Map;if(l.keyType!=null&&(f.keyType=l.keyType|0),l.valueType!=null){if(typeof l.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");f.valueType=a.onnx.TypeProto.fromObject(l.valueType)}return f},u.toObject=function(l,f){f||(f={});var x={};return f.defaults&&(x.keyType=0,x.valueType=null),l.keyType!=null&&l.hasOwnProperty("keyType")&&(x.keyType=l.keyType),l.valueType!=null&&l.hasOwnProperty("valueType")&&(x.valueType=a.onnx.TypeProto.toObject(l.valueType,f)),x},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Map"},u}(),p.Optional=function(){function u(l){if(l)for(var f=Object.keys(l),x=0;x<f.length;++x)l[f[x]]!=null&&(this[f[x]]=l[f[x]])}return u.prototype.elemType=null,u.create=function(l){return new u(l)},u.encode=function(l,f){return f||(f=c.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&a.onnx.TypeProto.encode(l.elemType,f.uint32(10).fork()).ldelim(),f},u.encodeDelimited=function(l,f){return this.encode(l,f).ldelim()},u.decode=function(l,f){l instanceof s||(l=s.create(l));for(var x=f===void 0?l.len:l.pos+f,I=new a.onnx.TypeProto.Optional;l.pos<x;){var R=l.uint32();switch(R>>>3){case 1:{I.elemType=a.onnx.TypeProto.decode(l,l.uint32());break}default:l.skipType(R&7);break}}return I},u.decodeDelimited=function(l){return l instanceof s||(l=new s(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")){var f=a.onnx.TypeProto.verify(l.elemType);if(f)return"elemType."+f}return null},u.fromObject=function(l){if(l instanceof a.onnx.TypeProto.Optional)return l;var f=new a.onnx.TypeProto.Optional;if(l.elemType!=null){if(typeof l.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");f.elemType=a.onnx.TypeProto.fromObject(l.elemType)}return f},u.toObject=function(l,f){f||(f={});var x={};return f.defaults&&(x.elemType=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(x.elemType=a.onnx.TypeProto.toObject(l.elemType,f)),x},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Optional"},u}(),p.SparseTensor=function(){function u(l){if(l)for(var f=Object.keys(l),x=0;x<f.length;++x)l[f[x]]!=null&&(this[f[x]]=l[f[x]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(l){return new u(l)},u.encode=function(l,f){return f||(f=c.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&f.uint32(8).int32(l.elemType),l.shape!=null&&Object.hasOwnProperty.call(l,"shape")&&a.onnx.TensorShapeProto.encode(l.shape,f.uint32(18).fork()).ldelim(),f},u.encodeDelimited=function(l,f){return this.encode(l,f).ldelim()},u.decode=function(l,f){l instanceof s||(l=s.create(l));for(var x=f===void 0?l.len:l.pos+f,I=new a.onnx.TypeProto.SparseTensor;l.pos<x;){var R=l.uint32();switch(R>>>3){case 1:{I.elemType=l.int32();break}case 2:{I.shape=a.onnx.TensorShapeProto.decode(l,l.uint32());break}default:l.skipType(R&7);break}}return I},u.decodeDelimited=function(l){return l instanceof s||(l=new s(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")&&!n.isInteger(l.elemType))return"elemType: integer expected";if(l.shape!=null&&l.hasOwnProperty("shape")){var f=a.onnx.TensorShapeProto.verify(l.shape);if(f)return"shape."+f}return null},u.fromObject=function(l){if(l instanceof a.onnx.TypeProto.SparseTensor)return l;var f=new a.onnx.TypeProto.SparseTensor;if(l.elemType!=null&&(f.elemType=l.elemType|0),l.shape!=null){if(typeof l.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");f.shape=a.onnx.TensorShapeProto.fromObject(l.shape)}return f},u.toObject=function(l,f){f||(f={});var x={};return f.defaults&&(x.elemType=0,x.shape=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(x.elemType=l.elemType),l.shape!=null&&l.hasOwnProperty("shape")&&(x.shape=a.onnx.TensorShapeProto.toObject(l.shape,f)),x},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.SparseTensor"},u}(),p}(),h.OperatorSetIdProto=function(){function p(t){if(t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.domain="",p.prototype.version=n.Long?n.Long.fromBits(0,0,!1):0,p.create=function(t){return new p(t)},p.encode=function(t,u){return u||(u=c.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&u.uint32(16).int64(t.version),u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.OperatorSetIdProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.domain=t.string();break}case 2:{f.version=t.int64();break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!n.isInteger(t.version)&&!(t.version&&n.isInteger(t.version.low)&&n.isInteger(t.version.high))?"version: integer|Long expected":null},p.fromObject=function(t){if(t instanceof a.onnx.OperatorSetIdProto)return t;var u=new a.onnx.OperatorSetIdProto;return t.domain!=null&&(u.domain=String(t.domain)),t.version!=null&&(n.Long?(u.version=n.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?u.version=parseInt(t.version,10):typeof t.version=="number"?u.version=t.version:typeof t.version=="object"&&(u.version=new n.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),u},p.toObject=function(t,u){u||(u={});var l={};if(u.defaults)if(l.domain="",n.Long){var f=new n.Long(0,0,!1);l.version=u.longs===String?f.toString():u.longs===Number?f.toNumber():f}else l.version=u.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(l.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?l.version=u.longs===String?String(t.version):t.version:l.version=u.longs===String?n.Long.prototype.toString.call(t.version):u.longs===Number?new n.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},p}(),h.OperatorStatus=function(){var p={},t=Object.create(p);return t[p[0]="EXPERIMENTAL"]=0,t[p[1]="STABLE"]=1,t}(),h.FunctionProto=function(){function p(t){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],t)for(var u=Object.keys(t),l=0;l<u.length;++l)t[u[l]]!=null&&(this[u[l]]=t[u[l]])}return p.prototype.name="",p.prototype.input=n.emptyArray,p.prototype.output=n.emptyArray,p.prototype.attribute=n.emptyArray,p.prototype.attributeProto=n.emptyArray,p.prototype.node=n.emptyArray,p.prototype.docString="",p.prototype.opsetImport=n.emptyArray,p.prototype.domain="",p.create=function(t){return new p(t)},p.encode=function(t,u){if(u||(u=c.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&u.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var l=0;l<t.input.length;++l)u.uint32(34).string(t.input[l]);if(t.output!=null&&t.output.length)for(var l=0;l<t.output.length;++l)u.uint32(42).string(t.output[l]);if(t.attribute!=null&&t.attribute.length)for(var l=0;l<t.attribute.length;++l)u.uint32(50).string(t.attribute[l]);if(t.node!=null&&t.node.length)for(var l=0;l<t.node.length;++l)a.onnx.NodeProto.encode(t.node[l],u.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&u.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var l=0;l<t.opsetImport.length;++l)a.onnx.OperatorSetIdProto.encode(t.opsetImport[l],u.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&u.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var l=0;l<t.attributeProto.length;++l)a.onnx.AttributeProto.encode(t.attributeProto[l],u.uint32(90).fork()).ldelim();return u},p.encodeDelimited=function(t,u){return this.encode(t,u).ldelim()},p.decode=function(t,u){t instanceof s||(t=s.create(t));for(var l=u===void 0?t.len:t.pos+u,f=new a.onnx.FunctionProto;t.pos<l;){var x=t.uint32();switch(x>>>3){case 1:{f.name=t.string();break}case 4:{f.input&&f.input.length||(f.input=[]),f.input.push(t.string());break}case 5:{f.output&&f.output.length||(f.output=[]),f.output.push(t.string());break}case 6:{f.attribute&&f.attribute.length||(f.attribute=[]),f.attribute.push(t.string());break}case 11:{f.attributeProto&&f.attributeProto.length||(f.attributeProto=[]),f.attributeProto.push(a.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{f.node&&f.node.length||(f.node=[]),f.node.push(a.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{f.docString=t.string();break}case 9:{f.opsetImport&&f.opsetImport.length||(f.opsetImport=[]),f.opsetImport.push(a.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{f.domain=t.string();break}default:t.skipType(x&7);break}}return f},p.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},p.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var u=0;u<t.input.length;++u)if(!n.isString(t.input[u]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var u=0;u<t.output.length;++u)if(!n.isString(t.output[u]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var u=0;u<t.attribute.length;++u)if(!n.isString(t.attribute[u]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var u=0;u<t.attributeProto.length;++u){var l=a.onnx.AttributeProto.verify(t.attributeProto[u]);if(l)return"attributeProto."+l}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var u=0;u<t.node.length;++u){var l=a.onnx.NodeProto.verify(t.node[u]);if(l)return"node."+l}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var u=0;u<t.opsetImport.length;++u){var l=a.onnx.OperatorSetIdProto.verify(t.opsetImport[u]);if(l)return"opsetImport."+l}}return t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain)?"domain: string expected":null},p.fromObject=function(t){if(t instanceof a.onnx.FunctionProto)return t;var u=new a.onnx.FunctionProto;if(t.name!=null&&(u.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");u.input=[];for(var l=0;l<t.input.length;++l)u.input[l]=String(t.input[l])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");u.output=[];for(var l=0;l<t.output.length;++l)u.output[l]=String(t.output[l])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");u.attribute=[];for(var l=0;l<t.attribute.length;++l)u.attribute[l]=String(t.attribute[l])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");u.attributeProto=[];for(var l=0;l<t.attributeProto.length;++l){if(typeof t.attributeProto[l]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");u.attributeProto[l]=a.onnx.AttributeProto.fromObject(t.attributeProto[l])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");u.node=[];for(var l=0;l<t.node.length;++l){if(typeof t.node[l]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");u.node[l]=a.onnx.NodeProto.fromObject(t.node[l])}}if(t.docString!=null&&(u.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");u.opsetImport=[];for(var l=0;l<t.opsetImport.length;++l){if(typeof t.opsetImport[l]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");u.opsetImport[l]=a.onnx.OperatorSetIdProto.fromObject(t.opsetImport[l])}}return t.domain!=null&&(u.domain=String(t.domain)),u},p.toObject=function(t,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.input=[],l.output=[],l.attribute=[],l.node=[],l.opsetImport=[],l.attributeProto=[]),u.defaults&&(l.name="",l.docString="",l.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(l.name=t.name),t.input&&t.input.length){l.input=[];for(var f=0;f<t.input.length;++f)l.input[f]=t.input[f]}if(t.output&&t.output.length){l.output=[];for(var f=0;f<t.output.length;++f)l.output[f]=t.output[f]}if(t.attribute&&t.attribute.length){l.attribute=[];for(var f=0;f<t.attribute.length;++f)l.attribute[f]=t.attribute[f]}if(t.node&&t.node.length){l.node=[];for(var f=0;f<t.node.length;++f)l.node[f]=a.onnx.NodeProto.toObject(t.node[f],u)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(l.docString=t.docString),t.opsetImport&&t.opsetImport.length){l.opsetImport=[];for(var f=0;f<t.opsetImport.length;++f)l.opsetImport[f]=a.onnx.OperatorSetIdProto.toObject(t.opsetImport[f],u)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(l.domain=t.domain),t.attributeProto&&t.attributeProto.length){l.attributeProto=[];for(var f=0;f<t.attributeProto.length;++f)l.attributeProto[f]=a.onnx.AttributeProto.toObject(t.attributeProto[f],u)}return l},p.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},p.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},p}(),h}(),r.exports=a});function ur(e,r){if(!e)throw new Error(typeof r=="string"?r:r())}function kr(e){return new TextDecoder().decode(e)}var ot,Me,ai,kt,Sn,At,Rt,B,$r,Ue,Ve,ze,Y=O(()=>{wn(),qo(),ot=rr(sr()),We(),Me=class{static arraysEqual(e,r){if(e.length!==r.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==r[i])return!1;return!0}},ai=class{static preprocessInputShapes(e,r){let i=e.length===1?[1,e[0]]:e,s=r.length===1?[r[0],1]:r;return[i,s]}static postprocessOutputShape(e,r,i){r===1&&e.splice(e.length-2,1),i===1&&e.pop()}static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},kt=class zv{static calcShape(r,i,s=!1){let c=r.length,n=i.length;if(c===0)return i;if(n===0)return r;let a=Math.max(r.length,i.length),h=new Array(a);if(s){if(c<2||n<2)return;let p=ai.calcMatMulShape([r[c-2],r[c-1]],[i[n-2],i[n-1]]);if(p===void 0)return;[h[a-2],h[a-1]]=p}for(let p=s?3:1;p<=a;p++){let t=c-p<0?1:r[c-p],u=n-p<0?1:i[n-p];if(t!==u&&t>1&&u>1)return;h[a-p]=Math.max(t,u)}return h}static index(r,i){let s=new Array(i.length);return zv.fillIndex(r,i,s),s}static fillIndex(r,i,s){let c=r.length-i.length;for(let n=0;n<i.length;n++)s[n]=r[c+n]%i[n]}static calc(r,i,s,c,n){let a=zv.calcShape(r.dims,i.dims);if(a){if(c&&!B.areEqual(a,r.dims))return;let h=B.size(a),p=c?r:new bt(a,n||r.type);if(a.length===0)p.set([],s(r.get([]),i.get([])));else{let t=new Array(a.length),u=new Array(r.dims.length),l=new Array(i.dims.length),f=0,x=0,I=!1,R=!1;r.dims.length===0&&(f=r.get([]),I=!0),i.dims.length===0&&(x=i.get([]),R=!0);let A;for(let Z=0;Z<h;Z++){A=Z;for(let K=a.length-1;K>=0;K--)t[K]=A%a[K],A=Math.floor(A/a[K]);I||(zv.fillIndex(t,r.dims,u),f=r.get(u)),R||(zv.fillIndex(t,i.dims,l),x=i.get(l)),p.set(t,s(f,x))}}return p}}static isValidBroadcast(r,i){let s=r.length,c=i.length;if(s>c)return!1;for(let n=1;n<=s;n++)if(r[s-n]!==1&&r[s-n]!==i[c-n])return!1;return!0}static getBroadcastDims(r,i){let s=r.length,c=[];for(let n=0;n<s;n++){let a=s-1-n,h=r[a]||1;(i[i.length-1-n]||1)>1&&h===1&&c.unshift(a)}return c}},Sn=class{static getShapeOfGemmResult(e,r,i,s,c){if(e.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let n,a,h;r?(n=e[1],a=e[0]):(n=e[0],a=e[1]);let p=-1;if(s?(h=i[0],p=1):(h=i[1],p=0),i[p]!==a)throw new Error("dimension mismatch");if(n<=0||h<=0||a<=0)throw new Error("invalid shape specified");if(c&&!kt.isValidBroadcast(c,[n,h]))throw new Error("gemm: invalid bias shape for broadcast");return[n,h,a]}},At=class D1{static tensorDataTypeFromProto(r){switch(r){case ot.onnx.TensorProto.DataType.INT8:return"int8";case ot.onnx.TensorProto.DataType.UINT8:return"uint8";case ot.onnx.TensorProto.DataType.BOOL:return"bool";case ot.onnx.TensorProto.DataType.INT16:return"int16";case ot.onnx.TensorProto.DataType.UINT16:return"uint16";case ot.onnx.TensorProto.DataType.INT32:return"int32";case ot.onnx.TensorProto.DataType.UINT32:return"uint32";case ot.onnx.TensorProto.DataType.FLOAT:return"float32";case ot.onnx.TensorProto.DataType.DOUBLE:return"float64";case ot.onnx.TensorProto.DataType.STRING:return"string";case ot.onnx.TensorProto.DataType.INT64:return"int32";case ot.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[r]}`)}}static tensorDataTypeStringToEnum(r){switch(r){case"int8":return ot.onnx.TensorProto.DataType.INT8;case"uint8":return ot.onnx.TensorProto.DataType.UINT8;case"bool":return ot.onnx.TensorProto.DataType.BOOL;case"int16":return ot.onnx.TensorProto.DataType.INT16;case"uint16":return ot.onnx.TensorProto.DataType.UINT16;case"int32":return ot.onnx.TensorProto.DataType.INT32;case"uint32":return ot.onnx.TensorProto.DataType.UINT32;case"float32":return ot.onnx.TensorProto.DataType.FLOAT;case"float64":return ot.onnx.TensorProto.DataType.DOUBLE;case"string":return ot.onnx.TensorProto.DataType.STRING;case"int64":return ot.onnx.TensorProto.DataType.INT64;case"uint64":return ot.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${r}`)}}static tensorDimsFromProto(r){return r.map(i=>xe.isLong(i)?i.toNumber():i)}static tensorValueTypeFromProto(r){return{tensorType:D1.tensorDataTypeFromProto(r.elemType),shape:{dims:D1.tensorDimsFromProto(r.shape.dim.map(i=>i.dimValue))}}}static tensorDimsFromORTFormat(r){let i=[];for(let s=0;s<r.dimsLength();s++)i.push(Rt.longToNumber(r.dims(s)));return i}static tensorAttributesFromORTFormat(r){let i=[];for(let s=0;s<r.attributesLength();s++)i.push(r.attributes(s));return i}},Rt=class{static longToNumber(e,r){return xe.isLong(e)?e.toNumber():e instanceof w.Long?xe.fromValue({low:e.low,high:e.high,unsigned:r??!1}).toNumber():e}static isLong(e){return xe.isLong(e)||e instanceof w.Long}},B=class ph{static size(r){return ph.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,i){if(i<0||i>r.length)throw new Error(`invalid dimension of ${i} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return ph.getSizeFromDimensionRange(r,i,r.length)}static sizeToDimension(r,i){if(i<0||i>r.length)throw new Error(`invalid dimension of ${i} for sizeToDimension as Tensor has ${r.length} dimensions.`);return ph.getSizeFromDimensionRange(r,0,i)}static getSizeFromDimensionRange(r,i,s){let c=1;for(let n=i;n<s;n++){if(r[n]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");c*=r[n]}return c}static computeStrides(r){let i=r.length;if(i===0)return[];if(i===1)return[1];let s=new Array(i);s[i-1]=1,s[i-2]=r[i-1];for(let c=i-3;c>=0;--c)s[c]=s[c+1]*r[c+1];return s}static transpose(r){return r.slice().reverse()}static indicesToOffset(r,i,s){s===void 0&&(s=r.length);let c=0;for(let n=0;n<s;++n)c+=i[n]*r[n];return c}static offsetToIndices(r,i){let s=i.length;if(s===0)return[];if(s===1)return[r*i[0]];let c=new Array(i.length);for(let n=0;n<c.length-1;++n)c[n]=Math.floor(r/i[n]),r-=c[n]*i[n];return c[c.length-1]=r,c}static normalizeAxis(r,i){if(r<-i&&r>=i)throw new Error("unsupported axis for this operation.");return r<0?r+i:r}static normalizeAxes(r,i){return r.map(s=>this.normalizeAxis(s,i))}static incrementIndex(r,i,s){if(i.length===0||r.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(s===void 0)s=i.length;else if(s<=0||s>i.length)throw new Error("Incorrect axis to increment on");for(let c=s-1;c>=0&&(r[c]++,!(r[c]<i[c]));--c)r[c]=0}static calculateReshapedDims(r,i){if(i.length===0){if(r.length===0||ph.size(r)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let s=i.length,c=new Array(s),n=-1,a=1;for(let p=0;p<s;p++){if(i[p]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(i[p]===-1){if(n!==-1)throw new Error("at most one dimension in shape hints can be -1");n=p}else{if(i[p]===0){if(p>=r.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");c[p]=r[p]}else c[p]=i[p];a*=c[p]}}let h=ph.size(r);if(n!==-1){if(h%a!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${r}] Output shape: [${i}]`);c[n]=h/a}else if(a!==h)throw new Error("reshapedDims and originalDims don't have matching sizes");return c}static sortBasedOnPerm(r,i){return i?i.map(s=>r[s]):r.slice().reverse()}static padShape(r,i){let s=r.length;return r.map((c,n)=>c+i[n]+i[n+s])}static areEqual(r,i){return r.length!==i.length?!1:r.every((s,c)=>s===i[c])}static validateDimsAndCalcSize(r){if(r.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let i=1;for(let s of r){if(!Number.isInteger(s))throw new TypeError(`Invalid shape: ${s} is not an integer`);if(s<0||s>2147483647)throw new TypeError(`Invalid shape: length ${s} is not allowed`);i*=s}return i}static flattenShape(r,i){i<0&&(i+=r.length);let s=r.reduce((n,a)=>n*a,1),c=r.slice(i).reduce((n,a)=>n*a,1);return[s/c,c]}static squeezeShape(r,i){let s=new Array;i=ph.normalizeAxes(i,r.length);for(let c=0;c<r.length;c++){let n=i.indexOf(c)>=0;if(n&&r[c]!==1)throw new Error("squeeze an axis of size different than 1");(i.length===0&&r[c]>1||i.length>0&&!n)&&s.push(r[c])}return s}static unsqueezeShape(r,i){let s=new Array(r.length+i.length);s.fill(0);for(let n=0;n<i.length;n++){let a=ph.normalizeAxis(i[n],s.length);if(a>=s.length)throw new Error("'axes' has an out of range axis");if(s[a]!==0)throw new Error("'axes' has a duplicate axis");s[a]=1}let c=0;for(let n=0;n<s.length;n++)s[n]===0&&(s[n]=r[c++]);if(c!==r.length)throw new Error("the unsqueezed dimension could not be established");return s}},$r=class eM{static splitShape(r,i,s,c){if(s.length===0){if(!c)throw new Error("need to know number of outputs when the 'split' attribute is not specified");eM.determineSplit(r[i],c,s)}let n=[],a=[0];for(let h=0;h<s.length;++h){h!==0&&a.push(a[h-1]+s[h-1]);let p=r.slice();p[i]=s[h],n.push(p)}return[n,a]}static determineSplit(r,i,s){if(r%i!==0)throw new Error("cannot split tensor to equal sized parts");for(let c=0;c<i;++c)s.push(r/i)}},Ue=class Nv{static adjustPoolAttributes(r,i,s,c,n,a){if(!r&&s.length!==i.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let h=0;h<i.length-2;h++)h>=s.length?s.push(i[h+2]):s[h]=i[h+2];for(let h=0;h<s.length;h++)if(h<c.length){if(c[h]<0)throw new Error("strides should be greater than or equal to 1")}else c.push(1);for(let h=0;h<s.length;h++)if(h<n.length){if(n[h]<0)throw new Error("dilations should be greater than or equal to 1")}else n.push(1);for(let h=0;h<s.length*2;h++)if(h<a.length){if(a[h]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let h=0;h<s.length;h++){if(s[h]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[h]>=s[h]||a[h+s.length]>=s[h])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,i,s,c,n,a){if(a){if(n.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(i.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(c.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let h=0;h<r.length-2;h++)Nv.adjustPadAndReturnShape(r[h+2],i[h],s[h],c[h],n,h,h+r.length-2,a)}}static computePoolOutputShape(r,i,s,c,n,a,h){if(i.length<=0)throw new Error("input shape must be of size greater than 0");let p=[i[0],i[1]];return Nv.computeShapeHelper(r,i,p,s,c,n,a,h),p}static computeConvOutputShape(r,i,s,c,n,a,h){if(r.length<=0||i.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let p=[r[0],i[0]];return Nv.computeShapeHelper(!1,r,p,s,c,n,a,h),p}static computeShapeHelper(r,i,s,c,n,a,h,p){if(r)for(let t=0;t<i.length-2;t++)s.push(1);else for(let t=0;t<i.length-2;t++)s.push(Nv.adjustPadAndReturnShape(i[t+2],c[t],n[t],a[t],h,t,t+i.length-2,p))}static adjustPadAndReturnShape(r,i,s,c,n,a,h,p){let t=s*(c-1)+1;if(p&&p!=="NOTSET")switch(p){case"VALID":return n[a]=0,n[h]=0,Math.floor((r-t)/i+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let u=((r+i-1)/i-1)*i+c-r;return n[a]=Math.floor(p==="SAME_LOWER"?(u+1)/2:u/2),n[h]=u-n[a],Math.floor((r+u-c)/i+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+n[a]+n[h]-t)/i+1)}},Ve=-34028234663852886e22,ze=34028234663852886e22});function hh(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}function Wu(e){switch(e){case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.BOOL:return 1;case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT16:return 2;case H.onnx.TensorProto.DataType.FLOAT:case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.UINT32:return 4;case H.onnx.TensorProto.DataType.INT64:case H.onnx.TensorProto.DataType.DOUBLE:case H.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${H.onnx.TensorProto.DataType[e]}`)}}function mh(e,r){return new(ju(r))(e)}function ju(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ui(e,r){if(r===H.onnx.TensorProto.DataType.INT64||r===si.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(r===H.onnx.TensorProto.DataType.UINT32||r===si.TensorDataType.UINT32||r===H.onnx.TensorProto.DataType.UINT64||r===si.TensorDataType.UINT64){if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${H.onnx.TensorProto.DataType[r]}`);return e.toNumber()}function Hu(e,r,i){switch(r){case H.onnx.TensorProto.DataType.BOOL:case H.onnx.TensorProto.DataType.UINT8:return e.getUint8(i);case H.onnx.TensorProto.DataType.INT8:return e.getInt8(i);case H.onnx.TensorProto.DataType.UINT16:return e.getUint16(i,!0);case H.onnx.TensorProto.DataType.INT16:return e.getInt16(i,!0);case H.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(i,!0);case H.onnx.TensorProto.DataType.INT32:return e.getInt32(i,!0);case H.onnx.TensorProto.DataType.UINT32:return e.getUint32(i,!0);case H.onnx.TensorProto.DataType.INT64:return ui(xe.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!1),r);case H.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(i,!0);case H.onnx.TensorProto.DataType.UINT64:return ui(xe.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!0),r);default:throw new Error(`cannot read from DataView for type ${H.onnx.TensorProto.DataType[r]}`)}}var qu,H,si,bt,We=O(()=>{qu=rr(Fs()),qo(),Pr(),H=rr(sr()),Y(),si=F.experimental.fbs,bt=class VT{constructor(r,i,s,c,n,a=qu.Guid.create()){this.dims=r,this.type=i,this.dataProvider=s,this.asyncDataProvider=c,this.cache=n,this.dataId=a,this.size=B.validateDimsAndCalcSize(r);let h=this.size,p=s===void 0&&c===void 0&&n===void 0;if(n!==void 0&&n.length!==h)throw new RangeError("Input dims doesn't match data length.");if(i==="string"){if(n!==void 0&&(!Array.isArray(n)||!n.every(t=>typeof t=="string")))throw new TypeError("cache should be a string array");p&&(this.cache=new Array(h))}else{if(n!==void 0){let t=ju(i);if(!(n instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(p){let t=new ArrayBuffer(h*hh(i));this.cache=mh(t,i)}}}get data(){if(this.cache===void 0){let r=this.dataProvider(this.dataId);if(r.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=r}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(r){return this.data[B.indicesToOffset(r,this.strides)]}set(r,i){this.data[B.indicesToOffset(r,this.strides)]=i}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=B.computeStrides(this.dims)),this._strides}static fromProto(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let i=At.tensorDataTypeFromProto(r.dataType),s=At.tensorDimsFromProto(r.dims),c=new VT(s,i);if(i==="string")r.stringData.forEach((n,a)=>{c.data[a]=kr(n)});else if(r.rawData&&typeof r.rawData.byteLength=="number"&&r.rawData.byteLength>0){let n=c.data,a=new DataView(r.rawData.buffer,r.rawData.byteOffset,r.rawData.byteLength),h=Wu(r.dataType),p=r.rawData.byteLength/h;if(r.rawData.byteLength%h!==0)throw new Error("invalid buffer length");if(n.length!==p)throw new Error("buffer length mismatch");for(let t=0;t<p;t++){let u=Hu(a,r.dataType,t*h);n[t]=u}}else{let n;switch(r.dataType){case H.onnx.TensorProto.DataType.FLOAT:n=r.floatData;break;case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.INT16:case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.BOOL:n=r.int32Data;break;case H.onnx.TensorProto.DataType.INT64:n=r.int64Data;break;case H.onnx.TensorProto.DataType.DOUBLE:n=r.doubleData;break;case H.onnx.TensorProto.DataType.UINT32:case H.onnx.TensorProto.DataType.UINT64:n=r.uint64Data;break;default:throw new Error("unspecific error")}if(n==null)throw new Error("failed to populate data from a tensorproto value");let a=c.data;if(a.length!==n.length)throw new Error("array length mismatch");for(let h=0;h<n.length;h++){let p=n[h];xe.isLong(p)?a[h]=ui(p,r.dataType):a[h]=p}}return c}static fromData(r,i,s){return new VT(i,s,void 0,void 0,r)}static fromOrtTensor(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let i=At.tensorDimsFromORTFormat(r),s=At.tensorDataTypeFromProto(r.dataType()),c=new VT(i,s);if(s==="string")for(let n=0;n<r.stringDataLength();n++)c.data[n]=r.stringData(n);else if(r.rawDataArray()&&typeof r.rawDataLength()=="number"&&r.rawDataLength()>0){let n=c.data,a=new DataView(r.rawDataArray().buffer,r.rawDataArray().byteOffset,r.rawDataLength()),h=Wu(r.dataType()),p=r.rawDataLength()/h;if(r.rawDataLength()%h!==0)throw new Error("invalid buffer length");if(n.length!==p)throw new Error("buffer length mismatch");for(let t=0;t<p;t++){let u=Hu(a,r.dataType(),t*h);n[t]=u}}return c}}});function G(e){return e===1?bh:gh}function Xu(e){let r=G(e);return`${r.version}
      precision highp float;
      ${r.attribute} vec3 position;
      ${r.attribute} vec2 textureCoord;

      ${r.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Ku(e){let r=G(e);return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFrag} vec2 TexCoords;
    ${r.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Ju(e,r){let i=G(e);return`
  void main() {
    int indices[${r}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i.output} = result;
  }
  `}var bh,gh,ut=O(()=>{bh={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},gh={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),j=O(()=>{});async function li(e,r=s=>0,i){return new Promise((s,c)=>{let n=0,a=()=>{if(e()){s();return}n++;let h=r(n);setTimeout(a,h)};a()})}function An(e){return ur(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)}function Yu(e){return ur(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"}function lr(e,r){let i=JSON.parse(JSON.stringify(e));return i=r,i}function fr(e,r){return r.map(i=>e[i]).join(", ")}function Bt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function ne(e=6){return["x","y","z","w","u","v"].slice(0,e)}var pe=O(()=>{Y()});function yh(e,r){return ne(r).map(i=>`${e}.${i}`)}function cr(e,r){return r===1?[e]:yh(e,r)}function de(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var He=O(()=>{pe()});function Th(e,r,i){if(e===0)return"false";if(e===1)return`rc > ${r[0]}`;let s="";for(let c=e-2;c<e;c++)s+=`${i[c]} >= ${r[c-e+2]}`,c<e-1&&(s+="||");return s}function wh(e,r){let i=e.length;if(i===0)return"getA(), 0, 0, 0";if(i===1)return`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`;let s="r, c",c="r, cp1",n="rp1, c",a="rp1, cp1",h="";if(i>2)for(let p=0;p<i-2;++p)h=h+`${r[p]},`;return`getA(${h}${s}),
          rEdge ? 0. : getA(${h}${n}),
          cEdge ? 0. : getA(${h}${c}),
          rEdge || cEdge ? 0. : getA(${h}${a})`}function vh(e,r,i,s){return e===0||e===1?"":`
    int r = ${r[e-2]};
    int c = ${r[e-1]};
    int rp1 = ${r[e-2]} + 1;
    int cp1 = ${r[e-1]} + 1;
    bool rEdge = rp1 >= ${s};
    bool cEdge = cp1 >= ${i};
    `}var Zu,xh,Qu,tl=O(()=>{ut(),j(),pe(),He(),Zu={name:"pack",inputNames:["A"],inputTypes:[1]},xh=(e,r)=>{let i=G(e.session.backend.glContext.version),s=r.dims,c=s.length,n=r.dims.length,a=Bt(n),h=cr("rc",n),p=vh(n,h,s[s.length-2],s[s.length-1]),t;c===0?t=[1,1]:c===1?t=[s[0],1]:t=[s[n-1],s[n-2]];let u=Th(n,t,h),l=wh(s,h),f=`
        void main() {
          ${a} rc = getOutputCoords();

          if(${u}) {
            ${i.output} = vec4(0);
          } else {
            ${p}

            ${i.output} = vec4(${l});
          }
        }
      `;return{...Zu,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:2},shaderSource:f}},Qu=(e,r)=>({...Zu,get:()=>xh(e,r)})});function fi(e){if(e.length===0)return[1,1,1];let r=1;for(let i=0;i<e.length-2;++i)r*=e[i];return[r,e.length>1?e[e.length-2]:1,e[e.length-1]]}function rl(e,r){let i=!1;return e.length===0||r.length===0?i=!0:e.length<2||r.length<2?i=e[e.length-1]===r[r.length-1]:i=e[e.length-1]===r[r.length-1]&&e[e.length-2]===r[r.length-2],i}function Oh(e){let r=B.computeStrides(e),i=["b","r","c"],s="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r.map((c,n)=>{let a=`int ${i[n]} = ${s} / ${c}`,h=n===r.length-1?`int ${i[n+1]} = ${s} - ${i[n]} * ${c}`:`index -= ${i[n]} * ${c}`;return`${a}; ${h};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function Sh(e){let r=B.computeStrides(e);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${r[0]} + coords.z * ${r[1]} + coords.y;
  }
`}var Ih,_h,el,nl=O(()=>{Y(),ut(),j(),He(),Ih=e=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${e}`}),_h=(e,r,i,s)=>{let c=r.dims,n=s,a="";for(let t=0;t<4;t++){let u="";switch(t){case 0:u="outputCoords = rc;";break;case 1:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:u="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}a+=`
        ${u}
        ${t>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t>0?"}":""}
      `}let h=G(e.session.backend.glContext.version),p=`
      ${Oh(c)}
      ${Sh(n)}
      ${de()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${n[2]};
        int cols = ${n[1]};

        ${a}
        ${h.output} = result;
      }
    `;return{...i,output:{dims:n,type:r.type,textureType:2},shaderSource:p,hasMain:!0}},el=(e,r,i)=>{let s=Ih(i);return{...s,get:()=>_h(e,r,s,i)}}}),ci,ol=O(()=>{ut(),j(),ci=(e,r)=>{let i=r.shape,s=G(e.session.backend.glContext.version),c=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,n={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:i,type:r.tensor.type,textureType:3},shaderSource:c,hasMain:!0};return e.executeProgram(n,[r.tensor])}});function Ph(e,r){if(e===1)return"rc";let i="";for(let s=0;s<e;s++)i+=r[s],s<e-1&&(i+=",");return i}var il,Ah,al,sl=O(()=>{ut(),j(),pe(),He(),il={name:"unpack",inputNames:["A"],inputTypes:[2]},Ah=(e,r)=>{let i=r.dims.length,s=cr("rc",i),c=s.slice(-2),n=Bt(i),a=de(),h=r.dims.length===0?"":Ph(i,s),p=i<=1?"rc":`vec2(${c.join(",")})`,t=G(e.session.backend.glContext.version),u=`
    ${a}
    void main() {
      ${n} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${h});

       ${t.output} = vec4(getChannel(packedInput, ${p}), 0, 0, 0);
     }
   `;return{...il,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:u}},al=(e,r)=>({...il,get:()=>Ah(e,r)})}),Pn,Br,En,Fr=O(()=>{Ut(),Pn=class{constructor(e,r=1){if(r===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){let i,s;return e.constructor!==Float32Array&&(tt.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(e)),r*this.channelSize>e.length?(tt.warning("Encoder","Source data too small. Allocating larger array"),s=e,i=this.allocate(r*this.channelSize),s.forEach((c,n)=>i[n]=c)):(s=e,i=s),i}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((i,s)=>s%4===0).subarray(0,r):e.subarray(0,r)}},Br=class{constructor(e,r=1,i){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=r,this.textureType=i||e.FLOAT}encode(e,r){let i=e;return this.channelSize===1&&(tt.verbose("Encoder","Exploding into a larger array"),i=this.allocate(r),e.forEach((s,c)=>i[c*4]=s)),i}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((i,s)=>s%4===0).subarray(0,r):e.subarray(0,r)}},En=class{constructor(e,r=1){if(this.channelSize=4,r===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,r){if(e instanceof Uint8Array)return e.subarray(0,r);throw new Error(`Invalid array type: ${e.constructor}`)}}}),Cr,ul,pi,ll=O(()=>{Y(),j(),Cr=(e,r,i)=>{let s=i===0||i===1?1:4,c=i===2,n=i===1||i===2,a=i===4?r.length-1:void 0,h=i===4?r.map((p,t)=>t===r.length-1?p*4:p):void 0;return pi(e,r,s,h,{isPacked:c,reverseWH:n,breakAxis:a})},ul=(e,r,i)=>{let s=Cr(e,r,i);return[s.width,s.height]},pi=(e,r,i=1,s,c)=>{let n=!!(c&&c.isPacked),[a,h]=e.computeTextureWH(n&&s||r,c),p=r.length,t=r.slice(0);if(p===0&&(t=[1]),i===1)s=r;else if(n){if(i!==4)throw new Error("a packed texture must be 4-channel");s=r,p>0&&(t[p-1]=Math.ceil(t[p-1]/2)),p>1&&(t[p-2]=Math.ceil(t[p-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:a,height:h,channels:i,isPacked:n,shape:t,strides:B.computeStrides(t),unpackedShape:s,reversedWH:c&&c.reverseWH}}}),Dh,Dn,cl=O(()=>{Ut(),We(),Y(),tl(),nl(),ol(),sl(),Fr(),ll(),j(),Dh=(e,r)=>{let i=r.map(c=>`${c.unpackedShape.join(",")};${c.width}x${c.height}`).join("_"),s=e.name;return e.cacheHint&&(s+="["+e.cacheHint+"]"),s+=":"+i,s},Dn=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,r){return ul(this.session.layoutStrategy,e,r)}executeProgram(e,r){if(r.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let i=[];for(let p=0;p<e.inputNames.length;++p)i[p]=this.getOrCreateTextureData(r[p],e.inputTypes[p]);let s=Dh(e,i),c=this.session.programManager.getArtifact(s),n=c?c.programInfo:typeof e.get=="function"?e.get():e,a=Cr(this.session.layoutStrategy,n.output.dims,n.output.textureType),h=this.createTextureData(a,n.output.type);return c||(c=this.session.programManager.build(n,i,h),this.session.programManager.setArtifact(s,c)),this.runProgram(c,i,h),h}run(e,r){return this.executeProgram(e,r).tensor}runProgram(e,r,i){for(let s=0;s<r.length;++s)if(!!r[s].isPacked!=(e.programInfo.inputTypes[s]===2))throw new Error(`input[${s}] property packed inconsistent`);if(!!i.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,r,i)}getOrCreateTextureData(e,r){let i=this.getTextureData(e.dataId,r===2);if(!i&&(i=this.getTextureData(e.dataId,r!==2),i))return r===2?this.pack(i):this.unpack(i);if(!i){let s=Cr(this.session.layoutStrategy,e.dims,r);if(r===4){let c=e.dims;if(c.length===4){let n=[c[0],Math.ceil(c[1]*c[2]*c[3]/4)],a=Cr(this.session.layoutStrategy,n,r),h=e.numberData;if(c[1]*c[2]*c[3]%4!==0){let p=c[0],t=c[1]*c[2]*c[3],u=Math.ceil(t*1/4)*4,l=p*u;h=new Float32Array(l);for(let f=0;f<p;++f){let x=f*t,I=f*u+f%1*t;h.set(e.numberData.subarray(x,x+t),I)}}return this.createTextureData(a,e.type,h,e,1)}}if(r===2){let c=pi(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),n=this.createTextureData(c,e.type,e.numberData,e,1);i=this.pack(n)}else i=this.createTextureData(s,e.type,e.numberData,e,1)}return i}createTextureDataFromLayoutBindTensor(e,r,i,s){return this.createTextureData(e,r,i,s,1)}createTextureData(e,r,i,s,c){tt.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let n=this.session.textureManager.createTextureFromLayout(r,e,i,c);return this.createTextureDataFromTexture(e,r,n,s)}reshapeUnpacked(e,r){let i=this.getOrCreateTextureData(e,0),s={channels:i.channels,height:i.height,width:i.width,shape:r.length!==0?r:[1],strides:B.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(s,e.type,i.texture).tensor}reshapePacked(e,r){let i=this.getOrCreateTextureData(e,2);if(rl(e.dims,r)){let h={channels:i.channels,height:i.height,width:i.width,shape:r.length!==0?r:[1],strides:B.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(h,e.type,i.texture).tensor}let s=fi(e.dims),c=fi(r),n=this.reshapePacked(e,s),a=this.run(el(this,n,c),[n]);return this.reshapePacked(a,r)}cast(e,r){let i=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(i,r,i.texture).tensor}createTextureDataFromTexture(e,r,i,s,c){let n={...e,tensor:s||new bt(e.unpackedShape,r,a=>this.readTexture(n),async a=>this.readTextureAsync(n),void 0,c),texture:i};return this.setTextureData(n.tensor.dataId,n,e.isPacked),n}getTextureData(e,r=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,r):r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,i=!1){this.session.isInitializer(e)?this.session.setTextureData(e,r,i):(i?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,r)}isTextureLayoutCached(e,r=!1){return!!this.getTextureData(e.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(ci(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(ci(this,e))}pack(e){return this.executeProgram(Qu(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(al(this,e.tensor),[e.tensor])}}}),di,W,It=O(()=>{di=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},W=e=>new di(e)}),pl,dl,hl,Lh,$h,ml=O(()=>{It(),ut(),j(),pl={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},dl=(e,r,i)=>($h(r),[e.run({...pl,cacheHint:i.cacheKey,get:()=>Lh(e,r,i)},r)]),hl=e=>{let r=e.attributes.getFloat("epsilon",1e-5),i=e.attributes.getFloat("momentum",.9),s=e.attributes.getInt("spatial",1);return W({epsilon:r,momentum:i,spatial:s})},Lh=(e,r,i)=>{let s=G(e.session.backend.glContext.version),c=r[0].dims.length,[n,a]=e.calculateTextureWidthAndHeight(r[1].dims,0),h=`
  float process(int[${c}] indices) {
    vec2 position = offsetToCoords(indices[1], ${n}, ${a});
    float scale = getColorAsFloat(${s.texture2D}(Scale, position));
    float mean = getColorAsFloat(${s.texture2D}(Mean, position));
    float variance = getColorAsFloat(${s.texture2D}(Variance, position));
    float b = getColorAsFloat(${s.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return{...pl,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:h}},$h=e=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let r=e[0],i=e[1],s=e[2],c=e[3],n=e[4];if(r.dims.length<3||i.dims.length!==1||s.dims.length!==1||c.dims.length!==1||n.dims.length!==1)throw new Error("invalid input shape.");if(i.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1]||c.dims[0]!==r.dims[1]||n.dims[0]!==r.dims[1])throw new Error("invalid input shape.");if(r.type!=="float32"&&r.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||c.type!=="float32"&&c.type!=="float64"||n.type!=="float32"&&n.type!=="float64")throw new Error("invalid input tensor types.")}}),Ln,Ht,k,Nr,$n,Te=O(()=>{Ln=class{constructor(e,r,i,s){this.glContext=e,this.programInfo=r,this.inputTextureLayouts=i,this.outputTextureLayout=s}},Ht=class{constructor(e){this.context=e}},k=class{constructor(e,r){this.routineBody=e,this.dependencies=r}},Nr=class{constructor(e,r,i){this.name=e,i?this.dependencies=i:this.dependencies=[],r&&(this.routineBody=r)}addDependency(e){e&&this.dependencies.push(e)}},$n=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let r=new Set,i=new Set,s=new Array;return this.createOrderedNodes(e,r,i,s),s}static createOrderedNodes(e,r,i,s){for(let c=0;c<e.length;++c)this.dfsTraverse(e[c],r,i,s)}static dfsTraverse(e,r,i,s){if(!e||i.has(e.name))return;if(r.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(e.name);let c=e.dependencies;if(c&&c.length>0)for(let n=0;n<c.length;++n)this.dfsTraverse(c[n],r,i,s);s.push(e),i.add(e.name),r.delete(e.name)}}});function Bh(){let e="add_";return{body:`
  float ${e}(float a, float b) {
    return a + b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:e,type:0}}function Fh(){let e="div_";return{body:`
  float ${e}(float a, float b) {
    return a / b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:e,type:0}}function Ch(){let e="mul_";return{body:`
  float ${e}(float a, float b) {
    return a * b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:e,type:0}}function Nh(){let e="sub_";return{body:`
  float ${e}(float a, float b) {
    return a - b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:e,type:0}}function Rh(){let e="equal_";return{body:`
  float ${e}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:e,type:0}}function Gh(){let e="greater_";return{body:`
  float ${e}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:e,type:0}}function Mh(){let e="less_";return{body:`
  float ${e}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:e,type:0}}function Uh(){let e="and_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:e,type:0}}function Vh(){let e="or_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:e,type:0}}function zh(){let e="xor_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:e,type:0}}function Wh(){return qh("pow")}function Hh(){let e="prelu_";return{body:`
  float ${e}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:e,type:0}}function qh(e){let r=`${e}_`;return{body:`
  float ${r}(float a, float b) {
    return ${e}(a, b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return ${e}(v1, v2);
  }
  `,name:r,type:0}}var qt,jh,bl,gl,yl,xl,Tl,wl,vl,Il,_l,Ol,Sl,Al,Pl=O(()=>{Y(),Te(),ut(),j(),qt=(e,r,i,s=r[0].type,c)=>{let n=e.session.pack?2:0;return{name:i.name,inputNames:["A","B"],inputTypes:[n,n],cacheHint:c,get:()=>jh(e,r,i,s)}},jh=(e,r,i,s=r[0].type)=>{let c=e.session.pack?2:0,n=!B.areEqual(r[0].dims,r[1].dims),a=r[0].dims,h=e.session.pack;if(n){let u=kt.calcShape(r[0].dims,r[1].dims,!1);if(!u)throw new Error("Can't perform binary op on the given tensors");a=u;let l=a.length,f=r[0].dims.length!==0?r[0].dims.length:1,x=r[1].dims.length!==0?r[1].dims.length:1,I=r[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",R=r[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",A=G(e.session.backend.glContext.version),Z=h?`
      ${i.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${i.name}(a, b);
        ${A.output} = result;
      }`:`
      ${i.body}
      float process(int indices[${l}]) {
        int aindices[${f}];
        int bindices[${x}];
        ${I}
        ${R}
        return ${i.name}(_A(aindices), _B(bindices));
      }`;return{name:i.name,inputNames:["A","B"],inputTypes:[c,c],output:{dims:a,type:s,textureType:c},shaderSource:Z,hasMain:h}}let p=G(e.session.backend.glContext.version),t=`
    ${i.body}
    void main() {
      vec4 v1 = ${p.texture2D}(A, TexCoords);
      vec4 v2 = ${p.texture2D}(B, TexCoords);
      vec4 result = ${i.name}(v1, v2);
      ${p.output} = result;
    }
    `;return{name:i.name,inputNames:["A","B"],inputTypes:[c,c],output:{dims:r[0].dims,type:s,textureType:c},shaderSource:t,hasMain:!0}},bl=(e,r)=>[e.run(qt(e,r,Bh()),r)],gl=(e,r)=>[e.run(qt(e,r,Uh(),"bool"),r)],yl=(e,r)=>[e.run(qt(e,r,Fh()),r)],xl=(e,r)=>[e.run(qt(e,r,Rh(),"bool"),r)],Tl=(e,r)=>[e.run(qt(e,r,Gh(),"bool"),r)],wl=(e,r)=>[e.run(qt(e,r,Mh(),"bool"),r)],vl=(e,r)=>[e.run(qt(e,r,Ch()),r)],Il=(e,r)=>[e.run(qt(e,r,Vh(),"bool"),r)],_l=(e,r)=>[e.run(qt(e,r,Wh()),r)],Ol=(e,r)=>[e.run(qt(e,r,Hh()),r)],Sl=(e,r)=>[e.run(qt(e,r,Nh()),r)],Al=(e,r)=>[e.run(qt(e,r,zh(),"bool"),r)]}),El,Dl,Kh,Ll=O(()=>{Y(),El=(e,r,i)=>(Kh(r),[e.cast(r[0],i)]),Dl=e=>At.tensorDataTypeFromProto(e.attributes.getInt("to")),Kh=e=>{if(!e||e.length!==1)throw new Error("Cast requires 1 input.");if(e[0].type==="string")throw new Error("Invalid input type.")}}),Jh,Yh,$l,kn,kl=O(()=>{ut(),j(),pe(),He(),Jh=(e,r)=>({name:"Concat (packed)",inputNames:Array.from({length:e},(i,s)=>`X${s}`),inputTypes:Array(e).fill(2),cacheHint:r}),Yh=(e,r,i,s)=>{let c=i[0].dims.slice();if(s>=c.length||s<-1*c.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=c.length+s);let n=c.slice(0);for(let se=1;se<i.length;se++){let ee=i[se].dims.slice();for(let ce=0;ce<c.length;ce++)if(ce===s)n[s]+=ee[ce];else if(c[ce]!==ee[ce])throw new Error("non concat dimensions must match")}let a=n.length,h=cr("coords",a),p=Bt(a),t=de(),u=i.map(se=>se.dims),l=ne(a),f=new Array(u.length-1);f[0]=u[0][s];for(let se=1;se<f.length;se++)f[se]=f[se-1]+u[se][s];let x=l[s],I=l.slice(-2),R=l.join(),A=`if (${x} < ${f[0]}) {
        return getChannel(
            getX0(${R}), vec2(${I.join()}));
        }`;for(let se=1;se<f.length;se++){let ee=f[se-1];A+=`
            if (${x} < ${f[se]}  && ${x} >= ${f[se-1]}) {
              return getChannel(
                getX${se}(${kn(l,x,ee)}),
                vec2(${kn(I,x,ee)}));
            }`}let Z=f.length,K=f[f.length-1];A+=`
            return getChannel(
              getX${Z}(${kn(l,x,K)}),
              vec2(${kn(I,x,K)}));`;let Q=G(e.session.backend.glContext.version),re=`
          ${t}
          float getValue(${l.map(se=>"int "+se)}) {
            ${A}
          }

          void main() {
            ${p} coords = getOutputCoords();
            int lastDim = coords.${l[a-1]};
            coords.${l[a-1]} = coords.${l[a-2]};
            coords.${l[a-2]} = lastDim;

            vec4 result = vec4(getValue(${h}), 0., 0., 0.);

            ${h[a-1]} = ${h[a-1]} + 1;
            if (${h[a-1]} < ${n[a-1]}) {
              result.g = getValue(${h});
            }

            ${h[a-2]} = ${h[a-2]} + 1;
            if (${h[a-2]} < ${n[a-2]}) {
              result.a = getValue(${h});
            }

            ${h[a-1]} = ${h[a-1]} - 1;
            if (${h[a-2]} < ${n[a-2]} &&
                ${h[a-1]} < ${n[a-1]}) {
              result.b = getValue(${h});
            }
            ${Q.output} = result;
          }
        `;return{...r,output:{dims:n,type:i[0].type,textureType:2},shaderSource:re,hasMain:!0}},$l=(e,r,i)=>{let s=Jh(r.length,i.cacheKey);return{...s,get:()=>Yh(e,s,r,i.axis)}},kn=(e,r,i)=>{let s=e.indexOf(r);return e.map((c,n)=>n===s?`${c} - ${i}`:c).join()}}),Bl,Zh,Qh,tm,Fl,em,rm,nm,Cl,om,Nl=O(()=>{It(),j(),kl(),Bl=(e,r,i)=>(om(r),e.session.pack&&r[0].dims.length>1?[e.run($l(e,r,i),r)]:[e.run(tm(e,r,i),r)]),Zh=(e,r)=>({name:"Concat",inputNames:Array.from({length:e},(i,s)=>`X${s}`),inputTypes:Array(e).fill(0),cacheHint:r}),Qh=(e,r,i,s)=>{let c=i[0].dims.slice();if(s>=c.length||s<-1*c.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=c.length+s);let n=c.slice(0);for(let x=1;x<i.length;x++){let I=i[x].dims.slice();for(let R=0;R<c.length;R++)if(R===s)n[s]+=I[R];else if(c[R]!==I[R])throw new Error("non concat dimensions must match")}let a=n.length,h=new Array(i.length),p=0;for(let x=0;x<h.length;++x)p+=i[x].dims[s],h[x]=p;let t="";i.length<5?t=Fl(h):t=em(h);let u=rm(i.length,a),l=nm(h),f=`
        ${u}
        ${l}
        ${t}
        float process(int indices[${a}]) {
          int textureIndex = getTextureWhereDataResides (indices[${s}]);

          if(textureIndex != 0) {
            indices[${s}] = indices[${s}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...r,output:{dims:n,type:i[0].type,textureType:0},shaderSource:f}},tm=(e,r,i)=>{let s=Zh(r.length,i.cacheKey);return{...s,get:()=>Qh(e,s,r,i.axis)}},Fl=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((r,i)=>`if(index<${r}) {return ${i};}
`).join("")}
    }`,em=e=>Fl(e),rm=(e,r)=>{let i=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${r}]) {`];for(let s=0;s<e;++s)s===0?i.push(`	if (textureIndex == ${s}) { return _X${s}(indices); }`):s===e-1?i.push(`	else { return _X${s}(indices); }`):i.push(`	else if (textureIndex == ${s}) { return _X${s}(indices); }`);return i.push("	}"),i.join(`
`)},nm=e=>{let r=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<e.length;++i)i===0?r.push(`	if (index == ${i}) { return ${e[i]}; }`):i===e.length-1?r.push(`	else { return ${e[i]}; }`):r.push(`	else if (index == ${i}) { return ${e[i]}; }`);return r.push("	}"),r.join(`
`)},Cl=e=>W({axis:e.attributes.getInt("axis")}),om=e=>{if(!e||e.length<1)throw new Error("too few inputs");let r=e[0].type,i=e[0].dims.length;if(r==="string")throw new Error("string tensor is not supported yet");for(let s of e){if(s.type!==r)throw new Error("input tensors should be one type");if(s.dims.length!==i)throw new Error("input tensors should have the same shape")}}});function im(){return jt("abs")}function am(){return jt("acos")}function sm(){return jt("asin")}function um(){return jt("atan")}function lm(){return jt("ceil")}function fm(){return jt("cos")}function cm(e){let r="elu";return{body:`
  const float alpha = float(${e});

  float ${r}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function pm(){return jt("exp")}function dm(){return jt("floor")}function hi(e,r){let i="clip";return{body:`
  const float min = float(${e});
  const float max = float(${r});

  float ${i}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${i}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:i,type:0}}function hm(){let e="indentity";return{body:`
  float ${e}_(float a) {
    return a;
  }
  vec4 ${e}_(vec4 v) {
    return v;
  }
  `,name:e,type:0}}function mm(e){let r="leakyRelu";return{body:`
  const float alpha = float(${e});

  float ${r}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function bm(){return jt("log")}function gm(){let e="neg";return{body:`
  float ${e}_(float a) {
    return -a;
  }
  vec4 ${e}_(vec4 v) {
    return -v;
  }
  `,name:e,type:0}}function ym(){let e="not";return{body:`
  float ${e}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e}_(bool a) {
    return !a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:e,type:0}}function xm(){return jt("sin")}function mi(){let e="relu";return{body:`
  float ${e}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:e,type:0}}function bi(){let e="sigmoid";return{body:`
  float ${e}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:e,type:0}}function Tm(){return jt("sqrt")}function wm(){return jt("tan")}function vm(){let e="tanh";return{body:`
  float ${e}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:e,type:0}}function jt(e){return{body:`
  float ${e}_(float a) {
    return ${e}(a);
  }
  vec4 ${e}_(vec4 v) {
    return ${e}(v);
  }
  `,name:e,type:0}}var Im,dt,Rl,Gl,Ml,Ul,gi,Vl,zl,_m,Wl,Hl,ql,jl,Xl,Kl,yi,Jl,Yl,Zl,Ql,tf,ef,rf,nf,of,af,sf,xi=O(()=>{It(),Y(),Te(),ut(),j(),Im=(e,r,i,s)=>{let c=e.session.pack?2:0,n=G(e.session.backend.glContext.version);return{...r,output:{dims:i.dims,type:i.type,textureType:c},shaderSource:`
     ${s.body}
     void main() {
       vec4 v = ${n.texture2D}(A, TexCoords);
       v = ${s.name}_(v);
       ${n.output} = v;
     }
     `,hasMain:!0}},dt=(e,r,i,s)=>{let c=e.session.pack?2:0,n={name:i.name,inputTypes:[c],inputNames:["A"],cacheHint:s};return{...n,get:()=>Im(e,n,r,i)}},Rl=(e,r)=>[e.run(dt(e,r[0],im()),r)],Gl=(e,r)=>[e.run(dt(e,r[0],am()),r)],Ml=(e,r)=>[e.run(dt(e,r[0],sm()),r)],Ul=(e,r)=>[e.run(dt(e,r[0],um()),r)],gi=(e,r,i)=>[e.run(dt(e,r[0],hi(i.min,i.max),i.cacheKey),r)],Vl=e=>W({min:e.attributes.getFloat("min",Ve),max:e.attributes.getFloat("max",ze)}),zl=(e,r)=>{let i=_m(e,r);return gi(e,[r[0]],i)},_m=(e,r)=>{if(r.length>=3&&(!e.session.isInitializer(r[1].dataId)||!e.session.isInitializer(r[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let i=r.length>=3?r[1].numberData[0]:Ve,s=r.length>=3?r[2].numberData[0]:ze;return W({min:i,max:s})},Wl=(e,r)=>[e.run(dt(e,r[0],lm()),r)],Hl=(e,r)=>[e.run(dt(e,r[0],fm()),r)],ql=(e,r,i)=>[e.run(dt(e,r[0],cm(i.alpha),i.cacheKey),r)],jl=e=>W({alpha:e.attributes.getFloat("alpha",1)}),Xl=(e,r)=>[e.run(dt(e,r[0],pm()),r)],Kl=(e,r)=>[e.run(dt(e,r[0],dm()),r)],yi=(e,r)=>[e.run(dt(e,r[0],hm()),r)],Jl=(e,r,i)=>[e.run(dt(e,r[0],mm(i.alpha),i.cacheKey),r)],Yl=e=>W({alpha:e.attributes.getFloat("alpha",.01)}),Zl=(e,r)=>[e.run(dt(e,r[0],bm()),r)],Ql=(e,r)=>[e.run(dt(e,r[0],gm()),r)],tf=(e,r)=>[e.run(dt(e,r[0],ym()),r)],ef=(e,r)=>[e.run(dt(e,r[0],mi()),r)],rf=(e,r)=>[e.run(dt(e,r[0],bi()),r)],nf=(e,r)=>[e.run(dt(e,r[0],xm()),r)],of=(e,r)=>[e.run(dt(e,r[0],Tm()),r)],af=(e,r)=>[e.run(dt(e,r[0],wm()),r)],sf=(e,r)=>[e.run(dt(e,r[0],vm()),r)]});function he(e){let r;switch(e.activation){case"Relu":r=mi();break;case"Sigmoid":r=bi();break;case"Clip":r=hi(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let i=r.name,s=r.body,c=`value = ${i}_(value);`;return{activationFunction:s,applyActivation:c}}var pr,qe=O(()=>{Y(),xi(),pr=e=>{let r=e.getString("activation","");if(r==="Clip"){let[i,s]=e.getFloats("activation_params",[Ve,ze]);return{activation:r,clipMax:s,clipMin:i,activationCacheKey:`${r}:${i},${s}`}}return{activation:r,activationCacheKey:r}}}),Sm,Am,uf,lf=O(()=>{Ut(),ut(),j(),Bn(),qe(),Sm=(e,r)=>({name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),Am=(e,r,i,s)=>{let c=r.length>2?"value += getBias(output_channel);":"",n=r[0].dims.slice(),a=r[1].dims.slice(),h=a[0]/s.group;tt.verbose("GroupedConv",`autpPad:${s.autoPad}, dilations:${s.dilations}, group:${s.group}, kernelShape:${s.kernelShape}, pads:${s.pads}, strides:${s.strides}`);let p=dr(n,a,s.dilations,s.pads,s.strides),t=G(e.session.backend.glContext.version),{activationFunction:u,applyActivation:l}=he(s),f=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${u}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${h};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {
      int input_channel = group_id * ${a[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${s.dilations[0]};

        if (xHeight < 0 || xHeight >= ${n[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${s.dilations[1]};
          if (xWidth < 0 || xWidth >= ${n[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c}
    ${l}
    ${t.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:p,type:r[0].type,textureType:0},shaderSource:f,hasMain:!0}},uf=(e,r,i)=>{let s=Sm(r.length>2,i.cacheKey);return{...s,get:()=>Am(e,r,s,i)}}}),Pm,Em,ff,cf=O(()=>{ut(),j(),He(),Pm=e=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:e}),Em=(e,r,i,s,c,n)=>{let a=i.dims,h=s.dims,p=2,t=3,u=c.length,l=[h[1]*h[2]*h[3],c[2]*c[3]],f=h[2]*h[3],x=de(),I=G(e.session.backend.glContext.version),R="";for(let Z=0;Z<=1;Z++)for(let K=0;K<=1;K++)R+=`
            blockIndex = rc.x + ${K};
            pos = rc.y + ${Z};

            if(blockIndex < ${l[1]} && pos < ${l[0]}) {
              offsetY = int(blockIndex / (${c[u-1]})) * ${n.strides[0]} -
                ${n.pads[0]};
              d0 = offsetY + ${n.dilations[0]} * (imod(pos, ${f}) / ${h[2]});

              if(d0 < ${a[p]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${c[u-1]}) * ${n.strides[1]} -
                  ${n.pads[1]};
                d1 = offsetX + ${n.dilations[1]} * imod(imod(pos, ${f}), ${h[2]});

                if(d1 < ${a[t]} && d1 >= 0) {

                  ch = int(float(pos)/ ${f}.);
                    innerDims = vec2(d0, d1);
                    result[${Z*2+K}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let A=`
      ${x}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${R}
          ${I.output} = result;
      }
            `;return{...r,output:{dims:l,type:i.type,textureType:2},shaderSource:A,hasMain:!0}},ff=(e,r,i,s,c)=>{let n=Pm(c.cacheKey);return{...n,get:()=>Em(e,n,r,i,s,c)}}});function Lm(e,r,i){let s=r[0].dims,c=r[1].dims,n=kt.calcShape(s,c,!0);if(!n)throw new Error("Can't use matmul on the given tensors");let a=Bt(n.length),h=ne(),{activationFunction:p,applyActivation:t}=he(i),u=r.length>2,l=u?"value += getBiasForMatmul();":"",f=u?`${wi(a,h,r[2].dims,n,!1)}`:"",x=n.length,I=s.length,R=c.length,A=s[s.length-1],Z=`
    ${p}
    ${f}
    float process(int indices[${x}]) {
        int a[${I}];
        int b[${R}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${A}; ++k) {
            a[${I-1}] = k;
            b[${R-2}] = k;
            value += _A(a) * _B(b);
        }
        ${l}
        ${t}
        return value;
    }`;return{...e,output:{dims:n,type:r[0].type,textureType:0},shaderSource:Z}}function Ti(e,r){let i=Dm(e.length>2,r.activationCacheKey);return{...i,get:()=>Lm(i,e,r)}}function wi(e,r,i,s,c){let n="",a=i.length,h=s.length,p=h-a;h<2&&a>0?n="coords":n=i.map((f,x)=>`coords.${r[x+p]}`).join(", ");let t=kt.getBroadcastDims(i,s).map(f=>`coords.${r[f+p]} = 0;`).join(`
`),u=B.size(i)===1,l="vec4(outputValue.xx, outputValue.yy)";return u&&(l="vec4(outputValue.x)"),c?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${t}
  vec4 outputValue = getBias(${n});
  return ${l};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${t}
  return getBias(coords.x);
}`}var pf,df,Dm,$m,Fn=O(()=>{Y(),j(),pe(),qe(),vi(),pf=(e,r,i)=>($m(r),e.session.pack?[e.run(Cn(e,r,i),r)]:[e.run(Ti(r,i),r)]),df=e=>pr(e.attributes),Dm=(e,r)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),$m=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")}});function Fm(e,r,i,s){let c=[],n=[],a=i[0].dims,h=i[1].dims,p=a.length,t=h.length,u=s.length,l=u-p,f=u-t;c=a.map((K,Q)=>`coords.${r[Q+l]}`),c[p-1]="i*2",c.join(", "),n=h.map((K,Q)=>`coords.${r[Q+f]}`),n[t-2]="i*2",n.join(", ");let x=kt.getBroadcastDims(a,s),I=kt.getBroadcastDims(h,s),R=x.map(K=>`coords.${r[K+l]} = 0;`).join(`
`),A=I.map(K=>`coords.${r[K+f]} = 0;`).join(`
`),Z=`int lastDim = coords.${r[u-1]};
  coords.${r[u-1]} = coords.${r[u-2]};
  coords.${r[u-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${Z}
  ${R}
  vec4 outputValue = getA(${c});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${Z}
  ${A}
  vec4 outputValue = getB(${n});
  return outputValue;
}`}function Cm(e,r){let i="";for(let s=0;s<r-2;s++)i+=`rc.${e[s]}, `;return i+=`rc.${e[r-2]}, i*2`,i}function Nm(e,r){let i="";for(let s=0;s<r-2;s++)i+=`rc.${e[s]}, `;return i+=`i*2, rc.${e[r-1]}`,i}var km,Bm,Cn,vi=O(()=>{Y(),ut(),j(),pe(),qe(),Fn(),km=(e,r)=>({name:"MatMul (packed)",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[2,2,2]:[2,2],cacheHint:r}),Bm=(e,r,i,s)=>{let c=i.length>2,n=c?"value += getBiasForMatmul();":"",a=i[0].dims,h=i[1].dims,p=kt.calcShape(a,h,!0),t=!B.areEqual(i[0].dims,i[1].dims);if(!p)throw new Error("Can't use matmul on the given tensors");let u=a[a.length-1],l=Math.ceil(u/2),f=a.length,x=h.length,I=G(e.session.backend.glContext.version),R=Bt(p.length),A=p.length,Z=ne(),{activationFunction:K,applyActivation:Q}=he(s),re=c?`${wi(R,Z,i[2].dims,p,!0)}`:"",se=t?`${Fm(R,Z,i,p)}`:"",ee=t?"getAAtOutCoordsMatmul(i)":`getA(${Cm(Z,f)})`,ce=t?"getBAtOutCoordsMatmul(i)":`getB(${Nm(Z,x)})`,X=t?"":`${R} rc =
          getOutputCoords(); int lastDim = rc.${Z[A-1]}; rc.${Z[A-1]} =
          rc.${Z[A-2]}; rc.${Z[A-2]} = lastDim;
      `,Re=`
            ${se}
            ${re}
            ${K}
            void main() {
              ${X}

              vec4 value = vec4(0);
              for (int i = 0; i < ${l}; i++) {
                vec4 a = ${ee};
                vec4 b = ${ce};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${n}
              ${Q}
              ${I.output} = value;
            }`;return{...r,output:{dims:p,type:i[0].type,textureType:2},shaderSource:Re,hasMain:!0}},Cn=(e,r,i)=>{let s=km(r.length>2,i.activationCacheKey);return{...s,get:()=>Bm(e,s,r,i)}}}),hf,mf=O(()=>{Bn(),cf(),vi(),hf=(e,r,i)=>{let s=r[0].dims,c=r[1].dims,n=dr(s,c,i.dilations,i.pads,i.strides),a=e.run(ff(e,r[0],r[1],n,i),[r[0]]),h=e.reshapePacked(r[1],[c[0],c[1]*c[2]*c[3]]),p=r.length===3?[h,a,r[2]]:[h,a],t=e.run(Cn(e,p,i),p);return e.reshapePacked(t,n)}}),Rm,Gm,bf,Ii,_i=O(()=>{j(),Rm=e=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:e}),Gm=(e,r,i,s,c,n)=>{let a=i.dims,h=s.dims,p=c.length,t=Ii(a,h,c,4),u=`
        const int XC = ${a[1]};
        const int XH = ${a[2]};
        const int XW = ${a[3]};
        const int KH = ${n.kernelShape[0]};
        const int KW = ${n.kernelShape[1]};
        const int dilationH = ${n.dilations[0]};
        const int dilationW = ${n.dilations[1]};
        const int strideH = ${n.strides[0]};
        const int strideW = ${n.strides[1]};
        const int padH = ${n.pads[0]};
        const int padW = ${n.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${p}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${a.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...r,output:{dims:t,type:i.type,textureType:4},shaderSource:u}},bf=(e,r,i,s,c)=>{let n=Rm(c.cacheKey);return{...n,get:()=>Gm(e,n,r,i,s,c)}},Ii=(e,r,i,s=4)=>[i[0],i[2],i[3],Math.ceil(e[1]*r[2]*r[3]/s)]}),Mm,Um,gf,yf=O(()=>{Y(),ut(),j(),qe(),_i(),Mm=(e,r)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[0,4,0]:[0,4],cacheKey:r.activationCacheKey}),Um=(e,r,i,s,c)=>{let n=i[0].dims,a=i[1].dims,h=[a[0],Math.ceil(n[1]*a[2]*a[3]/4)],p=Ii(n,a,s),[t,u]=e.calculateTextureWidthAndHeight(h,4),l=B.computeStrides(p),[f,x]=e.calculateTextureWidthAndHeight(p,4),I=s.length,R=i.length<3?"0.0":"_B(b)",A=Math.ceil(n[1]*a[2]*a[3]/4),{activationFunction:Z,applyActivation:K}=he(c),Q=G(e.session.backend.glContext.version),re=`
${Z}
float process(int indices[${I}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${l[0]} + im2col[1] * ${l[1]} + im2col[2] * ${l[2]};
  int kernelOffset = indices[1] * ${h[1]};
  float value = ${R};
  for (int i = 0; i < ${A}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${f}, ${x});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${t}, ${u});
    value += dot(${Q.texture2D}(Im2Col, im2colCoords), ${Q.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${K}
  return value;
}`;return{...r,output:{dims:s,type:i[0].type,textureType:0},shaderSource:re}},gf=(e,r,i,s)=>{let c=Mm(r.length>2,s);return{...c,get:()=>Um(e,c,r,i,s)}}}),dr,Oi,Vm,zm,Wm,Hm,Si,qm,Bn=O(()=>{It(),Y(),lf(),mf(),yf(),qe(),_i(),Fn(),dr=(e,r,i,s,c)=>{let n=e[0],a=e.slice(2),h=a.length,p=r[0],t=r.slice(2).map((l,f)=>l+(l-1)*(i[f]-1)),u=a.map((l,f)=>l+s[f]+s[f+h]).map((l,f)=>Math.floor((l-t[f]+c[f])/c[f]));return[n,p].concat(...u)},Oi=(e,r,i)=>(qm(r,i),Vm(e,r,i)),Vm=(e,r,i)=>{let s=Hm(i,r),c=e.session.pack,n=s.kernelShape[0]===1&&s.kernelShape[1]===1;return s.group>1?[e.run(uf(e,r,s),r)]:n&&c?[zm(e,r,s)]:c&&r[0].dims.length===4&&r[0].dims[0]===1&&!n?[hf(e,r,s)]:[Wm(e,r,s)]},zm=(e,r,i)=>{let s=r[0].dims,c=r[1].dims,n=dr(s,c,i.dilations,i.pads,i.strides),a=e.reshapeUnpacked(r[0],[s[1],s[2]*s[3]]),h=e.reshapeUnpacked(r[1],[c[0],c[1]]),p=r.length>2?[h,a,r[2]]:[h,a],t=e.run(Ti(p,i),p);return e.reshapeUnpacked(t,n)},Wm=(e,r,i)=>{let s=r[0].dims,c=r[1].dims,n=dr(s,c,i.dilations,i.pads,i.strides),a=e.run(bf(e,r[0],r[1],n,i),[r[0]]),h=r.length===3?[a,r[1],r[2]]:[a,r[1]];return e.run(gf(e,r,n,i),h)},Hm=(e,r)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let n=2;n<r[1].dims.length;++n)i.push(r[1].dims[n]);let s=e.pads.slice();Ue.adjustPadsBasedOnAutoPad(r[0].dims,e.strides,e.dilations,i,s,e.autoPad);let c=Object.assign({},e);return Object.assign(c,{kernelShape:i,pads:s,cacheKey:e.cacheKey}),c},Si=e=>{let r=e.attributes,i=pr(r),s=r.getString("auto_pad","NOTSET"),c=r.getInts("dilations",[1,1]),n=r.getInt("group",1),a=r.getInts("kernel_shape",[]),h=r.getInts("pads",[0,0,0,0]),p=r.getInts("strides",[1,1]);return W({autoPad:s,dilations:c,group:n,kernelShape:a,pads:h,strides:p,...i})},qm=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],s=e[1].dims[1]*r.group;if(i!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let c=e[0].dims.length-2;if(r.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(r.strides.length!==c)throw new Error(`strides should be ${c}D`);if(r.pads.length!==c*2)throw new Error(`pads should be ${c*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),jm,Xm,Km,xf,Jm,Ym,Zm,Qm,tb,eb,Tf,rb,wf=O(()=>{It(),ut(),j(),qe(),jm=(e,r,i,s,c,n)=>(e-1)*r+i+(s-1)*c+1-n,Xm=(e,r,i,s,c)=>{let n=Math.floor(e/2);r==="SAME_UPPER"?(i[s]=n,i[c]=e-n):r==="SAME_LOWER"&&(i[s]=e-n,i[c]=n)},Km=(e,r,i,s,c,n,a,h)=>{let p=e.length-2,t=h.length===0;for(let u=0;u<p;++u){let l=t?e[u+2]*n[u]:h[u],f=jm(e[u+2],n[u],c[u],r[u],i[u],l);Xm(f,s,c,u,u+p),t&&h.push(n[u]*(e[u+2]-1)+a[u]+(r[u]-1)*i[u]+1-c[u]-c[u+p])}},xf=(e,r,i)=>(rb(r,i),Jm(e,r,i)),Jm=(e,r,i)=>{let s=eb(i,r);return[tb(e,r,s)]},Ym=(e,r)=>({name:"ConvTranspose",inputNames:e?["X","W","B"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),Zm=(e,r,i,s)=>{let c=r.length>2?"getB(output_channel)":"0.0",n=r[0].dims,a=r[1].dims,h=a[1],p=a[0]/s.group,t=[r[0].dims[0],r[1].dims[1]*s.group,...s.outputShape],u=G(e.session.backend.glContext.version),{activationFunction:l,applyActivation:f}=he(s),x=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${l}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${h};
    int wOutChannel = output_channel - group_id * ${h};

    float value = ${c};
    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {
      int input_channel = group_id * ${p} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${s.dilations[0]}, wHOff * ${s.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${n[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${n[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${f}
    ${u.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:t,type:r[0].type,textureType:0},shaderSource:x,hasMain:!0}},Qm=(e,r,i)=>{let s=Ym(r.length>2,i.cacheKey);return{...s,get:()=>Zm(e,r,s,i)}},tb=(e,r,i)=>e.run(Qm(e,r,i),r),eb=(e,r)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let h=2;h<r[1].dims.length;++h)i.push(r[1].dims[h]);let s=e.pads.slice(),c=e.outputShape.slice(),n=r[0].dims;Km(n,i,e.dilations,e.autoPad,s,e.strides,e.outputPadding,c);let a=Object.assign({},e);return Object.assign(a,{kernelShape:i,pads:s,outputShape:c,cacheKey:e.cacheKey}),a},Tf=e=>{let r=e.attributes,i=pr(r),s=r.getString("auto_pad","NOTSET"),c=r.getInts("dilations",[1,1]),n=r.getInt("group",1),a=r.getInts("kernel_shape",[]),h=r.getInts("output_padding",[0,0]),p=r.getInts("output_shape",[]),t=r.getInts("pads",[0,0,0,0]),u=r.getInts("strides",[1,1]);return W({autoPad:s,dilations:c,group:n,kernelShape:a,outputPadding:h,outputShape:p,pads:t,strides:u,...i})},rb=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],s=e[1].dims[0];if(i!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let c=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==c))throw new Error("invalid bias");let n=e[0].dims.length-2;if(r.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(r.strides.length!==n)throw new Error(`strides should be ${n}D`);if(r.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(r.outputPadding.length!==n)throw new Error(`output_padding should be ${n}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),vf,je,If,nb,_f,ob,ib,ab,Nn=O(()=>{It(),Y(),j(),vf={name:"Transpose",inputNames:["A"],inputTypes:[0]},je=(e,r,i)=>(ab(r),[e.run({...vf,cacheHint:i.cacheKey,get:()=>nb(e,r[0],i.perm)},r)]),If=e=>W({perm:e.attributes.getInts("perm",[])}),nb=(e,r,i)=>{let s=r.dims;i=_f(s,i);let c=ob(s,i),n=s.length,a=`
      ${ib("perm",i,n)}
      float process(int indices[${n}]) {
        int a[${n}];
        perm(a, indices);
        return _A(a);
      }`;return{...vf,output:{dims:c,type:r.type,textureType:0},shaderSource:a}},_f=(e,r)=>(r&&r.length!==e.length&&(r=[...e.keys()].reverse()),r),ob=(e,r)=>(r=_f(e,r),B.sortBasedOnPerm(e,r)),ib=(e,r,i)=>{let s=[];s.push(`void ${e}(out int a[${i}], int src[${i}]) {`);for(let c=0;c<i;++c)s.push(`	a[${r[c]}]=src[${c}];`);return s.push("	}"),s.join(`
`)},ab=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}}),Of,Sf,sb,Af=O(()=>{Nn(),Of=(e,r,i)=>{sb(r);let s=i.blocksize,c=s*s,n=i.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],a=i.mode==="DCR"?[r[0].dims[0],s,s,r[0].dims[1]/c,r[0].dims[2],r[0].dims[3]]:[r[0].dims[0],r[0].dims[1]/c,s,s,r[0].dims[2],r[0].dims[3]],h=e.reshapeUnpacked(r[0],a),p={perm:n,cacheKey:`${n}`},[t]=je(e,[h],p),u=[r[0].dims[0],r[0].dims[1]/c,r[0].dims[2]*s,r[0].dims[3]*s];return[e.reshapeUnpacked(t,u)]},Sf=e=>{let r=e.attributes.getInt("blocksize");if(r<1)throw new Error(`blocksize must be >= 1, but got : ${r} for DepthToSpace`);let i=e.attributes.getString("mode","DCR");if(i!=="DCR"&&i!=="CRD")throw new Error(`unrecognized mode: ${i} for DepthToSpace`);return{mode:i,blocksize:r}},sb=e=>{if(e.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if(e[0].type==="string"||e[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Pf,Ef,ub,Df=O(()=>{Y(),Pf=(e,r,i)=>{ub(r,i);let s=B.flattenShape(r[0].dims,i);return[e.reshapeUnpacked(r[0],s)]},Ef=e=>e.attributes.getInt("axis",1),ub=(e,r)=>{if(!e||e.length!==1)throw new Error("Flatten requires 1 input.");let i=e[0].dims.length;if(i===0)throw new Error("scalar tensor is not supported.");if(r<-i||r>i)throw new Error("Invalid axis");if(e[0].type==="string")throw new Error("string tensor is not supported.")}}),Pe,Rr=O(()=>{Pe=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),Lf,$f,lb,fb,cb,pb,kf=O(()=>{It(),Rr(),Y(),j(),Lf=(e,r,i)=>(pb(r,i.axis),[e.run(cb(e,r,i),r)]),$f=e=>W({axis:e.attributes.getInt("axis",0)}),lb={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},fb=(e,r,i,s)=>{let c=i[0].dims.slice(),n=i[1].dims.slice(),a=new Array(c.length+n.length-1);s=B.normalizeAxis(s,c.length);let h=[];for(let f=0;f<a.length;f++)f<s?(a[f]=c[f],h.push(`inputIdx[${f}] = outputIdx[${f}];`)):f<s+n.length?(a[f]=n[f-s],h.push(`indexDataIdx[${f-s}] = outputIdx[${f}];`)):(a[f]=c[f-n.length+1],h.push(`inputIdx[${f-n.length+1}] = outputIdx[${f}];`));let p=a.length||1,t=c.length,u=n.length||1,l=`
      float process(int outputIdx[${p}]) {
        int inputIdx[${t}];
        int indexDataIdx[${u}];
        indexDataIdx[0] = 0;
        ${h.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${s}] = idx < 0 ? idx + ${c[s]} : idx;
        return _A(inputIdx);
      }`;return{...r,output:{dims:a,type:i[0].type,textureType:0},shaderSource:l}},cb=(e,r,i)=>{let s={...lb,cacheHint:i.cacheKey};return{...s,get:()=>fb(e,s,r,i.axis)}},pb=(e,r)=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.");let i=e[0].dims.length;if(i<1)throw new Error("Invalid input shape.");if(r<-i||r>i-1)throw new Error("Invalid axis.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invaid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invaid input type.")}}),Ai,Bf,Ff,Cf,db,hb,mb,Nf=O(()=>{It(),Y(),j(),Ai=(e,r,i)=>(mb(r,i),[e.run(db(r,i),r)]),Bf=(e,r)=>{let i=e.attributes.getInt("transA",0)!==0,s=e.attributes.getInt("transB",0)!==0,c=e.attributes.getFloat("alpha",1),n=e.attributes.getFloat("beta",1);return W({transA:i,transB:s,alpha:c,beta:n,isOptionalC:r})},Ff=e=>Bf(e,!1),Cf=e=>Bf(e,!0),db=(e,r)=>{let i={name:"Gemm",inputNames:e.length===3?["A","B","C"]:["A","B"],inputTypes:e.length===3?[0,0,0]:[0,0],key:r.cacheKey};return{...i,get:()=>hb(i,e,r)}},hb=(e,r,i)=>{let s=r[0].dims.slice(),c=r[1].dims.slice(),[n,a]=Sn.getShapeOfGemmResult(s,i.transA,c,i.transB,r.length===3?r[2].dims:void 0),h=[n,a];if(!h)throw new Error("Can't use gemm on the given tensors");let p=s[s.length-1],t="";i.transA&&(p=s[0]),i.transA&&i.transB?t="value += _A_T(a) * _B_T(b);":i.transA&&!i.transB?t="value += _A_T(a) * _B(b);":!i.transA&&i.transB?t="value += _A(a) * _B_T(b);":!i.transA&&!i.transB&&(t="value += _A(a) * _B(b);");let u=h.length,l=r.length===3?`int c[${r[2].dims.length}];`:"",f=r.length===3?"bcastIndices_C(indices, c);":"",x=r.length===3?"value += beta * _C(c);":"",I=`
      float process(int indices[${u}]) {
          int a[${u}];
          int b[${u}];
          ${l}

          copyVec(indices, a);
          copyVec(indices, b);
          ${f}

          float value = 0.0;
          for (int k=0; k<${p}; ++k) {
              a[${u-1}] = k;
              b[${u-2}] = k;
              ${t}
          }

          value = value * alpha;
          ${x}
          return value;
      }`;return{...e,output:{dims:h,type:r[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:i.alpha},{name:"beta",type:"float",data:i.beta}],shaderSource:I}},mb=(e,r)=>{if(!e)throw new Error("Input is missing");if(r.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!r.isOptionalC&&e.length!==3)throw new Error("Gemm requires 3 inputs");if(e.length===3&&e[2].dims.length!==1&&e[2].dims.length!==2)throw new Error("Invalid input shape of C");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64"||e.length===3&&e[2].type!=="float32"&&e[2].type!=="float64")throw new Error("Invalid input type.");if(e[0].type!==e[1].type||e.length===3&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}}),Rf,Gf,bb,gb,yb,xb,Tb,Mf=O(()=>{It(),j(),Rf=(e,r,i)=>(Tb(r),[e.run(yb(e,r,i),r)]),Gf=e=>{let r=e.attributes.getFloat("scale"),i=e.attributes.getFloats("bias");return W({scale:r,bias:i})},bb={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},gb=(e,r,i,s)=>{let c=i[0].dims.slice(),n=c.length,a=`
      ${xb(s.bias.length)}
      float process(int indices[${n}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...r,output:{dims:c,type:i[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:s.bias.length,data:s.bias},{name:"scale",type:"float",data:s.scale}],shaderSource:a}},yb=(e,r,i)=>{let s={...bb,cacheHint:i.cacheKey};return{...s,get:()=>gb(e,s,r,i)}},xb=e=>{let r=[`float getBias(float bias[${e}], int channel) {`];for(let i=0;i<e;++i)i===0?r.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===e-1?r.push(`	else { return bias[${i}]; }`):r.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return r.push("	}"),r.join(`
`)},Tb=e=>{if(!e||e.length!==1)throw new Error("ImageScaler requires 1 input.");if(e[0].dims.length!==4)throw new Error("Invalid input shape.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")}}),Vf,zf,Uf,wb,vb,Ib,_b,Ob,Sb,Wf=O(()=>{ut(),j(),Vf=(e,r,i)=>{Sb(r);let s=e.run(vb(r[0]),r);return[e.run(Ob(e,r[0],i,s.dims),[r[0],s,r[1],r[2]])]},zf=e=>e.attributes.getFloat("epsilon",1e-5),Uf={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},wb=(e,r)=>{let i=r.dims.slice(),s=i[1],c=i[2]*i[3],n=[i[0],s],a=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${c});
        temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${c});

        return v;
      }`;return{...e,output:{dims:n,type:r.type,textureType:4},shaderSource:a}},vb=e=>({...Uf,get:()=>wb(Uf,e)}),Ib={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},_b=(e,r,i,s,c)=>{let n=G(e.session.backend.glContext.version),[a,h]=e.calculateTextureWidthAndHeight(c,4),[p,t]=[a/4,h],u=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${p}, ${t});
        return ${n.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...r,output:{dims:i.dims,type:i.type,textureType:0},variables:[{name:"epsilon",type:"float",data:s}],shaderSource:u}},Ob=(e,r,i,s)=>{let c={...Ib,cacheHint:`${i}`};return{...c,get:()=>_b(e,c,r,i,s)}},Sb=e=>{if(!e||e.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let r=e[0],i=e[1],s=e[2];if(r.dims.length<3||i.dims.length!==1||s.dims.length!==1)throw new Error("Invalid input shape.");if(i.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1])throw new Error("Input shapes are mismatched.");if(r.type!=="float32"&&r.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||s.type!=="float32"&&s.type!=="float64")throw new Error("Invalid input type.");if(e[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function Ab(e,r){let i=e[0].dims[1],s=e[0].dims.length,c=-Math.floor((r.size-1)/2),n=Math.ceil((r.size-1)/2),a=`float(${r.alpha}) / float(${r.size})`,h=`float(${r.bias})`,p=`float(${r.beta})`,t=`
    float process(int indices[${s}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${c}; i <= ${n}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${i}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${h} + ${a} * square_sum, ${p});
    }`;return{...jf,cacheHint:r.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:t}}function Pb(e,r){return{...jf,cacheHint:r.cacheKey,get:()=>Ab(e,r)}}var Hf,qf,jf,Eb,Xf=O(()=>{It(),j(),Hf=(e,r,i)=>(Eb(r),[e.run(Pb(r,i),r)]),qf=e=>{let r=e.attributes.getFloat("alpha",1e-4),i=e.attributes.getFloat("beta",.75),s=e.attributes.getFloat("bias",1),c=e.attributes.getInt("size");return W({alpha:r,beta:i,bias:s,size:c})},jf={name:"LRN",inputNames:["X"],inputTypes:[0]},Eb=e=>{if(!e||e.length!==1)throw new Error("LRN requires 1 input.");if(e[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(e[0].type!=="float32")throw new Error("input should be float type")}}),Db,Pi,Kf,Jf,Yf,Lb,$b,kb,Bb,Fb,Cb,Nb,Rb,Zf=O(()=>{It(),Y(),ut(),j(),Db={name:"Pad",inputNames:["A"],inputTypes:[0]},Pi=(e,r,i)=>(kb(r),[e.run({...Db,cacheHint:i.cacheKey,get:()=>$b(e,r[0],i)},r)]),Kf=e=>{let r=e.attributes.getString("mode","constant"),i=e.attributes.getFloat("value",0),s=e.attributes.getInts("pads");return W({mode:r,value:i,pads:s})},Jf=(e,r,i)=>{Bb(r);let s=Lb(e,r,i);return Pi(e,[r[0]],s)},Yf=e=>e.attributes.getString("mode","constant"),Lb=(e,r,i)=>{if(!e.session.isInitializer(r[1].dataId)||r.length>=3&&!e.session.isInitializer(r[2].dataId))throw new Error("dynamic pad attributes are not allowed");let s=Array.from(r[1].integerData),c=r.length>=3?r[2].floatData[0]:0;return W({mode:i,pads:s,value:c})},$b=(e,r,i)=>{let s=B.padShape(r.dims.slice(),i.pads),c=s.length,n=`
      ${Fb(e,r,i)}
      float process(int[${c}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:s,type:r.type,textureType:0},shaderSource:n}},kb=e=>{if(!e||e.length!==1)throw new Error("Pad requires 1 input");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},Bb=e=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(e[1].type!=="int32")throw new Error("Invalid input type.");if(e.length>=3&&e[2].type==="string")throw new Error("Invalid input type.")},Fb=(e,r,i)=>{let s=G(e.session.backend.glContext.version),[c,n]=e.calculateTextureWidthAndHeight(r.dims,0),a=B.computeStrides(r.dims);switch(i.mode){case"constant":return Cb(s,r.dims,a,c,n,i.pads,i.value);case"reflect":return Nb(s,r.dims,a,c,n,i.pads);case"edge":return Rb(s,r.dims,a,c,n,i.pads);default:throw new Error("Invalid mode")}},Cb=(e,r,i,s,c,n,a)=>{let h=r.length,p="";for(let t=h-1;t>=0;--t)p+=`
        k = m[${t}] - ${n[t]};
        if (k < 0)  return constant;
        if (k >= ${r[t]}) return constant;
        offset += k * ${i[t]};
        `;return`
      float padA(int m[${h}]) {
        const float constant = float(${a});
        int offset = 0;
        int k = 0;
        ${p}
        vec2 coords = offsetToCoords(offset, ${s}, ${c});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},Nb=(e,r,i,s,c,n)=>{let a=r.length,h="";for(let p=a-1;p>=0;--p)h+=`
        k = m[${p}] - ${n[p]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(r[p]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${r[p]}) { k = _2n_1 - k; }
        }
        offset += k * ${i[p]};
        `;return`
      float padA(int m[${a}]) {
        int offset = 0;
        int k = 0;
        ${h}
        vec2 coords = offsetToCoords(offset, ${s}, ${c});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},Rb=(e,r,i,s,c,n)=>{let a=r.length,h="";for(let p=a-1;p>=0;--p)h+=`
        k = m[${p}] - ${n[p]};
        if (k < 0)  k = 0;
        if (k >= ${r[p]}) k = ${r[p]-1};
        offset += k * ${i[p]};
      `;return`
      float padA(int m[${a}]) {
        int offset = 0;
        int k = 0;
        ${h}
        vec2 coords = offsetToCoords(offset, ${s}, ${c});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `}}),tc,ec,rc,nc,oc,ic,ac,sc,uc,Gb,Qf,lc,Gn,fc,Rn,Mb,cc=O(()=>{It(),Y(),j(),tc=(e,r,i)=>{Gn(r);let s={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...s,get:()=>rc(r,s,!1,i)},r)]},ec=e=>{let r=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInt("count_include_pad",0)!==0,c=e.attributes.getInts("kernel_shape"),n=e.attributes.getInts("strides",[]),a=e.attributes.getInts("pads",[]);if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return W({autoPad:r,ceilMode:i,countIncludePad:s,kernelShape:c,strides:n,pads:a})},rc=(e,r,i,s)=>{let[c,n]=uc(e,s,i),a=B.size(c.kernelShape),h="value += _X(x);",p="";c.countIncludePad?p+=`value /= float(${a});`:p+=`value /= float(${a} - pad);`;let t=`
        ${fc(e[0].dims,c,h,p,"0.0")}
      `;return{...r,output:{dims:n,type:e[0].type,textureType:0},shaderSource:t}},nc=(e,r,i)=>{Gn(r);let s={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${i.countIncludePad}`};return[e.run({...s,get:()=>rc(r,s,!0,i)},r)]},oc=e=>{let r=e.attributes.getInt("count_include_pad",0)!==0;return W({autoPad:"",ceilMode:0,countIncludePad:r,kernelShape:[],strides:[],pads:[]})},ic=(e,r,i)=>{Gn(r);let s={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...s,get:()=>sc(r,s,!1,i)},r)]},ac=e=>{let r=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInts("kernel_shape"),c=e.attributes.getInts("strides",[]),n=e.attributes.getInts("pads",[]),a=e.attributes.getInt("storage_order",0),h=e.attributes.getInts("dilations",[]);if(a!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return W({autoPad:r,ceilMode:i,countIncludePad:!1,kernelShape:s,strides:c,pads:n,storageOrder:a,dilations:h})},sc=(e,r,i,s)=>{let[c,n]=uc(e,s,i),a=`
      value = max(_X(x), value);
    `,h="",p=`
      ${fc(e[0].dims,c,a,h,"-1e5")}
    `;return{...r,output:{dims:n,type:e[0].type,textureType:0},shaderSource:p}},uc=(e,r,i)=>{let s=e[0].dims.slice(),c=Object.hasOwnProperty.call(r,"dilations"),n=r.kernelShape.slice(),a=r.strides.slice(),h=c?r.dilations.slice():[],p=r.pads.slice();Ue.adjustPoolAttributes(i,s,n,a,h,p);let t=Ue.computePoolOutputShape(i,s,a,h,n,p,r.autoPad),u=Object.assign({},r);return c?Object.assign(u,{kernelShape:n,strides:a,pads:p,dilations:h,cacheKey:r.cacheKey}):Object.assign(u,{kernelShape:n,strides:a,pads:p,cacheKey:r.cacheKey}),[u,t]},Gb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Qf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},lc=(e,r)=>(Gn(r),[e.run({...Qf,get:()=>sc(r,Qf,!0,Gb)},r)]),Gn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},fc=(e,r,i,s,c)=>{let n=e.length;if(r.kernelShape.length<=2){let a=r.kernelShape[r.kernelShape.length-1],h=r.strides[r.strides.length-1],p=r.pads[r.pads.length/2-1],t=r.pads[r.pads.length-1],u=e[n-1],l="",f="",x="";if(p+t!==0?l=`
          for (int i = 0; i < ${a}; i++) {
            x[${n} - 1] = indices[${n} - 1] * ${h} - ${p} + i;
            if (x[${n} - 1] < 0 || x[${n} - 1] >= ${u}) {
              pad++;
              continue;
            }
            ${i}
          }`:l=`
          for (int i = 0; i < ${a}; i++) {
            x[${n} - 1] = indices[${n} - 1] * ${h} - ${p} + i;
            ${i}
          }`,r.kernelShape.length===2){let I=r.kernelShape[r.kernelShape.length-2],R=r.strides[r.strides.length-2],A=r.pads[r.pads.length/2-2],Z=r.pads[r.pads.length-2],K=e[n-2];A+Z!==0?f=`
            for (int j = 0; j < ${I}; j++) {
              x[${n} - 2] = indices[${n} - 2] * ${R} - ${A} + j;
              if (x[${n} - 2] < 0 || x[${n} - 2] >= ${K}) {
                pad+= ${a};
                continue;
              }
          `:f=`
            for (int j = 0; j < ${I}; j++) {
              x[${n} - 2] = indices[${n} - 2] * ${R} - ${A} + j;
            `,x=`
          }
        `}return`
        float process(int indices[${n}]) {
          int x[${n}];
          copyVec(indices, x);

          float value = ${c};
          int pad = 0;
          ${f}
          ${l}
          ${x}
          ${s}
          return value;
        }
      `}else{let a=B.size(r.kernelShape),h=B.computeStrides(r.kernelShape),p=h.length,t=r.pads.length,u=Mb(p),l=Rn(e,"inputDims"),f=Rn(r.pads,"pads"),x=Rn(h,"kernelStrides"),I=Rn(r.strides,"strides"),R=r.pads.reduce((Z,K)=>Z+K),A="";return R?A=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${i}
          }`:A=`
          }
          ${i}
        `,`
        ${u}
        float process(int indices[${n}]) {
          int x[${n}];
          copyVec(indices, x);
          int offset[${p}];
          int pads[${t}];
          int inputDims[${n}];
          int kernelStrides[${p}];
          int strides[${p}];
          ${f}
          ${l}
          ${I}
          ${x}

          float value = ${c};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${a}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${n} - ${p}; j < ${n}; j++) {
              x[j] = indices[j] * strides[j - ${n} + ${p}]
                + offset[j - ${n} + ${p}] - pads[j - 2];
              ${A}
          }
          ${s}

          return value;
        }
      `}},Rn=(e,r)=>{let i="";for(let s=0;s<e.length;s++)i+=`
      ${r}[${s}] = ${e[s]};
    `;return i},Mb=e=>`
  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {
    if (${e} == 0) {
      return;
    }
    for (int i = 0; i < ${e} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e} - 1] = offset;
  }`}),Xe,Ee,Ub,Vb,pc,dc,hc,mc,bc,gc,yc,xc=O(()=>{It(),Rr(),Y(),j(),Xe=(e,r,i,s,c)=>{Vb(r);let n={name:s,inputNames:["A"],inputTypes:[0]};return[e.run({...n,cacheHint:i.cacheKey,get:()=>Ub(e,r,i,s,c,n)},r)]},Ee=e=>{let r=e.attributes.getInts("axes",[]),i=e.attributes.getInt("keepdims",1)===1;return W({axes:r,keepDims:i})},Ub=(e,r,i,s,c,n)=>{let a=[],h=r[0].dims.length||1,p=[],t=B.normalizeAxes(i.axes,r[0].dims.length),u=c(r,t),l=u[1];for(let x=0;x<r[0].dims.length;x++)t.indexOf(x)>=0||t.length===0?(i.keepDims&&a.push(1),l=`
          for(int j${x} = 0; j${x} < ${r[0].dims[x]}; j${x}++) {
            inputIdx[${x}] = j${x};
            ${l}
          }`):(p.push(`inputIdx[${x}] = outputIdx[${a.length}];`),a.push(r[0].dims[x]));let f=`
      float process(int outputIdx[${a.length||1}]) {
        float value;                 // final result
        int inputIdx[${h}];      // addressing input data
        ${p.join(`
`)}
        ${u[0]}       // init ops for reduce max/min
        ${l}
        ${u[2]}       // final computation for reduce mean
        return value;
      }`;return{...n,output:{dims:a,type:r[0].type,textureType:0},shaderSource:f}},Vb=e=>{if(!e||e.length!==1)throw new Error("Reduce op requires 1 input.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},pc=(e,r,i)=>Xe(e,r,i,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),dc=(e,r,i)=>Xe(e,r,i,"ReduceMean",(s,c)=>{let n=1;for(let a=0;a<s[0].dims.length;a++)(c.indexOf(a)>=0||c.length===0)&&(n*=s[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]}),hc=(e,r,i)=>Xe(e,r,i,"ReduceMax",(s,c)=>{let n=[];for(let a=0;a<s[0].dims.length;a++)(c.indexOf(a)>=0||c.length===0)&&n.push(`inputIdx[${a}] = 0;`);return[`${n.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),mc=(e,r,i)=>Xe(e,r,i,"ReduceMin",(s,c)=>{let n=[];for(let a=0;a<s[0].dims.length;a++)(c.indexOf(a)>=0||c.length===0)&&n.push(`inputIdx[${a}] = 0;`);return[`${n.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),bc=(e,r,i)=>Xe(e,r,i,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),gc=(e,r,i)=>Xe(e,r,i,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),yc=(e,r,i)=>Xe(e,r,i,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),Tc,wc=O(()=>{Y(),Tc=(e,r)=>{let i=B.calculateReshapedDims(r[0].dims,r[1].integerData);return e.session.pack?[e.reshapePacked(r[0],i)]:[e.reshapeUnpacked(r[0],i)]}}),vc,Ei,Ic,_c,Gr,zb,Di,Mn,Li=O(()=>{It(),ut(),j(),vc={name:"Upsample",inputNames:["X"],inputTypes:[0]},Ei=(e,r,i)=>(Di(r,i),[e.run({...vc,cacheHint:i.cacheKey,get:()=>zb(e,r,i)},r)]),Ic=e=>Gr(e,7),_c=e=>Gr(e,9),Gr=(e,r)=>{let i=r>=10,s=e.attributes.getString("mode","nearest");if(s!=="nearest"&&s!=="linear"&&(r<11||s!=="cubic"))throw new Error(`unrecognized mode: ${s}`);let c=[];r<9&&(c=e.attributes.getFloats("scales"),Mn(c,s,i));let n=e.attributes.getFloat("extrapolation_value",0),a=r>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(a)===-1)throw new Error(`coordinate_transform_mode '${a}' is not supported`);let h=a==="tf_crop_and_resize",p=h,t=s==="nearest"&&r>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(t)===-1)throw new Error(`nearest_mode '${t}' is not supported`);let u=e.attributes.getFloat("cubic_coeff_a",-.75),l=e.attributes.getInt("exclude_outside",0)!==0;if(l&&s!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let f=r<11?!0:s==="nearest"&&a==="asymmetric"&&t==="floor",x=0,I=0,R=0;return r>10?e.inputs.length>2?(x=1,I=2,R=3):(I=1,R=2):r===9&&(I=1),W({opset:r,isResize:i,mode:s,scales:c,extrapolationValue:n,coordinateTransformMode:a,useExtrapolation:p,needRoiInput:h,nearestMode:t,cubicCoefficientA:u,excludeOutside:l,useNearest2xOptimization:f,roiInputIdx:x,scalesInputIdx:I,sizesInputIdx:R})},zb=(e,r,i)=>{let s=G(e.session.backend.glContext.version),[c,n]=e.calculateTextureWidthAndHeight(r[0].dims,0),a=r[0].dims.map((R,A)=>Math.floor(R*i.scales[A])),[h,p]=e.calculateTextureWidthAndHeight(a,0),t=a.length,u=new Array(t),l=new Array(t),f=`
      int output_pitches[${t}];
      int input_pitches[${t}];
      `;for(let R=t-1;R>=0;R--)u[R]=R===t-1?1:u[R+1]*a[R+1],l[R]=R===t-1?1:l[R+1]*r[0].dims[R+1],f+=`
        output_pitches[${R}] = ${u[R]};
        input_pitches[${R}] = ${l[R]};
        `;let x=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${c}, ${n});
        float value = getColorAsFloat(${s.texture2D}(X, coords));
        return value;
      }
      `,I=i.mode==="nearest"?`
    ${x}
    float process(int indices[${t}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${h}, ${p});

      ${f}

      int d, m;
      for (int dim = 0; dim < ${t}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:t===4?`
    ${x}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${h}, ${p});

      ${f}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${r[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${x}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${h}, ${p});

      ${f}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${r[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...vc,output:{dims:a,type:r[0].type,textureType:0},shaderSource:I,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(R=>Math.ceil(R))}]}},Di=(e,r)=>{if(!e||r.opset<9&&e.length!==1||r.opset>=9&&r.opset<11&&e.length!==2||r.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(r.scales.length>0&&e[0].dims.length!==r.scales.length)throw new Error("Invalid input shape.");if(e[0].type==="string")throw new Error("Invalid input tensor types.")},Mn=(e,r,i)=>{if(i){for(let s of e)if(s<=0)throw new Error("Scale value should be greater than 0.")}else for(let s of e)if(s<1)throw new Error("Scale value should be greater than or equal to 1.");if((r==="linear"||r==="cubic")&&e.length!==2&&(e.length!==4||e[0]!==1||e[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}}),$i,ki,Oc,Sc,Wb,Hb,qb,jb,Ac=O(()=>{ut(),j(),pe(),He(),Li(),$i={name:"Resize",inputNames:["A"],inputTypes:[2]},ki=(e,r,i)=>(Di(r,i),[e.run({...$i,cacheHint:i.cacheKey,get:()=>Wb(e,r,i)},r)]),Oc=e=>Gr(e,10),Sc=e=>Gr(e,11),Wb=(e,r,i)=>{let s=G(e.session.backend.glContext.version),[c,n]=Hb(r,i);if(c.every(K=>K===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return{...$i,output:{dims:n,type:r[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${s.texture2D}(X, TexCoords);
                    ${s.output} = v;
                }`};let a=n.length;if(a<2)throw new Error(`output dimension should be at least 2, but got ${a}`);let h=n[a-2],p=n[a-1],t=r[0].dims;if(a!==t.length)throw new Error(`output dimension should match input ${t.length}, but got ${a}`);let u=t[a-2],l=t[a-1],f=c[a-2],x=c[a-1],I="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${p}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${p}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${p}.0 - 1.0, ${h}.0 - 1.0, ${p}.0 - 1.0,
                            ${h}.0 - 1.0);
                        vec4 original = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let R=Bt(a),A=de(),Z=`
            const vec2 inputWH = vec2(${u}.0, ${l}.0);
            const vec4 scaleWHWH = vec4(float(${f}), float(${x}), float(${f}), float(${x}));
            ${A}
            ${I}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${R} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${h-1};
                bool hasNextCol = rc.z < ${p-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s.output} = vec4(newValue);
            }
        `;return{...$i,output:{dims:n,type:r[0].type,textureType:2},hasMain:!0,shaderSource:Z}},Hb=(e,r)=>{let i=e[0].dims,s=r.scales,c;if(s.length===0){let a=e[r.scalesInputIdx];if(a&&a.size!==0){if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=qb(a,r.mode,r.isResize)}else{let h=e[r.sizesInputIdx];if(!h||h.size===0)throw new Error("Either scales or sizes MUST be provided as input.");c=Array.from(h.integerData),s=jb(c,i,r.mode,r.isResize)}}else if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let n=c||i.map((a,h)=>Math.floor(a*s[h]));return[s,n]},qb=(e,r,i)=>{let s=Array.from(e.floatData);return Mn(s,r,i),s},jb=(e,r,i,s)=>{let c=r.length,n=new Array(c);for(let a=0,h=c;a<h;a++)if(r[a]===0){if(e[a]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");n[a]=1}else n[a]=e[a]/r[a];return Mn(n,i,s),n}}),Pc,Xb,Ec=O(()=>{We(),Pc=(e,r)=>(Xb(r),[new bt([r[0].dims.length],"int32",void 0,void 0,new Int32Array(r[0].dims))]),Xb=e=>{if(!e||e.length!==1)throw new Error("Shape requires 1 input.")}}),Bi,Dc,Lc,$c,Kb,kc,Jb,Yb,Bc=O(()=>{It(),Rr(),Y(),j(),Bi={name:"Slice",inputNames:["A"],inputTypes:[0]},Dc=(e,r,i)=>(Kb(r),[e.run({...Bi,cacheHint:i.cacheKey,get:()=>$c(e,r[0],i)},r)]),Lc=e=>{let r=e.attributes.getInts("starts"),i=e.attributes.getInts("ends"),s=e.attributes.getInts("axes",[]);return W({starts:r,ends:i,axes:s})},$c=(e,r,i)=>{let s=i.axes.length===0?r.dims.slice(0).map((u,l)=>l):i.axes,c=B.normalizeAxes(s,r.dims.length),n=i.starts.map((u,l)=>u>r.dims[c[l]]-1?r.dims[c[l]]:B.normalizeAxis(u,r.dims[c[l]])),a=i.ends.map((u,l)=>u>r.dims[c[l]]-1?r.dims[c[l]]:B.normalizeAxis(u,r.dims[c[l]])),h=r.dims.slice(),p=[];for(let u=0;u<c.length;u++)h[c[u]]=a[u]-n[u],n[u]>0&&p.push(`outputIdx[${c[u]}] += ${n[u]};`);let t=`
      float process(int outputIdx[${h.length}]) {
        ${p.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Bi,output:{dims:h,type:r.type,textureType:0},shaderSource:t}},Kb=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},kc=(e,r)=>{Yb(r);let i=Jb(e,r);return[e.run({...Bi,cacheHint:i.cacheKey,get:()=>$c(e,r[0],i)},[r[0]])]},Jb=(e,r)=>{if(!e.session.isInitializer(r[1].dataId)||!e.session.isInitializer(r[2].dataId)||r.length>=4&&!e.session.isInitializer(r[3].dataId)||r.length>=5&&!e.session.isInitializer(r[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(r.length>=5&&r[4].integerData.some(a=>a!==1))throw new Error("currently non-1 steps is not supported for Slice");let i=Array.from(r[1].integerData),s=Array.from(r[2].integerData),c=r.length>=4?Array.from(r[3].integerData):[],n=`${c};${i};${s}`;return{starts:i,ends:s,axes:c,cacheKey:n}},Yb=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}}),Fc,Cc,Nc,Rc,Gc,Mc,Uc,Vc,Zb,Qb,tg,zc,Wc=O(()=>{It(),Y(),ut(),j(),Nn(),Fc={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Cc={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Nc={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Rc=(e,r,i)=>{zc(r);let s=r[0].dims.slice(),c=B.normalizeAxis(i.axis,s.length),n=B.sizeToDimension(s,c),a=B.sizeFromDimension(s,c);return Vc(e,r,i,n,a)},Gc=e=>W({axis:e.attributes.getInt("axis",1)}),Mc=e=>W({axis:e.attributes.getInt("axis",-1)}),Uc=(e,r,i)=>{zc(r);let s=r[0].dims.slice(),c=B.normalizeAxis(i.axis,s.length),n=s.length,a=c!==n-1,h=[],p=[],t=[],u;a&&(p=Array.from({length:n}).map((I,R)=>R),p[c]=n-1,p[n-1]=c,p.map(I=>h.push(s[I])),u=W({perm:p}),t=je(e,r,u));let l=a?B.sizeToDimension(h,n-1):B.sizeToDimension(s,n-1),f=a?B.sizeFromDimension(h,n-1):B.sizeFromDimension(s,n-1),x=Vc(e,a?t:r,i,l,f);return a?je(e,x,u):x},Vc=(e,r,i,s,c)=>{let n=Zb(e,r[0],s,c,[s]),a=e.run({...Fc,cacheHint:i.cacheKey,get:()=>n},r),h=Qb(e,r[0],s,c,n.output.dims,[s]),p=e.run({...Cc,cacheHint:i.cacheKey,get:()=>h},[r[0],a]),t=tg(e,r[0],s,c,n.output.dims,h.output.dims);return[e.run({...Nc,cacheHint:i.cacheKey,get:()=>t},[r[0],a,p])]},Zb=(e,r,i,s,c)=>{let[n,a]=e.calculateTextureWidthAndHeight(r.dims,0),h=c.length;if(i<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(c.length!==1)throw new Error("Dimensionality of the output should be 1");if(c[0]!==i)throw new Error("Shape of the output should be equal to logical row count");let p=G(e.session.backend.glContext.version),t=`
      float process(int[${h}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n},
        ${a} )));
        for(int i=1; i<${s}; ++i)
        {
          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${n}, ${a})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Fc,output:{dims:c,type:r.type,textureType:0},shaderSource:t}},Qb=(e,r,i,s,c,n)=>{let[a,h]=e.calculateTextureWidthAndHeight(r.dims,0),p=n.length;if(i<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(n.length!==1)throw new Error("Dimensionality of the output should be 1");if(n[0]!==i)throw new Error("Shape of the output should be equal to logical row count");if(c.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(c[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let t=G(e.session.backend.glContext.version),u=`
      float process(int[${p}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${s}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${t.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${a}, ${h}))) - max);
        }

        return norm_factor;
      }`;return{...Cc,output:{dims:n,type:r.type,textureType:0},shaderSource:u}},tg=(e,r,i,s,c,n)=>{let[a,h]=e.calculateTextureWidthAndHeight(r.dims,0),p=r.dims.length;if(i<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(c.length!==1||n.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(c[0]!==i||n[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let t=`
      float process(int[${p}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${a}, ${h});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${s};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Nc,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:t}},zc=e=>{if(!e||e.length!==1)throw new Error("Softmax requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type")}}),Hc,qc,jc,eg,rg,ng,Xc=O(()=>{It(),Y(),j(),Hc={name:"Split",inputNames:["A"],inputTypes:[0]},qc=(e,r,i)=>{ng(r);let s=B.normalizeAxis(i.axis,r[0].dims.length),c=eg(e,r,s,i),n=[];for(let a=0;a<c;++a)n.push(e.run({...Hc,cacheHint:`${i.cacheKey};${a}`,get:()=>rg(e,r[0],i,s,a)},r));return n},jc=e=>{let r=e.attributes.getInt("axis",0),i=e.attributes.getInts("split",[]),s=e.outputs.length;return W({axis:r,split:i,numOutputs:s})},eg=(e,r,i,s)=>{let[,c]=$r.splitShape(r[0].dims,i,s.split,s.numOutputs);return c.length},rg=(e,r,i,s,c)=>{let[n,a]=$r.splitShape(r.dims,s,i.split,i.numOutputs),h=a[c],p=n[c],t=`
      float process(int indices[${p.length}]) {
        indices[${s}] += ${h};
        return _A(indices);
      }
    `;return{...Hc,cacheHint:`${i.cacheKey}:${c}`,output:{dims:p,type:r.type,textureType:0},shaderSource:t}},ng=e=>{if(!e||e.length!==1)throw new Error("Split requires one input.");if(e[0].type!=="int8"&&e[0].type!=="uint8"&&e[0].type!=="int16"&&e[0].type!=="uint16"&&e[0].type!=="int32"&&e[0].type!=="uint32"&&e[0].type!=="float32"&&e[0].type!=="float64"&&e[0].type!=="bool")throw new Error("Invalid input type.")}}),Fi,Kc,Jc,og,ig,Yc=O(()=>{Y(),Fi=(e,r,i)=>{og(r);let s=B.squeezeShape(r[0].dims,i);return[e.reshapeUnpacked(r[0],s)]},Kc=(e,r)=>(ig(r),Fi(e,[r[0]],Array.from(r[1].integerData))),Jc=e=>e.attributes.getInts("axes"),og=e=>{if(!e||e.length!==1)throw new Error("Squeeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},ig=e=>{if(!e||e.length!==2)throw new Error("Squeeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),Zc,ag,sg,Qc=O(()=>{ut(),j(),Zc=(e,r)=>{sg(r);let i={name:"Sum",inputNames:r.map((s,c)=>`X${c}`),inputTypes:new Array(r.length).fill(0)};return[e.run({...i,get:()=>ag(e,r,i)},r)]},ag=(e,r,i)=>{let s=G(e.session.backend.glContext.version),c=r[0].dims.slice(),n=`
      void main() {
        vec4 result = ${r.map((a,h)=>`${s.texture2D}(X${h},TexCoords)`).join(" + ")};
        ${s.output} = result;
      }
    `;return{...i,output:{dims:c,type:r[0].type,textureType:0},hasMain:!0,shaderSource:n}},sg=e=>{if(!e||e.length===0)throw new Error("Sum requires inputs.");let r=e[0].dims.length;for(let i=1;i<e.length;i++){if(r!==e[i].dims.length)throw new Error("Input shapes are mismatched.");for(let s=0;s<r;s++)if(e[0].dims[s]!==e[i].dims[s])throw new Error("Input shapes are not matched.")}if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.");for(let i=1;i<e.length;i++)if(e[0].type!==e[i].type)throw new Error("Input types are not matched.")}}),tp,ug,lg,ep=O(()=>{Rr(),j(),tp=(e,r)=>{lg(r);let i={name:"Tile",inputNames:["A"],inputTypes:[0]};return[e.run({...i,get:()=>ug(e,r,i)},r)]},ug=(e,r,i)=>{let s=r[0].dims.slice(),c=new Array(s.length),n=[];for(let p=0;p<s.length;p++)c[p]=s[p]*r[1].numberData[p],n.push(`inputIdx[${p}] = int(mod(float(outputIdx[${p}]), ${s[p]}.));`);let a=c.length,h=`
      float process(int outputIdx[${a}]) {
        int inputIdx[${a}];
        ${n.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...i,output:{dims:c,type:r[0].type,textureType:0},shaderSource:h}},lg=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 input.");if(e[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invalid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Ci,rp,np,fg,cg,op=O(()=>{Y(),Ci=(e,r,i)=>{fg(r);let s=B.unsqueezeShape(r[0].dims,i);return[e.reshapeUnpacked(r[0],s)]},rp=(e,r)=>(cg(r),Ci(e,[r[0]],Array.from(r[1].integerData))),np=e=>e.attributes.getInts("axes"),fg=e=>{if(!e||e.length!==1)throw new Error("Unsqueeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},cg=e=>{if(!e||e.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),ip,ap=O(()=>{ml(),Pl(),Ll(),Nl(),Bn(),wf(),Af(),Df(),kf(),Nf(),Mf(),Wf(),Xf(),Fn(),Zf(),cc(),xc(),wc(),Ac(),Ec(),Bc(),Wc(),Xc(),Yc(),Qc(),ep(),Nn(),xi(),op(),Li(),ip=[["Abs","","6+",Rl],["Acos","","7+",Gl],["Add","","7+",bl],["And","","7+",gl],["Asin","","7+",Ml],["Atan","","7+",Ul],["AveragePool","","7+",tc,ec],["BatchNormalization","","7+",dl,hl],["Cast","","6+",El,Dl],["Ceil","","6+",Wl],["Clip","","6-10",gi,Vl],["Clip","","11+",zl],["Concat","","4+",Bl,Cl],["Conv","","1+",Oi,Si],["ConvTranspose","","1+",xf,Tf],["Cos","","7+",Hl],["Div","","7+",yl],["Dropout","","7+",yi],["DepthToSpace","","1+",Of,Sf],["Equal","","7+",xl],["Elu","","6+",ql,jl],["Exp","","6+",Xl],["Flatten","","1+",Pf,Ef],["Floor","","6+",Kl],["FusedConv","com.microsoft","1+",Oi,Si],["Gather","","1+",Lf,$f],["Gemm","","7-10",Ai,Ff],["Gemm","","11+",Ai,Cf],["GlobalAveragePool","","1+",nc,oc],["GlobalMaxPool","","1+",lc],["Greater","","7+",Tl],["Identity","","1+",yi],["ImageScaler","","1+",Rf,Gf],["InstanceNormalization","","6+",Vf,zf],["LeakyRelu","","6+",Jl,Yl],["Less","","7+",wl],["LRN","","1+",Hf,qf],["Log","","6+",Zl],["MatMul","","1+",pf,df],["MaxPool","","1+",ic,ac],["Mul","","7+",vl],["Neg","","6+",Ql],["Not","","1+",tf],["Or","","7+",Il],["Pad","","2-10",Pi,Kf],["Pad","","11+",Jf,Yf],["Pow","","7+",_l],["PRelu","","7+",Ol],["ReduceLogSum","","1+",gc,Ee],["ReduceMax","","1+",hc,Ee],["ReduceMean","","1+",dc,Ee],["ReduceMin","","1+",mc,Ee],["ReduceProd","","1+",bc,Ee],["ReduceSum","","1-12",pc,Ee],["ReduceSumSquare","","1+",yc,Ee],["Relu","","6+",ef],["Reshape","","5+",Tc],["Resize","","10",ki,Oc],["Resize","","11+",ki,Sc],["Shape","","1+",Pc],["Sigmoid","","6+",rf],["Sin","","7+",nf],["Slice","","10+",kc],["Slice","","1-9",Dc,Lc],["Softmax","","1-12",Rc,Gc],["Softmax","","13+",Uc,Mc],["Split","","2-12",qc,jc],["Sqrt","","6+",of],["Squeeze","","1-12",Fi,Jc],["Squeeze","","13+",Kc],["Sub","","7+",Sl],["Sum","","6+",Zc],["Tan","","7+",af],["Tanh","","6+",sf],["Tile","","6+",tp],["Transpose","","1+",je,If],["Upsample","","7-8",Ei,Ic],["Upsample","","9",Ei,_c],["Unsqueeze","","1-12",Ci,np],["Unsqueeze","","13+",rp],["Xor","","7+",Al]]});function up(e){let r={},i;for(;(i=sp.exec(e))!==null;){let s=i[3].split(",").map(c=>{let n=c.trim().split(" ");return n&&n.length===2?{type:n[0],name:n[1]}:null}).filter(c=>c!==null);r[i[2]]={params:s,body:i[4]}}for(let s in r){let c=pg.replace("__FUNC__",s),n=new RegExp(c,"gm");for(;(i=n.exec(e))!==null;){let a=i[1],h=i[2],p=i[3].split(","),t=a?`${a} ${h};`:"",u=r[s].body,l="";r[s].params.forEach((x,I)=>{x&&(l+=`${x.type} ${x.name} = ${p[I]};
`)}),u=`${l}
 ${u}`,u=u.replace("return",`${h} = `);let f=`
      ${t}
      {
        ${u}
      }
      `;e=e.replace(i[0],f)}}return e=e.replace(sp,""),e}var sp,pg,lp=O(()=>{sp=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,pg="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function hr(e,r){let i=[],s=[];for(let c=0;c<e.length;++c)e[c]!==1&&(i.push(e[c]),s.push(c));return{newShape:i,keptDims:s}}function mg(e){if(e.length===0)return 1;let r=e[0];for(let i=1;i<e.length;i++)r*=e[i];return r}function fp(e){let r=Math.ceil(Math.sqrt(e));return[r,Math.ceil(e/r)]}var Un,Ni=O(()=>{Ut(),Y(),Un=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,r){let i=this.computeTexture(e,r);return r&&r.isPacked&&(i[0]/=2,i[1]/=2),r&&r.reverseWH?[i[1],i[0]]:i}computeTexture(e,r){let i=r&&r.isPacked;if(e.length===0)return i?[2,2]:[1,1];let s=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let a=r.breakAxis>=e.length?1:e.slice(r.breakAxis).reduce((p,t)=>p*t),h=r.breakAxis<=0?1:e.slice(0,r.breakAxis).reduce((p,t)=>p*t);if(a>s||h>s)tt.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${r.breakAxis}`);else return[a,h]}let c=e.slice(0);i&&(s=s*2,c=c.map((a,h)=>h>=c.length-2?c[h]%2===0?c[h]:c[h]+1:c[h]),c.length===1&&(c=[2,c[0]])),c.length!==2&&(c=hr(c).newShape);let n=mg(c);return c.length<=1&&n<=s?[1,n]:c.length===2&&c[0]<=s&&c[1]<=s?c:c.length===3&&c[0]*c[1]<=s&&c[2]<=s?[c[0]*c[1],c[2]]:c.length===3&&c[0]<=s&&c[1]*c[2]<=s?[c[0],c[1]*c[2]]:c.length===4&&c[0]*c[1]*c[2]<=s&&c[3]<=s?[c[0]*c[1]*c[2],c[3]]:c.length===4&&c[0]<=s&&c[1]*c[2]*c[3]<=s?[c[0],c[1]*c[2]*c[3]]:i?fp(n/4).map(a=>a*2):fp(n)}}}),Vn,cp=O(()=>{Y(),Te(),ut(),Ni(),pe(),Vn=class extends Ht{constructor(e){super(e)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let e="offsetToCoords";return{offsetToCoords:new k(`
      vec2 ${e}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let e="coordsToOffset";return{coordsToOffset:new k(`
      int ${e}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){let r=e.unpackedShape,i=[e.width,e.height],s={},c="getOutputCoords";switch(r.length){case 0:s[c]=this.getOutputScalarCoords();break;case 1:s[c]=this.getOutputPacked1DCoords(r,i);break;case 2:s[c]=this.getOutputPacked2DCoords(r,i);break;case 3:s[c]=this.getOutputPacked3DCoords(r,i);break;default:s[c]=this.getOutputPackedNDCoords(r,i)}let n=`
      void setOutput(vec4 val) {
        ${G(this.context.glContext.version).output} = val;
      }
    `,a="floatTextureSetRGBA";return s[a]=new k(n),s}getUnpackedOutputSamplingSnippet(e){let r=e.unpackedShape,i=[e.width,e.height],s={},c="getOutputCoords";switch(r.length){case 0:s[c]=this.getOutputScalarCoords();break;case 1:s[c]=this.getOutputUnpacked1DCoords(r,i);break;case 2:s[c]=this.getOutputUnpacked2DCoords(r,i);break;case 3:s[c]=this.getOutputUnpacked3DCoords(r,i);break;case 4:s[c]=this.getOutputUnpacked4DCoords(r,i);break;case 5:s[c]=this.getOutputUnpacked5DCoords(r,i);break;case 6:s[c]=this.getOutputUnpacked6DCoords(r,i);break;default:throw new Error(`Unsupported output dimensionality: ${r.length}`)}let n=`
        void setOutput(float val) {
          ${G(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,a="floatTextureSetR";return s[a]=new k(n),s}getOutputScalarCoords(){return new k(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(e,r){let i=r,s="";return i[0]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `,new k(s)):i[1]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `,new k(s)):(s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new k(s))}getOutputPacked2DCoords(e,r){let i="";if(Me.arraysEqual(e,r))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${r[0]}, ${r[1]}));
        }
      `,new k(i);let s=r,c=Math.ceil(e[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));

          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${c}) * 2;
          int c = 2 * (index / ${c});

          return ivec2(r, c);
        }
      `,new k(i)}getOutputPacked3DCoords(e,r){let i=[r[0],r[1]],s=Math.ceil(e[2]/2),c=s*Math.ceil(e[1]/2),n=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${c};
          index -= b * ${c};

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec3(b, r, c);
        }
      `;return new k(n)}getOutputPackedNDCoords(e,r){let i=[r[0],r[1]],s=Math.ceil(e[e.length-1]/2),c=s*Math.ceil(e[e.length-2]/2),n=c,a="",h="b, r, c";for(let t=2;t<e.length-1;t++)n*=e[e.length-t-1],a=`
      int b${t} = index / ${n};
      index -= b${t} * ${n};
    `+a,h=`b${t}, `+h;let p=`
      ivec${e.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${a}

        int b = index / ${c};
        index -= b * ${c};

        // reverse r and c order for packed texture
        int r = imod(index, ${s}) * 2;
        int c = 2 * (index / ${s});

        return ivec${e.length}(${h});
      }
    `;return new k(p)}getOutputUnpacked1DCoords(e,r){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          return resTexRC.y * ${r[0]} + resTexRC.x;
        }
      `;return new k(i)}getOutputUnpacked2DCoords(e,r){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          int r = index / ${e[1]};
          int c = index - r * ${e[1]};
          return ivec2(r, c);
        }
      `;return new k(i)}getOutputUnpacked3DCoords(e,r){let i="",s=e.length,c=null;s<2&&(c=[]),c=new Array(s-1),c[s-2]=e[s-1];for(let h=s-3;h>=0;--h)c[h]=c[h+1]*e[h+1];let n=["r","c","d"],a=c.map((h,p)=>{let t=`int ${n[p]} = index / ${h}`,u=p===c.length-1?`int ${n[p+1]} = index - ${n[p]} * ${h}`:`index -= ${n[p]} * ${h}`;return`${t}; ${u};`}).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${a}
          return ivec3(r, c, d);
        }
      `,new k(i)}getOutputUnpacked4DCoords(e,r){let i="",s=e.length,c=null;s<2&&(c=[]),c=new Array(s-1),c[s-2]=e[s-1];for(let h=s-3;h>=0;--h)c[h]=c[h+1]*e[h+1];let n=["r","c","d","d2"],a=c.map((h,p)=>{let t=`int ${n[p]} = index / ${h}`,u=p===c.length-1?`int ${n[p+1]} = index - ${n[p]} * ${h}`:`index -= ${n[p]} * ${h}`;return`${t}; ${u};`}).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${a}
          return ivec4(r, c, d, d2);
        }
      `,new k(i)}getOutputUnpacked5DCoords(e,r){let i="",s=e.length,c=null;s<2&&(c=[]),c=new Array(s-1),c[s-2]=e[s-1];for(let h=s-3;h>=0;--h)c[h]=c[h+1]*e[h+1];let n=["r","c","d","d2","d3"],a=c.map((h,p)=>{let t=`int ${n[p]} = index / ${h}`,u=p===c.length-1?`int ${n[p+1]} = index - ${n[p]} * ${h}`:`index -= ${n[p]} * ${h}`;return`${t}; ${u};`}).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${a}
          return ivec5(r, c, d, d2, d3);
        }
      `,new k(i)}getOutputUnpacked6DCoords(e,r){let i="",s=e.length,c=null;s<2&&(c=[]),c=new Array(s-1),c[s-2]=e[s-1];for(let h=s-3;h>=0;--h)c[h]=c[h+1]*e[h+1];let n=["r","c","d","d2","d3","d4"],a=c.map((h,p)=>{let t=`int ${n[p]} = index / ${h}`,u=p===c.length-1?`int ${n[p+1]} = index - ${n[p]} * ${h}`:`index -= ${n[p]} * ${h}`;return`${t}; ${u};`}).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${r[0]}, ${r[1]}));
         int index = resTexRC.y * ${r[0]} + resTexRC.x;
         ${a}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new k(i)}getCommonUtilFuncs(){let e={},r="uvFromFlat";e[r]=new k(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),r="packedUVfrom1D",e[r]=new k(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom2D",e[r]=new k(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom3D",e[r]=new k(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="sampleTexture";let i=G(this.context.glContext.version);return e[r]=new k(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),e}getInputsSamplingSnippets(){let e={},r=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,s)=>{let c=this.context.inputTextureLayouts[s],n=An(i);c.isPacked?e[n]=this.getPackedSamplerFromInput(n,i,c):e[n]=this.getUnpackedSamplerFromInput(n,i,c);let a=Yu(i);c.unpackedShape.length<=r.unpackedShape.length&&(c.isPacked?e[a]=this.getPackedSamplerAtOutputCoords(a,c,r,i):e[a]=this.getUnpackedSamplerAtOutputCoords(a,c,r,i))}),e}getPackedSamplerAtOutputCoords(e,r,i,s){let c=r.unpackedShape,n=i.unpackedShape,a=An(s),h=c.length,p=n.length,t=kt.getBroadcastDims(c,n),u=Bt(p),l=p-h,f,x=ne();h===0?f="":p<2&&t.length>=1?f="coords = 0;":f=t.map(re=>`coords.${x[re+l]} = 0;`).join(`
`);let I="";p<2&&h>0?I="coords":I=c.map((re,se)=>`coords.${x[se+l]}`).join(", ");let R="return outputValue;",A=B.size(c)===1,Z=B.size(n)===1;if(h===1&&!A&&!Z)R=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(A&&!Z)p===1?R=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:R=`
          return vec4(outputValue.x);
        `;else if(t.length){let re=h-2,se=h-1;t.indexOf(re)>-1&&t.indexOf(se)>-1?R="return vec4(outputValue.x);":t.indexOf(re)>-1?R="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":t.indexOf(se)>-1&&(R="return vec4(outputValue.xx, outputValue.zz);")}let K=`
        int lastDim = coords.${x[p-1]};
        coords.${x[p-1]} = coords.${x[p-2]};
        coords.${x[p-2]} = lastDim;
      `,Q=`
      vec4 ${e}() {
        ${u} coords = getOutputCoords();
        ${K}
        ${f}
        vec4 outputValue = ${a}(${I});
        ${R}
      }
    `;return new k(Q,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,r,i,s){let c=[i.width,i.height],n=[r.width,r.height],a=r.unpackedShape.length,h=i.unpackedShape.length,p=r.unpackedShape,t=i.unpackedShape,u=An(s);if(a===h&&Me.arraysEqual(n,c)){let K=`
          float ${e}() {
            return sampleTexture(${s}, TexCoords);
          }
        `;return new k(K,["coordinates.sampleTexture"])}let l=Bt(h),f=kt.getBroadcastDims(p,t),x=h-a,I,R=ne();a===0?I="":h<2&&f.length>=1?I="coords = 0;":I=f.map(K=>`coords.${R[K+x]} = 0;`).join(`
`);let A="";h<2&&a>0?A="coords":A=r.unpackedShape.map((K,Q)=>`coords.${R[Q+x]}`).join(", ");let Z=`
        float ${e}() {
          ${l} coords = getOutputCoords();
          ${I}
          return ${u}(${A});
        }
      `;return new k(Z,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,r,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,r);case 1:return this.getPackedSampler1D(e,r,i);case 2:return this.getPackedSampler2D(e,r,i);case 3:return this.getPackedSampler3D(e,r,i);default:return this.getPackedSamplerND(e,r,i)}}getUnpackedSamplerFromInput(e,r,i){let s=i.unpackedShape;switch(s.length){case 0:return this.getUnpackedSamplerScalar(e,r,i);case 1:return this.getUnpackedSampler1D(e,r,i);case 2:return this.getUnpackedSampler2D(e,r,i);case 3:return this.getUnpackedSampler3D(e,r,i);case 4:return this.getUnpackedSampler4D(e,r,i);case 5:return this.getUnpackedSampler5D(e,r,i);case 6:return this.getUnpackedSampler6D(e,r,i);default:throw new Error(`Unsupported dimension ${s.length}-D`)}}getPackedSamplerScalar(e,r){let i=G(this.context.glContext.version),s=`
          vec4 ${e}() {
            return ${i.texture2D}(${r}, halfCR);
          }
        `;return new k(s)}getPackedSampler1D(e,r,i){let s=[i.width,i.height],c=[s[1],s[0]],n=G(this.context.glContext.version),a=`vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
      ${c[0]}, ${c[1]}, index);
      return ${n.texture2D}(${r}, uv);
    }`;return new k(a,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,r,i){let s=i.unpackedShape,c=[i.width,i.height],n=G(this.context.glContext.version),a=c[0],h=c[1];if(c!=null&&Me.arraysEqual(s,c)){let l=`vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${a}.0);
        return ${n.texture2D}(${r}, uv);
      }`;return new k(l)}let p=c,t=Math.ceil(s[1]/2),u=`vec4 ${e}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${t}, row, col);
      return ${n.texture2D}(${r}, uv);
    }`;return new k(u,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,r,i){let s=i.unpackedShape,c=[i.width,i.height],n=[c[0],c[1]],a=G(this.context.glContext.version);if(s[0]===1){let f=s.slice(1),x=[1,2],I=lr(s,f),R=["b","row","col"],A=JSON.parse(JSON.stringify(i));A.unpackedShape=I;let Z=this.getPackedSamplerFromInput(e,r,A),K=`${Z.routineBody}
      vec4 ${e}(int b, int row, int col) {
        return ${e}(${fr(R,x)});
      } `;return new k(K,Z.dependencies)}let h=n[0],p=n[1],t=Math.ceil(s[2]/2),u=t*Math.ceil(s[1]/2),l=`vec4 ${e}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${h}, ${u}, ${t}, b, row, col);
      return ${a.texture2D}(${r}, uv);}`;return new k(l,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,r,i){let s=i.unpackedShape,c=s.length,n=[i.width,i.height],a=G(this.context.glContext.version),h=[n[0],n[1]],p=h[1],t=h[0],u=Math.ceil(s[c-1]/2),l=u*Math.ceil(s[c-2]/2),f="int b, int row, int col",x=`b * ${l} + (row / 2) * ${u} + (col / 2)`;for(let R=2;R<c-1;R++)f=`int b${R}, `+f,l*=s[c-R-1],x=`b${R} * ${l} + `+x;let I=`vec4 ${e}(${f}) {
      int index = ${x};
      int texR = index / ${t};
      int texC = index - texR * ${t};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}, ${p});
      return ${a.texture2D}(${r}, uv);
    }`;return new k(I)}getUnpackedSamplerScalar(e,r,i){let[s,c]=[i.width,i.height];if(s===1&&c===1){let a=`
          float ${e}() {
            return sampleTexture(${r}, halfCR);
          }
        `;return new k(a,["coordinates.sampleTexture"])}let n=`
        float ${e}() {
          int offset_${r} = coordsToOffset(TexCoords, ${s}, ${c});
          vec2 uv = uvFromFlat(${s}, ${c}, offset_${r});
          return sampleTexture(${r}, uv);
        }
      `;return new k(n,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,r,i){let s=i.width,c=i.height;if(c===1&&s===1){let a=`
        float ${e}(int index) {
          return sampleTexture(${r}, halfCR);
        }
      `;return new k(a,["coordinates.sampleTexture"])}if(c===1){let a=`
          float ${e}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${s}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new k(a,["coordinates.sampleTexture"])}if(s===1){let a=`
          float ${e}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${c}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new k(a,["coordinates.sampleTexture"])}let n=`
        float ${e}(int index) {
          vec2 uv = uvFromFlat(${s}, ${c}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(n,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,r,i){let s=i.unpackedShape,c=[i.height,i.width];if(c!=null&&Me.arraysEqual(s,c)){let l=c[1],f=c[0],x=`
          float ${e}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${l}.0, ${f}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new k(x,["coordinates.sampleTexture"])}let{newShape:n,keptDims:a}=hr(s),h=n;if(h.length<s.length){let l=lr(s,h),f=JSON.parse(JSON.stringify(i));f.unpackedShape=l;let x=["col","row"],I=`
          ${this.getUnpackedSamplerFromInput(e,r,f).routineBody}
          float ${e}(int row, int col) {
            return ${e}(${fr(x,a)});
          }
        `;return new k(I,["coordinates.sampleTexture"])}let p=c[1],t=c[0];if(t===1){let l=`
          float ${e}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${p}, ${t});
            float index = dot(vec3(row, col, offset_${r}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new k(l,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(p===1){let l=`
          float ${e}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${p}, ${t});
            float index = dot(vec3(row, col, offset_${r}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${t}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new k(l,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let u=`
        float ${e}(int row, int col) {
          int index = col * ${s[1]} + row;
          vec2 uv = uvFromFlat(${p}, ${t}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(u,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,r,i){let s=i.unpackedShape,c=s[1]*s[2],n=s[2],{newShape:a,keptDims:h}=hr(s),p=a;if(p.length<s.length){let f=lr(s,p),x=["batch","col","row"],I=JSON.parse(JSON.stringify(i));I.unpackedShape=f;let R=this.getUnpackedSamplerFromInput(e,r,I),A=h.reverse(),Z=`
          ${R.routineBody}
          float ${e}(int batch, int row, int col) {
            return ${e}(${fr(x,A)});
          }
        `;return new k(Z,R.dependencies)}let t=i.width,u=i.height,l=`
          float ${e}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${c} + col * ${n} + row;
            vec2 uv = uvFromFlat(${t}, ${u}, index);
            return sampleTexture(${r}, uv);
          }
      `;return new k(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,r,i){let s=i.unpackedShape,c=s[3],n=s[2]*c,a=s[1]*n,h=i.width,p=i.height,t=`
        float ${e}(int row, int col, int depth, int depth2) {
          int index = row * ${a} + col * ${n} +
              depth2 * ${c} + depth;
          vec2 uv = uvFromFlat(${h}, ${p}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(t,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,r,i){let s=i.unpackedShape,c=s[4],n=s[3]*c,a=s[2]*n,h=s[1]*a,{newShape:p,keptDims:t}=hr(s);if(p.length<s.length){let x=lr(s,p),I=["row","col","depth","depth2","depth3"],R=JSON.parse(JSON.stringify(i));R.unpackedShape=x;let A=`
          ${this.getUnpackedSamplerFromInput(e,r,R).routineBody}
          float ${e}(int row, int col, int depth, int depth2, int depth3) {
            return ${e}(${fr(I,t)});
          }
        `;return new k(A,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let u=i.width,l=i.height,f=`
        float ${e}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${h} + col * ${a} + depth * ${n} +
          depth3 * ${c} + depth2;
          vec2 uv = uvFromFlat(${u}, ${l}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new k(f,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,r,i){let s=i.unpackedShape,c=s[5],n=s[4]*c,a=s[3]*n,h=s[2]*a,p=s[1]*h,{newShape:t,keptDims:u}=hr(s);if(t.length<s.length){let I=lr(s,t),R=["row","col","depth","depth2","depth3","depth4"],A=JSON.parse(JSON.stringify(i));A.unpackedShape=I;let Z=`
            ${this.getUnpackedSamplerFromInput(e,r,A).routineBody}
            float ${e}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e}(${fr(R,u)});
            }
          `;return new k(Z,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let l=i.width,f=i.height,x=`
          float ${e}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${h} + depth * ${a} +
            depth2 * ${n} + depth3 * ${c} + depth4;
            vec2 uv = uvFromFlat(${l}, ${f}, index);
            return sampleTexture(${r}, uv);
          }
        `;return new k(x,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let e=this.context.outputTextureLayout,r=e.shape.length,i=e.strides,s=e.width,c=e.height,n=[];for(let h=0;h<r-1;++h)n.push(`
        c[${h}] = offset / ${i[h]};`),n.push(`
        offset -= c[${h}] * ${i[h]};`);n.push(`
        c[${r-1}] = offset;`);let a=`
      void toVec(vec2 texCoords, out int c[${r}]) {
        int offset = coordsToOffset(texCoords, ${s}, ${c});
        ${n.join("")}
      }
      void toVec(int offset, out int c[${r}]) {
        ${n.join("")}
      }
    `;return{toVec:new k(a,["coordinates.coordsToOffset"])}}valueFrom(){let e={};return this.context.programInfo.inputNames.forEach((r,i)=>{let s=this.context.inputTextureLayouts[i],c=(s.unpackedShape.length>0?s.unpackedShape:s.shape).length,n=`_${r}`;e[n]=new k(this.getValueFromSingle(r,c,s.width,s.height,!1),[`shapeUtils.indicesToOffset${n}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),n=n+"_T",e[n]=new k(this.getValueFromSingle(r,c,s.width,s.height,!0),[`shapeUtils.indicesToOffset${n}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),e}getValueFromSingle(e,r,i,s,c){let n=`_${e}`;c&&(n=n+"_T");let a=G(this.context.glContext.version);return`
        float ${n}(int m[${r}]) {
          int offset = indicesToOffset${n}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${s});
          float value = getColorAsFloat(${a.texture2D}(${e}, coords));
          return value;
        }
        `}getPackedValueFrom(e,r,i,s,c){let n=`_${e}_Pack`;c&&(n=n+"_T");let a=G(this.context.glContext.version);return`
        vec4 ${n}(int m[${r}]) {
          int offset = indicesToOffset_${e}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${s});
          return ${a.texture2D}(${e}, coords);
        }
        `}}}),zn,pp=O(()=>{Te(),zn=class F1 extends Ht{constructor(r){super(r)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new k(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new k(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let r=F1.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new k(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${r}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let r=F1.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new k(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${r}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let r=new ArrayBuffer(4),i=new Uint32Array(r),s=new Uint8Array(r);if(i[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}}),Wn,dp=O(()=>{Te(),ut(),Wn=class extends Ht{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=G(this.context.glContext.version);return{setFragColor:new k(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new k(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),Hn,hp=O(()=>{Te(),Hn=class Uv extends Ht{constructor(r){super(r)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let r=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((s,c)=>{let n=this.context.inputTextureLayouts[c].unpackedShape;if(n.length<=r){let a=n.length,h=r-a,p=`bcastIndices_${s}`,t="";for(let l=0;l<a;++l)t+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${h+l}]), ${n[l]}.0) );
          `;let u=`
        void ${p} (int bcastedIndices[${r}], out int realIndices[${a}]) {
          ${t}
        }
        `;i[p]=new k(u)}}),i}bcastMatmulIndex(){let r=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((s,c)=>{let n=this.context.inputTextureLayouts[c].shape;if(!(n.length<2||n.length>r)){let a=n.length,h=r-a,p=`bcastMatmulIndices_${s}`,t="";for(let l=0;l<a-2;++l)t+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${h+l}]), ${n[l]}.0) );
          `;let u=`
        void ${p}(int bcastedIndices[${r}], out int realIndices[${a}]) {
          ${t}
          realIndices[${a-1}] = bcastedIndices[${r-1}];
          realIndices[${a-2}] = bcastedIndices[${r-2}];
        }
        `;i[p]=new k(u)}}),i}indicesToOffset(){let r={};return this.context.programInfo.inputNames.forEach((i,s)=>{let c=this.context.inputTextureLayouts[s].shape,n=this.context.inputTextureLayouts[s].strides,a=c.length,h=`indicesToOffset_${i}`;r[h]=new k(Uv.indexToOffsetSingle(h,a,n)),h=`indicesToOffset_${i}_T`,r[h]=new k(Uv.indexToOffsetSingle(h,a,n.slice().reverse()))}),r}static indexToOffsetSingle(r,i,s){let c="";for(let n=i-1;n>=0;--n)c+=`
        offset += indices[${n}] * ${s[n]};
        `;return`
      int ${r}(int indices[${i}]) {
        int offset = 0;
        ${c}
        return offset;
      }
      `}offsetToIndices(){let r={};return this.context.programInfo.inputNames.forEach((i,s)=>{let c=this.context.inputTextureLayouts[s].shape,n=this.context.inputTextureLayouts[s].strides,a=c.length,h=`offsetToIndices_${i}`;r[h]=new k(Uv.offsetToIndicesSingle(h,a,n)),h=`offsetToIndices_${i}_T`,r[h]=new k(Uv.offsetToIndicesSingle(h,a,n.slice().reverse()))}),r}static offsetToIndicesSingle(r,i,s){let c=[];for(let n=0;n<i-1;++n)c.push(`
      indices[${n}] = offset / ${s[n]};`),c.push(`
        offset -= indices[${n}] * ${s[n]};`);return c.push(`
      indices[${i-1}] = offset;`),`
      void ${r}(int offset, out int indices[${i}]) {
        ${c.join("")}
      }
      `}incrementIndices(){let r={};return this.context.programInfo.inputNames.forEach((i,s)=>{let c=this.context.inputTextureLayouts[s].shape,n=c.length,a=`incrementIndices_${i}`,h="";for(let t=0;t<n;++t)h+=`
        shape[${t}] = ${c[t]};`;let p=`
        void ${a}(int axis, out int indices[${n}]) {
          int shape[${n}];
          ${h};
          for(int i = ${n} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;r[a]=new k(p)}),r}}}),qn,mp=O(()=>{Te(),qn=class extends Ht{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let e=this.context.outputTextureLayout.shape.length,r={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let s in r){let c=`${s}Vec`,n="";for(let h=0;h<e;++h)n+=`
          dest[${h}] ${r[s]} src[${h}];
          `;let a=`
        void ${c}(int src[${e}], out int dest[${e}]) {
          ${n}
        }
        `;i[c]=new k(a)}return i}copyVec(){let e=this.context.outputTextureLayout.shape.length,r="";for(let s=0;s<e;++s)r+=`
        dest[${s}] = src[${s}];
        `;let i=`
      void copyVec(int src[${e}], out int dest[${e}]) {
        ${r}
      }
      `;return{copyVec:new k(i)}}setVecItem(){let e=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index =${e} + index;
        if (index == 0)
            m[0] = value;
        `;for(let s=1;s<e-1;++s)r+=`
        else if (index == ${s})
            m[${s}] = value;
            `;r+=`
        else
            m[${e-1}] = value;
        `;let i=`
      void setVecItem(out int m[${e}], int index, int value) {
        ${r}
      }
        `;return{setVecItem:new k(i)}}getVecItem(){let e=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index = ${e} + index;
        if (index == 0)
            return m[0];
      `;for(let s=1;s<e-1;++s)r+=`
        else if (index == ${s})
            return m[${s}];
      `;r+=`
        else
            return m[${e-1}];
        `;let i=`
      int getVecItem(int m[${e}], int index) {
        ${r}
      }
    `;return{getVecItem:new k(i)}}}}),Ri,bp=O(()=>{cp(),pp(),dp(),hp(),mp(),Ri={encoding:zn,fragcolor:Wn,vec:qn,shapeUtils:Hn,coordinates:Vn}}),jn,gp=O(()=>{Te(),lp(),bp(),ut(),jn=class{constructor(e,r,i,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Ln(e,r,i,s),Object.keys(Ri).forEach(n=>{let a=new Ri[n](this.context);this.libs[n]=a});let c=this.glslLibRoutineDependencyGraph;for(let n in this.libs){let a=this.libs[n].getFunctions();for(let h in a){let p=n+"."+h,t;c[p]?(t=c[p],t.routineBody=a[h].routineBody):(t=new Nr(p,a[h].routineBody),c[p]=t);let u=a[h].dependencies;if(u)for(let l=0;l<u.length;++l)if(c[u[l]])t.addDependency(c[u[l]]);else{let f=new Nr(u[l]);c[u[l]]=f,t.addDependency(f)}}}}preprocess(){let e=this.context.programInfo,r=e.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${Ju(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=up(r),`${Ku(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(e){let r=this.selectGlslLibRoutinesToBeIncluded(e);if(r.length===0)return"";let i="";for(let s=0;s<r.length;++s)if(r[s].routineBody)i+=r[s].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[s].name}`);return i}selectGlslLibRoutinesToBeIncluded(e){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(i=>{let s=i.split(".")[1];e.indexOf(s)!==-1&&r.push(this.glslLibRoutineDependencyGraph[i])}),$n.returnOrderedNodes(r)}getUniforms(e,r){let i=[];if(e)for(let s of e)i.push(`uniform sampler2D ${s};`);if(r)for(let s of r)i.push(`uniform ${s.type} ${s.name}${s.arrayLength?`[${s.arrayLength}]`:""};`);return i.join(`
`)}}}),Xn,yp=O(()=>{Yt(),Ut(),gp(),ut(),Xn=class{constructor(e,r,i){this.profiler=e,this.glContext=r,this.textureLayoutStrategy=i,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,i){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let s=this.glContext.gl,c=e.program;s.useProgram(c);try{this.bindOutput(i),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],r)}catch(n){throw tt.error("ProgramManager",e.programInfo.shaderSource),n}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,r,i){return this.profiler.event("backend","ProgramManager.build",()=>{let s=new jn(this.glContext,e,r,i),c=s.preprocess(),n=this.compile(c);return{programInfo:e,program:n,uniformLocations:this.getUniformLocations(n,s.context.programInfo.inputNames,s.context.programInfo.variables),attribLocations:this.getAttribLocations(n)}})}compile(e){if(!this.vertexShader){tt.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let s=Xu(this.glContext.version);this.vertexShader=this.glContext.compileShader(s,this.glContext.gl.VERTEX_SHADER)}z.debug&&tt.verbose("ProrgramManager",`FragShader:
${e}
`);let r=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),i=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),i}bindOutput(e){let r=e.width,i=e.height;tt.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${i}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,r,i)}bindAttributes(e){let r=e.position,i=e.textureCoord;this.glContext.setVertexAttributes(r,i),this.attributesBound=!0}bindUniforms(e,r,i){var n;let s=this.glContext.gl,c=0;for(let{name:a,type:h,location:p,arrayLength:t}of e){let u=(n=r.find(l=>l.name===a))==null?void 0:n.data;if(h!=="sampler2D"&&!u)throw new Error(`variable '${a}' does not have data defined in program info`);switch(h){case"sampler2D":this.bindTexture(i[c],p,c),c++;break;case"float":t?s.uniform1fv(p,u):s.uniform1f(p,u);break;case"int":t?s.uniform1iv(p,u):s.uniform1i(p,u);break;default:throw new Error(`Uniform not implemented: ${h}`)}}}bindTexture(e,r,i){this.glContext.bindTextureToUniform(e.texture,i,r)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,r,i){let s=[];if(r)for(let c of r)s.push({name:c,type:"sampler2D",location:this.getUniformLocation(e,c)});if(i)for(let c of i)s.push({...c,location:this.getUniformLocation(e,c.name)});return s}getUniformLocation(e,r){let i=this.glContext.gl.getUniformLocation(e,r);if(i===null)throw new Error(`Uniform ${r} not found.`);return i}getAttribLocation(e,r){return this.glContext.gl.getAttribLocation(e,r)}}}),Kn,xp=O(()=>{Ut(),Fr(),Kn=class{constructor(e,r,i,s){this.glContext=e,this.layoutStrategy=r,this.profiler=i,this.config=s,this.pendingRead=new Map,s.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,r,i,s){let c=this.toEncoderType(e),n=this.glContext.getEncoder(c,r.channels||1,s);if(r.isPacked&&s===1)throw new Error("not implemented");let a=r.width,h=r.height,p,t;if(this.config.reuseTextures){p=`${a}x${h}_${n.format}_${n.internalFormat}_${n.textureType}`,t=this.inUseTextures.get(p),t||(t=[],this.inUseTextures.set(p,t));let l=this.idleTextures.get(p);if(l&&l.length>0){let f=l.pop();return t.push(f),s===1&&this.glContext.updateTexture(f,a,h,n,this.toTextureData(e,i)),f}}tt.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let u=this.glContext.allocateTexture(a,h,n,this.toTextureData(e,i));return this.config.reuseTextures&&(t.push(u),this.textureLookup.set(u,p)),u}readTexture(e,r,i){return i||(i=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let s=e.shape.reduce((n,a)=>n*a)*i,c=this.glContext.readTexture(e.texture,e.width,e.height,s,this.toEncoderType(r),i);return this.toTensorData(r,c)})}async readTextureAsync(e,r,i){let s=e.tensor.dataId;if(i||(i=1),this.pendingRead.has(s)){let c=this.pendingRead.get(s);return new Promise(n=>c==null?void 0:c.push(n))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(s,[]);let c=e.shape.reduce((p,t)=>p*t)*i;await this.glContext.createAndWaitForFence();let n=this.glContext.readTexture(e.texture,e.width,e.height,c,this.toEncoderType(r),i),a=this.toTensorData(r,n),h=this.pendingRead.get(s);return this.pendingRead.delete(s),h==null||h.forEach(p=>p(a)),a})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=e.shape.reduce((s,c)=>s*c),i=this.glContext.readTexture(e.texture,e.width,e.height,r*4,"byte",4);return new Float32Array(i.buffer,i.byteOffset,r)})}releaseTexture(e,r){let i;if(this.config.reuseTextures&&(i=this.textureLookup.get(e.texture),i)){r&&this.textureLookup.delete(i);let s=this.inUseTextures.get(i);if(s){let c=s.indexOf(e.texture);if(c!==-1){s.splice(c,1);let n=this.idleTextures.get(i);n||(n=[],this.idleTextures.set(i,n)),n.push(e.texture)}}}(!i||r)&&(tt.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,r){switch(e){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),Jn,Tp=O(()=>{Ut(),Bs(),cl(),ap(),yp(),Ni(),xp(),Jn=class{constructor(e,r){this.backend=e,this.context=r,this.layoutStrategy=new Un(e.glContext.maxTextureSize),this.programManager=new Xn(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new Kn(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Dn(this)}onGraphInitialized(e){let r=e.getValues().filter(i=>i.from===-1&&i.tensor).map(i=>i.tensor.dataId);this.initializers=new Set(r)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,r){return r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,i=!1){tt.verbose("WebGLSessionHandler","Storing Texture data in cache"),i?this.packedTextureDataCache.set(e,r):this.unpackedTextureDataCache.set(e,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,r,i){let s=ks(e,r,ip);return{impl:s.opImpl,context:s.opInit?s.opInit(e,i):e}}}});function bg(e){let r=0;for(;r<e.length&&e[r]();++r);return r-1}var Mr,wp=O(()=>{Yt(),Fr(),Fr(),pe(),Mr=class{constructor(e,r){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,r,i,s){let c=this.gl,n=c.createTexture();c.bindTexture(c.TEXTURE_2D,n),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,c.NEAREST),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,c.NEAREST),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE);let a=s?i.encode(s,e*r):null;return c.texImage2D(c.TEXTURE_2D,0,i.internalFormat,e,r,0,i.format,i.textureType,a),this.checkError(),n}updateTexture(e,r,i,s,c){let n=this.gl;n.bindTexture(n.TEXTURE_2D,e);let a=s.encode(c,r*i);n.texSubImage2D(n.TEXTURE_2D,0,0,0,r,i,s.format,s.textureType,a),this.checkError()}attachFramebuffer(e,r,i){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e),s.bindFramebuffer(s.FRAMEBUFFER,this.framebuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0),this.checkError(),s.viewport(0,0,r,i),s.scissor(0,0,r,i)}readTexture(e,r,i,s,c,n){let a=this.gl;n||(n=1),this.frameBufferBound||this.attachFramebuffer(e,r,i);let h=this.getEncoder(c,n),p=h.allocate(r*i);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,r,i,a.RGBA,h.textureType,p),this.checkError(),h.decode(p,s)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,r){let i=this.gl;i.vertexAttribPointer(e,3,i.FLOAT,!1,20,0),i.enableVertexAttribArray(e),r!==-1&&(i.vertexAttribPointer(r,2,i.FLOAT,!1,20,12),i.enableVertexAttribArray(r)),this.checkError()}createProgram(e,r){let i=this.gl,s=i.createProgram();return i.attachShader(s,e),i.attachShader(s,r),i.linkProgram(s),s}compileShader(e,r){let i=this.gl,s=i.createShader(r);if(!s)throw new Error(`createShader() returned null with type ${r}`);if(i.shaderSource(s,e),i.compileShader(s),i.getShaderParameter(s,i.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${i.getShaderInfoLog(s)}
Shader source:
${e}`);return s}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,r,i){let s=this.gl;s.activeTexture(s.TEXTURE0+r),this.checkError(),s.bindTexture(s.TEXTURE_2D,e),this.checkError(),s.uniform1i(i,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(z.debug){let e=this.gl,r=e.getError(),i="";switch(r){case e.NO_ERROR:return;case e.INVALID_ENUM:i="INVALID_ENUM";break;case e.INVALID_VALUE:i="INVALID_VALUE";break;case e.INVALID_OPERATION:i="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:i="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:i="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:i="CONTEXT_LOST_WEBGL";break;default:i=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(i)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,r,i=0){if(this.version===2)return new Pn(this.gl,r);switch(e){case"float":return i===1||this.isRenderFloat32Supported?new Br(this.gl,r):new Br(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new En(this.gl,r);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,r=e.createBuffer();if(!r)throw new Error("createBuffer() returned null");let i=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let i=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let c=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),c}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,r,i,s,c,n;try{r=e.createTexture(),i=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,r);let a=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0),e.enable(e.BLEND),s=e.createShader(e.VERTEX_SHADER),!s||(e.shaderSource(s,"void main(){}"),e.compileShader(s),c=e.createShader(e.FRAGMENT_SHADER),!c)||(e.shaderSource(c,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(c),n=e.createProgram(),!n)?!1:(e.attachShader(n,s),e.attachShader(n,c),e.linkProgram(n),e.useProgram(n),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),n&&e.deleteProgram(n),s&&e.deleteShader(s),c&&e.deleteShader(c),i&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(i)),r&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension,i=e.createQuery();return e.beginQuery(r.TIME_ELAPSED_EXT,i),i}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension;e.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let r=!1,i=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let s=this.gl,c=this.disjointTimerQueryWebgl2Extension;r=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE),i=s.getParameter(c.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!i}getTimerResult(e){let r=0;if(this.version===2){let i=this.gl;r=i.getQueryParameter(e,i.QUERY_RESULT),i.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(e){return await li(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let r,i=e,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),s===null?r=()=>!0:r=()=>{let c=i.clientWaitSync(s,0,0);return c===i.ALREADY_SIGNALED||c===i.CONDITION_SATISFIED},{query:s,isFencePassed:r}}async pollFence(e){return new Promise(r=>{this.addItemToPoll(()=>e.isFencePassed(),()=>r())})}pollItems(){let e=bg(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=e;++r){let{resolveFn:i}=this.itemsToPoll[r];i()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,r){this.itemsToPoll.push({isDoneFn:e,resolveFn:r}),!(this.itemsToPoll.length>1)&&await li(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Gi(e){let r;if((!e||e==="webgl2")&&"webgl2"in mr?r=mr.webgl2:(!e||e==="webgl")&&"webgl"in mr&&(r=mr.webgl),!r)try{let s=yg();r=vp(s,e)}catch{let s=gg();r=vp(s,e)}e=e||r.version===1?"webgl":"webgl2";let i=r.gl;return mr[e]=r,i.isContextLost()?(delete mr[e],Gi(e)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),r)}function vp(e,r){let i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},s,c=i;if((!r||r==="webgl2")&&(s=e.getContext("webgl2",c),s))try{return new Mr(s,2)}catch(n){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!r||r==="webgl")&&(s=e.getContext("webgl",c)||e.getContext("experimental-webgl",c),s))try{return new Mr(s,1)}catch(n){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}function gg(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}function yg(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var mr,Ip=O(()=>{Ut(),wp(),mr={}}),Yn,_p=O(()=>{Yt(),Ut(),Tp(),Ip(),Yn=class{get contextId(){return z.webgl.contextId}set contextId(e){z.webgl.contextId=e}get matmulMaxBatchSize(){return z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){z.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return z.webgl.textureCacheMode}set textureCacheMode(e){z.webgl.textureCacheMode=e}get pack(){return z.webgl.pack}set pack(e){z.webgl.pack=e}get async(){return z.webgl.async}set async(e){z.webgl.async=e}initialize(){try{return this.glContext=Gi(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),tt.setWithEnv(z),z.webgl.context||Object.defineProperty(z.webgl,"context",{value:this.glContext.gl}),tt.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return tt.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Jn(this,e)}dispose(){this.glContext.dispose()}}});async function Mi(e){if(e){let r=typeof e=="string"?[e]:e;for(let i of r){let s=Op.get(i);if(s)return s;let c=await Tg(i);if(c)return c}}else return Mi(["webgl"]);throw new Error("no available backend to use")}async function Tg(e){let r=xg;if(typeof r[e]<"u"&&wg(r[e])){let i=r[e],s=i.initialize();if(typeof s=="object"&&"then"in s&&(s=await s),s)return Op.set(e,i),i}}function wg(e){let r=e;return"initialize"in r&&typeof r.initialize=="function"&&"createSessionHandler"in r&&typeof r.createSessionHandler=="function"&&"dispose"in r&&typeof r.dispose=="function"}var Op,xg,Sp=O(()=>{_p(),Op=new Map,xg={webgl:new Yn}}),Ui,Zn,Ap=O(()=>{Ut(),Ui=class{constructor(e,r){this.op=e,this.node=r}},Zn=class{constructor(e,r,i){this.graph=e,this.profiler=i,this.initialize(r)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((i,s)=>new Ui(i,r[s])),this.reset(),this._starter=[],this._ops.forEach((i,s)=>{let c=!0;for(let n of i.node.inputs)if(!this._values[n]&&this.graph.getInputIndices().indexOf(n)===-1){c=!1;break}c&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let i=e.createInferenceHandler(),s=this.graph.getInputIndices();if(r.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${s.length}`);r.forEach((t,u)=>{let l=s[u];this._values[l]=t});let c=this._starter.slice(0),n=this.graph.getValues(),a=this.graph.getNodes(),h=0;for(;h<c.length;){let t=c[h++],u=this._ops[t],l=u.node.inputs.map(R=>this._values[R]);if(l.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${u.node}`);let f=l;tt.verbose("ExecPlan",`Running op:${u.node.name} (${f.map((R,A)=>`'${u.node.inputs[A]}': ${R.type}[${R.dims.join(",")}]`).join(", ")})`);let x=await this.profiler.event("node",u.node.name,async()=>u.op.impl(i,f,u.op.context));if(x.length!==u.node.outputs.length)throw new Error("the size of output does not match model definition.");x.forEach((R,A)=>{let Z=u.node.outputs[A];if(this._values[Z])throw new Error(`output [${Z}] already has value: op:${u.node.name}`);this._values[Z]=R});let I=new Set;x.forEach((R,A)=>{let Z=u.node.outputs[A];for(let K of n[Z].to){let Q=a[K],re=!0;for(let se of Q.inputs)if(!this._values[se]){re=!1;break}re&&I.add(K)}}),c.push(...I)}let p=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){let u=this.graph.getOutputIndices()[t],l=this._values[u];if(l===void 0)throw new Error(`required output [${u}] does not have value`);u===0?await l.getData():l.data,p.push(l)}return tt.verbose("ExecPlan","disposing of inferenceHandler"),i.dispose(),p})}}}),q,Xt,Ur,Pp=O(()=>{Pr(),q=rr(sr()),We(),Y(),Xt=F.experimental.fbs,Ur=class Wv{constructor(r){if(this._attributes=new Map,r!=null){for(let i of r)i instanceof q.onnx.AttributeProto?this._attributes.set(i.name,[Wv.getValue(i),Wv.getType(i)]):i instanceof Xt.Attribute&&this._attributes.set(i.name(),[Wv.getValue(i),Wv.getType(i)]);if(this._attributes.size<r.length)throw new Error("duplicated attribute names")}}set(r,i,s){this._attributes.set(r,[s,i])}delete(r){this._attributes.delete(r)}getFloat(r,i){return this.get(r,"float",i)}getInt(r,i){return this.get(r,"int",i)}getString(r,i){return this.get(r,"string",i)}getTensor(r,i){return this.get(r,"tensor",i)}getFloats(r,i){return this.get(r,"floats",i)}getInts(r,i){return this.get(r,"ints",i)}getStrings(r,i){return this.get(r,"strings",i)}getTensors(r,i){return this.get(r,"tensors",i)}get(r,i,s){let c=this._attributes.get(r);if(c===void 0){if(s!==void 0)return s;throw new Error(`required attribute not found: ${r}`)}if(c[1]!==i)throw new Error(`type mismatch: expected ${i} but got ${c[1]}`);return c[0]}static getType(r){let i=r instanceof q.onnx.AttributeProto?r.type:r.type();switch(i){case q.onnx.AttributeProto.AttributeType.FLOAT:return"float";case q.onnx.AttributeProto.AttributeType.INT:return"int";case q.onnx.AttributeProto.AttributeType.STRING:return"string";case q.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case q.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case q.onnx.AttributeProto.AttributeType.INTS:return"ints";case q.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case q.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${q.onnx.AttributeProto.AttributeType[i]}`)}}static getValue(r){let i=r instanceof q.onnx.AttributeProto?r.type:r.type();if(i===q.onnx.AttributeProto.AttributeType.GRAPH||i===q.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let s=this.getValueNoCheck(r);if(i===q.onnx.AttributeProto.AttributeType.INT&&Rt.isLong(s))return Rt.longToNumber(s);if(i===q.onnx.AttributeProto.AttributeType.INTS){let c=s,n=new Array(c.length);for(let a=0;a<c.length;a++){let h=c[a];n[a]=Rt.longToNumber(h)}return n}if(i===q.onnx.AttributeProto.AttributeType.TENSOR)return r instanceof q.onnx.AttributeProto?bt.fromProto(s):bt.fromOrtTensor(s);if(i===q.onnx.AttributeProto.AttributeType.TENSORS){if(r instanceof q.onnx.AttributeProto)return s.map(c=>bt.fromProto(c));if(r instanceof Xt.Attribute)return s.map(c=>bt.fromOrtTensor(c))}return i===q.onnx.AttributeProto.AttributeType.STRING&&r instanceof q.onnx.AttributeProto?kr(s):i===q.onnx.AttributeProto.AttributeType.STRINGS&&r instanceof q.onnx.AttributeProto?s.map(kr):s}static getValueNoCheck(r){return r instanceof q.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(r):this.getValueNoCheckFromOrtFormat(r)}static getValueNoCheckFromOnnxFormat(r){switch(r.type){case q.onnx.AttributeProto.AttributeType.FLOAT:return r.f;case q.onnx.AttributeProto.AttributeType.INT:return r.i;case q.onnx.AttributeProto.AttributeType.STRING:return r.s;case q.onnx.AttributeProto.AttributeType.TENSOR:return r.t;case q.onnx.AttributeProto.AttributeType.GRAPH:return r.g;case q.onnx.AttributeProto.AttributeType.FLOATS:return r.floats;case q.onnx.AttributeProto.AttributeType.INTS:return r.ints;case q.onnx.AttributeProto.AttributeType.STRINGS:return r.strings;case q.onnx.AttributeProto.AttributeType.TENSORS:return r.tensors;case q.onnx.AttributeProto.AttributeType.GRAPHS:return r.graphs;default:throw new Error(`unsupported attribute type: ${q.onnx.AttributeProto.AttributeType[r.type]}`)}}static getValueNoCheckFromOrtFormat(r){switch(r.type()){case Xt.AttributeType.FLOAT:return r.f();case Xt.AttributeType.INT:return r.i();case Xt.AttributeType.STRING:return r.s();case Xt.AttributeType.TENSOR:return r.t();case Xt.AttributeType.GRAPH:return r.g();case Xt.AttributeType.FLOATS:return r.floatsArray();case Xt.AttributeType.INTS:{let i=[];for(let s=0;s<r.intsLength();s++)i.push(r.ints(s));return i}case Xt.AttributeType.STRINGS:{let i=[];for(let s=0;s<r.stringsLength();s++)i.push(r.strings(s));return i}case Xt.AttributeType.TENSORS:{let i=[];for(let s=0;s<r.tensorsLength();s++)i.push(r.tensors(s));return i}default:throw new Error(`unsupported attribute type: ${Xt.AttributeType[r.type()]}`)}}}}),zi,Qn,Wi,me,to,Vi,Ep=O(()=>{Pp(),Pr(),zi=rr(sr()),We(),Y(),Qn=F.experimental.fbs,Wi={from:(e,r)=>new Vi(e,r)},me=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=At.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},to=class{constructor(e,r){e instanceof zi.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new Ur(e.attribute)):e instanceof Qn.Node&&(this.name=r??e.name(),this.opType=e.opType(),this.attributes=new Ur(At.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Vi=class{constructor(e,r){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof zi.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Qn.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!e.input)throw new Error("missing information in graph: input");let s=[];for(let c of e.input){if(r.has(c.name))throw new Error(`duplicated input name: ${c.name}`);let n=this._allData.push(new me(c))-1;r.set(c.name,n),s.push(c.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let c of e.initializer){let n=r.get(c.name);if(n===void 0){let a=new me;a.type={shape:{dims:At.tensorDimsFromProto(c.dims)},tensorType:At.tensorDataTypeFromProto(c.dataType)},n=this._allData.push(a)-1,r.set(c.name,n)}this._allData[n]._from=-1,this._allData[n].tensor=bt.fromProto(c)}for(let c=0;c<this._allData.length;c++)this._allData[c].tensor||(this._allInputIndices.push(c),this._allInputNames.push(s[c]));if(!e.output)throw new Error("missing information in graph: output");for(let c of e.output){if(r.has(c.name))throw new Error(`duplicated output name: ${c.name}`);let n=this._allData.push(new me(c))-1;r.set(c.name,n),this._allOutputIndices.push(n),this._allOutputNames.push(c.name)}if(!e.node)throw new Error("missing information in graph: node");for(let c of e.node){if(!c.name)for(let a=0;;a++){let h=`unnamed_${c.opType}_${a}`;if(!i.has(h)){c.name=h;break}}if(i.has(c.name))throw new Error(`duplicated node name: ${c.name}`);let n=this._nodes.push(new to(c))-1;i.set(c.name,n)}for(let c=0;c<this._nodes.length;c++){let n=this._nodes[c],a=e.node[c];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(let h of a.output){let p=r.get(h);if(typeof p>"u"&&(p=this._allData.push(new me)-1,r.set(h,p)),n.outputs.push(p),this._allData[p]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${p}`);if(this._allData[p]._from=c,a.opType==="Constant"){if(!a.attribute||a.attribute.length!==1||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||a.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[p]._from=-1,this._allData[p].tensor=bt.fromProto(a.attribute[0].t)}}}for(let c=0;c<this._nodes.length;c++){let n=this._nodes[c],a=e.node[c];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(let h of a.input){let p=r.get(h);if(typeof p>"u"){if(h===""&&(a.input.length===3||a.input.length===4)&&a.opType==="Resize")continue;throw new Error(`unrecognized input '${h}' for node: ${a.name}`)}n.inputs.push(p),this._allData[p]._to.push(c)}}return!0}buildGraphFromOrtFormat(e){var c,n,a;let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map,s=[];for(let h=0;h<e.inputsLength();h++){let p=e.inputs(h);if(r.has(p))throw new Error(`duplicated input name: ${p}`);for(let t=0;t<e.nodeArgsLength();t++)if(((c=e.nodeArgs(t))==null?void 0:c.name())===p){let u=new me;if(((a=(n=e.nodeArgs(t))==null?void 0:n.type())==null?void 0:a.valueType())!==Qn.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let l=e.nodeArgs(t).type().value(new Qn.TensorTypeAndShape),f=At.tensorDataTypeFromProto(l.elemType()),x=l.shape(),I=[];for(let A=0;A<x.dimLength();A++)I.push(Rt.longToNumber(x.dim(A).value().dimValue()));u.type={shape:{dims:I},tensorType:f};let R=this._allData.push(u)-1;r.set(p,R),s.push(p)}}for(let h=0;h<e.initializersLength();h++){let p=e.initializers(h),t=r.get(p.name());if(t===void 0){let u=new me,l=At.tensorDimsFromORTFormat(p),f=At.tensorDataTypeFromProto(p.dataType());u.type={shape:{dims:l},tensorType:f},t=this._allData.push(u)-1,r.set(p.name(),t)}this._allData[t]._from=-1,this._allData[t].tensor=bt.fromOrtTensor(p)}for(let h=0;h<this._allData.length;h++)this._allData[h].tensor||(this._allInputIndices.push(h),this._allInputNames.push(s[h]));for(let h=0;h<e.outputsLength();h++){let p=e.outputs(h);if(r.has(p))throw new Error(`duplicated output name: ${p}`);let t=this._allData.push(new me)-1;r.set(p,t),this._allOutputIndices.push(t),this._allOutputNames.push(p)}if(!e.nodes)throw new Error("missing information in graph: node");for(let h=0;h<e.nodesLength();h++){let p=e.nodes(h),t=p.name();if(!t)for(let l=0;t=`unnamed_${p.opType()}_${l}`,!!i.has(t);l++);if(i.has(t))throw new Error(`duplicated node name: ${t}`);let u=this._nodes.push(new to(p,t))-1;i.set(t,u)}for(let h=0;h<this._nodes.length;h++){let p=this._nodes[h],t=e.nodes(h);if(t==null)throw new Error(`No node exists at index ${h}`);if((t==null?void 0:t.outputsLength())===0)throw new Error(`missing output for node: ${t.name}`);for(let u=0;u<(t==null?void 0:t.outputsLength());u++){let l=t==null?void 0:t.outputs(u),f=r.get(l);if(typeof f>"u"&&(f=this._allData.push(new me)-1,r.set(l,f)),p.outputs.push(f),this._allData[f]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${f}`);if(this._allData[f]._from=h,t.opType()==="Constant"){if(t.attributesLength()!==1||!t.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(t.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");p.outputs.pop(),p.executeNode=!1,this._allData[f]._from=-1,this._allData[f].tensor=bt.fromOrtTensor(t.attributes(0).t())}}}for(let h=0;h<this._nodes.length;h++){let p=this._nodes[h],t=e.nodes(h);if(t.inputsLength()===0)throw new Error(`missing input for node: ${t.name}`);for(let u=0;u<t.inputsLength();u++){let l=t.inputs(u),f=r.get(l);if(typeof f>"u")throw new Error(`unrecognized input '${l}' for node: ${t.name()}`);p.inputs.push(f),this._allData[f]._to.push(h)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(s=>{this._allData[s]._to.forEach(c=>{e.add(c)})});let r=Array.from(e),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){let s=r.pop();i[s]==="gray"?i[s]="black":(r.push(s),i[s]="gray",this._nodes[s].outputs.forEach(c=>{let n=this._allData[c];if(typeof n.tensor<"u")throw new Error("node outputs should not be initialized");if(n._from!==s)throw new Error("from property of the Value object doesn't match index of Node being processed");n._to.forEach(a=>{if(i[a]==="gray")throw new Error("model graph is cyclic");i[a]==="white"&&r.push(a)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,r=new Array(this._nodes.length,0),i=0;for(let s=0;s<this._nodes.length;s++)r[s]=i,this._nodes[s].executeNode?(i!==s&&(this._nodes[i]=this._nodes[s]),i++):this._nodes[s].outputs.forEach(c=>{this._allData[c]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let s=0;s<this._allData.length;s++){let c=this._allData[s];c._from!==void 0&&c._from!==-1&&c._from!==-2&&(c._from=r[c._from]);for(let n=0;n<c._to.length;n++)if(c._to[n]>=0)c._to[n]=r[c._to[n]];else throw new Error("Trying to update a removed node")}e=0;for(let s=0;s<this._allData.length;s++){if(this._allData[s].from===-2&&this._allOutputIndices.indexOf(s+e)===-1){e++,this._allData.splice(s,1),s--;continue}if(e>0){let c=-1;this._allData[s].from!==void 0&&this._allData[s].from!==-1?(c=this._nodes[this._allData[s].from].outputs.indexOf(s+e),c!==-1&&(this._nodes[this._allData[s].from].outputs[c]=s)):(c=this._allInputIndices.indexOf(s+e),c!==-1&&(this._allInputIndices[c]=s)),this._allData[s].to.forEach(n=>{c=this._nodes[n].inputs.indexOf(s+e),c!==-1&&(this._nodes[n].inputs[c]=s)}),this._allData[s].to.length===0&&(c=this._allOutputIndices.indexOf(s+e),c!==-1&&(this._allOutputIndices[c]=s))}}}deleteNode(e){let r=this._nodes[e];if(r.outputs.length>1){for(let a=1;a<r.outputs.length;a++)if(this._allData[r.outputs[a]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let i=r.inputs[0],s=r.outputs[0],c=this._allData[s].to;for(let a=0;a<r.inputs.length;a++){let h=this._allData[r.inputs[a]].to.indexOf(e);if(h===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[a]].to.splice(h,1)}this._allData[s]._to=[];let n=this._allOutputIndices.indexOf(s);if(n!==-1&&(this._allOutputIndices[n]=i),c&&c.length>0)for(let a of c){let h=this._nodes[a].inputs.indexOf(s);if(h===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[a].inputs[h]=i,this._allData[i].to.push(a)}}removeAllDropoutNodes(){let e=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let r=this._allData[e.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{e.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[Ve,ze])}else if(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}}),Dp,vg,eo,Lp=O(()=>{wn(),Ep(),Pr(),Dp=rr(sr()),Y(),vg=F.experimental.fbs,eo=class{constructor(){}load(e,r,i){let s;if(!i)try{this.loadFromOnnxFormat(e,r);return}catch(c){if(i!==void 0)throw c;s=c}try{this.loadFromOrtFormat(e,r)}catch(c){throw i!==void 0?c:new Error(`Failed to load model as ONNX format: ${s}
as ORT format: ${c}`)}}loadFromOnnxFormat(e,r){let i=Dp.onnx.ModelProto.decode(e);if(Rt.longToNumber(i.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map(s=>({domain:s.domain,version:Rt.longToNumber(s.version)})),this._graph=Wi.from(i.graph,r)}loadFromOrtFormat(e,r){let i=new w.ByteBuffer(e),s=vg.InferenceSession.getRootAsInferenceSession(i).model();if(Rt.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let c=0;c<s.opsetImportLength();c++){let n=s.opsetImport(c);this._opsets.push({domain:n==null?void 0:n.domain(),version:Rt.longToNumber(n.version())})}this._graph=Wi.from(s.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}}),ro,$p=O(()=>{Sp(),Ap(),Ut(),Lp(),ro=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=xn.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,r,i){await this.profiler.event("session","Session.loadModel",async()=>{let s=await Mi(this.backendHint);if(this.sessionHandler=s.createSessionHandler(this.context),this._model=new eo,typeof e=="string"){let c=e.endsWith(".ort");{let n=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(n),c)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let c=new Uint8Array(e,r||0,i||e.byteLength);this.initialize(c)}})}initialize(e,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,i,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Zn(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(e),i=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(i)})}normalizeAndValidateInputs(e){let r=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${e.length}`)}else{if(e.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${e.size}`);let i=new Array(e.size),s=0;for(let c=0;c<r.length;++c){let n=e.get(r[c]);if(!n)throw new Error(`missing input tensor for: '${name}'`);i[s++]=n}e=i}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let i=this._model.graph.getInputIndices(),s=this._model.graph.getValues(),c=new Array(i.length);for(let n=0;n<i.length;++n){let a=s[i[n]];c[n]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[n].dims)}this.validateInputTensorDims(c,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,r){for(let i=0;i<r.length;i++){let s=e[i],c=r[i].type;if(s!==c)throw new Error(`input tensor[${i}] check failed: expected type '${s}' but got ${c}`)}}validateInputTensorDims(e,r,i){for(let s=0;s<r.length;s++){let c=e[s],n=r[s].dims;if(!this.compareTensorDims(c,n,i))throw new Error(`input tensor[${s}] check failed: expected shape '[${c.join(",")}]' but got [${n.join(",")}]`)}}compareTensorDims(e,r,i){if(e.length!==r.length)return!1;for(let s=0;s<e.length;++s)if(e[s]!==r[s]&&(!i||e[s]!==0))return!1;return!0}createOutput(e){let r=this._model.graph.getOutputNames();if(e.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let i=new Map;for(let s=0;s<r.length;++s)i.set(r[s],e[s]);return i}initializeOps(e){let r=e.getNodes();this._ops=new Array(r.length);for(let i=0;i<r.length;i++)this._ops[i]=this.sessionHandler.resolve(r[i],this._model.opsets,e)}}}),no,kp=O(()=>{Yt(),We(),no=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,r,i){let s=new Map;for(let a in e)if(Object.hasOwnProperty.call(e,a)){let h=e[a];s.set(a,new bt(h.dims,h.type,void 0,void 0,h.data))}let c=await this.session.run(s),n={};return c.forEach((a,h)=>{n[h]=new yt(a.type,a.data,a.dims)}),n}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),Bp={};Or(Bp,{onnxjsBackend:()=>Ig});var Hi,Ig,Fp=O(()=>{$p(),kp(),Hi=class{async init(){}async createInferenceSessionHandler(e,r){let i=new ro(r);return typeof e=="string"?await i.loadModel(e):await i.loadModel(e),new no(i)}},Ig=new Hi}),oo=O(()=>{}),Rp={};Or(Rp,{default:()=>_g});var Cp,Np,_g,Gp=O(()=>{var e;qi(),Ke(),Vr(),Cp="ort-wasm-proxy-worker",Np=((e=globalThis.self)==null?void 0:e.name)===Cp,Np&&(self.onmessage=r=>{let{type:i,in:s}=r.data;try{switch(i){case"init-wasm":io(s.wasm).then(()=>{ao(s).then(()=>{postMessage({type:i})},c=>{postMessage({type:i,err:c})})},c=>{postMessage({type:i,err:c})});break;case"init-ep":{let{epName:c,env:n}=s;so(n,c).then(()=>{postMessage({type:i})},a=>{postMessage({type:i,err:a})});break}case"copy-from":{let{buffer:c}=s,n=zr(c);postMessage({type:i,out:n});break}case"create":{let{model:c,options:n}=s;uo(c,n).then(a=>{postMessage({type:i,out:a})},a=>{postMessage({type:i,err:a})});break}case"release":lo(s),postMessage({type:i});break;case"run":{let{sessionId:c,inputIndices:n,inputs:a,outputIndices:h,options:p}=s;fo(c,n,a,h,new Array(h.length).fill(null),p).then(t=>{t.some(u=>u[3]!=="cpu")?postMessage({type:i,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:i,out:t},po([...a,...t]))},t=>{postMessage({type:i,err:t})});break}case"end-profiling":co(s),postMessage({type:i});break;default:}}catch(c){postMessage({type:i,err:c})}}),_g=Np?null:r=>new Worker(r??br,{type:"module",name:Cp})}),Up={};Or(Up,{default:()=>Og});var ji,Mp,Og,Vp=O(()=>{var e;Mp=(ji=import.meta.url,async function(r={}){function i(){return nt.buffer!=gt.buffer&&gr(),gt}function s(){return nt.buffer!=gt.buffer&&gr(),Dt}function c(){return nt.buffer!=gt.buffer&&gr(),Ge}function n(){return nt.buffer!=gt.buffer&&gr(),ge}function a(){return nt.buffer!=gt.buffer&&gr(),Ot}var h,p,t=Object.assign({},r),u=new Promise((S,be)=>{h=S,p=be}),l=typeof window=="object",f=typeof importScripts=="function",x=f&&self.name=="em-pthread";t.mountExternalData=(S,be)=>{S.startsWith("./")&&(S=S.substring(2)),(t.Ua||(t.Ua=new Map)).set(S,be)},t.unmountExternalData=()=>{delete t.Ua};var I,R,A=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,Z=Object.assign({},t),K="./this.program",Q=(S,be)=>{throw be},re="";(l||f)&&(f?re=self.location.href:typeof document<"u"&&document.currentScript&&(re=document.currentScript.src),ji&&(re=ji),re=re.startsWith("blob:")?"":re.substr(0,re.replace(/[?#].*/,"").lastIndexOf("/")+1),f&&(R=S=>{var be=new XMLHttpRequest;return be.open("GET",S,!1),be.responseType="arraybuffer",be.send(null),new Uint8Array(be.response)}),I=(S,be,wt)=>{var Jt=new XMLHttpRequest;Jt.open("GET",S,!0),Jt.responseType="arraybuffer",Jt.onload=()=>{Jt.status==200||Jt.status==0&&Jt.response?be(Jt.response):wt()},Jt.onerror=wt,Jt.send(null)});var se,ee=console.log.bind(console),ce=console.error.bind(console),X=ee,Re=ce;if(Object.assign(t,Z),Z=null,x){let S=function(be){try{var wt=be.data,Jt=wt.cmd;if(Jt==="load"){let Ir=[];self.onmessage=Lo=>Ir.push(Lo),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let Lo of Ir)S(Lo);self.onmessage=S};for(let Lo of wt.handlers)t[Lo]&&!t[Lo].proxy||(t[Lo]=(...Xo)=>{postMessage({Za:"callHandler",kb:Lo,args:Xo})},Lo=="print"&&(X=t[Lo]),Lo=="printErr"&&(Re=t[Lo]));nt=wt.wasmMemory,gr(),De(wt.wasmModule)}else if(Jt==="run"){Du(wt.pthread_ptr,0,0,1,0,0),o_(wt.pthread_ptr),$u(),ii(),et||(et=!0);try{Ie(wt.start_routine,wt.arg)}catch(Ir){if(Ir!="unwind")throw Ir}}else Jt==="cancel"?vd()&&qs(-1):wt.target!=="setimmediate"&&(Jt==="checkMailbox"?et&&Id():Jt&&(Re(`worker: received unknown command ${Jt}`),Re(wt)))}catch(Ir){throw xu(),Ir}};var De,et=!1;Re=function(...be){be=be.join(" "),console.error(be)},self.alert=function(...be){postMessage({Za:"alert",text:be.join(" "),nb:vd()})},t.instantiateWasm=(be,wt)=>new Promise(Jt=>{De=Ir=>{Ir=new WebAssembly.Instance(Ir,en()),wt(Ir),Jt()}}),self.onunhandledrejection=be=>{throw be.reason||be},self.onmessage=S}t.wasmBinary&&(se=t.wasmBinary);var nt,it,_t,gt,Dt,Ge,ge,ct,Ot,$t=!1;function gr(){var S=nt.buffer;t.HEAP8=gt=new Int8Array(S),t.HEAP16=new Int16Array(S),t.HEAPU8=Dt=new Uint8Array(S),t.HEAPU16=new Uint16Array(S),t.HEAP32=Ge=new Int32Array(S),t.HEAPU32=ge=new Uint32Array(S),t.HEAPF32=new Float32Array(S),t.HEAPF64=Ot=new Float64Array(S),t.HEAP64=ct=new BigInt64Array(S),t.HEAPU64=new BigUint64Array(S)}if(!x){if(!((nt=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof A))throw Re("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");gr()}var Qe=[],Dr=[],vn=[],vr=0,Eo=null;function Ao(){if(--vr==0&&Eo){var S=Eo;Eo=null,S()}}function Yr(S){throw Re(S="Aborted("+S+")"),$t=!0,_t=1,S=new WebAssembly.RuntimeError(S+". Build with -sASSERTIONS for more info."),p(S),S}var Ze,er=S=>S.startsWith("data:application/octet-stream;base64,"),Kr=S=>S.startsWith("file://");function _o(S){if(S==Ze&&se)return new Uint8Array(se);if(R)return R(S);throw"both async and sync fetching of the wasm failed"}function Jr(S,be,wt){return function(Jt){if(!se&&(l||f)){if(typeof fetch=="function"&&!Kr(Jt))return fetch(Jt,{credentials:"same-origin"}).then(Ir=>{if(!Ir.ok)throw`failed to load wasm binary file at '${Jt}'`;return Ir.arrayBuffer()}).catch(()=>_o(Jt));if(I)return new Promise((Ir,Lo)=>{I(Jt,Xo=>Ir(new Uint8Array(Xo)),Lo)})}return Promise.resolve().then(()=>_o(Jt))}(S).then(Jt=>WebAssembly.instantiate(Jt,be)).then(wt,Jt=>{Re(`failed to asynchronously prepare wasm: ${Jt}`),Yr(Jt)})}function en(){return{a:{j:Ks,b:Lr,E:tr,g:ri,V:Yo,A:ha,C:Wt,W:$o,T:Io,L:ma,S:Ba,o:eu,B:wu,y:Oa,U:bu,z:tu,_:Bd,Z:_u,P:m_,w:M_,F:P_,k:k_,O:o_,Y:O_,I:i_,J:g_,K:Rd,G:a_,H:l_,v:b_,q:u_,l:$_,p:A_,e:y_,X:S_,x:d_,d:w_,f:I_,i:Pt,u:L,t:Lt,s:tn,Q:oa,R:va,D:ko,h:Wa,n:$a,M:hu,m:ka,a:nt,r:at,N:wr,c:Su}}}var Bo={836884:(S,be,wt,Jt,Ir)=>{if(t===void 0||!t.Ua)return 1;if((S=jo(S>>>0)).startsWith("./")&&(S=S.substring(2)),!(S=t.Ua.get(S)))return 2;if(Jt>>>=0,(be>>>=0)+(wt>>>=0)>S.byteLength)return 3;try{let Lo=S.subarray(be,be+wt);switch(Ir){case 0:s().set(Lo,Jt>>>0);break;case 1:t.mb(Jt,Lo);break;default:return 4}return 0}catch{return 4}},837567:()=>typeof wasmOffsetConverter<"u"};function Ks(){return typeof wasmOffsetConverter<"u"}function ni(S){this.name="ExitStatus",this.message=`Program terminated with exit(${S})`,this.status=S}var ti=S=>{S.terminate(),S.onmessage=()=>{}},oe=S=>{_n.length==0&&(Na(),Sa(_n[0]));var be=_n.pop();if(!be)return 6;ra.push(be),Jo[S.Ra]=be,be.Ra=S.Ra;var wt={cmd:"run",start_routine:S.cb,arg:S.ab,pthread_ptr:S.Ra};return be.postMessage(wt,S.ib),0},Ye=0,le=(S,be,...wt)=>{for(var Jt=2*wt.length,Ir=ca(),Lo=Dd(8*Jt),Xo=Lo>>>3,gu=0;gu<wt.length;gu++){var Bu=wt[gu];typeof Bu=="bigint"?(ct[Xo+2*gu]=1n,ct[Xo+2*gu+1]=Bu):(ct[Xo+2*gu]=0n,a()[Xo+2*gu+1>>>0]=Bu)}return S=Fa(S,0,Jt,Lo,be),Cd(Ir),S};function at(S){if(x)return le(0,1,S);if(_t=S,!(0<Ye)){for(var be of ra)ti(be);for(be of _n)ti(be);_n=[],ra=[],Jo=[],$t=!0}Q(S,new ni(S))}function Ft(S){if(x)return le(1,0,S);ko(S)}var ko=S=>{if(_t=S,x)throw Ft(S),"unwind";at(S)},_n=[],ra=[],zo=[],Jo={},ia=S=>{var be=S.Ra;delete Jo[be],_n.push(S),ra.splice(ra.indexOf(S),1),S.Ra=0,Ga(be)};function ii(){zo.forEach(S=>S())}var Sa=S=>new Promise(be=>{S.onmessage=Ir=>{var Lo=(Ir=Ir.data).cmd;if(Ir.targetThread&&Ir.targetThread!=vd()){var Xo=Jo[Ir.targetThread];Xo?Xo.postMessage(Ir,Ir.transferList):Re(`Internal error! Worker sent a message "${Lo}" to target pthread ${Ir.targetThread}, but that thread no longer exists!`)}else Lo==="checkMailbox"?Id():Lo==="spawnThread"?oe(Ir):Lo==="cleanupThread"?ia(Jo[Ir.thread]):Lo==="killThread"?(Ir=Ir.thread,Lo=Jo[Ir],delete Jo[Ir],ti(Lo),Ga(Ir),ra.splice(ra.indexOf(Lo),1),Lo.Ra=0):Lo==="cancelThread"?Jo[Ir.thread].postMessage({cmd:"cancel"}):Lo==="loaded"?(S.loaded=!0,be(S)):Lo==="alert"?alert(`Thread ${Ir.threadId}: ${Ir.text}`):Ir.target==="setimmediate"?S.postMessage(Ir):Lo==="callHandler"?t[Ir.handler](...Ir.args):Lo&&Re(`worker sent an unknown command ${Lo}`)},S.onerror=Ir=>{throw Re(`worker sent an error! ${Ir.filename}:${Ir.lineno}: ${Ir.message}`),Ir};var wt,Jt=[];for(wt of[])t.hasOwnProperty(wt)&&Jt.push(wt);S.postMessage({cmd:"load",handlers:Jt,wasmMemory:nt,wasmModule:it})});function Na(){var S=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});_n.push(S)}var Tu,Ua=S=>{for(;0<S.length;)S.shift()(t)},$u=()=>{var S=vd(),be=n()[S+52>>>2>>>0];S=n()[S+56>>>2>>>0],t_(be,be-S),Cd(be)},So=[],Ie=(S,be)=>{Ye=0;var wt=So[S];wt||(S>=So.length&&(So.length=S+1),So[S]=wt=Tu.get(S)),S=wt(be),0<Ye?_t=S:qs(S)};class Nt{constructor(be){this.Xa=be-24}}function Lr(S,be,wt){var Jt=new Nt(S>>>=0);throw be>>>=0,wt>>>=0,n()[Jt.Xa+16>>>2>>>0]=0,n()[Jt.Xa+4>>>2>>>0]=be,n()[Jt.Xa+8>>>2>>>0]=wt,S}function Oo(S,be,wt,Jt){return x?le(2,1,S,be,wt,Jt):tr(S,be,wt,Jt)}function tr(S,be,wt,Jt){if(S>>>=0,be>>>=0,wt>>>=0,Jt>>>=0,A===void 0)return Re("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ir=[];return x&&Ir.length===0?Oo(S,be,wt,Jt):(S={cb:wt,Ra:S,ab:Jt,ib:Ir},x?(S.Za="spawnThread",postMessage(S,Ir),0):oe(S))}var Po=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Ko=(S,be,wt)=>{var Jt=(be>>>=0)+wt;for(wt=be;S[wt]&&!(wt>=Jt);)++wt;if(16<wt-be&&S.buffer&&Po)return Po.decode(S.buffer instanceof A?S.slice(be,wt):S.subarray(be,wt));for(Jt="";be<wt;){var Ir=S[be++];if(128&Ir){var Lo=63&S[be++];if((224&Ir)==192)Jt+=String.fromCharCode((31&Ir)<<6|Lo);else{var Xo=63&S[be++];65536>(Ir=(240&Ir)==224?(15&Ir)<<12|Lo<<6|Xo:(7&Ir)<<18|Lo<<12|Xo<<6|63&S[be++])?Jt+=String.fromCharCode(Ir):(Ir-=65536,Jt+=String.fromCharCode(55296|Ir>>10,56320|1023&Ir))}}else Jt+=String.fromCharCode(Ir)}return Jt},jo=(S,be)=>(S>>>=0)?Ko(s(),S,be):"";function ri(S,be,wt){return x?le(3,1,S,be,wt):0}function Yo(S,be){if(x)return le(4,1,S,be)}var la=S=>{for(var be=0,wt=0;wt<S.length;++wt){var Jt=S.charCodeAt(wt);127>=Jt?be++:2047>=Jt?be+=2:55296<=Jt&&57343>=Jt?(be+=4,++wt):be+=3}return be},da=(S,be,wt,Jt)=>{if(!(0<Jt))return 0;var Ir=wt>>>=0;Jt=wt+Jt-1;for(var Lo=0;Lo<S.length;++Lo){var Xo=S.charCodeAt(Lo);if(55296<=Xo&&57343>=Xo&&(Xo=65536+((1023&Xo)<<10)|1023&S.charCodeAt(++Lo)),127>=Xo){if(wt>=Jt)break;be[wt++>>>0]=Xo}else{if(2047>=Xo){if(wt+1>=Jt)break;be[wt++>>>0]=192|Xo>>6}else{if(65535>=Xo){if(wt+2>=Jt)break;be[wt++>>>0]=224|Xo>>12}else{if(wt+3>=Jt)break;be[wt++>>>0]=240|Xo>>18,be[wt++>>>0]=128|Xo>>12&63}be[wt++>>>0]=128|Xo>>6&63}be[wt++>>>0]=128|63&Xo}}return be[wt>>>0]=0,wt-Ir},na=(S,be,wt)=>da(S,s(),be,wt);function ha(S,be){if(x)return le(5,1,S,be)}function Wt(S,be,wt){if(x)return le(6,1,S,be,wt)}function $o(S,be,wt){return x?le(7,1,S,be,wt):0}function Io(S,be){if(x)return le(8,1,S,be)}function ma(S,be,wt){if(x)return le(9,1,S,be,wt)}function Ba(S,be,wt,Jt){if(x)return le(10,1,S,be,wt,Jt)}function eu(S,be,wt,Jt){if(x)return le(11,1,S,be,wt,Jt)}function wu(S,be,wt,Jt){if(x)return le(12,1,S,be,wt,Jt)}function Oa(S){if(x)return le(13,1,S)}function bu(S,be){if(x)return le(14,1,S,be)}function tu(S,be,wt){if(x)return le(15,1,S,be,wt)}var Bd=()=>{Yr("")},_u=()=>1;function m_(S){Du(S>>>0,!f,1,!l,131072,!1),ii()}function o_(S){S>>>=0,typeof Atomics.jb=="function"&&(Atomics.jb(c(),S>>>2,S).value.then(Id),S+=128,Atomics.store(c(),S>>>2,1))}var Id=()=>{var S=vd();if(S&&(o_(S),S=La,!$t))try{if(S(),!(0<Ye))try{x?qs(_t):ko(_t)}catch(be){be instanceof ni||be=="unwind"||Q(1,be)}}catch(be){be instanceof ni||be=="unwind"||Q(1,be)}};function M_(S,be){(S>>>=0)==be>>>0?setTimeout(Id):x?postMessage({targetThread:S,cmd:"checkMailbox"}):(S=Jo[S])&&S.postMessage({cmd:"checkMailbox"})}var s_=[];function P_(S,be,wt,Jt,Ir){for(be>>>=0,Jt/=2,s_.length=Jt,wt=Ir>>>0>>>3,Ir=0;Ir<Jt;Ir++)s_[Ir]=ct[wt+2*Ir]?ct[wt+2*Ir+1]:a()[wt+2*Ir+1>>>0];return(be?Bo[be]:zu[S])(...s_)}function k_(S){S>>>=0,x?postMessage({cmd:"cleanupThread",thread:S}):ia(Jo[S])}function O_(S){}function i_(S,be){S=-9007199254740992>S||9007199254740992<S?NaN:Number(S),be>>>=0,S=new Date(1e3*S),c()[be>>>2>>>0]=S.getUTCSeconds(),c()[be+4>>>2>>>0]=S.getUTCMinutes(),c()[be+8>>>2>>>0]=S.getUTCHours(),c()[be+12>>>2>>>0]=S.getUTCDate(),c()[be+16>>>2>>>0]=S.getUTCMonth(),c()[be+20>>>2>>>0]=S.getUTCFullYear()-1900,c()[be+24>>>2>>>0]=S.getUTCDay(),S=(S.getTime()-Date.UTC(S.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,c()[be+28>>>2>>>0]=S}var Pd=S=>S%4==0&&(S%100!=0||S%400==0),Ad=[0,31,60,91,121,152,182,213,244,274,305,335],Ld=[0,31,59,90,120,151,181,212,243,273,304,334];function g_(S,be){S=-9007199254740992>S||9007199254740992<S?NaN:Number(S),be>>>=0,S=new Date(1e3*S),c()[be>>>2>>>0]=S.getSeconds(),c()[be+4>>>2>>>0]=S.getMinutes(),c()[be+8>>>2>>>0]=S.getHours(),c()[be+12>>>2>>>0]=S.getDate(),c()[be+16>>>2>>>0]=S.getMonth(),c()[be+20>>>2>>>0]=S.getFullYear()-1900,c()[be+24>>>2>>>0]=S.getDay();var wt=(Pd(S.getFullYear())?Ad:Ld)[S.getMonth()]+S.getDate()-1|0;c()[be+28>>>2>>>0]=wt,c()[be+36>>>2>>>0]=-60*S.getTimezoneOffset(),wt=new Date(S.getFullYear(),6,1).getTimezoneOffset();var Jt=new Date(S.getFullYear(),0,1).getTimezoneOffset();S=0|(wt!=Jt&&S.getTimezoneOffset()==Math.min(Jt,wt)),c()[be+32>>>2>>>0]=S}function Rd(S){S>>>=0;var be=new Date(c()[S+20>>>2>>>0]+1900,c()[S+16>>>2>>>0],c()[S+12>>>2>>>0],c()[S+8>>>2>>>0],c()[S+4>>>2>>>0],c()[S>>>2>>>0],0),wt=c()[S+32>>>2>>>0],Jt=be.getTimezoneOffset(),Ir=new Date(be.getFullYear(),6,1).getTimezoneOffset(),Lo=new Date(be.getFullYear(),0,1).getTimezoneOffset(),Xo=Math.min(Lo,Ir);return 0>wt?c()[S+32>>>2>>>0]=+(Ir!=Lo&&Xo==Jt):0<wt!=(Xo==Jt)&&(Ir=Math.max(Lo,Ir),be.setTime(be.getTime()+6e4*((0<wt?Xo:Ir)-Jt))),c()[S+24>>>2>>>0]=be.getDay(),wt=(Pd(be.getFullYear())?Ad:Ld)[be.getMonth()]+be.getDate()-1|0,c()[S+28>>>2>>>0]=wt,c()[S>>>2>>>0]=be.getSeconds(),c()[S+4>>>2>>>0]=be.getMinutes(),c()[S+8>>>2>>>0]=be.getHours(),c()[S+12>>>2>>>0]=be.getDate(),c()[S+16>>>2>>>0]=be.getMonth(),c()[S+20>>>2>>>0]=be.getYear(),S=be.getTime(),BigInt(isNaN(S)?-1:S/1e3)}function a_(S,be,wt,Jt,Ir,Lo,Xo){return x?le(16,1,S,be,wt,Jt,Ir,Lo,Xo):-52}function l_(S,be,wt,Jt,Ir,Lo){if(x)return le(17,1,S,be,wt,Jt,Ir,Lo)}function b_(S,be,wt,Jt){S>>>=0,be>>>=0,wt>>>=0,Jt>>>=0;var Ir=new Date().getFullYear(),Lo=new Date(Ir,0,1),Xo=new Date(Ir,6,1);Ir=Lo.getTimezoneOffset();var gu=Xo.getTimezoneOffset(),Bu=Math.max(Ir,gu);n()[S>>>2>>>0]=60*Bu,c()[be>>>2>>>0]=+(Ir!=gu),Lo=(S=Pu=>Pu.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(Lo),Xo=S(Xo),gu<Ir?(na(Lo,wt,17),na(Xo,Jt,17)):(na(Lo,Jt,17),na(Xo,wt,17))}var ya=[];function u_(S,be,wt){S>>>=0,be>>>=0,wt>>>=0,ya.length=0;for(var Jt;Jt=s()[be++>>>0];){var Ir=Jt!=105;wt+=(Ir&=Jt!=112)&&wt%8?4:0,ya.push(Jt==112?n()[wt>>>2>>>0]:Jt==106?ct[wt>>>3]:Jt==105?c()[wt>>>2>>>0]:a()[wt>>>3>>>0]),wt+=Ir?8:4}return Bo[S](...ya)}var $_=()=>{},A_=()=>Date.now();function y_(S,be){return Re(jo(S>>>0,be>>>0))}var w_,S_=()=>{throw Ye+=1,"unwind"};function d_(){return 4294901760}w_=()=>performance.timeOrigin+performance.now();var I_=()=>navigator.hardwareConcurrency;function Pt(){return Yr("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function L(S){S>>>=0;var be=s().length;if(S<=be||4294901760<S)return!1;for(var wt=1;4>=wt;wt*=2){var Jt=be*(1+.2/wt);Jt=Math.min(Jt,S+100663296);var Ir=Math;Jt=Math.max(S,Jt);e:{Ir=(Ir.min.call(Ir,4294901760,Jt+(65536-Jt%65536)%65536)-nt.buffer.byteLength+65535)/65536;try{nt.grow(Ir),gr();var Lo=1;break e}catch{}Lo=void 0}if(Lo)return!0}return!1}var we=()=>(Yr("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),st={},Mt=S=>{S.forEach(be=>{we()})};function Lt(){var S=Error().stack.toString().split(`
`);return S[0]=="Error"&&S.shift(),Mt(S),st.$a=we(),st.bb=S,st.$a}function tn(S,be,wt){if(S>>>=0,be>>>=0,st.$a==S)var Jt=st.bb;else(Jt=Error().stack.toString().split(`
`))[0]=="Error"&&Jt.shift(),Mt(Jt);for(var Ir=3;Jt[Ir]&&we()!=S;)++Ir;for(S=0;S<wt&&Jt[S+Ir];++S)c()[be+4*S>>>2>>>0]=we();return S}var Zo,Js={},Xs=()=>{if(!Zo){var S,be={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:K};for(S in Js)Js[S]===void 0?delete be[S]:be[S]=Js[S];var wt=[];for(S in be)wt.push(`${S}=${be[S]}`);Zo=wt}return Zo};function oa(S,be){if(x)return le(18,1,S,be);S>>>=0,be>>>=0;var wt=0;return Xs().forEach((Jt,Ir)=>{var Lo=be+wt;for(Ir=n()[S+4*Ir>>>2>>>0]=Lo,Lo=0;Lo<Jt.length;++Lo)i()[Ir++>>>0]=Jt.charCodeAt(Lo);i()[Ir>>>0]=0,wt+=Jt.length+1}),0}function va(S,be){if(x)return le(19,1,S,be);S>>>=0,be>>>=0;var wt=Xs();n()[S>>>2>>>0]=wt.length;var Jt=0;return wt.forEach(Ir=>Jt+=Ir.length+1),n()[be>>>2>>>0]=Jt,0}function Wa(S){return x?le(20,1,S):52}function $a(S,be,wt,Jt){return x?le(21,1,S,be,wt,Jt):52}function hu(S,be,wt,Jt){return x?le(22,1,S,be,wt,Jt):70}var Au=[null,[],[]];function ka(S,be,wt,Jt){if(x)return le(23,1,S,be,wt,Jt);be>>>=0,wt>>>=0,Jt>>>=0;for(var Ir=0,Lo=0;Lo<wt;Lo++){var Xo=n()[be>>>2>>>0],gu=n()[be+4>>>2>>>0];be+=8;for(var Bu=0;Bu<gu;Bu++){var Pu=s()[Xo+Bu>>>0],md=Au[S];Pu===0||Pu===10?((S===1?X:Re)(Ko(md,0)),md.length=0):md.push(Pu)}Ir+=gu}return n()[Jt>>>2>>>0]=Ir,0}var Va=[31,29,31,30,31,30,31,31,30,31,30,31],Gu=[31,28,31,30,31,30,31,31,30,31,30,31],xd=(S,be)=>{i().set(S,be>>>0)};function wr(S,be,wt,Jt){function Ir(In,qa,ru){for(In=typeof In=="number"?In.toString():In||"";In.length<qa;)In=ru[0]+In;return In}function Lo(In,qa){return Ir(In,qa,"0")}function Xo(In,qa){function ru(U_){return 0>U_?-1:0<U_?1:0}var r_;return(r_=ru(In.getFullYear()-qa.getFullYear()))===0&&(r_=ru(In.getMonth()-qa.getMonth()))===0&&(r_=ru(In.getDate()-qa.getDate())),r_}function gu(In){switch(In.getDay()){case 0:return new Date(In.getFullYear()-1,11,29);case 1:return In;case 2:return new Date(In.getFullYear(),0,3);case 3:return new Date(In.getFullYear(),0,2);case 4:return new Date(In.getFullYear(),0,1);case 5:return new Date(In.getFullYear()-1,11,31);case 6:return new Date(In.getFullYear()-1,11,30)}}function Bu(In){var qa=In.Sa;for(In=new Date(new Date(In.Ta+1900,0,1).getTime());0<qa;){var ru=In.getMonth(),r_=(Pd(In.getFullYear())?Va:Gu)[ru];if(!(qa>r_-In.getDate())){In.setDate(In.getDate()+qa);break}qa-=r_-In.getDate()+1,In.setDate(1),11>ru?In.setMonth(ru+1):(In.setMonth(0),In.setFullYear(In.getFullYear()+1))}return ru=new Date(In.getFullYear()+1,0,4),qa=gu(new Date(In.getFullYear(),0,4)),ru=gu(ru),0>=Xo(qa,In)?0>=Xo(ru,In)?In.getFullYear()+1:In.getFullYear():In.getFullYear()-1}S>>>=0,be>>>=0,wt>>>=0,Jt>>>=0;var Pu=n()[Jt+40>>>2>>>0];for(var md in Jt={gb:c()[Jt>>>2>>>0],fb:c()[Jt+4>>>2>>>0],Va:c()[Jt+8>>>2>>>0],Ya:c()[Jt+12>>>2>>>0],Wa:c()[Jt+16>>>2>>>0],Ta:c()[Jt+20>>>2>>>0],Qa:c()[Jt+24>>>2>>>0],Sa:c()[Jt+28>>>2>>>0],ob:c()[Jt+32>>>2>>>0],eb:c()[Jt+36>>>2>>>0],hb:Pu?jo(Pu):""},wt=jo(wt),Pu={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})wt=wt.replace(new RegExp(md,"g"),Pu[md]);var fh="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Td="January February March April May June July August September October November December".split(" ");for(md in Pu={"%a":In=>fh[In.Qa].substring(0,3),"%A":In=>fh[In.Qa],"%b":In=>Td[In.Wa].substring(0,3),"%B":In=>Td[In.Wa],"%C":In=>Lo((In.Ta+1900)/100|0,2),"%d":In=>Lo(In.Ya,2),"%e":In=>Ir(In.Ya,2," "),"%g":In=>Bu(In).toString().substring(2),"%G":Bu,"%H":In=>Lo(In.Va,2),"%I":In=>((In=In.Va)==0?In=12:12<In&&(In-=12),Lo(In,2)),"%j":In=>{for(var qa=0,ru=0;ru<=In.Wa-1;qa+=(Pd(In.Ta+1900)?Va:Gu)[ru++]);return Lo(In.Ya+qa,3)},"%m":In=>Lo(In.Wa+1,2),"%M":In=>Lo(In.fb,2),"%n":()=>`
`,"%p":In=>0<=In.Va&&12>In.Va?"AM":"PM","%S":In=>Lo(In.gb,2),"%t":()=>"	","%u":In=>In.Qa||7,"%U":In=>Lo(Math.floor((In.Sa+7-In.Qa)/7),2),"%V":In=>{var qa=Math.floor((In.Sa+7-(In.Qa+6)%7)/7);if(2>=(In.Qa+371-In.Sa-2)%7&&qa++,qa)qa==53&&((ru=(In.Qa+371-In.Sa)%7)==4||ru==3&&Pd(In.Ta)||(qa=1));else{qa=52;var ru=(In.Qa+7-In.Sa-1)%7;(ru==4||ru==5&&Pd(In.Ta%400-1))&&qa++}return Lo(qa,2)},"%w":In=>In.Qa,"%W":In=>Lo(Math.floor((In.Sa+7-(In.Qa+6)%7)/7),2),"%y":In=>(In.Ta+1900).toString().substring(2),"%Y":In=>In.Ta+1900,"%z":In=>{var qa=0<=(In=In.eb);return In=Math.abs(In)/60,(qa?"+":"-")+("0000"+(In/60*100+In%60)).slice(-4)},"%Z":In=>In.hb,"%%":()=>"%"},wt=wt.replace(/%%/g,"\0\0"),Pu)wt.includes(md)&&(wt=wt.replace(new RegExp(md,"g"),Pu[md](Jt)));return md=function(In){var qa=Array(la(In)+1);return da(In,qa,0,qa.length),qa}(wt=wt.replace(/\0\0/g,"%")),md.length>be?0:(xd(md,S),md.length-1)}function Su(S,be,wt,Jt){return wr(S>>>0,be>>>0,wt>>>0,Jt>>>0)}x||function(){for(var S=t.numThreads-1;S--;)Na();Qe.unshift(()=>{vr++,function(be){x?be():Promise.all(_n.map(Sa)).then(be)}(()=>Ao())})}();var zu=[at,Ft,Oo,ri,Yo,ha,Wt,$o,Io,ma,Ba,eu,wu,Oa,bu,tu,a_,l_,oa,va,Wa,$a,hu,ka],ba=function(){function S(wt,Jt){return ba=wt.exports,ba=function(){var Ir=ba,Lo=gu=>()=>gu()>>>0,Xo=gu=>Bu=>gu(Bu)>>>0;return(Ir=Object.assign({},Ir)).Ba=Lo(Ir.Ba),Ir.Ca=Xo(Ir.Ca),Ir.emscripten_main_runtime_thread_id=Lo(Ir.emscripten_main_runtime_thread_id),Ir.Oa=Xo(Ir.Oa),Ir.Pa=Lo(Ir.Pa),Ir}(),zo.push(ba.Ea),Tu=ba.Fa,Dr.unshift(ba.$),it=Jt,Ao(),ba}var be=en();if(vr++,t.instantiateWasm)try{return t.instantiateWasm(be,S)}catch(wt){Re(`Module.instantiateWasm callback failed with error: ${wt}`),p(wt)}return Ze||(Ze=t.locateFile?er("ort-wasm-simd-threaded.wasm")?"ort-wasm-simd-threaded.wasm":t.locateFile?t.locateFile("ort-wasm-simd-threaded.wasm",re):re+"ort-wasm-simd-threaded.wasm":new URL(""+new URL("../assets/ort-wasm-simd-threaded.Q3J8IDpZ.wasm",import.meta.url).href,import.meta.url).href),function(wt,Jt){var Ir=Ze;return se||typeof WebAssembly.instantiateStreaming!="function"||er(Ir)||Kr(Ir)||typeof fetch!="function"?Jr(Ir,wt,Jt):fetch(Ir,{credentials:"same-origin"}).then(Lo=>WebAssembly.instantiateStreaming(Lo,wt).then(Jt,function(Xo){return Re(`wasm streaming compile failed: ${Xo}`),Re("falling back to ArrayBuffer instantiation"),Jr(Ir,wt,Jt)}))}(be,function(wt){S(wt.instance,wt.module)}).catch(p),{}}();t._OrtInit=(S,be)=>(t._OrtInit=ba.aa)(S,be),t._OrtGetLastError=(S,be)=>(t._OrtGetLastError=ba.ba)(S,be),t._OrtCreateSessionOptions=(S,be,wt,Jt,Ir,Lo,Xo,gu,Bu,Pu)=>(t._OrtCreateSessionOptions=ba.ca)(S,be,wt,Jt,Ir,Lo,Xo,gu,Bu,Pu),t._OrtAppendExecutionProvider=(S,be)=>(t._OrtAppendExecutionProvider=ba.da)(S,be),t._OrtAddFreeDimensionOverride=(S,be,wt)=>(t._OrtAddFreeDimensionOverride=ba.ea)(S,be,wt),t._OrtAddSessionConfigEntry=(S,be,wt)=>(t._OrtAddSessionConfigEntry=ba.fa)(S,be,wt),t._OrtReleaseSessionOptions=S=>(t._OrtReleaseSessionOptions=ba.ga)(S),t._OrtCreateSession=(S,be,wt)=>(t._OrtCreateSession=ba.ha)(S,be,wt),t._OrtReleaseSession=S=>(t._OrtReleaseSession=ba.ia)(S),t._OrtGetInputOutputCount=(S,be,wt)=>(t._OrtGetInputOutputCount=ba.ja)(S,be,wt),t._OrtGetInputName=(S,be)=>(t._OrtGetInputName=ba.ka)(S,be),t._OrtGetOutputName=(S,be)=>(t._OrtGetOutputName=ba.la)(S,be),t._OrtFree=S=>(t._OrtFree=ba.ma)(S),t._OrtCreateTensor=(S,be,wt,Jt,Ir,Lo)=>(t._OrtCreateTensor=ba.na)(S,be,wt,Jt,Ir,Lo),t._OrtGetTensorData=(S,be,wt,Jt,Ir)=>(t._OrtGetTensorData=ba.oa)(S,be,wt,Jt,Ir),t._OrtReleaseTensor=S=>(t._OrtReleaseTensor=ba.pa)(S),t._OrtCreateRunOptions=(S,be,wt,Jt)=>(t._OrtCreateRunOptions=ba.qa)(S,be,wt,Jt),t._OrtAddRunConfigEntry=(S,be,wt)=>(t._OrtAddRunConfigEntry=ba.ra)(S,be,wt),t._OrtReleaseRunOptions=S=>(t._OrtReleaseRunOptions=ba.sa)(S),t._OrtCreateBinding=S=>(t._OrtCreateBinding=ba.ta)(S),t._OrtBindInput=(S,be,wt)=>(t._OrtBindInput=ba.ua)(S,be,wt),t._OrtBindOutput=(S,be,wt,Jt)=>(t._OrtBindOutput=ba.va)(S,be,wt,Jt),t._OrtClearBoundOutputs=S=>(t._OrtClearBoundOutputs=ba.wa)(S),t._OrtReleaseBinding=S=>(t._OrtReleaseBinding=ba.xa)(S),t._OrtRunWithBinding=(S,be,wt,Jt,Ir)=>(t._OrtRunWithBinding=ba.ya)(S,be,wt,Jt,Ir),t._OrtRun=(S,be,wt,Jt,Ir,Lo,Xo,gu)=>(t._OrtRun=ba.za)(S,be,wt,Jt,Ir,Lo,Xo,gu),t._OrtEndProfiling=S=>(t._OrtEndProfiling=ba.Aa)(S);var vd=()=>(vd=ba.Ba)();t._malloc=S=>(t._malloc=ba.Ca)(S),t._free=S=>(t._free=ba.Da)(S);var fa,Du=(S,be,wt,Jt,Ir,Lo)=>(Du=ba.Ga)(S,be,wt,Jt,Ir,Lo),xu=()=>(xu=ba.Ha)(),Fa=(S,be,wt,Jt,Ir)=>(Fa=ba.Ia)(S,be,wt,Jt,Ir),Ga=S=>(Ga=ba.Ja)(S),qs=S=>(qs=ba.Ka)(S),La=()=>(La=ba.La)(),t_=(S,be)=>(t_=ba.Ma)(S,be),Cd=S=>(Cd=ba.Na)(S),Dd=S=>(Dd=ba.Oa)(S),ca=()=>(ca=ba.Pa)();function C_(){0<vr||(x?(h(t),x||Ua(Dr),startWorker(t)):(Ua(Qe),0<vr||fa||(fa=!0,t.calledRun=!0,$t||(x||Ua(Dr),h(t),x||Ua(vn)))))}return t.___start_em_js=837624,t.___stop_em_js=837685,t.stackSave=()=>ca(),t.stackRestore=S=>Cd(S),t.stackAlloc=S=>Dd(S),t.UTF8ToString=jo,t.stringToUTF8=na,t.lengthBytesUTF8=la,Eo=function S(){fa||C_(),fa||(Eo=S)},C_(),u}),Og=Mp,((e=globalThis.self)==null?void 0:e.name)==="em-pthread"&&Mp()}),br,Sg,Ag,Pg,zp,Wp,Eg,Hp,Vr=O(()=>{var e,r;oo(),br=import.meta.url??(typeof document<"u"?(e=document.currentScript)==null?void 0:e.src:typeof self<"u"?(r=self.location)==null?void 0:r.href:void 0),Sg=typeof location>"u"?void 0:location.origin,Ag=(i,s)=>{try{let c=s??br;return(c?new URL(i,c):new URL(i)).origin===Sg}catch{return!1}},Pg=async i=>{let s=await(await fetch(i,{credentials:"same-origin"})).blob();return URL.createObjectURL(s)},zp=(Gp(),sn(Rp)).default,Wp=async()=>{if(!br)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ag(br))return[void 0,zp()];let i=await Pg(br);return[i,zp(i)]},Eg=(Vp(),sn(Up)).default,Hp=async(i,s,c)=>[void 0,Eg]}),Xi,Ki,ho,qp,Dg,Lg,io,xt,Ke=O(()=>{Vr(),Ki=!1,ho=!1,qp=!1,Dg=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},io=async e=>{if(Ki)return Promise.resolve();if(ho)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(qp)throw new Error("previous call to 'initializeWebAssembly()' failed.");ho=!0;let r=e.initTimeout,i=e.numThreads;if(!Lg())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Dg();i>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=i=1);let c=e.wasmPaths,n=typeof c=="string"?c:void 0,a=c==null?void 0:c.mjs,h=(a==null?void 0:a.href)??a,p=c==null?void 0:c.wasm,t=(p==null?void 0:p.href)??p,u=e.wasmBinary,[l,f]=await Hp(h,n,i>1),x=!1,I=[];if(r>0&&I.push(new Promise(R=>{setTimeout(()=>{x=!0,R()},r)})),I.push(new Promise((R,A)=>{let Z={numThreads:i};u?Z.wasmBinary=u:(t||n)&&(Z.locateFile=(K,Q)=>t??(n??Q)+K),f(Z).then(K=>{ho=!1,Ki=!0,Xi=K,R(),l&&URL.revokeObjectURL(l)},K=>{ho=!1,qp=!0,A(K)})})),await Promise.race(I),x)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},xt=()=>{if(Ki&&Xi)return Xi;throw new Error("WebAssembly is not initialized yet.")}}),Tt,Wr,ht,mo=O(()=>{Ke(),Tt=(e,r)=>{let i=xt(),s=i.lengthBytesUTF8(e)+1,c=i._malloc(s);return i.stringToUTF8(e,c,s),r.push(c),c},Wr=(e,r,i,s)=>{if(typeof e=="object"&&e!==null){if(i.has(e))throw new Error("Circular reference in options");i.add(e)}Object.entries(e).forEach(([c,n])=>{let a=r?r+c:c;if(typeof n=="object")Wr(n,a+".",i,s);else if(typeof n=="string"||typeof n=="number")s(a,n.toString());else if(typeof n=="boolean")s(a,n?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof n}`)})},ht=e=>{let r=xt(),i=r.stackSave();try{let s=r.stackAlloc(8);r._OrtGetLastError(s,s+4);let c=r.HEAP32[s/4],n=r.HEAPU32[s/4+1],a=n?r.UTF8ToString(n):"";throw new Error(`${e} ERROR_CODE: ${c}, ERROR_MESSAGE: ${a}`)}finally{r.stackRestore(i)}}}),jp,Xp=O(()=>{Ke(),mo(),jp=e=>{let r=xt(),i=0,s=[],c=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)c.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)c.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(c.terminate=!1);let n=0;return(e==null?void 0:e.tag)!==void 0&&(n=Tt(e.tag,s)),i=r._OrtCreateRunOptions(c.logSeverityLevel,c.logVerbosityLevel,!!c.terminate,n),i===0&&ht("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&Wr(e.extra,"",new WeakSet,(a,h)=>{let p=Tt(a,s),t=Tt(h,s);r._OrtAddRunConfigEntry(i,p,t)!==0&&ht(`Can't set a run config entry: ${a} - ${h}.`)}),[i,s]}catch(n){throw i!==0&&r._OrtReleaseRunOptions(i),s.forEach(a=>r._free(a)),n}}}),$g,kg,Bg,Fg,Kp,Jp=O(()=>{Ke(),mo(),$g=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},kg=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Bg=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let r=e.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(i=>(typeof i=="string"?i:i.name)==="webgpu")&&(e.enableMemPattern=!1)},Fg=(e,r,i)=>{for(let s of r){let c=typeof s=="string"?s:s.name;switch(c){case"webnn":if(c="WEBNN",typeof s!="string"){let a=s==null?void 0:s.deviceType;if(a){let h=Tt("deviceType",i),p=Tt(a,i);xt()._OrtAddSessionConfigEntry(e,h,p)!==0&&ht(`Can't set a session config entry: 'deviceType' - ${a}.`)}}break;case"webgpu":if(c="JS",typeof s!="string"){let a=s;if(a!=null&&a.preferredLayout){if(a.preferredLayout!=="NCHW"&&a.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);let h=Tt("preferredLayout",i),p=Tt(a.preferredLayout,i);xt()._OrtAddSessionConfigEntry(e,h,p)!==0&&ht(`Can't set a session config entry: 'preferredLayout' - ${a.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${c}`)}let n=Tt(c,i);xt()._OrtAppendExecutionProvider(e,n)!==0&&ht(`Can't append execution provider: ${c}.`)}},Kp=e=>{let r=xt(),i=0,s=[],c=e||{};Bg(c);try{let n=$g(c.graphOptimizationLevel??"all"),a=kg(c.executionMode??"sequential"),h=typeof c.logId=="string"?Tt(c.logId,s):0,p=c.logSeverityLevel??2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);let t=c.logVerbosityLevel??0;if(!Number.isInteger(t)||t<0||t>4)throw new Error(`log verbosity level is not valid: ${t}`);let u=typeof c.optimizedModelFilePath=="string"?Tt(c.optimizedModelFilePath,s):0;if(i=r._OrtCreateSessionOptions(n,!!c.enableCpuMemArena,!!c.enableMemPattern,a,!!c.enableProfiling,0,h,p,t,u),i===0&&ht("Can't create session options."),c.executionProviders&&Fg(i,c.executionProviders,s),c.enableGraphCapture!==void 0){if(typeof c.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${c.enableGraphCapture}`);let l=Tt("enableGraphCapture",s),f=Tt(c.enableGraphCapture.toString(),s);r._OrtAddSessionConfigEntry(i,l,f)!==0&&ht(`Can't set a session config entry: 'enableGraphCapture' - ${c.enableGraphCapture}.`)}if(c.freeDimensionOverrides)for(let[l,f]of Object.entries(c.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof f!="number"||!Number.isInteger(f)||f<0)throw new Error(`free dimension override value must be a non-negative integer: ${f}`);let x=Tt(l,s);r._OrtAddFreeDimensionOverride(i,x,f)!==0&&ht(`Can't set a free dimension override: ${l} - ${f}.`)}return c.extra!==void 0&&Wr(c.extra,"",new WeakSet,(l,f)=>{let x=Tt(l,s),I=Tt(f,s);r._OrtAddSessionConfigEntry(i,x,I)!==0&&ht(`Can't set a session config entry: ${l} - ${f}.`)}),[i,s]}catch(n){throw i!==0&&r._OrtReleaseSessionOptions(i),s.forEach(a=>r._free(a)),n}}}),Hr,Yp,qr,Zp,Qp,bo,go,td,Ji=O(()=>{Hr=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Yp=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},qr=(e,r)=>{let i=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof r=="number"?r:r.reduce((c,n)=>c*n,1);return i>0?Math.ceil(s*i):void 0},Zp=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Qp=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},bo=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",go=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool",td=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),jr,Yi=O(()=>{oo(),jr=async e=>{if(typeof e=="string"){let r=await fetch(e);if(!r.ok)throw new Error(`failed to load external data file: ${e}`);let i=r.headers.get("Content-Length"),s=i?parseInt(i,10):0;if(s<1073741824)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let c=r.body.getReader(),n;try{n=new ArrayBuffer(s)}catch(h){if(h instanceof RangeError){let p=Math.ceil(s/65536);n=new WebAssembly.Memory({initial:p,maximum:p}).buffer}else throw h}let a=0;for(;;){let{done:h,value:p}=await c.read();if(h)break;let t=p.byteLength;new Uint8Array(n,a,t).set(p),a+=t}return new Uint8Array(n,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),Cg,ao,so,yr,Ng,zr,uo,lo,ed,fo,co,po,qi=O(()=>{Xp(),Jp(),Ji(),Ke(),mo(),Yi(),Cg=(e,r)=>{xt()._OrtInit(e,r)!==0&&ht("Can't initialize onnxruntime.")},ao=async e=>{Cg(e.wasm.numThreads,Qp(e.logLevel))},so=async(e,r)=>{},yr=new Map,Ng=e=>{let r=xt(),i=r.stackSave();try{let s=r.stackAlloc(8);return r._OrtGetInputOutputCount(e,s,s+4)!==0&&ht("Can't get session input/output count."),[r.HEAP32[s/4],r.HEAP32[s/4+1]]}finally{r.stackRestore(i)}},zr=e=>{let r=xt(),i=r._malloc(e.byteLength);if(i===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,i),[i,e.byteLength]},uo=async(e,r)=>{var u;let i,s,c=xt();Array.isArray(e)?[i,s]=e:e.buffer===c.HEAPU8.buffer?[i,s]=[e.byteOffset,e.byteLength]:[i,s]=zr(e);let n=0,a=0,h=[],p=[],t=[];try{if([a,h]=Kp(r),(r==null?void 0:r.externalData)&&c.mountExternalData){let K=[];for(let Q of r.externalData){let re=typeof Q=="string"?Q:Q.path;K.push(jr(typeof Q=="string"?Q:Q.data).then(se=>{c.mountExternalData(re,se)}))}await Promise.all(K)}for(let K of(r==null?void 0:r.executionProviders)??[])if((typeof K=="string"?K:K.name)==="webnn"){if(c.shouldTransferToMLTensor=!1,c.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof K!="string"){let Q=K,re=Q==null?void 0:Q.context,se=Q==null?void 0:Q.gpuDevice,ee=Q==null?void 0:Q.deviceType,ce=Q==null?void 0:Q.numThreads,X=Q==null?void 0:Q.powerPreference;re?c.currentContext=re:se?c.currentContext=await navigator.ml.createContext(se):c.currentContext=await navigator.ml.createContext({deviceType:ee,numThreads:ce,powerPreference:X})}else c.currentContext=await navigator.ml.createContext();break}n=await c._OrtCreateSession(i,s,a),n===0&&ht("Can't create a session."),c.currentContext&&(c.jsepRegisterMLContext(n,c.currentContext),c.currentContext=void 0,c.shouldTransferToMLTensor=!0);let[l,f]=Ng(n),x=!!(r!=null&&r.enableGraphCapture),I=[],R=[],A=[];for(let K=0;K<l;K++){let Q=c._OrtGetInputName(n,K);Q===0&&ht("Can't get an input name."),p.push(Q),I.push(c.UTF8ToString(Q))}for(let K=0;K<f;K++){let Q=c._OrtGetOutputName(n,K);Q===0&&ht("Can't get an output name."),t.push(Q);let re=c.UTF8ToString(Q);R.push(re)}return yr.set(n,[n,p,t,null,x,!1]),[n,I,R]}catch(l){throw p.forEach(f=>c._OrtFree(f)),t.forEach(f=>c._OrtFree(f)),n!==0&&c._OrtReleaseSession(n),l}finally{c._free(i),a!==0&&c._OrtReleaseSessionOptions(a),h.forEach(l=>c._free(l)),(u=c.unmountExternalData)==null||u.call(c)}},lo=e=>{var p;let r=xt(),i=yr.get(e);if(!i)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,c,n,a,h]=i;a&&(h&&r._OrtClearBoundOutputs(a.handle),r._OrtReleaseBinding(a.handle)),(p=r.jsepOnReleaseSession)==null||p.call(r,e),c.forEach(t=>r._OrtFree(t)),n.forEach(t=>r._OrtFree(t)),r._OrtReleaseSession(s),yr.delete(e)},ed=(e,r,i,s,c,n=!1)=>{if(!e){r.push(0);return}let a=xt(),h=e[0],p=e[1],t=e[3],u,l;if(h==="string"&&(t==="gpu-buffer"||t==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(n&&t!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${c} when enableGraphCapture is true.`);if(t==="gpu-buffer"){let I=e[2].gpuBuffer;l=qr(Hr(h),p);let R=a.jsepRegisterBuffer;if(!R)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=R(s,c,I,l)}else if(t==="ml-tensor"){let I=e[2].mlTensor;l=qr(Hr(h),p);let R=a.jsepRegisterMLTensor;if(!R)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=R(I,Hr(h),p)}else{let I=e[2];if(Array.isArray(I)){l=4*I.length,u=a._malloc(l),i.push(u);let R=u/4;for(let A=0;A<I.length;A++){if(typeof I[A]!="string")throw new TypeError(`tensor data at index ${A} is not a string`);a.HEAPU32[R++]=Tt(I[A],i)}}else l=I.byteLength,u=a._malloc(l),i.push(u),a.HEAPU8.set(new Uint8Array(I.buffer,I.byteOffset,l),u)}let f=a.stackSave(),x=a.stackAlloc(4*p.length);try{let I=x/4;p.forEach(A=>a.HEAP32[I++]=A);let R=a._OrtCreateTensor(Hr(h),u,l,x,p.length,td(t));R===0&&ht(`Can't create tensor for input/output. session=${s}, index=${c}.`),r.push(R)}finally{a.stackRestore(f)}},fo=async(e,r,i,s,c,n)=>{var Re;let a=xt(),h=yr.get(e);if(!h)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=h[0],t=h[1],u=h[2],l=h[3],f=h[4];h[5];let x=r.length,I=s.length,R=0,A=[],Z=[],K=[],Q=[],re=a.stackSave(),se=a.stackAlloc(x*4),ee=a.stackAlloc(x*4),ce=a.stackAlloc(I*4),X=a.stackAlloc(I*4);try{(Re=a.jsepOnRunStart)==null||Re.call(a,p),[R,A]=jp(n);for(let Dt=0;Dt<x;Dt++)ed(i[Dt],Z,Q,e,r[Dt],f);for(let Dt=0;Dt<I;Dt++)ed(c[Dt],K,Q,e,x+s[Dt],f);let De=se/4,et=ee/4,nt=ce/4,it=X/4;for(let Dt=0;Dt<x;Dt++)a.HEAPU32[De++]=Z[Dt],a.HEAPU32[et++]=t[r[Dt]];for(let Dt=0;Dt<I;Dt++)a.HEAPU32[nt++]=K[Dt],a.HEAPU32[it++]=u[s[Dt]];let _t;_t=await a._OrtRun(p,ee,se,x,X,I,ce,R),_t!==0&&ht("failed to call OrtRun().");let gt=[];for(let Dt=0;Dt<I;Dt++){let Ge=a.HEAPU32[ce/4+Dt];if(Ge===K[Dt]){gt.push(c[Dt]);continue}let ge=a.stackSave(),ct=a.stackAlloc(4*4),Ot=!1,$t,gr=0;try{a._OrtGetTensorData(Ge,ct,ct+4,ct+8,ct+12)!==0&&ht(`Can't access output tensor data on index ${Dt}.`);let Qe=ct/4,Dr=a.HEAPU32[Qe++];gr=a.HEAPU32[Qe++];let vn=a.HEAPU32[Qe++],vr=a.HEAPU32[Qe++],Eo=[];for(let Ze=0;Ze<vr;Ze++)Eo.push(a.HEAPU32[vn/4+Ze]);a._OrtFree(vn);let Ao=Eo.reduce((Ze,er)=>Ze*er,1);$t=Yp(Dr);let Yr=l==null?void 0:l.outputPreferredLocations[s[Dt]];if($t==="string"){if(Yr==="gpu-buffer"||Yr==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Ze=[],er=gr/4;for(let Kr=0;Kr<Ao;Kr++){let _o=a.HEAPU32[er++],Jr=Kr===Ao-1?void 0:a.HEAPU32[er]-_o;Ze.push(a.UTF8ToString(_o,Jr))}gt.push([$t,Eo,Ze,"cpu"])}else if(Yr==="gpu-buffer"&&Ao>0){let Ze=a.jsepGetBuffer;if(!Ze)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let er=Ze(gr),Kr=qr(Dr,Ao);if(Kr===void 0||!bo($t))throw new Error(`Unsupported data type: ${$t}`);Ot=!0,gt.push([$t,Eo,{gpuBuffer:er,download:a.jsepCreateDownloader(er,Kr,$t),dispose:()=>{a._OrtReleaseTensor(Ge)}},"gpu-buffer"])}else if(Yr==="ml-tensor"&&Ao>0){let Ze=a.jsepEnsureTensor;if(!Ze)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(qr(Dr,Ao)===void 0||!go($t))throw new Error(`Unsupported data type: ${$t}`);let er=await Ze(gr,Dr,Eo,!1);Ot=!0,gt.push([$t,Eo,{mlTensor:er,download:a.jsepCreateMLTensorDownloader(gr,$t),dispose:()=>{a.jsepReleaseTensorId(gr),a._OrtReleaseTensor(Ge)}},"ml-tensor"])}else{let Ze=Zp($t),er=new Ze(Ao);new Uint8Array(er.buffer,er.byteOffset,er.byteLength).set(a.HEAPU8.subarray(gr,gr+er.byteLength)),gt.push([$t,Eo,er,"cpu"])}}finally{a.stackRestore(ge),$t==="string"&&gr&&a._free(gr),Ot||a._OrtReleaseTensor(Ge)}}return l&&!f&&(a._OrtClearBoundOutputs(l.handle),yr.set(e,[p,t,u,l,f,!1])),gt}finally{a.stackRestore(re),Z.forEach(De=>a._OrtReleaseTensor(De)),K.forEach(De=>a._OrtReleaseTensor(De)),Q.forEach(De=>a._free(De)),R!==0&&a._OrtReleaseRunOptions(R),A.forEach(De=>a._free(De))}},co=e=>{let r=xt(),i=yr.get(e);if(!i)throw new Error("invalid session id");let s=i[0],c=r._OrtEndProfiling(s);c===0&&ht("Can't get an profile file name."),r._OrtFree(c)},po=e=>{let r=[];for(let i of e){let s=i[2];!Array.isArray(s)&&"buffer"in s&&r.push(s.buffer)}return r}}),Je,Kt,Xr,xo,To,yo,Zi,Qi,xr,Tr,Gg,rd,nd,od,id,ad,sd,ud,ta=O(()=>{Yt(),qi(),Ke(),Vr(),Je=()=>!!z.wasm.proxy&&typeof document<"u",Xr=!1,xo=!1,To=!1,Qi=new Map,xr=(e,r)=>{let i=Qi.get(e);i?i.push(r):Qi.set(e,[r])},Tr=()=>{if(Xr||!xo||To||!Kt)throw new Error("worker not ready")},Gg=e=>{switch(e.data.type){case"init-wasm":Xr=!1,e.data.err?(To=!0,Zi[1](e.data.err)):(xo=!0,Zi[0]()),yo&&(URL.revokeObjectURL(yo),yo=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=Qi.get(e.data.type);e.data.err?r.shift()[1](e.data.err):r.shift()[0](e.data.out);break}}},rd=async()=>{if(!xo){if(Xr)throw new Error("multiple calls to 'initWasm()' detected.");if(To)throw new Error("previous call to 'initWasm()' failed.");if(Xr=!0,Je())return new Promise((e,r)=>{Kt==null||Kt.terminate(),Wp().then(([i,s])=>{try{Kt=s,Kt.onerror=n=>r(n),Kt.onmessage=Gg,Zi=[e,r];let c={type:"init-wasm",in:z};Kt.postMessage(c),yo=i}catch(c){r(c)}},r)});try{await io(z.wasm),await ao(z),xo=!0}catch(e){throw To=!0,e}finally{Xr=!1}}},nd=async e=>{if(Je())return Tr(),new Promise((r,i)=>{xr("init-ep",[r,i]);let s={type:"init-ep",in:{epName:e,env:z}};Kt.postMessage(s)});await so(z,e)},od=async e=>Je()?(Tr(),new Promise((r,i)=>{xr("copy-from",[r,i]);let s={type:"copy-from",in:{buffer:e}};Kt.postMessage(s,[e.buffer])})):zr(e),id=async(e,r)=>{if(Je()){if(r!=null&&r.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Tr(),new Promise((i,s)=>{xr("create",[i,s]);let c={type:"create",in:{model:e,options:{...r}}},n=[];e instanceof Uint8Array&&n.push(e.buffer),Kt.postMessage(c,n)})}else return uo(e,r)},ad=async e=>{if(Je())return Tr(),new Promise((r,i)=>{xr("release",[r,i]);let s={type:"release",in:e};Kt.postMessage(s)});lo(e)},sd=async(e,r,i,s,c,n)=>{if(Je()){if(i.some(a=>a[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(c.some(a=>a))throw new Error("pre-allocated output tensor is not supported for proxy.");return Tr(),new Promise((a,h)=>{xr("run",[a,h]);let p=i,t={type:"run",in:{sessionId:e,inputIndices:r,inputs:p,outputIndices:s,options:n}};Kt.postMessage(t,po(p))})}else return fo(e,r,i,s,c,n)},ud=async e=>{if(Je())return Tr(),new Promise((r,i)=>{xr("end-profiling",[r,i]);let s={type:"end-profiling",in:e};Kt.postMessage(s)});co(e)}}),ld,Mg,wo,fd=O(()=>{Yt(),ta(),Ji(),oo(),Yi(),ld=(e,r)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${r()}`)}},Mg=e=>{switch(e[3]){case"cpu":return new yt(e[0],e[2],e[1]);case"gpu-buffer":{let r=e[0];if(!bo(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:i,download:s,dispose:c}=e[2];return yt.fromGpuBuffer(i,{dataType:r,dims:e[1],download:s,dispose:c})}case"ml-tensor":{let r=e[0];if(!go(r))throw new Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:i,download:s,dispose:c}=e[2];return yt.fromMLTensor(i,{dataType:r,dims:e[1],download:s,dispose:c})}default:throw new Error(`invalid data location: ${e[3]}`)}},wo=class{async fetchModelAndCopyToWasmMemory(e){return od(await jr(e))}async loadModel(e,r){Fe();let i;typeof e=="string"?i=await this.fetchModelAndCopyToWasmMemory(e):i=e,[this.sessionId,this.inputNames,this.outputNames]=await id(i,r),Ce()}async dispose(){return ad(this.sessionId)}async run(e,r,i){Fe();let s=[],c=[];Object.entries(e).forEach(l=>{let f=l[0],x=l[1],I=this.inputNames.indexOf(f);if(I===-1)throw new Error(`invalid input '${f}'`);s.push(x),c.push(I)});let n=[],a=[];Object.entries(r).forEach(l=>{let f=l[0],x=l[1],I=this.outputNames.indexOf(f);if(I===-1)throw new Error(`invalid output '${f}'`);n.push(x),a.push(I)});let h=s.map((l,f)=>ld(l,()=>`input "${this.inputNames[c[f]]}"`)),p=n.map((l,f)=>l?ld(l,()=>`output "${this.outputNames[a[f]]}"`):null),t=await sd(this.sessionId,c,h,a,p,i),u={};for(let l=0;l<t.length;l++)u[this.outputNames[a[l]]]=n[l]??Mg(t[l]);return Ce(),u}startProfiling(){}endProfiling(){ud(this.sessionId)}}}),pd={};Or(pd,{OnnxruntimeWebAssemblyBackend:()=>vo,initializeFlags:()=>cd,wasmBackend:()=>Ug});var cd,vo,Ug,dd=O(()=>{Yt(),ta(),fd(),Vr(),cd=()=>{if((typeof z.wasm.initTimeout!="number"||z.wasm.initTimeout<0)&&(z.wasm.initTimeout=0),z.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof z.wasm.proxy!="boolean"&&(z.wasm.proxy=!1),typeof z.wasm.trace!="boolean"&&(z.wasm.trace=!1),typeof z.wasm.numThreads!="number"||!Number.isInteger(z.wasm.numThreads)||z.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)z.wasm.numThreads=1;else{let e=typeof navigator>"u"?Co("node:os").cpus().length:navigator.hardwareConcurrency;z.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},vo=class{async init(e){cd(),await rd(),await nd(e)}async createInferenceSessionHandler(e,r){let i=new wo;return await i.loadModel(e,r),Promise.resolve(i)}},Ug=new vo});Yt();Yt();Yt();var Ds="1.20.0-dev.20241016-2b8fc5529b";{let e=(Fp(),sn(Bp)).onnxjsBackend;nr("webgl",e,-10)}{let e=(dd(),sn(pd)).wasmBackend;nr("cpu",e,10),nr("wasm",e,10)}Object.defineProperty(z.versions,"web",{value:Ds,enumerable:!0});/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/var define_process_env_default={},__webpack_modules__={"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":(e,r,i)=>{e.exports=i.p+"ort-wasm-simd-threaded.jsep.wasm"},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,r,i)=>{i.r(r),i.d(r,{Environment:()=>en,Interpreter:()=>Bo,Template:()=>ti,parse:()=>Ot,tokenize:()=>l});var s=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),c=Object.freeze({set:s.Set,for:s.For,in:s.In,is:s.Is,if:s.If,else:s.Else,endif:s.EndIf,elif:s.ElseIf,endfor:s.EndFor,and:s.And,or:s.Or,not:s.Not,"not in":s.NotIn,macro:s.Macro,endmacro:s.EndMacro,true:s.BooleanLiteral,false:s.BooleanLiteral,True:s.BooleanLiteral,False:s.BooleanLiteral}),n=class{constructor(oe,Ye){this.value=oe,this.type=Ye}};function a(oe){return/\w/.test(oe)}function h(oe){return/[0-9]/.test(oe)}var p=[["{%",s.OpenStatement],["%}",s.CloseStatement],["{{",s.OpenExpression],["}}",s.CloseExpression],["(",s.OpenParen],[")",s.CloseParen],["{",s.OpenCurlyBracket],["}",s.CloseCurlyBracket],["[",s.OpenSquareBracket],["]",s.CloseSquareBracket],[",",s.Comma],[".",s.Dot],[":",s.Colon],["|",s.Pipe],["<=",s.ComparisonBinaryOperator],[">=",s.ComparisonBinaryOperator],["==",s.ComparisonBinaryOperator],["!=",s.ComparisonBinaryOperator],["<",s.ComparisonBinaryOperator],[">",s.ComparisonBinaryOperator],["+",s.AdditiveBinaryOperator],["-",s.AdditiveBinaryOperator],["*",s.MultiplicativeBinaryOperator],["/",s.MultiplicativeBinaryOperator],["%",s.MultiplicativeBinaryOperator],["=",s.Equals]],t=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function u(oe,Ye={}){return oe.endsWith(`
`)&&(oe=oe.slice(0,-1)),oe=oe.replace(/{#.*?#}/gs,"{##}"),Ye.lstrip_blocks&&(oe=oe.replace(/^[ \t]*({[#%])/gm,"$1")),Ye.trim_blocks&&(oe=oe.replace(/([#%]})\n/g,"$1")),oe.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function l(oe,Ye={}){var _n,ra,zo;const le=[],at=u(oe,Ye);let Ft=0;const ko=Jo=>{let ia="";for(;Jo(at[Ft]);){if(at[Ft]==="\\"){if(++Ft,Ft>=at.length)throw new SyntaxError("Unexpected end of input");const ii=at[Ft++],Sa=t.get(ii);if(Sa===void 0)throw new SyntaxError(`Unexpected escaped character: ${ii}`);ia+=Sa;continue}if(ia+=at[Ft++],Ft>=at.length)throw new SyntaxError("Unexpected end of input")}return ia};e:for(;Ft<at.length;){const Jo=(_n=le.at(-1))==null?void 0:_n.type;if(Jo===void 0||Jo===s.CloseStatement||Jo===s.CloseExpression){let ii="";for(;Ft<at.length&&!(at[Ft]==="{"&&(at[Ft+1]==="%"||at[Ft+1]==="{"));)ii+=at[Ft++];if(ii.length>0){le.push(new n(ii,s.Text));continue}}ko(ii=>/\s/.test(ii));const ia=at[Ft];if(ia==="-"||ia==="+"){const ii=(ra=le.at(-1))==null?void 0:ra.type;if(ii===s.Text||ii===void 0)throw new SyntaxError(`Unexpected character: ${ia}`);switch(ii){case s.Identifier:case s.NumericLiteral:case s.BooleanLiteral:case s.StringLiteral:case s.CloseParen:case s.CloseSquareBracket:break;default:{++Ft;const Sa=ko(h);le.push(new n(`${ia}${Sa}`,Sa.length>0?s.NumericLiteral:s.UnaryOperator));continue}}}for(const[ii,Sa]of p)if(at.slice(Ft,Ft+ii.length)===ii){le.push(new n(ii,Sa)),Ft+=ii.length;continue e}if(ia==="'"||ia==='"'){++Ft;const ii=ko(Sa=>Sa!==ia);le.push(new n(ii,s.StringLiteral)),++Ft;continue}if(h(ia)){const ii=ko(h);le.push(new n(ii,s.NumericLiteral));continue}if(a(ia)){const ii=ko(a),Sa=Object.hasOwn(c,ii)?c[ii]:s.Identifier;Sa===s.In&&((zo=le.at(-1))==null?void 0:zo.type)===s.Not?(le.pop(),le.push(new n("not in",s.NotIn))):le.push(new n(ii,Sa));continue}throw new SyntaxError(`Unexpected character: ${ia}`)}return le}var f=class{constructor(){_r(this,"type","Statement")}},x=class extends f{constructor(Ye){super();_r(this,"type","Program");this.body=Ye}},I=class extends f{constructor(Ye,le,at){super();_r(this,"type","If");this.test=Ye,this.body=le,this.alternate=at}},R=class extends f{constructor(Ye,le,at,Ft){super();_r(this,"type","For");this.loopvar=Ye,this.iterable=le,this.body=at,this.defaultBlock=Ft}},A=class extends f{constructor(Ye,le){super();_r(this,"type","Set");this.assignee=Ye,this.value=le}},Z=class extends f{constructor(Ye,le,at){super();_r(this,"type","Macro");this.name=Ye,this.args=le,this.body=at}},K=class extends f{constructor(){super(...arguments);_r(this,"type","Expression")}},Q=class extends K{constructor(Ye,le,at){super();_r(this,"type","MemberExpression");this.object=Ye,this.property=le,this.computed=at}},re=class extends K{constructor(Ye,le){super();_r(this,"type","CallExpression");this.callee=Ye,this.args=le}},se=class extends K{constructor(Ye){super();_r(this,"type","Identifier");this.value=Ye}},ee=class extends K{constructor(Ye){super();_r(this,"type","Literal");this.value=Ye}},ce=class extends ee{constructor(){super(...arguments);_r(this,"type","NumericLiteral")}},X=class extends ee{constructor(){super(...arguments);_r(this,"type","StringLiteral")}},Re=class extends ee{constructor(){super(...arguments);_r(this,"type","BooleanLiteral")}},De=class extends ee{constructor(){super(...arguments);_r(this,"type","ArrayLiteral")}},et=class extends ee{constructor(){super(...arguments);_r(this,"type","TupleLiteral")}},nt=class extends ee{constructor(){super(...arguments);_r(this,"type","ObjectLiteral")}},it=class extends K{constructor(Ye,le,at){super();_r(this,"type","BinaryExpression");this.operator=Ye,this.left=le,this.right=at}},_t=class extends K{constructor(Ye,le){super();_r(this,"type","FilterExpression");this.operand=Ye,this.filter=le}},gt=class extends K{constructor(Ye,le){super();_r(this,"type","SelectExpression");this.iterable=Ye,this.test=le}},Dt=class extends K{constructor(Ye,le,at){super();_r(this,"type","TestExpression");this.operand=Ye,this.negate=le,this.test=at}},Ge=class extends K{constructor(Ye,le){super();_r(this,"type","UnaryExpression");this.operator=Ye,this.argument=le}},ge=class extends K{constructor(Ye=void 0,le=void 0,at=void 0){super();_r(this,"type","SliceExpression");this.start=Ye,this.stop=le,this.step=at}},ct=class extends K{constructor(Ye,le){super();_r(this,"type","KeywordArgumentExpression");this.key=Ye,this.value=le}};function Ot(oe){const Ye=new x([]);let le=0;function at(Wt,$o){const Io=oe[le++];if(!Io||Io.type!==Wt)throw new Error(`Parser Error: ${$o}. ${Io.type} !== ${Wt}.`);return Io}function Ft(){switch(oe[le].type){case s.Text:return ra();case s.OpenStatement:return zo();case s.OpenExpression:return Jo();default:throw new SyntaxError(`Unexpected token type: ${oe[le].type}`)}}function ko(...Wt){return le+Wt.length<=oe.length&&Wt.some(($o,Io)=>$o!==oe[le+Io].type)}function _n(...Wt){return le+Wt.length<=oe.length&&Wt.every(($o,Io)=>$o===oe[le+Io].type)}function ra(){return new X(at(s.Text,"Expected text token").value)}function zo(){at(s.OpenStatement,"Expected opening statement token");let Wt;switch(oe[le].type){case s.Set:++le,Wt=ia(),at(s.CloseStatement,"Expected closing statement token");break;case s.If:++le,Wt=ii(),at(s.OpenStatement,"Expected {% token"),at(s.EndIf,"Expected endif token"),at(s.CloseStatement,"Expected %} token");break;case s.Macro:++le,Wt=Sa(),at(s.OpenStatement,"Expected {% token"),at(s.EndMacro,"Expected endmacro token"),at(s.CloseStatement,"Expected %} token");break;case s.For:++le,Wt=Tu(),at(s.OpenStatement,"Expected {% token"),at(s.EndFor,"Expected endfor token"),at(s.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${oe[le].type}`)}return Wt}function Jo(){at(s.OpenExpression,"Expected opening expression token");const Wt=Ua();return at(s.CloseExpression,"Expected closing expression token"),Wt}function ia(){const Wt=Ua();if(_n(s.Equals)){++le;const $o=ia();return new A(Wt,$o)}return Wt}function ii(){var ma,Ba,eu,wu,Oa,bu,tu,Bd;const Wt=Ua();at(s.CloseStatement,"Expected closing statement token");const $o=[],Io=[];for(;!(((ma=oe[le])==null?void 0:ma.type)===s.OpenStatement&&(((Ba=oe[le+1])==null?void 0:Ba.type)===s.ElseIf||((eu=oe[le+1])==null?void 0:eu.type)===s.Else||((wu=oe[le+1])==null?void 0:wu.type)===s.EndIf));)$o.push(Ft());if(((Oa=oe[le])==null?void 0:Oa.type)===s.OpenStatement&&((bu=oe[le+1])==null?void 0:bu.type)!==s.EndIf)if(++le,_n(s.ElseIf))at(s.ElseIf,"Expected elseif token"),Io.push(ii());else for(at(s.Else,"Expected else token"),at(s.CloseStatement,"Expected closing statement token");!(((tu=oe[le])==null?void 0:tu.type)===s.OpenStatement&&((Bd=oe[le+1])==null?void 0:Bd.type)===s.EndIf);)Io.push(Ft());return new I(Wt,$o,Io)}function Sa(){const Wt=ha();if(Wt.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const $o=Ko();at(s.CloseStatement,"Expected closing statement token");const Io=[];for(;ko(s.OpenStatement,s.EndMacro);)Io.push(Ft());return new Z(Wt,$o,Io)}function Na(Wt=!1){const $o=Wt?ha:Ua,Io=[$o()],ma=_n(s.Comma);for(;ma&&(++le,Io.push($o()),!!_n(s.Comma)););return ma?new et(Io):Io[0]}function Tu(){const Wt=Na(!0);if(!(Wt instanceof se||Wt instanceof et))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Wt.type} instead`);at(s.In,"Expected `in` keyword following loop variable");const $o=Ua();at(s.CloseStatement,"Expected closing statement token");const Io=[];for(;ko(s.OpenStatement,s.EndFor)&&ko(s.OpenStatement,s.Else);)Io.push(Ft());const ma=[];if(_n(s.OpenStatement,s.Else))for(++le,++le,at(s.CloseStatement,"Expected closing statement token");ko(s.OpenStatement,s.EndFor);)ma.push(Ft());return new R(Wt,$o,Io,ma)}function Ua(){return $u()}function $u(){const Wt=So();if(_n(s.If)){++le;const $o=So();if(_n(s.Else)){++le;const Io=So();return new I($o,[Wt],[Io])}else return new gt(Wt,$o)}return Wt}function So(){let Wt=Ie();for(;_n(s.Or);){const $o=oe[le];++le;const Io=Ie();Wt=new it($o,Wt,Io)}return Wt}function Ie(){let Wt=Nt();for(;_n(s.And);){const $o=oe[le];++le;const Io=Nt();Wt=new it($o,Wt,Io)}return Wt}function Nt(){let Wt;for(;_n(s.Not);){const $o=oe[le];++le;const Io=Nt();Wt=new Ge($o,Io)}return Wt??Lr()}function Lr(){let Wt=Oo();for(;_n(s.ComparisonBinaryOperator)||_n(s.In)||_n(s.NotIn);){const $o=oe[le];++le;const Io=Oo();Wt=new it($o,Wt,Io)}return Wt}function Oo(){let Wt=la();for(;_n(s.AdditiveBinaryOperator);){const $o=oe[le];++le;const Io=la();Wt=new it($o,Wt,Io)}return Wt}function tr(){const Wt=Yo();return _n(s.OpenParen)?Po(Wt):Wt}function Po(Wt){let $o=new re(Wt,Ko());return _n(s.OpenParen)&&($o=Po($o)),$o}function Ko(){at(s.OpenParen,"Expected opening parenthesis for arguments list");const Wt=jo();return at(s.CloseParen,"Expected closing parenthesis for arguments list"),Wt}function jo(){const Wt=[];for(;!_n(s.CloseParen);){let $o=Ua();if(_n(s.Equals)){if(++le,!($o instanceof se))throw new SyntaxError("Expected identifier for keyword argument");const Io=Ua();$o=new ct($o,Io)}Wt.push($o),_n(s.Comma)&&++le}return Wt}function ri(){const Wt=[];let $o=!1;for(;!_n(s.CloseSquareBracket);)_n(s.Colon)?(Wt.push(void 0),++le,$o=!0):(Wt.push(Ua()),_n(s.Colon)&&(++le,$o=!0));if(Wt.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if($o){if(Wt.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new ge(...Wt)}return Wt[0]}function Yo(){let Wt=ha();for(;_n(s.Dot)||_n(s.OpenSquareBracket);){const $o=oe[le];++le;let Io;const ma=$o.type!==s.Dot;if(ma)Io=ri(),at(s.CloseSquareBracket,"Expected closing square bracket");else if(Io=ha(),Io.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Wt=new Q(Wt,Io,ma)}return Wt}function la(){let Wt=da();for(;_n(s.MultiplicativeBinaryOperator);){const $o=oe[le];++le;const Io=da();Wt=new it($o,Wt,Io)}return Wt}function da(){let Wt=na();for(;_n(s.Is);){++le;const $o=_n(s.Not);$o&&++le;let Io=ha();if(Io instanceof Re&&(Io=new se(Io.value.toString())),!(Io instanceof se))throw new SyntaxError("Expected identifier for the test");Wt=new Dt(Wt,$o,Io)}return Wt}function na(){let Wt=tr();for(;_n(s.Pipe);){++le;let $o=ha();if(!($o instanceof se))throw new SyntaxError("Expected identifier for the filter");_n(s.OpenParen)&&($o=Po($o)),Wt=new _t(Wt,$o)}return Wt}function ha(){const Wt=oe[le];switch(Wt.type){case s.NumericLiteral:return++le,new ce(Number(Wt.value));case s.StringLiteral:return++le,new X(Wt.value);case s.BooleanLiteral:return++le,new Re(Wt.value.toLowerCase()==="true");case s.Identifier:return++le,new se(Wt.value);case s.OpenParen:{++le;const $o=Na();if(oe[le].type!==s.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${oe[le].type} instead`);return++le,$o}case s.OpenSquareBracket:{++le;const $o=[];for(;!_n(s.CloseSquareBracket);)$o.push(Ua()),_n(s.Comma)&&++le;return++le,new De($o)}case s.OpenCurlyBracket:{++le;const $o=new Map;for(;!_n(s.CloseCurlyBracket);){const Io=Ua();at(s.Colon,"Expected colon between key and value in object literal");const ma=Ua();$o.set(Io,ma),_n(s.Comma)&&++le}return++le,new nt($o)}default:throw new SyntaxError(`Unexpected token: ${Wt.type}`)}}for(;le<oe.length;)Ye.body.push(Ft());return Ye}function $t(oe,Ye,le=1){Ye===void 0&&(Ye=oe,oe=0);const at=[];for(let Ft=oe;Ft<Ye;Ft+=le)at.push(Ft);return at}function gr(oe,Ye,le,at=1){const Ft=Math.sign(at);Ft>=0?(Ye=(Ye??(Ye=0))<0?Math.max(oe.length+Ye,0):Math.min(Ye,oe.length),le=(le??(le=oe.length))<0?Math.max(oe.length+le,0):Math.min(le,oe.length)):(Ye=(Ye??(Ye=oe.length-1))<0?Math.max(oe.length+Ye,-1):Math.min(Ye,oe.length-1),le=(le??(le=-1))<-1?Math.max(oe.length+le,-1):Math.min(le,oe.length-1));const ko=[];for(let _n=Ye;Ft*_n<Ft*le;_n+=at)ko.push(oe[_n]);return ko}function Qe(oe){return oe.replace(/\b\w/g,Ye=>Ye.toUpperCase())}var Dr=class{constructor(oe=void 0){_r(this,"type","RuntimeValue");_r(this,"value");_r(this,"builtins",new Map);this.value=oe}__bool__(){return new Eo(!!this.value)}},vn=class extends Dr{constructor(){super(...arguments);_r(this,"type","NumericValue")}},vr=class extends Dr{constructor(){super(...arguments);_r(this,"type","StringValue");_r(this,"builtins",new Map([["upper",new Kr(()=>new vr(this.value.toUpperCase()))],["lower",new Kr(()=>new vr(this.value.toLowerCase()))],["strip",new Kr(()=>new vr(this.value.trim()))],["title",new Kr(()=>new vr(Qe(this.value)))],["length",new vn(this.value.length)]]))}},Eo=class extends Dr{constructor(){super(...arguments);_r(this,"type","BooleanValue")}},Ao=class extends Dr{constructor(){super(...arguments);_r(this,"type","ObjectValue");_r(this,"builtins",new Map([["get",new Kr(([Ye,le])=>{if(!(Ye instanceof vr))throw new Error(`Object key must be a string: got ${Ye.type}`);return this.value.get(Ye.value)??le??new _o})],["items",new Kr(()=>new Ze(Array.from(this.value.entries()).map(([Ye,le])=>new Ze([new vr(Ye),le]))))]]))}__bool__(){return new Eo(this.value.size>0)}},Yr=class extends Ao{constructor(){super(...arguments);_r(this,"type","KeywordArgumentsValue")}},Ze=class extends Dr{constructor(){super(...arguments);_r(this,"type","ArrayValue");_r(this,"builtins",new Map([["length",new vn(this.value.length)]]))}__bool__(){return new Eo(this.value.length>0)}},er=class extends Ze{constructor(){super(...arguments);_r(this,"type","TupleValue")}},Kr=class extends Dr{constructor(){super(...arguments);_r(this,"type","FunctionValue")}},_o=class extends Dr{constructor(){super(...arguments);_r(this,"type","NullValue")}},Jr=class extends Dr{constructor(){super(...arguments);_r(this,"type","UndefinedValue")}},en=class{constructor(oe){_r(this,"variables",new Map([["namespace",new Kr(oe=>{if(oe.length===0)return new Ao(new Map);if(oe.length!==1||!(oe[0]instanceof Ao))throw new Error("`namespace` expects either zero arguments or a single object argument");return oe[0]})]]));_r(this,"tests",new Map([["boolean",oe=>oe.type==="BooleanValue"],["callable",oe=>oe instanceof Kr],["odd",oe=>{if(oe.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${oe.type}`);return oe.value%2!==0}],["even",oe=>{if(oe.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${oe.type}`);return oe.value%2===0}],["false",oe=>oe.type==="BooleanValue"&&!oe.value],["true",oe=>oe.type==="BooleanValue"&&oe.value],["string",oe=>oe.type==="StringValue"],["number",oe=>oe.type==="NumericValue"],["integer",oe=>oe.type==="NumericValue"&&Number.isInteger(oe.value)],["iterable",oe=>oe instanceof Ze||oe instanceof vr],["lower",oe=>{const Ye=oe.value;return oe.type==="StringValue"&&Ye===Ye.toLowerCase()}],["upper",oe=>{const Ye=oe.value;return oe.type==="StringValue"&&Ye===Ye.toUpperCase()}],["none",oe=>oe.type==="NullValue"],["defined",oe=>oe.type!=="UndefinedValue"],["undefined",oe=>oe.type==="UndefinedValue"],["equalto",(oe,Ye)=>oe.value===Ye.value],["eq",(oe,Ye)=>oe.value===Ye.value]]));this.parent=oe}set(oe,Ye){return this.declareVariable(oe,Ks(Ye))}declareVariable(oe,Ye){if(this.variables.has(oe))throw new SyntaxError(`Variable already declared: ${oe}`);return this.variables.set(oe,Ye),Ye}setVariable(oe,Ye){return this.variables.set(oe,Ye),Ye}resolve(oe){if(this.variables.has(oe))return this;if(this.parent)return this.parent.resolve(oe);throw new Error(`Unknown variable: ${oe}`)}lookupVariable(oe){try{return this.resolve(oe).variables.get(oe)??new Jr}catch{return new Jr}}},Bo=class{constructor(oe){_r(this,"global");this.global=oe??new en}run(oe){return this.evaluate(oe,this.global)}evaluateBinaryExpression(oe,Ye){const le=this.evaluate(oe.left,Ye);switch(oe.operator.value){case"and":return le.__bool__().value?this.evaluate(oe.right,Ye):le;case"or":return le.__bool__().value?le:this.evaluate(oe.right,Ye)}const at=this.evaluate(oe.right,Ye);switch(oe.operator.value){case"==":return new Eo(le.value==at.value);case"!=":return new Eo(le.value!=at.value)}if(le instanceof Jr||at instanceof Jr)throw new Error("Cannot perform operation on undefined values");if(le instanceof _o||at instanceof _o)throw new Error("Cannot perform operation on null values");if(le instanceof vn&&at instanceof vn)switch(oe.operator.value){case"+":return new vn(le.value+at.value);case"-":return new vn(le.value-at.value);case"*":return new vn(le.value*at.value);case"/":return new vn(le.value/at.value);case"%":return new vn(le.value%at.value);case"<":return new Eo(le.value<at.value);case">":return new Eo(le.value>at.value);case">=":return new Eo(le.value>=at.value);case"<=":return new Eo(le.value<=at.value)}else if(le instanceof Ze&&at instanceof Ze)switch(oe.operator.value){case"+":return new Ze(le.value.concat(at.value))}else if(at instanceof Ze){const Ft=at.value.find(ko=>ko.value===le.value)!==void 0;switch(oe.operator.value){case"in":return new Eo(Ft);case"not in":return new Eo(!Ft)}}if(le instanceof vr||at instanceof vr)switch(oe.operator.value){case"+":return new vr(le.value.toString()+at.value.toString())}if(le instanceof vr&&at instanceof vr)switch(oe.operator.value){case"in":return new Eo(at.value.includes(le.value));case"not in":return new Eo(!at.value.includes(le.value))}if(le instanceof vr&&at instanceof Ao)switch(oe.operator.value){case"in":return new Eo(at.value.has(le.value));case"not in":return new Eo(!at.value.has(le.value))}throw new SyntaxError(`Unknown operator "${oe.operator.value}" between ${le.type} and ${at.type}`)}evaluateArguments(oe,Ye){const le=[],at=new Map;for(const Ft of oe)if(Ft.type==="KeywordArgumentExpression"){const ko=Ft;at.set(ko.key.value,this.evaluate(ko.value,Ye))}else{if(at.size>0)throw new Error("Positional arguments must come before keyword arguments");le.push(this.evaluate(Ft,Ye))}return[le,at]}evaluateFilterExpression(oe,Ye){const le=this.evaluate(oe.operand,Ye);if(oe.filter.type==="Identifier"){const at=oe.filter;if(at.value==="tojson")return new vr(ni(le));if(le instanceof Ze)switch(at.value){case"list":return le;case"first":return le.value[0];case"last":return le.value[le.value.length-1];case"length":return new vn(le.value.length);case"reverse":return new Ze(le.value.reverse());case"sort":return new Ze(le.value.sort((Ft,ko)=>{if(Ft.type!==ko.type)throw new Error(`Cannot compare different types: ${Ft.type} and ${ko.type}`);switch(Ft.type){case"NumericValue":return Ft.value-ko.value;case"StringValue":return Ft.value.localeCompare(ko.value);default:throw new Error(`Cannot compare type: ${Ft.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${at.value}`)}else if(le instanceof vr)switch(at.value){case"length":return new vn(le.value.length);case"upper":return new vr(le.value.toUpperCase());case"lower":return new vr(le.value.toLowerCase());case"title":return new vr(Qe(le.value));case"capitalize":return new vr(le.value.charAt(0).toUpperCase()+le.value.slice(1));case"trim":return new vr(le.value.trim());case"indent":return new vr(le.value.split(`
`).map((Ft,ko)=>ko===0||Ft.length===0?Ft:"    "+Ft).join(`
`));case"string":return le;default:throw new Error(`Unknown StringValue filter: ${at.value}`)}else if(le instanceof vn)switch(at.value){case"abs":return new vn(Math.abs(le.value));default:throw new Error(`Unknown NumericValue filter: ${at.value}`)}else if(le instanceof Ao)switch(at.value){case"items":return new Ze(Array.from(le.value.entries()).map(([Ft,ko])=>new Ze([new vr(Ft),ko])));case"length":return new vn(le.value.size);default:throw new Error(`Unknown ObjectValue filter: ${at.value}`)}throw new Error(`Cannot apply filter "${at.value}" to type: ${le.type}`)}else if(oe.filter.type==="CallExpression"){const at=oe.filter;if(at.callee.type!=="Identifier")throw new Error(`Unknown filter: ${at.callee.type}`);const Ft=at.callee.value;if(Ft==="tojson"){const[,ko]=this.evaluateArguments(at.args,Ye),_n=ko.get("indent")??new _o;if(!(_n instanceof vn||_n instanceof _o))throw new Error("If set, indent must be a number");return new vr(ni(le,_n.value))}if(le instanceof Ze){switch(Ft){case"selectattr":{if(le.value.some(ia=>!(ia instanceof Ao)))throw new Error("`selectattr` can only be applied to array of objects");if(at.args.some(ia=>ia.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[ko,_n,ra]=at.args.map(ia=>this.evaluate(ia,Ye));let zo;if(_n){const ia=Ye.tests.get(_n.value);if(!ia)throw new Error(`Unknown test: ${_n.value}`);zo=ia}else zo=(...ia)=>ia[0].__bool__().value;const Jo=le.value.filter(ia=>{const ii=ia.value.get(ko.value);return ii?zo(ii,ra):!1});return new Ze(Jo)}case"map":{const[,ko]=this.evaluateArguments(at.args,Ye);if(ko.has("attribute")){const _n=ko.get("attribute");if(!(_n instanceof vr))throw new Error("attribute must be a string");const ra=ko.get("default"),zo=le.value.map(Jo=>{if(!(Jo instanceof Ao))throw new Error("items in map must be an object");return Jo.value.get(_n.value)??ra??new Jr});return new Ze(zo)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${Ft}`)}else if(le instanceof vr){switch(Ft){case"indent":{const[ko,_n]=this.evaluateArguments(at.args,Ye),ra=ko.at(0)??_n.get("width")??new vn(4);if(!(ra instanceof vn))throw new Error("width must be a number");const zo=ko.at(1)??_n.get("first")??new Eo(!1),Jo=ko.at(2)??_n.get("blank")??new Eo(!1),ia=le.value.split(`
`),ii=" ".repeat(ra.value),Sa=ia.map((Na,Tu)=>!zo.value&&Tu===0||!Jo.value&&Na.length===0?Na:ii+Na);return new vr(Sa.join(`
`))}}throw new Error(`Unknown StringValue filter: ${Ft}`)}else throw new Error(`Cannot apply filter "${Ft}" to type: ${le.type}`)}throw new Error(`Unknown filter: ${oe.filter.type}`)}evaluateTestExpression(oe,Ye){const le=this.evaluate(oe.operand,Ye),at=Ye.tests.get(oe.test.value);if(!at)throw new Error(`Unknown test: ${oe.test.value}`);const Ft=at(le);return new Eo(oe.negate?!Ft:Ft)}evaluateUnaryExpression(oe,Ye){const le=this.evaluate(oe.argument,Ye);switch(oe.operator.value){case"not":return new Eo(!le.value);default:throw new SyntaxError(`Unknown operator: ${oe.operator.value}`)}}evalProgram(oe,Ye){return this.evaluateBlock(oe.body,Ye)}evaluateBlock(oe,Ye){let le="";for(const at of oe){const Ft=this.evaluate(at,Ye);Ft.type!=="NullValue"&&Ft.type!=="UndefinedValue"&&(le+=Ft.value)}return new vr(le)}evaluateIdentifier(oe,Ye){return Ye.lookupVariable(oe.value)}evaluateCallExpression(oe,Ye){const[le,at]=this.evaluateArguments(oe.args,Ye);at.size>0&&le.push(new Yr(at));const Ft=this.evaluate(oe.callee,Ye);if(Ft.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Ft.type}`);return Ft.value(le,Ye)}evaluateSliceExpression(oe,Ye,le){if(!(oe instanceof Ze||oe instanceof vr))throw new Error("Slice object must be an array or string");const at=this.evaluate(Ye.start,le),Ft=this.evaluate(Ye.stop,le),ko=this.evaluate(Ye.step,le);if(!(at instanceof vn||at instanceof Jr))throw new Error("Slice start must be numeric or undefined");if(!(Ft instanceof vn||Ft instanceof Jr))throw new Error("Slice stop must be numeric or undefined");if(!(ko instanceof vn||ko instanceof Jr))throw new Error("Slice step must be numeric or undefined");return oe instanceof Ze?new Ze(gr(oe.value,at.value,Ft.value,ko.value)):new vr(gr(Array.from(oe.value),at.value,Ft.value,ko.value).join(""))}evaluateMemberExpression(oe,Ye){const le=this.evaluate(oe.object,Ye);let at;if(oe.computed){if(oe.property.type==="SliceExpression")return this.evaluateSliceExpression(le,oe.property,Ye);at=this.evaluate(oe.property,Ye)}else at=new vr(oe.property.value);let Ft;if(le instanceof Ao){if(!(at instanceof vr))throw new Error(`Cannot access property with non-string: got ${at.type}`);Ft=le.value.get(at.value)??le.builtins.get(at.value)}else if(le instanceof Ze||le instanceof vr)if(at instanceof vn)Ft=le.value.at(at.value),le instanceof vr&&(Ft=new vr(le.value.at(at.value)));else if(at instanceof vr)Ft=le.builtins.get(at.value);else throw new Error(`Cannot access property with non-string/non-number: got ${at.type}`);else{if(!(at instanceof vr))throw new Error(`Cannot access property with non-string: got ${at.type}`);Ft=le.builtins.get(at.value)}return Ft instanceof Dr?Ft:new Jr}evaluateSet(oe,Ye){const le=this.evaluate(oe.value,Ye);if(oe.assignee.type==="Identifier"){const at=oe.assignee.value;Ye.setVariable(at,le)}else if(oe.assignee.type==="MemberExpression"){const at=oe.assignee,Ft=this.evaluate(at.object,Ye);if(!(Ft instanceof Ao))throw new Error("Cannot assign to member of non-object");if(at.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");Ft.value.set(at.property.value,le)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(oe.assignee)}`);return new _o}evaluateIf(oe,Ye){const le=this.evaluate(oe.test,Ye);return this.evaluateBlock(le.__bool__().value?oe.body:oe.alternate,Ye)}evaluateFor(oe,Ye){const le=new en(Ye);let at,Ft;if(oe.iterable.type==="SelectExpression"){const Jo=oe.iterable;Ft=this.evaluate(Jo.iterable,le),at=Jo.test}else Ft=this.evaluate(oe.iterable,le);if(!(Ft instanceof Ze))throw new Error(`Expected iterable type in for loop: got ${Ft.type}`);const ko=[],_n=[];for(let Jo=0;Jo<Ft.value.length;++Jo){const ia=new en(le),ii=Ft.value[Jo];let Sa;if(oe.loopvar.type==="Identifier")Sa=Na=>Na.setVariable(oe.loopvar.value,ii);else if(oe.loopvar.type==="TupleLiteral"){const Na=oe.loopvar;if(ii.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${ii.type}`);const Tu=ii;if(Na.value.length!==Tu.value.length)throw new Error(`Too ${Na.value.length>Tu.value.length?"few":"many"} items to unpack`);Sa=Ua=>{for(let $u=0;$u<Na.value.length;++$u){if(Na.value[$u].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Na.value[$u].type}`);Ua.setVariable(Na.value[$u].value,Tu.value[$u])}}}else throw new Error(`Invalid loop variable(s): ${oe.loopvar.type}`);at&&(Sa(ia),!this.evaluate(at,ia).__bool__().value)||(ko.push(ii),_n.push(Sa))}let ra="",zo=!0;for(let Jo=0;Jo<ko.length;++Jo){const ia=new Map([["index",new vn(Jo+1)],["index0",new vn(Jo)],["revindex",new vn(ko.length-Jo)],["revindex0",new vn(ko.length-Jo-1)],["first",new Eo(Jo===0)],["last",new Eo(Jo===ko.length-1)],["length",new vn(ko.length)],["previtem",Jo>0?ko[Jo-1]:new Jr],["nextitem",Jo<ko.length-1?ko[Jo+1]:new Jr]]);le.setVariable("loop",new Ao(ia)),_n[Jo](le);const ii=this.evaluateBlock(oe.body,le);ra+=ii.value,zo=!1}if(zo){const Jo=this.evaluateBlock(oe.defaultBlock,le);ra+=Jo.value}return new vr(ra)}evaluateMacro(oe,Ye){return Ye.setVariable(oe.name.value,new Kr((le,at)=>{var _n;const Ft=new en(at);le=le.slice();let ko;((_n=le.at(-1))==null?void 0:_n.type)==="KeywordArgumentsValue"&&(ko=le.pop());for(let ra=0;ra<oe.args.length;++ra){const zo=oe.args[ra],Jo=le[ra];if(zo.type==="Identifier"){const ia=zo;if(!Jo)throw new Error(`Missing positional argument: ${ia.value}`);Ft.setVariable(ia.value,Jo)}else if(zo.type==="KeywordArgumentExpression"){const ia=zo,ii=Jo??(ko==null?void 0:ko.value.get(ia.key.value))??this.evaluate(ia.value,Ft);Ft.setVariable(ia.key.value,ii)}else throw new Error(`Unknown argument type: ${zo.type}`)}return this.evaluateBlock(oe.body,Ft)})),new _o}evaluate(oe,Ye){if(oe===void 0)return new Jr;switch(oe.type){case"Program":return this.evalProgram(oe,Ye);case"Set":return this.evaluateSet(oe,Ye);case"If":return this.evaluateIf(oe,Ye);case"For":return this.evaluateFor(oe,Ye);case"Macro":return this.evaluateMacro(oe,Ye);case"NumericLiteral":return new vn(Number(oe.value));case"StringLiteral":return new vr(oe.value);case"BooleanLiteral":return new Eo(oe.value);case"ArrayLiteral":return new Ze(oe.value.map(le=>this.evaluate(le,Ye)));case"TupleLiteral":return new er(oe.value.map(le=>this.evaluate(le,Ye)));case"ObjectLiteral":{const le=new Map;for(const[at,Ft]of oe.value){const ko=this.evaluate(at,Ye);if(!(ko instanceof vr))throw new Error(`Object keys must be strings: got ${ko.type}`);le.set(ko.value,this.evaluate(Ft,Ye))}return new Ao(le)}case"Identifier":return this.evaluateIdentifier(oe,Ye);case"CallExpression":return this.evaluateCallExpression(oe,Ye);case"MemberExpression":return this.evaluateMemberExpression(oe,Ye);case"UnaryExpression":return this.evaluateUnaryExpression(oe,Ye);case"BinaryExpression":return this.evaluateBinaryExpression(oe,Ye);case"FilterExpression":return this.evaluateFilterExpression(oe,Ye);case"TestExpression":return this.evaluateTestExpression(oe,Ye);default:throw new SyntaxError(`Unknown node type: ${oe.type}`)}}};function Ks(oe){switch(typeof oe){case"number":return new vn(oe);case"string":return new vr(oe);case"boolean":return new Eo(oe);case"undefined":return new Jr;case"object":return oe===null?new _o:Array.isArray(oe)?new Ze(oe.map(Ks)):new Ao(new Map(Object.entries(oe).map(([Ye,le])=>[Ye,Ks(le)])));case"function":return new Kr((Ye,le)=>{const at=oe(...Ye.map(Ft=>Ft.value))??null;return Ks(at)});default:throw new Error(`Cannot convert to runtime value: ${oe}`)}}function ni(oe,Ye,le){const at=le??0;switch(oe.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(oe.value);case"ArrayValue":case"ObjectValue":{const Ft=Ye?" ".repeat(Ye):"",ko=`
`+Ft.repeat(at),_n=ko+Ft;if(oe.type==="ArrayValue"){const ra=oe.value.map(zo=>ni(zo,Ye,at+1));return Ye?`[${_n}${ra.join(`,${_n}`)}${ko}]`:`[${ra.join(", ")}]`}else{const ra=Array.from(oe.value.entries()).map(([zo,Jo])=>{const ia=`"${zo}": ${ni(Jo,Ye,at+1)}`;return Ye?`${_n}${ia}`:ia});return Ye?`{${ra.join(",")}${ko}}`:`{${ra.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${oe.type}`)}}var ti=class{constructor(oe){_r(this,"parsed");const Ye=l(oe,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Ot(Ye)}render(oe){const Ye=new en;Ye.set("false",!1),Ye.set("true",!0),Ye.set("raise_exception",Ft=>{throw new Error(Ft)}),Ye.set("range",$t);for(const[Ft,ko]of Object.entries(oe))Ye.set(Ft,ko);return new Bo(Ye).run(this.parsed).value}}},"./node_modules/onnxruntime-common/dist/esm/backend-impl.js":(e,r,i)=>{i.r(r),i.d(r,{registerBackend:()=>n,resolveBackendAndExecutionProviders:()=>h});const s=new Map,c=[],n=(p,t,u)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){const l=s.get(p);if(l===void 0)s.set(p,{backend:t,priority:u});else{if(l.priority>u)return;if(l.priority===u&&l.backend!==t)throw new Error(`cannot register backend "${p}" using priority ${u}`)}if(u>=0){const f=c.indexOf(p);f!==-1&&c.splice(f,1);for(let x=0;x<c.length;x++)if(s.get(c[x]).priority<=u){c.splice(x,0,p);return}c.push(p)}return}throw new TypeError("not a valid backend")},a=async p=>{const t=s.get(p);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{const u=!!t.initPromise;try{return u||(t.initPromise=t.backend.init(p)),await t.initPromise,t.initialized=!0,t.backend}catch(l){return u||(t.error=`${l}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},h=async p=>{const t=p.executionProviders||[],u=t.map(A=>typeof A=="string"?A:A.name),l=u.length===0?c:u;let f;const x=[],I=new Set;for(const A of l){const Z=await a(A);typeof Z=="string"?x.push({name:A,err:Z}):(f||(f=Z),f===Z&&I.add(A))}if(!f)throw new Error(`no available backend found. ERR: ${x.map(A=>`[${A.name}] ${A.err}`).join(", ")}`);for(const{name:A,err:Z}of x)u.includes(A)&&console.warn(`removing requested execution provider "${A}" from session options because it is not available: ${Z}`);const R=t.filter(A=>I.has(typeof A=="string"?A:A.name));return[f,new Proxy(p,{get:(A,Z)=>Z==="executionProviders"?R:Reflect.get(A,Z)})]}},"./node_modules/onnxruntime-common/dist/esm/backend.js":(e,r,i)=>{i.r(r),i.d(r,{registerBackend:()=>s.registerBackend});var s=i("./node_modules/onnxruntime-common/dist/esm/backend-impl.js")},"./node_modules/onnxruntime-common/dist/esm/env-impl.js":(e,r,i)=>{i.r(r),i.d(r,{env:()=>n});var s=i("./node_modules/onnxruntime-common/dist/esm/version.js");let c="warning";const n={wasm:{},webgl:{},webgpu:{},versions:{common:s.version},set logLevel(a){if(a!==void 0){if(typeof a!="string"||["verbose","info","warning","error","fatal"].indexOf(a)===-1)throw new Error(`Unsupported logging level: ${a}`);c=a}},get logLevel(){return c}};Object.defineProperty(n,"logLevel",{enumerable:!0})},"./node_modules/onnxruntime-common/dist/esm/env.js":(e,r,i)=>{i.r(r),i.d(r,{env:()=>c});var s=i("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const c=s.env},"./node_modules/onnxruntime-common/dist/esm/index.js":(e,r,i)=>{i.r(r),i.d(r,{InferenceSession:()=>n.InferenceSession,TRACE:()=>h.TRACE,TRACE_FUNC_BEGIN:()=>h.TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>h.TRACE_FUNC_END,Tensor:()=>a.Tensor,TrainingSession:()=>p.TrainingSession,env:()=>c.env,registerBackend:()=>s.registerBackend});var s=i("./node_modules/onnxruntime-common/dist/esm/backend.js"),c=i("./node_modules/onnxruntime-common/dist/esm/env.js"),n=i("./node_modules/onnxruntime-common/dist/esm/inference-session.js"),a=i("./node_modules/onnxruntime-common/dist/esm/tensor.js");i("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),i("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");var h=i("./node_modules/onnxruntime-common/dist/esm/trace.js");i("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),i("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");var p=i("./node_modules/onnxruntime-common/dist/esm/training-session.js")},"./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":(e,r,i)=>{i.r(r),i.d(r,{InferenceSession:()=>a});var s=i("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),c=i("./node_modules/onnxruntime-common/dist/esm/tensor.js"),n=i("./node_modules/onnxruntime-common/dist/esm/trace.js");class a{constructor(p){this.handler=p}async run(p,t,u){(0,n.TRACE_FUNC_BEGIN)();const l={};let f={};if(typeof p!="object"||p===null||p instanceof c.Tensor||Array.isArray(p))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let x=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof c.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");x=!1;for(const A of t){if(typeof A!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(A)===-1)throw new RangeError(`'fetches' contains invalid output name: ${A}.`);l[A]=null}if(typeof u=="object"&&u!==null)f=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else{let A=!1;const Z=Object.getOwnPropertyNames(t);for(const K of this.outputNames)if(Z.indexOf(K)!==-1){const Q=t[K];(Q===null||Q instanceof c.Tensor)&&(A=!0,x=!1,l[K]=Q)}if(A){if(typeof u=="object"&&u!==null)f=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else f=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const A of this.inputNames)if(typeof p[A]>"u")throw new Error(`input '${A}' is missing in 'feeds'.`);if(x)for(const A of this.outputNames)l[A]=null;const I=await this.handler.run(p,l,f),R={};for(const A in I)if(Object.hasOwnProperty.call(I,A)){const Z=I[A];Z instanceof c.Tensor?R[A]=Z:R[A]=new c.Tensor(Z.type,Z.data,Z.dims)}return(0,n.TRACE_FUNC_END)(),R}async release(){return this.handler.dispose()}static async create(p,t,u,l){(0,n.TRACE_FUNC_BEGIN)();let f,x={};if(typeof p=="string"){if(f=p,typeof t=="object"&&t!==null)x=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(p instanceof Uint8Array){if(f=p,typeof t=="object"&&t!==null)x=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(p instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&p instanceof SharedArrayBuffer){const Z=p;let K=0,Q=p.byteLength;if(typeof t=="object"&&t!==null)x=t;else if(typeof t=="number"){if(K=t,!Number.isSafeInteger(K))throw new RangeError("'byteOffset' must be an integer.");if(K<0||K>=Z.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${Z.byteLength}).`);if(Q=p.byteLength-K,typeof u=="number"){if(Q=u,!Number.isSafeInteger(Q))throw new RangeError("'byteLength' must be an integer.");if(Q<=0||K+Q>Z.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${Z.byteLength-K}].`);if(typeof l=="object"&&l!==null)x=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else if(typeof u<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");f=new Uint8Array(Z,K,Q)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[I,R]=await(0,s.resolveBackendAndExecutionProviders)(x),A=await I.createInferenceSessionHandler(f,R);return(0,n.TRACE_FUNC_END)(),new a(A)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./node_modules/onnxruntime-common/dist/esm/inference-session.js":(e,r,i)=>{i.r(r),i.d(r,{InferenceSession:()=>c});var s=i("./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js");const c=s.InferenceSession},"./node_modules/onnxruntime-common/dist/esm/onnx-model.js":(e,r,i)=>{i.r(r)},"./node_modules/onnxruntime-common/dist/esm/onnx-value.js":(e,r,i)=>{i.r(r)},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":(e,r,i)=>{i.r(r),i.d(r,{tensorToDataURL:()=>s,tensorToImageData:()=>c});const s=(n,a)=>{const h=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);h.width=n.dims[3],h.height=n.dims[2];const p=h.getContext("2d");if(p!=null){let t,u;(a==null?void 0:a.tensorLayout)!==void 0&&a.tensorLayout==="NHWC"?(t=n.dims[2],u=n.dims[3]):(t=n.dims[3],u=n.dims[2]);const l=(a==null?void 0:a.format)!==void 0?a.format:"RGB",f=a==null?void 0:a.norm;let x,I;f===void 0||f.mean===void 0?x=[255,255,255,255]:typeof f.mean=="number"?x=[f.mean,f.mean,f.mean,f.mean]:(x=[f.mean[0],f.mean[1],f.mean[2],0],f.mean[3]!==void 0&&(x[3]=f.mean[3])),f===void 0||f.bias===void 0?I=[0,0,0,0]:typeof f.bias=="number"?I=[f.bias,f.bias,f.bias,f.bias]:(I=[f.bias[0],f.bias[1],f.bias[2],0],f.bias[3]!==void 0&&(I[3]=f.bias[3]));const R=u*t;let A=0,Z=R,K=R*2,Q=-1;l==="RGBA"?(A=0,Z=R,K=R*2,Q=R*3):l==="RGB"?(A=0,Z=R,K=R*2):l==="RBG"&&(A=0,K=R,Z=R*2);for(let re=0;re<u;re++)for(let se=0;se<t;se++){const ee=(n.data[A++]-I[0])*x[0],ce=(n.data[Z++]-I[1])*x[1],X=(n.data[K++]-I[2])*x[2],Re=Q===-1?255:(n.data[Q++]-I[3])*x[3];p.fillStyle="rgba("+ee+","+ce+","+X+","+Re+")",p.fillRect(se,re,1,1)}if("toDataURL"in h)return h.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},c=(n,a)=>{const h=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let p;if(h!=null){let t,u,l;(a==null?void 0:a.tensorLayout)!==void 0&&a.tensorLayout==="NHWC"?(t=n.dims[2],u=n.dims[1],l=n.dims[3]):(t=n.dims[3],u=n.dims[2],l=n.dims[1]);const f=a!==void 0&&a.format!==void 0?a.format:"RGB",x=a==null?void 0:a.norm;let I,R;x===void 0||x.mean===void 0?I=[255,255,255,255]:typeof x.mean=="number"?I=[x.mean,x.mean,x.mean,x.mean]:(I=[x.mean[0],x.mean[1],x.mean[2],255],x.mean[3]!==void 0&&(I[3]=x.mean[3])),x===void 0||x.bias===void 0?R=[0,0,0,0]:typeof x.bias=="number"?R=[x.bias,x.bias,x.bias,x.bias]:(R=[x.bias[0],x.bias[1],x.bias[2],0],x.bias[3]!==void 0&&(R[3]=x.bias[3]));const A=u*t;if(a!==void 0&&(a.format!==void 0&&l===4&&a.format!=="RGBA"||l===3&&a.format!=="RGB"&&a.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const Z=4;let K=0,Q=1,re=2,se=3,ee=0,ce=A,X=A*2,Re=-1;f==="RGBA"?(ee=0,ce=A,X=A*2,Re=A*3):f==="RGB"?(ee=0,ce=A,X=A*2):f==="RBG"&&(ee=0,X=A,ce=A*2),p=h.createImageData(t,u);for(let De=0;De<u*t;K+=Z,Q+=Z,re+=Z,se+=Z,De++)p.data[K]=(n.data[ee++]-R[0])*I[0],p.data[Q]=(n.data[ce++]-R[1])*I[1],p.data[re]=(n.data[X++]-R[2])*I[2],p.data[se]=Re===-1?255:(n.data[Re++]-R[3])*I[3]}else throw new Error("Can not access image data");return p}},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":(e,r,i)=>{i.r(r)},"./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":(e,r,i)=>{i.r(r),i.d(r,{bufferToTensor:()=>c,tensorFromGpuBuffer:()=>h,tensorFromImage:()=>n,tensorFromPinnedBuffer:()=>p,tensorFromTexture:()=>a});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const c=(t,u)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(u.height===void 0||u.width===void 0)throw new Error("Image height and width must be defined");if(u.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:l,width:f}=u,x=u.norm??{mean:255,bias:0};let I,R;typeof x.mean=="number"?I=[x.mean,x.mean,x.mean,x.mean]:I=[x.mean[0],x.mean[1],x.mean[2],x.mean[3]??255],typeof x.bias=="number"?R=[x.bias,x.bias,x.bias,x.bias]:R=[x.bias[0],x.bias[1],x.bias[2],x.bias[3]??0];const A=u.format!==void 0?u.format:"RGBA",Z=u.tensorFormat!==void 0&&u.tensorFormat!==void 0?u.tensorFormat:"RGB",K=l*f,Q=Z==="RGBA"?new Float32Array(K*4):new Float32Array(K*3);let re=4,se=0,ee=1,ce=2,X=3,Re=0,De=K,et=K*2,nt=-1;A==="RGB"&&(re=3,se=0,ee=1,ce=2,X=-1),Z==="RGBA"?nt=K*3:Z==="RBG"?(Re=0,et=K,De=K*2):Z==="BGR"&&(et=0,De=K,Re=K*2);for(let _t=0;_t<K;_t++,se+=re,ce+=re,ee+=re,X+=re)Q[Re++]=(t[se]+R[0])/I[0],Q[De++]=(t[ee]+R[1])/I[1],Q[et++]=(t[ce]+R[2])/I[2],nt!==-1&&X!==-1&&(Q[nt++]=(t[X]+R[3])/I[3]);return Z==="RGBA"?new s.Tensor("float32",Q,[1,4,l,f]):new s.Tensor("float32",Q,[1,3,l,f])},n=async(t,u)=>{const l=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,f=typeof ImageData<"u"&&t instanceof ImageData,x=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,I=typeof t=="string";let R,A=u??{};const Z=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},K=Q=>Q instanceof HTMLCanvasElement||Q instanceof OffscreenCanvas?Q.getContext("2d"):null;if(l){const Q=Z();Q.width=t.width,Q.height=t.height;const re=K(Q);if(re!=null){let se=t.height,ee=t.width;if(u!==void 0&&u.resizedHeight!==void 0&&u.resizedWidth!==void 0&&(se=u.resizedHeight,ee=u.resizedWidth),u!==void 0){if(A=u,u.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");A.tensorFormat="RGBA",A.height=se,A.width=ee}else A.tensorFormat="RGBA",A.height=se,A.width=ee;re.drawImage(t,0,0),R=re.getImageData(0,0,ee,se).data}else throw new Error("Can not access image data")}else if(f){let Q,re;if(u!==void 0&&u.resizedWidth!==void 0&&u.resizedHeight!==void 0?(Q=u.resizedHeight,re=u.resizedWidth):(Q=t.height,re=t.width),u!==void 0&&(A=u),A.format="RGBA",A.height=Q,A.width=re,u!==void 0){const se=Z();se.width=re,se.height=Q;const ee=K(se);if(ee!=null)ee.putImageData(t,0,0),R=ee.getImageData(0,0,re,Q).data;else throw new Error("Can not access image data")}else R=t.data}else if(x){if(u===void 0)throw new Error("Please provide image config with format for Imagebitmap");const Q=Z();Q.width=t.width,Q.height=t.height;const re=K(Q);if(re!=null){const se=t.height,ee=t.width;return re.drawImage(t,0,0,ee,se),R=re.getImageData(0,0,ee,se).data,A.height=se,A.width=ee,c(R,A)}else throw new Error("Can not access image data")}else{if(I)return new Promise((Q,re)=>{const se=Z(),ee=K(se);if(!t||!ee)return re();const ce=new Image;ce.crossOrigin="Anonymous",ce.src=t,ce.onload=()=>{se.width=ce.width,se.height=ce.height,ee.drawImage(ce,0,0,se.width,se.height);const X=ee.getImageData(0,0,se.width,se.height);A.height=se.height,A.width=se.width,Q(c(X.data,A))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(R!==void 0)return c(R,A);throw new Error("Input data provided is not supported - aborted tensor creation")},a=(t,u)=>{const{width:l,height:f,download:x,dispose:I}=u,R=[1,f,l,4];return new s.Tensor({location:"texture",type:"float32",texture:t,dims:R,download:x,dispose:I})},h=(t,u)=>{const{dataType:l,dims:f,download:x,dispose:I}=u;return new s.Tensor({location:"gpu-buffer",type:l??"float32",gpuBuffer:t,dims:f,download:x,dispose:I})},p=(t,u,l)=>new s.Tensor({location:"cpu-pinned",type:t,data:u,dims:l??[u.length]})},"./node_modules/onnxruntime-common/dist/esm/tensor-factory.js":(e,r,i)=>{i.r(r)},"./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":(e,r,i)=>{i.r(r),i.d(r,{NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP:()=>c,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP:()=>s,checkTypedArray:()=>a});const s=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),c=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let n=!1;const a=()=>{if(!n){n=!0;const h=typeof BigInt64Array<"u"&&BigInt64Array.from,p=typeof BigUint64Array<"u"&&BigUint64Array.from,t=typeof Float16Array<"u"&&Float16Array.from;h&&(s.set("int64",BigInt64Array),c.set(BigInt64Array,"int64")),p&&(s.set("uint64",BigUint64Array),c.set(BigUint64Array,"uint64")),t?(s.set("float16",Float16Array),c.set(Float16Array,"float16")):s.set("float16",Uint16Array)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-impl.js":(e,r,i)=>{i.r(r),i.d(r,{Tensor:()=>h});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"),c=i("./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"),n=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"),a=i("./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js");class h{constructor(t,u,l){(0,n.checkTypedArray)();let f,x;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,f=t.type,x=t.dims,t.location){case"cpu-pinned":{const R=n.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(f);if(!R)throw new TypeError(`unsupported type "${f}" to create tensor from pinned buffer`);if(!(t.data instanceof R))throw new TypeError(`buffer should be of type ${R.name}`);this.cpuData=t.data;break}case"texture":{if(f!=="float32")throw new TypeError(`unsupported type "${f}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(f!=="float32"&&f!=="float16"&&f!=="int32"&&f!=="int64"&&f!=="uint32"&&f!=="uint8"&&f!=="bool")throw new TypeError(`unsupported type "${f}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let R,A;if(typeof t=="string")if(f=t,A=l,t==="string"){if(!Array.isArray(u))throw new TypeError("A string tensor's data must be a string array.");R=u}else{const Z=n.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(t);if(Z===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(u)){if(t==="float16"&&Z===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?R=Z.from(u,BigInt):R=Z.from(u)}else if(u instanceof Z)R=u;else throw new TypeError(`A ${f} tensor's data must be type of ${Z}`)}else if(A=u,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const Z=typeof t[0];if(Z==="string")f="string",R=t;else if(Z==="boolean")f="bool",R=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${Z}.`)}else{const Z=n.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(t.constructor);if(Z===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);f=Z,R=t}if(A===void 0)A=[R.length];else if(!Array.isArray(A))throw new TypeError("A tensor's dims must be a number array");x=A,this.cpuData=R,this.dataLocation="cpu"}const I=(0,a.calculateSize)(x);if(this.cpuData&&I!==this.cpuData.length)throw new Error(`Tensor's size(${I}) does not match data length(${this.cpuData.length}).`);this.type=f,this.dims=x,this.size=I}static async fromImage(t,u){return(0,c.tensorFromImage)(t,u)}static fromTexture(t,u){return(0,c.tensorFromTexture)(t,u)}static fromGpuBuffer(t,u){return(0,c.tensorFromGpuBuffer)(t,u)}static fromPinnedBuffer(t,u,l){return(0,c.tensorFromPinnedBuffer)(t,u,l)}toDataURL(t){return(0,s.tensorToDataURL)(this,t)}toImageData(t){return(0,s.tensorToImageData)(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const u=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=u,t&&this.disposer&&(this.disposer(),this.disposer=void 0),u}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return(0,a.tensorReshape)(this,t)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":(e,r,i)=>{i.r(r),i.d(r,{calculateSize:()=>c,tensorReshape:()=>n});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const c=a=>{let h=1;for(let p=0;p<a.length;p++){const t=a[p];if(typeof t!="number"||!Number.isSafeInteger(t))throw new TypeError(`dims[${p}] must be an integer, got: ${t}`);if(t<0)throw new RangeError(`dims[${p}] must be a non-negative integer, got: ${t}`);h*=t}return h},n=(a,h)=>{switch(a.location){case"cpu":return new s.Tensor(a.type,a.data,h);case"cpu-pinned":return new s.Tensor({location:"cpu-pinned",data:a.data,type:a.type,dims:h});case"texture":return new s.Tensor({location:"texture",texture:a.texture,type:a.type,dims:h});case"gpu-buffer":return new s.Tensor({location:"gpu-buffer",gpuBuffer:a.gpuBuffer,type:a.type,dims:h});default:throw new Error(`tensorReshape: tensor location ${a.location} is not supported`)}}},"./node_modules/onnxruntime-common/dist/esm/tensor.js":(e,r,i)=>{i.r(r),i.d(r,{Tensor:()=>c});var s=i("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const c=s.Tensor},"./node_modules/onnxruntime-common/dist/esm/trace.js":(e,r,i)=>{i.r(r),i.d(r,{TRACE:()=>c,TRACE_FUNC_BEGIN:()=>a,TRACE_FUNC_END:()=>h});var s=i("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const c=(p,t)=>{(typeof s.env.trace>"u"?!s.env.wasm.trace:!s.env.trace)||console.timeStamp(`${p}::ORT::${t}`)},n=(p,t)=>{var f;const u=((f=new Error().stack)==null?void 0:f.split(/\r\n|\r|\n/g))||[];let l=!1;for(let x=0;x<u.length;x++){if(l&&!u[x].includes("TRACE_FUNC")){let I=`FUNC_${p}::${u[x].trim().split(" ")[1]}`;t&&(I+=`::${t}`),c("CPU",I);return}u[x].includes("TRACE_FUNC")&&(l=!0)}},a=p=>{(typeof s.env.trace>"u"?!s.env.wasm.trace:!s.env.trace)||n("BEGIN",p)},h=p=>{(typeof s.env.trace>"u"?!s.env.wasm.trace:!s.env.trace)||n("END",p)}},"./node_modules/onnxruntime-common/dist/esm/training-session-impl.js":(e,r,i)=>{i.r(r),i.d(r,{TrainingSession:()=>a});var s=i("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),c=i("./node_modules/onnxruntime-common/dist/esm/tensor.js");const n="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";class a{constructor(p,t,u){this.handler=p,this.hasOptimizerModel=t,this.hasEvalModel=u}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(p,t){const u=p.evalModel||"",l=p.optimizerModel||"",f=t||{},[x,I]=await(0,s.resolveBackendAndExecutionProviders)(f);if(x.createTrainingSessionHandler){const R=await x.createTrainingSessionHandler(p.checkpointState,p.trainModel,u,l,I);return new a(R,!!p.optimizerModel,!!p.evalModel)}else throw new Error(n)}typeNarrowingForRunStep(p,t,u,l,f){const x={};let I={};if(typeof u!="object"||u===null||u instanceof c.Tensor||Array.isArray(u))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let R=!0;if(typeof l=="object"){if(l===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(l instanceof c.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(l)){if(l.length===0)throw new TypeError("'fetches' cannot be an empty array.");R=!1;for(const A of l){if(typeof A!="string")throw new TypeError("'fetches' must be a string array or an object.");if(t.indexOf(A)===-1)throw new RangeError(`'fetches' contains invalid output name: ${A}.`);x[A]=null}if(typeof f=="object"&&f!==null)I=f;else if(typeof f<"u")throw new TypeError("'options' must be an object.")}else{let A=!1;const Z=Object.getOwnPropertyNames(l);for(const K of t)if(Z.indexOf(K)!==-1){const Q=l[K];(Q===null||Q instanceof c.Tensor)&&(A=!0,R=!1,x[K]=Q)}if(A){if(typeof f=="object"&&f!==null)I=f;else if(typeof f<"u")throw new TypeError("'options' must be an object.")}else I=l}}else if(typeof l<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const A of p)if(typeof u[A]>"u")throw new Error(`input '${A}' is missing in 'feeds'.`);if(R)for(const A of t)x[A]=null;return[x,I]}convertHandlerReturnTypeToMapOfTensors(p){const t={};for(const u in p)if(Object.hasOwnProperty.call(p,u)){const l=p[u];l instanceof c.Tensor?t[u]=l:t[u]=new c.Tensor(l.type,l.data,l.dims)}return t}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(p,t,u){const[l,f]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,p,t,u),x=await this.handler.runTrainStep(p,l,f);return this.convertHandlerReturnTypeToMapOfTensors(x)}async runOptimizerStep(p){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(p||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(p,t,u){if(this.hasEvalModel){const[l,f]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,p,t,u),x=await this.handler.runEvalStep(p,l,f);return this.convertHandlerReturnTypeToMapOfTensors(x)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(p=!0){return this.handler.getParametersSize(p)}async loadParametersBuffer(p,t=!0){const u=await this.getParametersSize(t);if(p.length!==4*u)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(p,t)}async getContiguousParameters(p=!0){return this.handler.getContiguousParameters(p)}async release(){return this.handler.dispose()}}},"./node_modules/onnxruntime-common/dist/esm/training-session.js":(e,r,i)=>{i.r(r),i.d(r,{TrainingSession:()=>c});var s=i("./node_modules/onnxruntime-common/dist/esm/training-session-impl.js");const c=s.TrainingSession},"./node_modules/onnxruntime-common/dist/esm/version.js":(e,r,i)=>{i.r(r),i.d(r,{version:()=>s});const s="1.19.2"},"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs":(e,r,i)=>{i.r(r),i.d(r,{InferenceSession:()=>ti,TRACE:()=>Kr,TRACE_FUNC_BEGIN:()=>Jr,TRACE_FUNC_END:()=>en,Tensor:()=>Ze,TrainingSession:()=>zo,default:()=>bM,env:()=>X,registerBackend:()=>I});/*!
 * ONNX Runtime Web v1.20.0-dev.20241016-2b8fc5529b
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var s=Object.defineProperty,c=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,a=Object.prototype.hasOwnProperty,h=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(d,_)=>(typeof require<"u"?require:d)[_]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+o+'" is not supported')}),p=(o,d)=>()=>(o&&(d=o(o=0)),d),t=(o,d)=>{for(var _ in d)s(o,_,{get:d[_],enumerable:!0})},u=(o,d,_,m)=>{if(d&&typeof d=="object"||typeof d=="function")for(let g of n(d))!a.call(o,g)&&g!==_&&s(o,g,{get:()=>d[g],enumerable:!(m=c(d,g))||m.enumerable});return o},l=o=>u(s({},"__esModule",{value:!0}),o),f,x,I,R,A,Z=p(()=>{f=new Map,x=[],I=(o,d,_)=>{if(d&&typeof d.init=="function"&&typeof d.createInferenceSessionHandler=="function"){let m=f.get(o);if(m===void 0)f.set(o,{backend:d,priority:_});else{if(m.priority>_)return;if(m.priority===_&&m.backend!==d)throw new Error(`cannot register backend "${o}" using priority ${_}`)}if(_>=0){let g=x.indexOf(o);g!==-1&&x.splice(g,1);for(let y=0;y<x.length;y++)if(f.get(x[y]).priority<=_){x.splice(y,0,o);return}x.push(o)}return}throw new TypeError("not a valid backend")},R=async o=>{let d=f.get(o);if(!d)return"backend not found.";if(d.initialized)return d.backend;if(d.aborted)return d.error;{let _=!!d.initPromise;try{return _||(d.initPromise=d.backend.init(o)),await d.initPromise,d.initialized=!0,d.backend}catch(m){return _||(d.error=`${m}`,d.aborted=!0),d.error}finally{delete d.initPromise}}},A=async o=>{let d=o.executionProviders||[],_=d.map(M=>typeof M=="string"?M:M.name),m=_.length===0?x:_,g,y=[],b=new Set;for(let M of m){let P=await R(M);typeof P=="string"?y.push({name:M,err:P}):(g||(g=P),g===P&&b.add(M))}if(!g)throw new Error(`no available backend found. ERR: ${y.map(M=>`[${M.name}] ${M.err}`).join(", ")}`);for(let{name:M,err:P}of y)_.includes(M)&&console.warn(`removing requested execution provider "${M}" from session options because it is not available: ${P}`);let E=d.filter(M=>b.has(typeof M=="string"?M:M.name));return[g,new Proxy(o,{get:(M,P)=>P==="executionProviders"?E:Reflect.get(M,P)})]}}),K=p(()=>{Z()}),Q,re=p(()=>{Q="1.20.0-dev.20241016-2b8fc5529b"}),se,ee,ce=p(()=>{re(),se="warning",ee={wasm:{},webgl:{},webgpu:{},versions:{common:Q},set logLevel(o){if(o!==void 0){if(typeof o!="string"||["verbose","info","warning","error","fatal"].indexOf(o)===-1)throw new Error(`Unsupported logging level: ${o}`);se=o}},get logLevel(){return se}},Object.defineProperty(ee,"logLevel",{enumerable:!0})}),X,Re=p(()=>{ce(),X=ee}),De,et,nt=p(()=>{De=(o,d)=>{let _=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);_.width=o.dims[3],_.height=o.dims[2];let m=_.getContext("2d");if(m!=null){let g,y;(d==null?void 0:d.tensorLayout)!==void 0&&d.tensorLayout==="NHWC"?(g=o.dims[2],y=o.dims[3]):(g=o.dims[3],y=o.dims[2]);let b=(d==null?void 0:d.format)!==void 0?d.format:"RGB",E=d==null?void 0:d.norm,M,P;E===void 0||E.mean===void 0?M=[255,255,255,255]:typeof E.mean=="number"?M=[E.mean,E.mean,E.mean,E.mean]:(M=[E.mean[0],E.mean[1],E.mean[2],0],E.mean[3]!==void 0&&(M[3]=E.mean[3])),E===void 0||E.bias===void 0?P=[0,0,0,0]:typeof E.bias=="number"?P=[E.bias,E.bias,E.bias,E.bias]:(P=[E.bias[0],E.bias[1],E.bias[2],0],E.bias[3]!==void 0&&(P[3]=E.bias[3]));let U=y*g,N=0,T=U,ae=U*2,ue=-1;b==="RGBA"?(N=0,T=U,ae=U*2,ue=U*3):b==="RGB"?(N=0,T=U,ae=U*2):b==="RBG"&&(N=0,ae=U,T=U*2);for(let fe=0;fe<y;fe++)for(let Ae=0;Ae<g;Ae++){let Le=(o.data[N++]-P[0])*M[0],Oe=(o.data[T++]-P[1])*M[1],pt=(o.data[ae++]-P[2])*M[2],lt=ue===-1?255:(o.data[ue++]-P[3])*M[3];m.fillStyle="rgba("+Le+","+Oe+","+pt+","+lt+")",m.fillRect(Ae,fe,1,1)}if("toDataURL"in _)return _.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},et=(o,d)=>{let _=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),m;if(_!=null){let g,y,b;(d==null?void 0:d.tensorLayout)!==void 0&&d.tensorLayout==="NHWC"?(g=o.dims[2],y=o.dims[1],b=o.dims[3]):(g=o.dims[3],y=o.dims[2],b=o.dims[1]);let E=d!==void 0&&d.format!==void 0?d.format:"RGB",M=d==null?void 0:d.norm,P,U;M===void 0||M.mean===void 0?P=[255,255,255,255]:typeof M.mean=="number"?P=[M.mean,M.mean,M.mean,M.mean]:(P=[M.mean[0],M.mean[1],M.mean[2],255],M.mean[3]!==void 0&&(P[3]=M.mean[3])),M===void 0||M.bias===void 0?U=[0,0,0,0]:typeof M.bias=="number"?U=[M.bias,M.bias,M.bias,M.bias]:(U=[M.bias[0],M.bias[1],M.bias[2],0],M.bias[3]!==void 0&&(U[3]=M.bias[3]));let N=y*g;if(d!==void 0&&(d.format!==void 0&&b===4&&d.format!=="RGBA"||b===3&&d.format!=="RGB"&&d.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let T=4,ae=0,ue=1,fe=2,Ae=3,Le=0,Oe=N,pt=N*2,lt=-1;E==="RGBA"?(Le=0,Oe=N,pt=N*2,lt=N*3):E==="RGB"?(Le=0,Oe=N,pt=N*2):E==="RBG"&&(Le=0,pt=N,Oe=N*2),m=_.createImageData(g,y);for(let ft=0;ft<y*g;ae+=T,ue+=T,fe+=T,Ae+=T,ft++)m.data[ae]=(o.data[Le++]-U[0])*P[0],m.data[ue]=(o.data[Oe++]-U[1])*P[1],m.data[fe]=(o.data[pt++]-U[2])*P[2],m.data[Ae]=lt===-1?255:(o.data[lt++]-U[3])*P[3]}else throw new Error("Can not access image data");return m}}),it,_t,gt,Dt,Ge,ge,ct=p(()=>{Yr(),it=(o,d)=>{if(o===void 0)throw new Error("Image buffer must be defined");if(d.height===void 0||d.width===void 0)throw new Error("Image height and width must be defined");if(d.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:_,width:m}=d,g=d.norm??{mean:255,bias:0},y,b;typeof g.mean=="number"?y=[g.mean,g.mean,g.mean,g.mean]:y=[g.mean[0],g.mean[1],g.mean[2],g.mean[3]??255],typeof g.bias=="number"?b=[g.bias,g.bias,g.bias,g.bias]:b=[g.bias[0],g.bias[1],g.bias[2],g.bias[3]??0];let E=d.format!==void 0?d.format:"RGBA",M=d.tensorFormat!==void 0&&d.tensorFormat!==void 0?d.tensorFormat:"RGB",P=_*m,U=M==="RGBA"?new Float32Array(P*4):new Float32Array(P*3),N=4,T=0,ae=1,ue=2,fe=3,Ae=0,Le=P,Oe=P*2,pt=-1;E==="RGB"&&(N=3,T=0,ae=1,ue=2,fe=-1),M==="RGBA"?pt=P*3:M==="RBG"?(Ae=0,Oe=P,Le=P*2):M==="BGR"&&(Oe=0,Le=P,Ae=P*2);for(let lt=0;lt<P;lt++,T+=N,ue+=N,ae+=N,fe+=N)U[Ae++]=(o[T]+b[0])/y[0],U[Le++]=(o[ae]+b[1])/y[1],U[Oe++]=(o[ue]+b[2])/y[2],pt!==-1&&fe!==-1&&(U[pt++]=(o[fe]+b[3])/y[3]);return M==="RGBA"?new Ao("float32",U,[1,4,_,m]):new Ao("float32",U,[1,3,_,m])},_t=async(o,d)=>{let _=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,m=typeof ImageData<"u"&&o instanceof ImageData,g=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,y=typeof o=="string",b,E=d??{},M=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},P=U=>typeof HTMLCanvasElement<"u"&&U instanceof HTMLCanvasElement||U instanceof OffscreenCanvas?U.getContext("2d"):null;if(_){let U=M();U.width=o.width,U.height=o.height;let N=P(U);if(N!=null){let T=o.height,ae=o.width;if(d!==void 0&&d.resizedHeight!==void 0&&d.resizedWidth!==void 0&&(T=d.resizedHeight,ae=d.resizedWidth),d!==void 0){if(E=d,d.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");E.tensorFormat="RGBA",E.height=T,E.width=ae}else E.tensorFormat="RGBA",E.height=T,E.width=ae;N.drawImage(o,0,0),b=N.getImageData(0,0,ae,T).data}else throw new Error("Can not access image data")}else if(m){let U,N;if(d!==void 0&&d.resizedWidth!==void 0&&d.resizedHeight!==void 0?(U=d.resizedHeight,N=d.resizedWidth):(U=o.height,N=o.width),d!==void 0&&(E=d),E.format="RGBA",E.height=U,E.width=N,d!==void 0){let T=M();T.width=N,T.height=U;let ae=P(T);if(ae!=null)ae.putImageData(o,0,0),b=ae.getImageData(0,0,N,U).data;else throw new Error("Can not access image data")}else b=o.data}else if(g){if(d===void 0)throw new Error("Please provide image config with format for Imagebitmap");let U=M();U.width=o.width,U.height=o.height;let N=P(U);if(N!=null){let T=o.height,ae=o.width;return N.drawImage(o,0,0,ae,T),b=N.getImageData(0,0,ae,T).data,E.height=T,E.width=ae,it(b,E)}else throw new Error("Can not access image data")}else{if(y)return new Promise((U,N)=>{let T=M(),ae=P(T);if(!o||!ae)return N();let ue=new Image;ue.crossOrigin="Anonymous",ue.src=o,ue.onload=()=>{T.width=ue.width,T.height=ue.height,ae.drawImage(ue,0,0,T.width,T.height);let fe=ae.getImageData(0,0,T.width,T.height);E.height=T.height,E.width=T.width,U(it(fe.data,E))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(b!==void 0)return it(b,E);throw new Error("Input data provided is not supported - aborted tensor creation")},gt=(o,d)=>{let{width:_,height:m,download:g,dispose:y}=d,b=[1,m,_,4];return new Ao({location:"texture",type:"float32",texture:o,dims:b,download:g,dispose:y})},Dt=(o,d)=>{let{dataType:_,dims:m,download:g,dispose:y}=d;return new Ao({location:"gpu-buffer",type:_??"float32",gpuBuffer:o,dims:m,download:g,dispose:y})},Ge=(o,d)=>{let{dataType:_,dims:m,download:g,dispose:y}=d;return new Ao({location:"ml-tensor",type:_??"float32",mlTensor:o,dims:m,download:g,dispose:y})},ge=(o,d,_)=>new Ao({location:"cpu-pinned",type:o,data:d,dims:_??[d.length]})}),Ot,$t,gr,Qe,Dr=p(()=>{Ot=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),$t=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),gr=!1,Qe=()=>{if(!gr){gr=!0;let o=typeof BigInt64Array<"u"&&BigInt64Array.from,d=typeof BigUint64Array<"u"&&BigUint64Array.from,_=typeof Float16Array<"u"&&Float16Array.from;o&&(Ot.set("int64",BigInt64Array),$t.set(BigInt64Array,"int64")),d&&(Ot.set("uint64",BigUint64Array),$t.set(BigUint64Array,"uint64")),_?(Ot.set("float16",Float16Array),$t.set(Float16Array,"float16")):Ot.set("float16",Uint16Array)}}}),vn,vr,Eo=p(()=>{Yr(),vn=o=>{let d=1;for(let _=0;_<o.length;_++){let m=o[_];if(typeof m!="number"||!Number.isSafeInteger(m))throw new TypeError(`dims[${_}] must be an integer, got: ${m}`);if(m<0)throw new RangeError(`dims[${_}] must be a non-negative integer, got: ${m}`);d*=m}return d},vr=(o,d)=>{switch(o.location){case"cpu":return new Ao(o.type,o.data,d);case"cpu-pinned":return new Ao({location:"cpu-pinned",data:o.data,type:o.type,dims:d});case"texture":return new Ao({location:"texture",texture:o.texture,type:o.type,dims:d});case"gpu-buffer":return new Ao({location:"gpu-buffer",gpuBuffer:o.gpuBuffer,type:o.type,dims:d});case"ml-tensor":return new Ao({location:"ml-tensor",mlTensor:o.mlTensor,type:o.type,dims:d});default:throw new Error(`tensorReshape: tensor location ${o.location} is not supported`)}}}),Ao,Yr=p(()=>{nt(),ct(),Dr(),Eo(),Ao=class{constructor(o,d,_){Qe();let m,g;if(typeof o=="object"&&"location"in o)switch(this.dataLocation=o.location,m=o.type,g=o.dims,o.location){case"cpu-pinned":{let b=Ot.get(m);if(!b)throw new TypeError(`unsupported type "${m}" to create tensor from pinned buffer`);if(!(o.data instanceof b))throw new TypeError(`buffer should be of type ${b.name}`);this.cpuData=o.data;break}case"texture":{if(m!=="float32")throw new TypeError(`unsupported type "${m}" to create tensor from texture`);this.gpuTextureData=o.texture,this.downloader=o.download,this.disposer=o.dispose;break}case"gpu-buffer":{if(m!=="float32"&&m!=="float16"&&m!=="int32"&&m!=="int64"&&m!=="uint32"&&m!=="uint8"&&m!=="bool"&&m!=="uint4"&&m!=="int4")throw new TypeError(`unsupported type "${m}" to create tensor from gpu buffer`);this.gpuBufferData=o.gpuBuffer,this.downloader=o.download,this.disposer=o.dispose;break}case"ml-tensor":{if(m!=="float32"&&m!=="float16"&&m!=="int32"&&m!=="int64"&&m!=="uint32"&&m!=="uint64"&&m!=="int8"&&m!=="uint8"&&m!=="bool")throw new TypeError(`unsupported type "${m}" to create tensor from MLTensor`);this.mlTensorData=o.mlTensor,this.downloader=o.download,this.disposer=o.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let b,E;if(typeof o=="string")if(m=o,E=_,o==="string"){if(!Array.isArray(d))throw new TypeError("A string tensor's data must be a string array.");b=d}else{let M=Ot.get(o);if(M===void 0)throw new TypeError(`Unsupported tensor type: ${o}.`);if(Array.isArray(d)){if(o==="float16"&&M===Uint16Array||o==="uint4"||o==="int4")throw new TypeError(`Creating a ${o} tensor from number array is not supported. Please use ${M.name} as data.`);o==="uint64"||o==="int64"?b=M.from(d,BigInt):b=M.from(d)}else if(d instanceof M)b=d;else if(d instanceof Uint8ClampedArray)if(o==="uint8")b=Uint8Array.from(d);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${m} tensor's data must be type of ${M}`)}else if(E=d,Array.isArray(o)){if(o.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let M=typeof o[0];if(M==="string")m="string",b=o;else if(M==="boolean")m="bool",b=Uint8Array.from(o);else throw new TypeError(`Invalid element type of data array: ${M}.`)}else if(o instanceof Uint8ClampedArray)m="uint8",b=Uint8Array.from(o);else{let M=$t.get(o.constructor);if(M===void 0)throw new TypeError(`Unsupported type for tensor data: ${o.constructor}.`);m=M,b=o}if(E===void 0)E=[b.length];else if(!Array.isArray(E))throw new TypeError("A tensor's dims must be a number array");g=E,this.cpuData=b,this.dataLocation="cpu"}let y=vn(g);if(this.cpuData&&y!==this.cpuData.length&&!((m==="uint4"||m==="int4")&&Math.ceil(y/2)===this.cpuData.length))throw new Error(`Tensor's size(${y}) does not match data length(${this.cpuData.length}).`);this.type=m,this.dims=g,this.size=y}static async fromImage(o,d){return _t(o,d)}static fromTexture(o,d){return gt(o,d)}static fromGpuBuffer(o,d){return Dt(o,d)}static fromMLTensor(o,d){return Ge(o,d)}static fromPinnedBuffer(o,d,_){return ge(o,d,_)}toDataURL(o){return De(this,o)}toImageData(o){return et(this,o)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(o){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let d=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=d,o&&this.disposer&&(this.disposer(),this.disposer=void 0),d}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(o){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return vr(this,o)}}}),Ze,er=p(()=>{Yr(),Ze=Ao}),Kr,_o,Jr,en,Bo=p(()=>{ce(),Kr=(o,d)=>{(typeof ee.trace>"u"?!ee.wasm.trace:!ee.trace)||console.timeStamp(`${o}::ORT::${d}`)},_o=(o,d)=>{var g;let _=((g=new Error().stack)==null?void 0:g.split(/\r\n|\r|\n/g))||[],m=!1;for(let y=0;y<_.length;y++){if(m&&!_[y].includes("TRACE_FUNC")){let b=`FUNC_${o}::${_[y].trim().split(" ")[1]}`;d&&(b+=`::${d}`),Kr("CPU",b);return}_[y].includes("TRACE_FUNC")&&(m=!0)}},Jr=o=>{(typeof ee.trace>"u"?!ee.wasm.trace:!ee.trace)||_o("BEGIN",o)},en=o=>{(typeof ee.trace>"u"?!ee.wasm.trace:!ee.trace)||_o("END",o)}}),Ks,ni=p(()=>{Z(),er(),Bo(),Ks=class tM{constructor(d){this.handler=d}async run(d,_,m){Jr();let g={},y={};if(typeof d!="object"||d===null||d instanceof Ze||Array.isArray(d))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let b=!0;if(typeof _=="object"){if(_===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(_ instanceof Ze)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(_)){if(_.length===0)throw new TypeError("'fetches' cannot be an empty array.");b=!1;for(let P of _){if(typeof P!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(P)===-1)throw new RangeError(`'fetches' contains invalid output name: ${P}.`);g[P]=null}if(typeof m=="object"&&m!==null)y=m;else if(typeof m<"u")throw new TypeError("'options' must be an object.")}else{let P=!1,U=Object.getOwnPropertyNames(_);for(let N of this.outputNames)if(U.indexOf(N)!==-1){let T=_[N];(T===null||T instanceof Ze)&&(P=!0,b=!1,g[N]=T)}if(P){if(typeof m=="object"&&m!==null)y=m;else if(typeof m<"u")throw new TypeError("'options' must be an object.")}else y=_}}else if(typeof _<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let P of this.inputNames)if(typeof d[P]>"u")throw new Error(`input '${P}' is missing in 'feeds'.`);if(b)for(let P of this.outputNames)g[P]=null;let E=await this.handler.run(d,g,y),M={};for(let P in E)if(Object.hasOwnProperty.call(E,P)){let U=E[P];U instanceof Ze?M[P]=U:M[P]=new Ze(U.type,U.data,U.dims)}return en(),M}async release(){return this.handler.dispose()}static async create(d,_,m,g){Jr();let y,b={};if(typeof d=="string"){if(y=d,typeof _=="object"&&_!==null)b=_;else if(typeof _<"u")throw new TypeError("'options' must be an object.")}else if(d instanceof Uint8Array){if(y=d,typeof _=="object"&&_!==null)b=_;else if(typeof _<"u")throw new TypeError("'options' must be an object.")}else if(d instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&d instanceof SharedArrayBuffer){let U=d,N=0,T=d.byteLength;if(typeof _=="object"&&_!==null)b=_;else if(typeof _=="number"){if(N=_,!Number.isSafeInteger(N))throw new RangeError("'byteOffset' must be an integer.");if(N<0||N>=U.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${U.byteLength}).`);if(T=d.byteLength-N,typeof m=="number"){if(T=m,!Number.isSafeInteger(T))throw new RangeError("'byteLength' must be an integer.");if(T<=0||N+T>U.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${U.byteLength-N}].`);if(typeof g=="object"&&g!==null)b=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else if(typeof m<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof _<"u")throw new TypeError("'options' must be an object.");y=new Uint8Array(U,N,T)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[E,M]=await A(b),P=await E.createInferenceSessionHandler(y,M);return en(),new tM(P)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),ti,oe=p(()=>{ni(),ti=Ks}),Ye=p(()=>{}),le=p(()=>{}),at=p(()=>{}),Ft=p(()=>{}),ko,_n,ra=p(()=>{Z(),er(),ko="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",_n=class rM{constructor(d,_,m){this.handler=d,this.hasOptimizerModel=_,this.hasEvalModel=m}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(d,_){let m=d.evalModel||"",g=d.optimizerModel||"",y=_||{},[b,E]=await A(y);if(b.createTrainingSessionHandler){let M=await b.createTrainingSessionHandler(d.checkpointState,d.trainModel,m,g,E);return new rM(M,!!d.optimizerModel,!!d.evalModel)}else throw new Error(ko)}typeNarrowingForRunStep(d,_,m,g,y){let b={},E={};if(typeof m!="object"||m===null||m instanceof Ze||Array.isArray(m))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let M=!0;if(typeof g=="object"){if(g===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(g instanceof Ze)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(g)){if(g.length===0)throw new TypeError("'fetches' cannot be an empty array.");M=!1;for(let P of g){if(typeof P!="string")throw new TypeError("'fetches' must be a string array or an object.");if(_.indexOf(P)===-1)throw new RangeError(`'fetches' contains invalid output name: ${P}.`);b[P]=null}if(typeof y=="object"&&y!==null)E=y;else if(typeof y<"u")throw new TypeError("'options' must be an object.")}else{let P=!1,U=Object.getOwnPropertyNames(g);for(let N of _)if(U.indexOf(N)!==-1){let T=g[N];(T===null||T instanceof Ze)&&(P=!0,M=!1,b[N]=T)}if(P){if(typeof y=="object"&&y!==null)E=y;else if(typeof y<"u")throw new TypeError("'options' must be an object.")}else E=g}}else if(typeof g<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let P of d)if(typeof m[P]>"u")throw new Error(`input '${P}' is missing in 'feeds'.`);if(M)for(let P of _)b[P]=null;return[b,E]}convertHandlerReturnTypeToMapOfTensors(d){let _={};for(let m in d)if(Object.hasOwnProperty.call(d,m)){let g=d[m];g instanceof Ze?_[m]=g:_[m]=new Ze(g.type,g.data,g.dims)}return _}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(d,_,m){let[g,y]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,d,_,m),b=await this.handler.runTrainStep(d,g,y);return this.convertHandlerReturnTypeToMapOfTensors(b)}async runOptimizerStep(d){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(d||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(d,_,m){if(this.hasEvalModel){let[g,y]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,d,_,m),b=await this.handler.runEvalStep(d,g,y);return this.convertHandlerReturnTypeToMapOfTensors(b)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(d=!0){return this.handler.getParametersSize(d)}async loadParametersBuffer(d,_=!0){let m=await this.getParametersSize(_);if(d.length!==4*m)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(d,_)}async getContiguousParameters(d=!0){return this.handler.getContiguousParameters(d)}async release(){return this.handler.dispose()}}}),zo,Jo=p(()=>{ra(),zo=_n}),ia={};t(ia,{InferenceSession:()=>ti,TRACE:()=>Kr,TRACE_FUNC_BEGIN:()=>Jr,TRACE_FUNC_END:()=>en,Tensor:()=>Ze,TrainingSession:()=>zo,env:()=>X,registerBackend:()=>I});var ii=p(()=>{K(),Re(),oe(),er(),Ye(),le(),Bo(),at(),Ft(),Jo()}),Sa=p(()=>{}),Na={};t(Na,{default:()=>$u});var Tu,Ua,$u,So=p(()=>{var o;wE(),bu(),ha(),Tu="ort-wasm-proxy-worker",Ua=((o=globalThis.self)==null?void 0:o.name)===Tu,Ua&&(self.onmessage=d=>{let{type:_,in:m}=d.data;try{switch(_){case"init-wasm":wu(m.wasm).then(()=>{JT(m).then(()=>{postMessage({type:_})},g=>{postMessage({type:_,err:g})})},g=>{postMessage({type:_,err:g})});break;case"init-ep":{let{epName:g,env:y}=m;e1(y,g).then(()=>{postMessage({type:_})},b=>{postMessage({type:_,err:b})});break}case"copy-from":{let{buffer:g}=m,y=kT(g);postMessage({type:_,out:y});break}case"create":{let{model:g,options:y}=m;t1(g,y).then(b=>{postMessage({type:_,out:b})},b=>{postMessage({type:_,err:b})});break}case"release":r1(m),postMessage({type:_});break;case"run":{let{sessionId:g,inputIndices:y,inputs:b,outputIndices:E,options:M}=m;o1(g,y,b,E,new Array(E.length).fill(null),M).then(P=>{P.some(U=>U[3]!=="cpu")?postMessage({type:_,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:_,out:P},i1([...b,...P]))},P=>{postMessage({type:_,err:P})});break}case"end-profiling":s1(m),postMessage({type:_});break;default:}}catch(g){postMessage({type:_,err:g})}}),$u=Ua?null:d=>new Worker(d??Po,{type:"module",name:Tu})}),Ie={};t(Ie,{default:()=>Oo});var Nt,Lr,Oo,tr=p(()=>{var o;Lr=(Nt=import.meta.url,async function(d={}){function _(){return Ra.buffer!=Ea.buffer&&Md(),Ea}function m(){return Ra.buffer!=Ea.buffer&&Md(),Xa}function g(){return Ra.buffer!=Ea.buffer&&Md(),on}function y(){return Ra.buffer!=Ea.buffer&&Md(),Zs}function b(){return Ra.buffer!=Ea.buffer&&Md(),Ma}function E(){return Ra.buffer!=Ea.buffer&&Md(),pu}function M(){return Ra.buffer!=Ea.buffer&&Md(),Uu}function P(){return Ra.buffer!=Ea.buffer&&Md(),AT}var U,N,T=Object.assign({},d),ae=new Promise((v,$)=>{U=v,N=$}),ue=typeof window=="object",fe=typeof importScripts=="function",Ae=fe&&self.name=="em-pthread";T.mountExternalData=(v,$)=>{v.startsWith("./")&&(v=v.substring(2)),(T.Fb||(T.Fb=new Map)).set(v,$)},T.unmountExternalData=()=>{delete T.Fb};var Le=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let Oe=()=>{let v=(V,ie,ve)=>(...vt)=>{let On=L_,Fo=ie==null?void 0:ie();vt=V(...vt);let sa=ie==null?void 0:ie();return Fo!==sa&&(V=sa,ve(Fo),ie=ve=null),L_!=On?new Promise((ua,Ta)=>{P1={resolve:ua,reject:Ta}}):vt},$=V=>async(...ie)=>{var ve;try{if(T.Eb)throw Error("Session already started");let vt=T.Eb={fc:ie[0],errors:[]},On=await V(...ie);if(T.Eb!==vt)throw Error("Session mismatch");(ve=T.Gb)==null||ve.flush();let Fo=vt.errors;if(0<Fo.length){let sa=await Promise.all(Fo);if(sa=sa.filter(ua=>ua),0<sa.length)throw Error(sa.join(`
`))}return On}finally{T.Eb=null}};T._OrtCreateSession=v(T._OrtCreateSession,()=>T._OrtCreateSession,V=>T._OrtCreateSession=V),T._OrtRun=$(v(T._OrtRun,()=>T._OrtRun,V=>T._OrtRun=V)),T._OrtRunWithBinding=$(v(T._OrtRunWithBinding,()=>T._OrtRunWithBinding,V=>T._OrtRunWithBinding=V)),T._OrtBindInput=v(T._OrtBindInput,()=>T._OrtBindInput,V=>T._OrtBindInput=V),Oe=void 0};T.jsepInit=(v,$)=>{if(Oe==null||Oe(),v==="webgpu"){[T.Gb,T.Ub,T.Yb,T.Nb,T.Xb,T.jb,T.Zb,T.bc,T.Vb,T.Wb,T.$b]=$;let V=T.Gb;T.jsepRegisterBuffer=(ie,ve,vt,On)=>V.registerBuffer(ie,ve,vt,On),T.jsepGetBuffer=ie=>V.getBuffer(ie),T.jsepCreateDownloader=(ie,ve,vt)=>V.createDownloader(ie,ve,vt),T.jsepOnReleaseSession=ie=>{V.onReleaseSession(ie)},T.jsepOnRunStart=ie=>V.onRunStart(ie),T.cc=(ie,ve)=>{V.upload(ie,ve)}}else if(v==="webnn"){[T.Gb,T.ac,T.Ob,T.jsepEnsureTensor,T.dc,T.jsepDownloadTensor]=$,T.jsepReleaseTensorId=T.Ob;let V=T.Gb;T.jsepOnRunStart=ie=>V.onRunStart(ie),T.jsepRegisterMLContext=(ie,ve)=>{V.registerMLContext(ie,ve)},T.jsepOnReleaseSession=ie=>{V.onReleaseSession(ie)},T.jsepCreateMLTensorDownloader=(ie,ve)=>V.createMLTensorDownloader(ie,ve),T.jsepRegisterMLTensor=(ie,ve,vt)=>V.registerMLTensor(ie,ve,vt)}};var pt,lt,ft=Object.assign({},T),nn="./this.program",Er=(v,$)=>{throw $},Do="";(ue||fe)&&(fe?Do=self.location.href:typeof document<"u"&&document.currentScript&&(Do=document.currentScript.src),Nt&&(Do=Nt),Do=Do.startsWith("blob:")?"":Do.substr(0,Do.replace(/[?#].*/,"").lastIndexOf("/")+1),fe&&(lt=v=>{var $=new XMLHttpRequest;return $.open("GET",v,!1),$.responseType="arraybuffer",$.send(null),new Uint8Array($.response)}),pt=(v,$,V)=>{var ie=new XMLHttpRequest;ie.open("GET",v,!0),ie.responseType="arraybuffer",ie.onload=()=>{ie.status==200||ie.status==0&&ie.response?$(ie.response):V()},ie.onerror=V,ie.send(null)});var aa,pa=console.log.bind(console),Ia=console.error.bind(console),Da=pa,wa=Ia;if(Object.assign(T,ft),ft=null,Ae){let v=function($){try{var V=$.data,ie=V.cmd;if(ie==="load"){let ve=[];self.onmessage=vt=>ve.push(vt),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let vt of ve)v(vt);self.onmessage=v};for(let vt of V.handlers)T[vt]&&!T[vt].proxy||(T[vt]=(...On)=>{postMessage({Mb:"callHandler",oc:vt,args:On})},vt=="print"&&(Da=T[vt]),vt=="printErr"&&(wa=T[vt]));Ra=V.wasmMemory,Md(),uu(V.wasmModule)}else if(ie==="run"){A1(V.pthread_ptr,0,0,1,0,0),T1(V.pthread_ptr),xM(),WE(),yu||(z2(),yu=!0);try{vM(V.start_routine,V.arg)}catch(ve){if(ve!="unwind")throw ve}}else ie==="cancel"?jw()&&UT(-1):V.target!=="setimmediate"&&(ie==="checkMailbox"?yu&&CT():ie&&(wa(`worker: received unknown command ${ie}`),wa(V)))}catch(ve){throw N2(),ve}};var uu,yu=!1;wa=function(...$){$=$.join(" "),console.error($)},self.alert=function(...$){postMessage({Mb:"alert",text:$.join(" "),qc:jw()})},T.instantiateWasm=($,V)=>new Promise(ie=>{uu=ve=>{ve=new WebAssembly.Instance(ve,RE()),V(ve),ie()}}),self.onunhandledrejection=$=>{throw $.reason||$},self.onmessage=v}T.wasmBinary&&(aa=T.wasmBinary);var Ra,fu,ga,Ea,Xa,on,Zs,Ma,pu,Uu,hd,ih,AT,Nd=!1;function Md(){var v=Ra.buffer;T.HEAP8=Ea=new Int8Array(v),T.HEAP16=on=new Int16Array(v),T.HEAPU8=Xa=new Uint8Array(v),T.HEAPU16=Zs=new Uint16Array(v),T.HEAP32=Ma=new Int32Array(v),T.HEAPU32=pu=new Uint32Array(v),T.HEAPF32=Uu=new Float32Array(v),T.HEAPF64=AT=new Float64Array(v),T.HEAP64=hd=new BigInt64Array(v),T.HEAPU64=ih=new BigUint64Array(v)}if(!Ae){if(!((Ra=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof Le))throw wa("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");Md()}var ty=[],wd=[],Sd=[],__=0,ah=null;function ST(){if(--__==0&&ah){var v=ah;ah=null,v()}}function Bw(v){throw wa(v="Aborted("+v+")"),Nd=!0,ga=1,v=new WebAssembly.RuntimeError(v+". Build with -sASSERTIONS for more info."),N(v),v}var c1,DE=v=>v.startsWith("data:application/octet-stream;base64,"),FE=v=>v.startsWith("file://");function BE(v){if(v==c1&&aa)return new Uint8Array(aa);if(lt)return lt(v);throw"both async and sync fetching of the wasm failed"}function LE(v,$,V){return function(ie){if(!aa&&(ue||fe)){if(typeof fetch=="function"&&!FE(ie))return fetch(ie,{credentials:"same-origin"}).then(ve=>{if(!ve.ok)throw`failed to load wasm binary file at '${ie}'`;return ve.arrayBuffer()}).catch(()=>BE(ie));if(pt)return new Promise((ve,vt)=>{pt(ie,On=>ve(new Uint8Array(On)),vt)})}return Promise.resolve().then(()=>BE(ie))}(v).then(ie=>WebAssembly.instantiate(ie,$)).then(V,ie=>{wa(`failed to asynchronously prepare wasm: ${ie}`),Bw(ie)})}function RE(){return{a:{O:wM,Aa:yM,b:EM,aa:qE,B:YE,qa:QE,Y:JE,_:e2,ra:t2,oa:r2,ha:n2,na:o2,L:s2,Z:i2,W:a2,pa:l2,X:u2,wa:MM,F:PM,Q:kM,P:$M,E:SM,u:IM,q:CM,G:DM,A:NM,R:UM,ua:WM,ka:VM,U:GM,ba:KM,H:qM,ja:T1,ta:HM,t:XM,x:ZM,o:JM,l:tP,c:x1,n:rP,j:sP,w:iP,p:aP,g:lP,s:uP,m:dP,e:cP,k:pP,i:_P,h:hP,d:fP,ea:mP,fa:gP,ga:bP,ca:T2,da:E2,T:yP,f:wP,D:xP,I:vP,M:TP,y:EP,sa:MP,V:PP,v:P2,z:kP,N:OP,S:$P,za:AP,ya:SP,la:$2,ma:A2,$:m1,C:S2,K:I2,ia:C2,J:D2,a:Ra,xa:f1,va:L2,r:DP}}}var p1={867620:(v,$,V,ie,ve)=>{if(T===void 0||!T.Fb)return 1;if((v=$d(v>>>0)).startsWith("./")&&(v=v.substring(2)),!(v=T.Fb.get(v)))return 2;if(ie>>>=0,($>>>=0)+(V>>>=0)>v.byteLength)return 3;try{let vt=v.subarray($,$+V);switch(ve){case 0:m().set(vt,ie>>>0);break;case 1:T.cc(ie,vt);break;default:return 4}return 0}catch{return 4}},868303:(v,$,V)=>{T.dc(v,m().subarray($>>>0,$+V>>>0))},868366:()=>T.ac(),868407:v=>{T.Ob(v)},868443:()=>{T.Vb()},868474:()=>{T.Wb()},868503:()=>{T.$b()},868528:v=>T.Ub(v),868561:v=>T.Yb(v),868593:(v,$,V)=>{T.Nb(v,$,V,!0)},868632:(v,$,V)=>{T.Nb(v,$,V)},868665:()=>typeof wasmOffsetConverter<"u",868722:v=>{T.jb("Abs",v,void 0)},868773:v=>{T.jb("Neg",v,void 0)},868824:v=>{T.jb("Floor",v,void 0)},868877:v=>{T.jb("Ceil",v,void 0)},868929:v=>{T.jb("Reciprocal",v,void 0)},868987:v=>{T.jb("Sqrt",v,void 0)},869039:v=>{T.jb("Exp",v,void 0)},869090:v=>{T.jb("Erf",v,void 0)},869141:v=>{T.jb("Sigmoid",v,void 0)},869196:(v,$,V)=>{T.jb("HardSigmoid",v,{alpha:$,beta:V})},869275:v=>{T.jb("Log",v,void 0)},869326:v=>{T.jb("Sin",v,void 0)},869377:v=>{T.jb("Cos",v,void 0)},869428:v=>{T.jb("Tan",v,void 0)},869479:v=>{T.jb("Asin",v,void 0)},869531:v=>{T.jb("Acos",v,void 0)},869583:v=>{T.jb("Atan",v,void 0)},869635:v=>{T.jb("Sinh",v,void 0)},869687:v=>{T.jb("Cosh",v,void 0)},869739:v=>{T.jb("Asinh",v,void 0)},869792:v=>{T.jb("Acosh",v,void 0)},869845:v=>{T.jb("Atanh",v,void 0)},869898:v=>{T.jb("Tanh",v,void 0)},869950:v=>{T.jb("Not",v,void 0)},870001:(v,$,V)=>{T.jb("Clip",v,{min:$,max:V})},870070:v=>{T.jb("Clip",v,void 0)},870122:(v,$)=>{T.jb("Elu",v,{alpha:$})},870180:v=>{T.jb("Gelu",v,void 0)},870232:v=>{T.jb("Relu",v,void 0)},870284:(v,$)=>{T.jb("LeakyRelu",v,{alpha:$})},870348:(v,$)=>{T.jb("ThresholdedRelu",v,{alpha:$})},870418:(v,$)=>{T.jb("Cast",v,{to:$})},870476:v=>{T.jb("Add",v,void 0)},870527:v=>{T.jb("Sub",v,void 0)},870578:v=>{T.jb("Mul",v,void 0)},870629:v=>{T.jb("Div",v,void 0)},870680:v=>{T.jb("Pow",v,void 0)},870731:v=>{T.jb("Equal",v,void 0)},870784:v=>{T.jb("Greater",v,void 0)},870839:v=>{T.jb("GreaterOrEqual",v,void 0)},870901:v=>{T.jb("Less",v,void 0)},870953:v=>{T.jb("LessOrEqual",v,void 0)},871012:(v,$,V,ie,ve)=>{T.jb("ReduceMean",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},871171:(v,$,V,ie,ve)=>{T.jb("ReduceMax",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},871329:(v,$,V,ie,ve)=>{T.jb("ReduceMin",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},871487:(v,$,V,ie,ve)=>{T.jb("ReduceProd",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},871646:(v,$,V,ie,ve)=>{T.jb("ReduceSum",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},871804:(v,$,V,ie,ve)=>{T.jb("ReduceL1",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},871961:(v,$,V,ie,ve)=>{T.jb("ReduceL2",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},872118:(v,$,V,ie,ve)=>{T.jb("ReduceLogSum",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},872279:(v,$,V,ie,ve)=>{T.jb("ReduceSumSquare",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},872443:(v,$,V,ie,ve)=>{T.jb("ReduceLogSumExp",v,{keepDims:!!$,noopWithEmptyAxes:!!V,axes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},872607:v=>{T.jb("Where",v,void 0)},872660:(v,$,V)=>{T.jb("Transpose",v,{perm:$?Array.from(b().subarray($>>>0,V>>>0)):[]})},872768:(v,$,V,ie)=>{T.jb("DepthToSpace",v,{blocksize:$,mode:$d(V),format:ie?"NHWC":"NCHW"})},872901:(v,$,V,ie)=>{T.jb("DepthToSpace",v,{blocksize:$,mode:$d(V),format:ie?"NHWC":"NCHW"})},873034:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr,Ka)=>{T.jb("ConvTranspose",v,{format:sa?"NHWC":"NCHW",autoPad:$,dilations:[V],group:ie,kernelShape:[ve],pads:[vt,On],strides:[Fo],wIsConst:()=>!!_()[ua>>>0],outputPadding:Ta?Array.from(b().subarray(Ta>>>0,Ya>>>0)):[],outputShape:mu?Array.from(b().subarray(mu>>>0,Zr>>>0)):[],activation:$d(Ka)})},873435:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr)=>{T.jb("ConvTranspose",v,{format:Fo?"NHWC":"NCHW",autoPad:$,dilations:Array.from(b().subarray(V>>>0,2+(V>>>0)>>>0)),group:ie,kernelShape:Array.from(b().subarray(ve>>>0,2+(ve>>>0)>>>0)),pads:Array.from(b().subarray(vt>>>0,4+(vt>>>0)>>>0)),strides:Array.from(b().subarray(On>>>0,2+(On>>>0)>>>0)),wIsConst:()=>!!_()[sa>>>0],outputPadding:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],outputShape:Ya?Array.from(b().subarray(Ya>>>0,mu>>>0)):[],activation:$d(Zr)})},874e3:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr,Ka)=>{T.jb("ConvTranspose",v,{format:sa?"NHWC":"NCHW",autoPad:$,dilations:[V],group:ie,kernelShape:[ve],pads:[vt,On],strides:[Fo],wIsConst:()=>!!_()[ua>>>0],outputPadding:Ta?Array.from(b().subarray(Ta>>>0,Ya>>>0)):[],outputShape:mu?Array.from(b().subarray(mu>>>0,Zr>>>0)):[],activation:$d(Ka)})},874401:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr)=>{T.jb("ConvTranspose",v,{format:Fo?"NHWC":"NCHW",autoPad:$,dilations:Array.from(b().subarray(V>>>0,2+(V>>>0)>>>0)),group:ie,kernelShape:Array.from(b().subarray(ve>>>0,2+(ve>>>0)>>>0)),pads:Array.from(b().subarray(vt>>>0,4+(vt>>>0)>>>0)),strides:Array.from(b().subarray(On>>>0,2+(On>>>0)>>>0)),wIsConst:()=>!!_()[sa>>>0],outputPadding:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],outputShape:Ya?Array.from(b().subarray(Ya>>>0,mu>>>0)):[],activation:$d(Zr)})},874966:(v,$)=>{T.jb("GlobalAveragePool",v,{format:$?"NHWC":"NCHW"})},875057:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr)=>{T.jb("AveragePool",v,{format:Zr?"NHWC":"NCHW",auto_pad:$,ceil_mode:V,count_include_pad:ie,storage_order:ve,dilations:vt?Array.from(b().subarray(vt>>>0,On>>>0)):[],kernel_shape:Fo?Array.from(b().subarray(Fo>>>0,sa>>>0)):[],pads:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],strides:Ya?Array.from(b().subarray(Ya>>>0,mu>>>0)):[]})},875472:(v,$)=>{T.jb("GlobalAveragePool",v,{format:$?"NHWC":"NCHW"})},875563:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr)=>{T.jb("AveragePool",v,{format:Zr?"NHWC":"NCHW",auto_pad:$,ceil_mode:V,count_include_pad:ie,storage_order:ve,dilations:vt?Array.from(b().subarray(vt>>>0,On>>>0)):[],kernel_shape:Fo?Array.from(b().subarray(Fo>>>0,sa>>>0)):[],pads:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],strides:Ya?Array.from(b().subarray(Ya>>>0,mu>>>0)):[]})},875978:(v,$)=>{T.jb("GlobalMaxPool",v,{format:$?"NHWC":"NCHW"})},876065:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr)=>{T.jb("MaxPool",v,{format:Zr?"NHWC":"NCHW",auto_pad:$,ceil_mode:V,count_include_pad:ie,storage_order:ve,dilations:vt?Array.from(b().subarray(vt>>>0,On>>>0)):[],kernel_shape:Fo?Array.from(b().subarray(Fo>>>0,sa>>>0)):[],pads:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],strides:Ya?Array.from(b().subarray(Ya>>>0,mu>>>0)):[]})},876476:(v,$)=>{T.jb("GlobalMaxPool",v,{format:$?"NHWC":"NCHW"})},876563:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr)=>{T.jb("MaxPool",v,{format:Zr?"NHWC":"NCHW",auto_pad:$,ceil_mode:V,count_include_pad:ie,storage_order:ve,dilations:vt?Array.from(b().subarray(vt>>>0,On>>>0)):[],kernel_shape:Fo?Array.from(b().subarray(Fo>>>0,sa>>>0)):[],pads:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],strides:Ya?Array.from(b().subarray(Ya>>>0,mu>>>0)):[]})},876974:(v,$,V,ie,ve)=>{T.jb("Gemm",v,{alpha:$,beta:V,transA:ie,transB:ve})},877078:v=>{T.jb("MatMul",v,void 0)},877132:(v,$,V,ie)=>{T.jb("ArgMax",v,{keepDims:!!$,selectLastIndex:!!V,axis:ie})},877240:(v,$,V,ie)=>{T.jb("ArgMin",v,{keepDims:!!$,selectLastIndex:!!V,axis:ie})},877348:(v,$)=>{T.jb("Softmax",v,{axis:$})},877411:(v,$)=>{T.jb("Concat",v,{axis:$})},877471:(v,$,V,ie,ve)=>{T.jb("Split",v,{axis:$,numOutputs:V,splitSizes:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},877611:v=>{T.jb("Expand",v,void 0)},877665:(v,$)=>{T.jb("Gather",v,{axis:Number($)})},877736:(v,$)=>{T.jb("GatherElements",v,{axis:Number($)})},877815:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta)=>{T.jb("Resize",v,{antialias:$,axes:V?Array.from(b().subarray(V>>>0,ie>>>0)):[],coordinateTransformMode:$d(ve),cubicCoeffA:vt,excludeOutside:On,extrapolationValue:Fo,keepAspectRatioPolicy:$d(sa),mode:$d(ua),nearestMode:$d(Ta)})},878161:(v,$,V,ie,ve,vt,On)=>{T.jb("Slice",v,{starts:$?Array.from(b().subarray($>>>0,V>>>0)):[],ends:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[],axes:vt?Array.from(b().subarray(vt>>>0,On>>>0)):[]})},878377:v=>{T.jb("Tile",v,void 0)},878429:(v,$,V)=>{T.jb("InstanceNormalization",v,{epsilon:$,format:V?"NHWC":"NCHW"})},878543:(v,$,V)=>{T.jb("InstanceNormalization",v,{epsilon:$,format:V?"NHWC":"NCHW"})},878657:v=>{T.jb("Range",v,void 0)},878710:(v,$)=>{T.jb("Einsum",v,{equation:$d($)})},878791:(v,$,V,ie,ve)=>{T.jb("Pad",v,{mode:$,value:V,pads:ie?Array.from(b().subarray(ie>>>0,ve>>>0)):[]})},878918:(v,$,V,ie,ve,vt)=>{T.jb("BatchNormalization",v,{epsilon:$,momentum:V,spatial:!!ve,trainingMode:!!ie,format:vt?"NHWC":"NCHW"})},879087:(v,$,V,ie,ve,vt)=>{T.jb("BatchNormalization",v,{epsilon:$,momentum:V,spatial:!!ve,trainingMode:!!ie,format:vt?"NHWC":"NCHW"})},879256:(v,$,V)=>{T.jb("CumSum",v,{exclusive:Number($),reverse:Number(V)})},879353:(v,$,V)=>{T.jb("DequantizeLinear",v,{axis:$,blockSize:V})},879443:(v,$,V,ie,ve,vt,On,Fo,sa)=>{T.jb("Attention",v,{numHeads:$,isUnidirectional:V,maskFilterValue:ie,scale:ve,doRotary:vt,qkvHiddenSizes:On?Array.from(b().subarray(Number(Fo)>>>0,Number(Fo)+On>>>0)):[],pastPresentShareBuffer:!!sa})},879715:v=>{T.jb("BiasAdd",v,void 0)},879770:v=>{T.jb("BiasSplitGelu",v,void 0)},879831:v=>{T.jb("FastGelu",v,void 0)},879887:(v,$,V,ie,ve,vt,On,Fo,sa,ua,Ta,Ya,mu,Zr,Ka,Ru)=>{T.jb("Conv",v,{format:Ya?"NHWC":"NCHW",auto_pad:$,dilations:V?Array.from(b().subarray(V>>>0,ie>>>0)):[],group:ve,kernel_shape:vt?Array.from(b().subarray(vt>>>0,On>>>0)):[],pads:Fo?Array.from(b().subarray(Fo>>>0,sa>>>0)):[],strides:ua?Array.from(b().subarray(ua>>>0,Ta>>>0)):[],w_is_const:()=>!!_()[mu>>>0],activation:$d(Zr),activation_params:Ka?Array.from(M().subarray(Ka>>>0,Ru>>>0)):[]})},880383:v=>{T.jb("Gelu",v,void 0)},880435:(v,$,V,ie)=>{T.jb("GroupQueryAttention",v,{numHeads:$,kvNumHeads:V,scale:ie})},880548:(v,$,V,ie)=>{T.jb("LayerNormalization",v,{axis:$,epsilon:V,simplified:!!ie})},880659:(v,$,V,ie)=>{T.jb("LayerNormalization",v,{axis:$,epsilon:V,simplified:!!ie})},880770:(v,$,V,ie,ve,vt)=>{T.jb("MatMulNBits",v,{k:$,n:V,accuracyLevel:ie,bits:ve,blockSize:vt})},880897:(v,$,V,ie,ve,vt)=>{T.jb("MultiHeadAttention",v,{numHeads:$,isUnidirectional:V,maskFilterValue:ie,scale:ve,doRotary:vt})},881056:(v,$)=>{T.jb("QuickGelu",v,{alpha:$})},881120:(v,$,V,ie,ve)=>{T.jb("RotaryEmbedding",v,{interleaved:!!$,numHeads:V,rotaryEmbeddingDim:ie,scale:ve})},881259:(v,$,V)=>{T.jb("SkipLayerNormalization",v,{epsilon:$,simplified:!!V})},881361:(v,$,V)=>{T.jb("SkipLayerNormalization",v,{epsilon:$,simplified:!!V})},881463:(v,$,V,ie)=>{T.jb("GatherBlockQuantized",v,{gatherAxis:$,quantizeAxis:V,blockSize:ie})},881584:v=>{T.Zb(v)},881618:(v,$)=>T.bc(v,$,T.Eb.fc,T.Eb.errors)};function yM(v,$,V){return b2(async()=>{await T.Xb(v,$,V)})}function wM(){return typeof wasmOffsetConverter<"u"}function _1(v){this.name="ExitStatus",this.message=`Program terminated with exit(${v})`,this.status=v}var h1=v=>{v.terminate(),v.onmessage=()=>{}},jE=v=>{lh.length==0&&(GE(),VE(lh[0]));var $=lh.pop();if(!$)return 6;ny.push($),F_[v.Ab]=$,$.Ab=v.Ab;var V={cmd:"run",start_routine:v.hc,arg:v.Qb,pthread_ptr:v.Ab};return $.postMessage(V,v.mc),0},ry=0,Cu=(v,$,...V)=>{for(var ie=2*V.length,ve=C1(),vt=I1(8*ie),On=vt>>>3,Fo=0;Fo<V.length;Fo++){var sa=V[Fo];typeof sa=="bigint"?(hd[On+2*Fo]=1n,hd[On+2*Fo+1]=sa):(hd[On+2*Fo]=0n,P()[On+2*Fo+1>>>0]=sa)}return v=U2(v,0,ie,vt,$),WT(ve),v};function f1(v){if(Ae)return Cu(0,1,v);if(ga=v,!(0<ry)){for(var $ of ny)h1($);for($ of lh)h1($);lh=[],ny=[],F_=[],Nd=!0}Er(v,new _1(v))}function zE(v){if(Ae)return Cu(1,0,v);m1(v)}var m1=v=>{if(ga=v,Ae)throw zE(v),"unwind";f1(v)},lh=[],ny=[],NE=[],F_={},UE=v=>{var $=v.Ab;delete F_[$],lh.push(v),ny.splice(ny.indexOf(v),1),v.Ab=0,S1($)};function WE(){NE.forEach(v=>v())}var VE=v=>new Promise($=>{v.onmessage=ve=>{var vt=(ve=ve.data).cmd;if(ve.targetThread&&ve.targetThread!=jw()){var On=F_[ve.targetThread];On?On.postMessage(ve,ve.transferList):wa(`Internal error! Worker sent a message "${vt}" to target pthread ${ve.targetThread}, but that thread no longer exists!`)}else vt==="checkMailbox"?CT():vt==="spawnThread"?jE(ve):vt==="cleanupThread"?UE(F_[ve.thread]):vt==="killThread"?(ve=ve.thread,vt=F_[ve],delete F_[ve],h1(vt),S1(ve),ny.splice(ny.indexOf(vt),1),vt.Ab=0):vt==="cancelThread"?F_[ve.thread].postMessage({cmd:"cancel"}):vt==="loaded"?(v.loaded=!0,$(v)):vt==="alert"?alert(`Thread ${ve.threadId}: ${ve.text}`):ve.target==="setimmediate"?v.postMessage(ve):vt==="callHandler"?T[ve.handler](...ve.args):vt&&wa(`worker sent an unknown command ${vt}`)},v.onerror=ve=>{throw wa(`worker sent an error! ${ve.filename}:${ve.lineno}: ${ve.message}`),ve};var V,ie=[];for(V of[])T.hasOwnProperty(V)&&ie.push(V);v.postMessage({cmd:"load",handlers:ie,wasmMemory:Ra,wasmModule:fu})});function GE(){var v=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});lh.push(v)}var IT=v=>{for(;0<v.length;)v.shift()(T)},xM=()=>{var v=jw(),$=E()[v+52>>>2>>>0];v=E()[v+56>>>2>>>0],V2($,$-v),WT($)},vM=(v,$)=>{ry=0,v=G2(v,$),0<ry?ga=v:UT(v)};class TM{constructor($){this.Jb=$-24}}function EM(v,$,V){var ie=new TM(v>>>=0);throw $>>>=0,V>>>=0,E()[ie.Jb+16>>>2>>>0]=0,E()[ie.Jb+4>>>2>>>0]=$,E()[ie.Jb+8>>>2>>>0]=V,v}function KE(v,$,V,ie){return Ae?Cu(2,1,v,$,V,ie):qE(v,$,V,ie)}function qE(v,$,V,ie){if(v>>>=0,$>>>=0,V>>>=0,ie>>>=0,Le===void 0)return wa("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ve=[];return Ae&&ve.length===0?KE(v,$,V,ie):(v={hc:V,Ab:v,Qb:ie,mc:ve},Ae?(v.Mb="spawnThread",postMessage(v,ve),0):jE(v))}var HE=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,XE=(v,$,V)=>{var ie=($>>>=0)+V;for(V=$;v[V]&&!(V>=ie);)++V;if(16<V-$&&v.buffer&&HE)return HE.decode(v.buffer instanceof Le?v.slice($,V):v.subarray($,V));for(ie="";$<V;){var ve=v[$++];if(128&ve){var vt=63&v[$++];if((224&ve)==192)ie+=String.fromCharCode((31&ve)<<6|vt);else{var On=63&v[$++];65536>(ve=(240&ve)==224?(15&ve)<<12|vt<<6|On:(7&ve)<<18|vt<<12|On<<6|63&v[$++])?ie+=String.fromCharCode(ve):(ve-=65536,ie+=String.fromCharCode(55296|ve>>10,56320|1023&ve))}}else ie+=String.fromCharCode(ve)}return ie},$d=(v,$)=>(v>>>=0)?XE(m(),v,$):"";function YE(v,$,V){return Ae?Cu(3,1,v,$,V):0}function QE(v,$){if(Ae)return Cu(4,1,v,$)}var g1=v=>{for(var $=0,V=0;V<v.length;++V){var ie=v.charCodeAt(V);127>=ie?$++:2047>=ie?$+=2:55296<=ie&&57343>=ie?($+=4,++V):$+=3}return $},ZE=(v,$,V,ie)=>{if(!(0<ie))return 0;var ve=V>>>=0;ie=V+ie-1;for(var vt=0;vt<v.length;++vt){var On=v.charCodeAt(vt);if(55296<=On&&57343>=On&&(On=65536+((1023&On)<<10)|1023&v.charCodeAt(++vt)),127>=On){if(V>=ie)break;$[V++>>>0]=On}else{if(2047>=On){if(V+1>=ie)break;$[V++>>>0]=192|On>>6}else{if(65535>=On){if(V+2>=ie)break;$[V++>>>0]=224|On>>12}else{if(V+3>=ie)break;$[V++>>>0]=240|On>>18,$[V++>>>0]=128|On>>12&63}$[V++>>>0]=128|On>>6&63}$[V++>>>0]=128|63&On}}return $[V>>>0]=0,V-ve},Lw=(v,$,V)=>ZE(v,m(),$,V);function JE(v,$){if(Ae)return Cu(5,1,v,$)}function e2(v,$,V){if(Ae)return Cu(6,1,v,$,V)}function t2(v,$,V){return Ae?Cu(7,1,v,$,V):0}function r2(v,$){if(Ae)return Cu(8,1,v,$)}function n2(v,$,V){if(Ae)return Cu(9,1,v,$,V)}function o2(v,$,V,ie){if(Ae)return Cu(10,1,v,$,V,ie)}function s2(v,$,V,ie){if(Ae)return Cu(11,1,v,$,V,ie)}function i2(v,$,V,ie){if(Ae)return Cu(12,1,v,$,V,ie)}function a2(v){if(Ae)return Cu(13,1,v)}function l2(v,$){if(Ae)return Cu(14,1,v,$)}function u2(v,$,V){if(Ae)return Cu(15,1,v,$,V)}var d2,uh,MM=()=>{Bw("")},B_=v=>{for(var $="";m()[v>>>0];)$+=d2[m()[v++>>>0]];return $},b1={},y1={};function z_(v,$,V={}){if(!("argPackAdvance"in $))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(ie,ve,vt={}){var On=ve.name;if(!ie)throw new uh(`type "${On}" must have a positive integer typeid pointer`);if(y1.hasOwnProperty(ie)){if(vt.Sb)return;throw new uh(`Cannot register type '${On}' twice`)}y1[ie]=ve,b1.hasOwnProperty(ie)&&(ve=b1[ie],delete b1[ie],ve.forEach(Fo=>Fo()))}(v,$,V)}var c2=(v,$,V)=>{switch($){case 1:return V?ie=>_()[ie>>>0]:ie=>m()[ie>>>0];case 2:return V?ie=>g()[ie>>>1>>>0]:ie=>y()[ie>>>1>>>0];case 4:return V?ie=>b()[ie>>>2>>>0]:ie=>E()[ie>>>2>>>0];case 8:return V?ie=>hd[ie>>>3]:ie=>ih[ie>>>3];default:throw new TypeError(`invalid integer width (${$}): ${v}`)}};function PM(v,$,V){V>>>=0,z_(v>>>=0,{name:$=B_($>>>0),fromWireType:ie=>ie,toWireType:function(ie,ve){if(typeof ve!="bigint"&&typeof ve!="number")throw ve=ve===null?"null":(ie=typeof ve)=="object"||ie==="array"||ie==="function"?ve.toString():""+ve,new TypeError(`Cannot convert "${ve}" to ${this.name}`);return typeof ve=="number"&&(ve=BigInt(ve)),ve},argPackAdvance:dh,readValueFromPointer:c2($,V,$.indexOf("u")==-1),Db:null})}var dh=8;function kM(v,$,V,ie){z_(v>>>=0,{name:$=B_($>>>0),fromWireType:function(ve){return!!ve},toWireType:function(ve,vt){return vt?V:ie},argPackAdvance:dh,readValueFromPointer:function(ve){return this.fromWireType(m()[ve>>>0])},Db:null})}var w1=[],N_=[];function x1(v){9<(v>>>=0)&&--N_[v+1]==0&&(N_[v]=void 0,w1.push(v))}var h_=v=>{if(!v)throw new uh("Cannot use deleted val. handle = "+v);return N_[v]},f_=v=>{switch(v){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let $=w1.pop()||N_.length;return N_[$]=v,N_[$+1]=1,$}};function v1(v){return this.fromWireType(E()[v>>>2>>>0])}var OM={name:"emscripten::val",fromWireType:v=>{var $=h_(v);return x1(v),$},toWireType:(v,$)=>f_($),argPackAdvance:dh,readValueFromPointer:v1,Db:null};function $M(v){return z_(v>>>0,OM)}var AM=(v,$)=>{switch($){case 4:return function(V){return this.fromWireType(M()[V>>>2>>>0])};case 8:return function(V){return this.fromWireType(P()[V>>>3>>>0])};default:throw new TypeError(`invalid float width (${$}): ${v}`)}};function SM(v,$,V){V>>>=0,z_(v>>>=0,{name:$=B_($>>>0),fromWireType:ie=>ie,toWireType:(ie,ve)=>ve,argPackAdvance:dh,readValueFromPointer:AM($,V),Db:null})}function IM(v,$,V,ie,ve){if(v>>>=0,V>>>=0,$=B_($>>>0),ve===-1&&(ve=4294967295),ve=Fo=>Fo,ie===0){var vt=32-8*V;ve=Fo=>Fo<<vt>>>vt}var On=$.includes("unsigned")?function(Fo,sa){return sa>>>0}:function(Fo,sa){return sa};z_(v,{name:$,fromWireType:ve,toWireType:On,argPackAdvance:dh,readValueFromPointer:c2($,V,ie!==0),Db:null})}function CM(v,$,V){function ie(vt){var On=E()[vt>>>2>>>0];return vt=E()[vt+4>>>2>>>0],new ve(_().buffer,vt,On)}var ve=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][$];z_(v>>>=0,{name:V=B_(V>>>0),fromWireType:ie,argPackAdvance:dh,readValueFromPointer:ie},{Sb:!0})}function DM(v,$){v>>>=0;var V=($=B_($>>>0))==="std::string";z_(v,{name:$,fromWireType:function(ie){var ve=E()[ie>>>2>>>0],vt=ie+4;if(V)for(var On=vt,Fo=0;Fo<=ve;++Fo){var sa=vt+Fo;if(Fo==ve||m()[sa>>>0]==0){if(On=$d(On,sa-On),ua===void 0)var ua=On;else ua+="\0",ua+=On;On=sa+1}}else{for(ua=Array(ve),Fo=0;Fo<ve;++Fo)ua[Fo]=String.fromCharCode(m()[vt+Fo>>>0]);ua=ua.join("")}return R_(ie),ua},toWireType:function(ie,ve){ve instanceof ArrayBuffer&&(ve=new Uint8Array(ve));var vt=typeof ve=="string";if(!(vt||ve instanceof Uint8Array||ve instanceof Uint8ClampedArray||ve instanceof Int8Array))throw new uh("Cannot pass non-string to std::string");var On=V&&vt?g1(ve):ve.length,Fo=NT(4+On+1),sa=Fo+4;if(E()[Fo>>>2>>>0]=On,V&&vt)Lw(ve,sa,On+1);else if(vt)for(vt=0;vt<On;++vt){var ua=ve.charCodeAt(vt);if(255<ua)throw R_(sa),new uh("String has UTF-16 code units that do not fit in 8 bits");m()[sa+vt>>>0]=ua}else for(vt=0;vt<On;++vt)m()[sa+vt>>>0]=ve[vt];return ie!==null&&ie.push(R_,Fo),Fo},argPackAdvance:dh,readValueFromPointer:v1,Db(ie){R_(ie)}})}var p2=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,FM=(v,$)=>{for(var V=v>>1,ie=V+$/2;!(V>=ie)&&y()[V>>>0];)++V;if(32<(V<<=1)-v&&p2)return p2.decode(m().slice(v,V));for(V="",ie=0;!(ie>=$/2);++ie){var ve=g()[v+2*ie>>>1>>>0];if(ve==0)break;V+=String.fromCharCode(ve)}return V},BM=(v,$,V)=>{if(V??(V=2147483647),2>V)return 0;var ie=$;V=(V-=2)<2*v.length?V/2:v.length;for(var ve=0;ve<V;++ve){var vt=v.charCodeAt(ve);g()[$>>>1>>>0]=vt,$+=2}return g()[$>>>1>>>0]=0,$-ie},LM=v=>2*v.length,RM=(v,$)=>{for(var V=0,ie="";!(V>=$/4);){var ve=b()[v+4*V>>>2>>>0];if(ve==0)break;++V,65536<=ve?(ve-=65536,ie+=String.fromCharCode(55296|ve>>10,56320|1023&ve)):ie+=String.fromCharCode(ve)}return ie},jM=(v,$,V)=>{if($>>>=0,V??(V=2147483647),4>V)return 0;var ie=$;V=ie+V-4;for(var ve=0;ve<v.length;++ve){var vt=v.charCodeAt(ve);if(55296<=vt&&57343>=vt&&(vt=65536+((1023&vt)<<10)|1023&v.charCodeAt(++ve)),b()[$>>>2>>>0]=vt,($+=4)+4>V)break}return b()[$>>>2>>>0]=0,$-ie},zM=v=>{for(var $=0,V=0;V<v.length;++V){var ie=v.charCodeAt(V);55296<=ie&&57343>=ie&&++V,$+=4}return $};function NM(v,$,V){if(v>>>=0,$>>>=0,V=B_(V>>>=0),$===2)var ie=FM,ve=BM,vt=LM,On=Fo=>y()[Fo>>>1>>>0];else $===4&&(ie=RM,ve=jM,vt=zM,On=Fo=>E()[Fo>>>2>>>0]);z_(v,{name:V,fromWireType:Fo=>{for(var sa,ua=E()[Fo>>>2>>>0],Ta=Fo+4,Ya=0;Ya<=ua;++Ya){var mu=Fo+4+Ya*$;Ya!=ua&&On(mu)!=0||(Ta=ie(Ta,mu-Ta),sa===void 0?sa=Ta:(sa+="\0",sa+=Ta),Ta=mu+$)}return R_(Fo),sa},toWireType:(Fo,sa)=>{if(typeof sa!="string")throw new uh(`Cannot pass non-string to C++ string type ${V}`);var ua=vt(sa),Ta=NT(4+ua+$);return E()[Ta>>>2>>>0]=ua/$,ve(sa,Ta+4,ua+$),Fo!==null&&Fo.push(R_,Ta),Ta},argPackAdvance:dh,readValueFromPointer:v1,Db(Fo){R_(Fo)}})}function UM(v,$){z_(v>>>=0,{Tb:!0,name:$=B_($>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var WM=()=>1;function VM(v){A1(v>>>0,!fe,1,!ue,131072,!1),WE()}var _2=v=>{if(!Nd)try{if(v(),!(0<ry))try{Ae?UT(ga):m1(ga)}catch($){$ instanceof _1||$=="unwind"||Er(1,$)}}catch($){$ instanceof _1||$=="unwind"||Er(1,$)}};function T1(v){v>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(b(),v>>>2,v).value.then(CT),v+=128,Atomics.store(b(),v>>>2,1))}var CT=()=>{var v=jw();v&&(T1(v),_2(W2))};function GM(v,$){(v>>>=0)==$>>>0?setTimeout(CT):Ae?postMessage({targetThread:v,cmd:"checkMailbox"}):(v=F_[v])&&v.postMessage({cmd:"checkMailbox"})}var E1=[];function KM(v,$,V,ie,ve){for($>>>=0,ie/=2,E1.length=ie,V=ve>>>0>>>3,ve=0;ve<ie;ve++)E1[ve]=hd[V+2*ve]?hd[V+2*ve+1]:P()[V+2*ve+1>>>0];return($?p1[$]:FP[v])(...E1)}function qM(v){v>>>=0,Ae?postMessage({cmd:"cleanupThread",thread:v}):UE(F_[v])}function HM(v){}var M1=(v,$)=>{var V=y1[v];if(V===void 0)throw v=j2(v),V=B_(v),R_(v),new uh(`${$} has unknown type ${V}`);return V},h2=(v,$,V)=>{var ie=[];return v=v.toWireType(ie,V),ie.length&&(E()[$>>>2>>>0]=f_(ie)),v};function XM(v,$,V){return $>>>=0,V>>>=0,v=h_(v>>>0),$=M1($,"emval::as"),h2($,V,v)}var DT=v=>{try{v()}catch($){Bw($)}},ch=0,L_=null,f2=0,FT=[],m2={},g2={},YM=0,P1=null,QM=[];function b2(v){return function($){if(!Nd){if(ch===0){var V=!1,ie=!1;$((ve=0)=>{if(!Nd&&(f2=ve,V=!0,ie)){ch=2,DT(()=>H2(L_)),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.resume(),ve=!1;try{var vt=function(){var sa=b()[L_+8>>>2>>>0];return sa=xa[g2[sa]],--ry,sa()}()}catch(sa){vt=sa,ve=!0}var On=!1;if(!L_){var Fo=P1;Fo&&(P1=null,(ve?Fo.reject:Fo.resolve)(vt),On=!0)}if(ve&&!On)throw vt}}),ie=!0,V||(ch=1,L_=function(){var ve=NT(65548),vt=ve+12;E()[ve>>>2>>>0]=vt,E()[ve+4>>>2>>>0]=vt+65536,vt=FT[0];var On=m2[vt];return On===void 0&&(On=YM++,m2[vt]=On,g2[On]=vt),vt=On,b()[ve+8>>>2>>>0]=vt,ve}(),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.pause(),DT(()=>K2(L_)))}else ch===2?(ch=0,DT(X2),R_(L_),L_=null,QM.forEach(_2)):Bw(`invalid state: ${ch}`);return f2}}($=>{v().then($)})}function ZM(v){return v>>>=0,b2(()=>(v=h_(v)).then(f_))}var BT=[];function JM(v,$,V,ie){return V>>>=0,ie>>>=0,(v=BT[v>>>0])(null,$=h_($>>>0),V,ie)}var eP={},LT=v=>{var $=eP[v];return $===void 0?B_(v):$};function tP(v,$,V,ie,ve){return V>>>=0,ie>>>=0,ve>>>=0,(v=BT[v>>>0])($=h_($>>>0),$[V=LT(V)],ie,ve)}var y2=()=>typeof globalThis=="object"?globalThis:Function("return this")();function rP(v){return(v>>>=0)==0?f_(y2()):(v=LT(v),f_(y2()[v]))}var nP=v=>{var $=BT.length;return BT.push(v),$},oP=(v,$)=>{for(var V=Array(v),ie=0;ie<v;++ie)V[ie]=M1(E()[$+4*ie>>>2>>>0],"parameter "+ie);return V},w2=(v,$)=>Object.defineProperty($,"name",{value:v});function sP(v,$,V){var ie=($=oP(v,$>>>0)).shift();v--;var ve=`return function (obj, func, destructorsRef, args) {
`,vt=0,On=[];V===0&&On.push("obj");for(var Fo=["retType"],sa=[ie],ua=0;ua<v;++ua)On.push("arg"+ua),Fo.push("argType"+ua),sa.push($[ua]),ve+=`  var arg${ua} = argType${ua}.readValueFromPointer(args${vt?"+"+vt:""});
`,vt+=$[ua].argPackAdvance;return ve+=`  var rv = ${V===1?"new func":"func.call"}(${On.join(", ")});
`,ie.Tb||(Fo.push("emval_returnValue"),sa.push(h2),ve+=`  return emval_returnValue(retType, destructorsRef, rv);
`),Fo.push(ve+`};
`),v=function(Ta){var Ya=Function;if(!(Ya instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Ya} which is not a function`);var mu=w2(Ya.name||"unknownFunctionName",function(){});return mu.prototype=Ya.prototype,mu=new mu,(Ta=Ya.apply(mu,Ta))instanceof Object?Ta:mu}(Fo)(...sa),V=`methodCaller<(${$.map(Ta=>Ta.name).join(", ")}) => ${ie.name}>`,nP(w2(V,v))}function iP(v){return v=LT(v>>>0),f_(T[v])}function aP(v,$){return $>>>=0,v=h_(v>>>0),$=h_($),f_(v[$])}function lP(v){9<(v>>>=0)&&(N_[v+1]+=1)}function uP(){return f_([])}function dP(v){v=h_(v>>>0);for(var $=Array(v.length),V=0;V<v.length;V++)$[V]=v[V];return f_($)}function cP(v){return f_(LT(v>>>0))}function pP(){return f_({})}function _P(v){for(var $=h_(v>>>=0);$.length;){var V=$.pop();$.pop()(V)}x1(v)}function hP(v,$,V){$>>>=0,V>>>=0,v=h_(v>>>0),$=h_($),V=h_(V),v[$]=V}function fP(v,$){return $>>>=0,v=(v=M1(v>>>0,"_emval_take_value")).readValueFromPointer($),f_(v)}function mP(v,$){v=-9007199254740992>v||9007199254740992<v?NaN:Number(v),$>>>=0,v=new Date(1e3*v),b()[$>>>2>>>0]=v.getUTCSeconds(),b()[$+4>>>2>>>0]=v.getUTCMinutes(),b()[$+8>>>2>>>0]=v.getUTCHours(),b()[$+12>>>2>>>0]=v.getUTCDate(),b()[$+16>>>2>>>0]=v.getUTCMonth(),b()[$+20>>>2>>>0]=v.getUTCFullYear()-1900,b()[$+24>>>2>>>0]=v.getUTCDay(),v=(v.getTime()-Date.UTC(v.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,b()[$+28>>>2>>>0]=v}var Rw=v=>v%4==0&&(v%100!=0||v%400==0),x2=[0,31,60,91,121,152,182,213,244,274,305,335],v2=[0,31,59,90,120,151,181,212,243,273,304,334];function gP(v,$){v=-9007199254740992>v||9007199254740992<v?NaN:Number(v),$>>>=0,v=new Date(1e3*v),b()[$>>>2>>>0]=v.getSeconds(),b()[$+4>>>2>>>0]=v.getMinutes(),b()[$+8>>>2>>>0]=v.getHours(),b()[$+12>>>2>>>0]=v.getDate(),b()[$+16>>>2>>>0]=v.getMonth(),b()[$+20>>>2>>>0]=v.getFullYear()-1900,b()[$+24>>>2>>>0]=v.getDay();var V=(Rw(v.getFullYear())?x2:v2)[v.getMonth()]+v.getDate()-1|0;b()[$+28>>>2>>>0]=V,b()[$+36>>>2>>>0]=-60*v.getTimezoneOffset(),V=new Date(v.getFullYear(),6,1).getTimezoneOffset();var ie=new Date(v.getFullYear(),0,1).getTimezoneOffset();v=0|(V!=ie&&v.getTimezoneOffset()==Math.min(ie,V)),b()[$+32>>>2>>>0]=v}function bP(v){v>>>=0;var $=new Date(b()[v+20>>>2>>>0]+1900,b()[v+16>>>2>>>0],b()[v+12>>>2>>>0],b()[v+8>>>2>>>0],b()[v+4>>>2>>>0],b()[v>>>2>>>0],0),V=b()[v+32>>>2>>>0],ie=$.getTimezoneOffset(),ve=new Date($.getFullYear(),6,1).getTimezoneOffset(),vt=new Date($.getFullYear(),0,1).getTimezoneOffset(),On=Math.min(vt,ve);return 0>V?b()[v+32>>>2>>>0]=+(ve!=vt&&On==ie):0<V!=(On==ie)&&(ve=Math.max(vt,ve),$.setTime($.getTime()+6e4*((0<V?On:ve)-ie))),b()[v+24>>>2>>>0]=$.getDay(),V=(Rw($.getFullYear())?x2:v2)[$.getMonth()]+$.getDate()-1|0,b()[v+28>>>2>>>0]=V,b()[v>>>2>>>0]=$.getSeconds(),b()[v+4>>>2>>>0]=$.getMinutes(),b()[v+8>>>2>>>0]=$.getHours(),b()[v+12>>>2>>>0]=$.getDate(),b()[v+16>>>2>>>0]=$.getMonth(),b()[v+20>>>2>>>0]=$.getYear(),v=$.getTime(),BigInt(isNaN(v)?-1:v/1e3)}function T2(v,$,V,ie,ve,vt,On){return Ae?Cu(16,1,v,$,V,ie,ve,vt,On):-52}function E2(v,$,V,ie,ve,vt){if(Ae)return Cu(17,1,v,$,V,ie,ve,vt)}function yP(v,$,V,ie){v>>>=0,$>>>=0,V>>>=0,ie>>>=0;var ve=new Date().getFullYear(),vt=new Date(ve,0,1),On=new Date(ve,6,1);ve=vt.getTimezoneOffset();var Fo=On.getTimezoneOffset(),sa=Math.max(ve,Fo);E()[v>>>2>>>0]=60*sa,b()[$>>>2>>>0]=+(ve!=Fo),vt=(v=ua=>ua.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(vt),On=v(On),Fo<ve?(Lw(vt,V,17),Lw(On,ie,17)):(Lw(vt,ie,17),Lw(On,V,17))}var k1=[],M2=(v,$)=>{k1.length=0;for(var V;V=m()[v++>>>0];){var ie=V!=105;$+=(ie&=V!=112)&&$%8?4:0,k1.push(V==112?E()[$>>>2>>>0]:V==106?hd[$>>>3]:V==105?b()[$>>>2>>>0]:P()[$>>>3>>>0]),$+=ie?8:4}return k1};function wP(v,$,V){return v>>>=0,$=M2($>>>0,V>>>0),p1[v](...$)}function xP(v,$,V){return v>>>=0,$=M2($>>>0,V>>>0),p1[v](...$)}var vP=()=>{},TP=()=>Date.now();function EP(v,$){return wa($d(v>>>0,$>>>0))}var P2,MP=()=>{throw ry+=1,"unwind"};function PP(){return 4294901760}P2=()=>performance.timeOrigin+performance.now();var kP=()=>navigator.hardwareConcurrency;function OP(){return Bw("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function $P(v){v>>>=0;var $=m().length;if(v<=$||4294901760<v)return!1;for(var V=1;4>=V;V*=2){var ie=$*(1+.2/V);ie=Math.min(ie,v+100663296);var ve=Math;ie=Math.max(v,ie);e:{ve=(ve.min.call(ve,4294901760,ie+(65536-ie%65536)%65536)-Ra.buffer.byteLength+65535)/65536;try{Ra.grow(ve),Md();var vt=1;break e}catch{}vt=void 0}if(vt)return!0}return!1}var RT=()=>(Bw("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),jv={},k2=v=>{v.forEach($=>{RT()})};function AP(){var v=Error().stack.toString().split(`
`);return v[0]=="Error"&&v.shift(),k2(v),jv.Pb=RT(),jv.ec=v,jv.Pb}function SP(v,$,V){if(v>>>=0,$>>>=0,jv.Pb==v)var ie=jv.ec;else(ie=Error().stack.toString().split(`
`))[0]=="Error"&&ie.shift(),k2(ie);for(var ve=3;ie[ve]&&RT()!=v;)++ve;for(v=0;v<V&&ie[v+ve];++v)b()[$+4*v>>>2>>>0]=RT();return v}var O1,$1={},O2=()=>{if(!O1){var v,$={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:nn};for(v in $1)$1[v]===void 0?delete $[v]:$[v]=$1[v];var V=[];for(v in $)V.push(`${v}=${$[v]}`);O1=V}return O1};function $2(v,$){if(Ae)return Cu(18,1,v,$);v>>>=0,$>>>=0;var V=0;return O2().forEach((ie,ve)=>{var vt=$+V;for(ve=E()[v+4*ve>>>2>>>0]=vt,vt=0;vt<ie.length;++vt)_()[ve++>>>0]=ie.charCodeAt(vt);_()[ve>>>0]=0,V+=ie.length+1}),0}function A2(v,$){if(Ae)return Cu(19,1,v,$);v>>>=0,$>>>=0;var V=O2();E()[v>>>2>>>0]=V.length;var ie=0;return V.forEach(ve=>ie+=ve.length+1),E()[$>>>2>>>0]=ie,0}function S2(v){return Ae?Cu(20,1,v):52}function I2(v,$,V,ie){return Ae?Cu(21,1,v,$,V,ie):52}function C2(v,$,V,ie){return Ae?Cu(22,1,v,$,V,ie):70}var IP=[null,[],[]];function D2(v,$,V,ie){if(Ae)return Cu(23,1,v,$,V,ie);$>>>=0,V>>>=0,ie>>>=0;for(var ve=0,vt=0;vt<V;vt++){var On=E()[$>>>2>>>0],Fo=E()[$+4>>>2>>>0];$+=8;for(var sa=0;sa<Fo;sa++){var ua=m()[On+sa>>>0],Ta=IP[v];ua===0||ua===10?((v===1?Da:wa)(XE(Ta,0)),Ta.length=0):Ta.push(ua)}ve+=Fo}return E()[ie>>>2>>>0]=ve,0}var F2=[31,29,31,30,31,30,31,31,30,31,30,31],B2=[31,28,31,30,31,30,31,31,30,31,30,31],CP=(v,$)=>{_().set(v,$>>>0)};function L2(v,$,V,ie){function ve(Zr,Ka,Ru){for(Zr=typeof Zr=="number"?Zr.toString():Zr||"";Zr.length<Ka;)Zr=Ru[0]+Zr;return Zr}function vt(Zr,Ka){return ve(Zr,Ka,"0")}function On(Zr,Ka){function Ru(Q2){return 0>Q2?-1:0<Q2?1:0}var oy;return(oy=Ru(Zr.getFullYear()-Ka.getFullYear()))===0&&(oy=Ru(Zr.getMonth()-Ka.getMonth()))===0&&(oy=Ru(Zr.getDate()-Ka.getDate())),oy}function Fo(Zr){switch(Zr.getDay()){case 0:return new Date(Zr.getFullYear()-1,11,29);case 1:return Zr;case 2:return new Date(Zr.getFullYear(),0,3);case 3:return new Date(Zr.getFullYear(),0,2);case 4:return new Date(Zr.getFullYear(),0,1);case 5:return new Date(Zr.getFullYear()-1,11,31);case 6:return new Date(Zr.getFullYear()-1,11,30)}}function sa(Zr){var Ka=Zr.Bb;for(Zr=new Date(new Date(Zr.Cb+1900,0,1).getTime());0<Ka;){var Ru=Zr.getMonth(),oy=(Rw(Zr.getFullYear())?F2:B2)[Ru];if(!(Ka>oy-Zr.getDate())){Zr.setDate(Zr.getDate()+Ka);break}Ka-=oy-Zr.getDate()+1,Zr.setDate(1),11>Ru?Zr.setMonth(Ru+1):(Zr.setMonth(0),Zr.setFullYear(Zr.getFullYear()+1))}return Ru=new Date(Zr.getFullYear()+1,0,4),Ka=Fo(new Date(Zr.getFullYear(),0,4)),Ru=Fo(Ru),0>=On(Ka,Zr)?0>=On(Ru,Zr)?Zr.getFullYear()+1:Zr.getFullYear():Zr.getFullYear()-1}v>>>=0,$>>>=0,V>>>=0,ie>>>=0;var ua=E()[ie+40>>>2>>>0];for(var Ta in ie={kc:b()[ie>>>2>>>0],jc:b()[ie+4>>>2>>>0],Hb:b()[ie+8>>>2>>>0],Lb:b()[ie+12>>>2>>>0],Ib:b()[ie+16>>>2>>>0],Cb:b()[ie+20>>>2>>>0],ub:b()[ie+24>>>2>>>0],Bb:b()[ie+28>>>2>>>0],rc:b()[ie+32>>>2>>>0],ic:b()[ie+36>>>2>>>0],lc:ua?$d(ua):""},V=$d(V),ua={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})V=V.replace(new RegExp(Ta,"g"),ua[Ta]);var Ya="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),mu="January February March April May June July August September October November December".split(" ");for(Ta in ua={"%a":Zr=>Ya[Zr.ub].substring(0,3),"%A":Zr=>Ya[Zr.ub],"%b":Zr=>mu[Zr.Ib].substring(0,3),"%B":Zr=>mu[Zr.Ib],"%C":Zr=>vt((Zr.Cb+1900)/100|0,2),"%d":Zr=>vt(Zr.Lb,2),"%e":Zr=>ve(Zr.Lb,2," "),"%g":Zr=>sa(Zr).toString().substring(2),"%G":sa,"%H":Zr=>vt(Zr.Hb,2),"%I":Zr=>((Zr=Zr.Hb)==0?Zr=12:12<Zr&&(Zr-=12),vt(Zr,2)),"%j":Zr=>{for(var Ka=0,Ru=0;Ru<=Zr.Ib-1;Ka+=(Rw(Zr.Cb+1900)?F2:B2)[Ru++]);return vt(Zr.Lb+Ka,3)},"%m":Zr=>vt(Zr.Ib+1,2),"%M":Zr=>vt(Zr.jc,2),"%n":()=>`
`,"%p":Zr=>0<=Zr.Hb&&12>Zr.Hb?"AM":"PM","%S":Zr=>vt(Zr.kc,2),"%t":()=>"	","%u":Zr=>Zr.ub||7,"%U":Zr=>vt(Math.floor((Zr.Bb+7-Zr.ub)/7),2),"%V":Zr=>{var Ka=Math.floor((Zr.Bb+7-(Zr.ub+6)%7)/7);if(2>=(Zr.ub+371-Zr.Bb-2)%7&&Ka++,Ka)Ka==53&&((Ru=(Zr.ub+371-Zr.Bb)%7)==4||Ru==3&&Rw(Zr.Cb)||(Ka=1));else{Ka=52;var Ru=(Zr.ub+7-Zr.Bb-1)%7;(Ru==4||Ru==5&&Rw(Zr.Cb%400-1))&&Ka++}return vt(Ka,2)},"%w":Zr=>Zr.ub,"%W":Zr=>vt(Math.floor((Zr.Bb+7-(Zr.ub+6)%7)/7),2),"%y":Zr=>(Zr.Cb+1900).toString().substring(2),"%Y":Zr=>Zr.Cb+1900,"%z":Zr=>{var Ka=0<=(Zr=Zr.ic);return Zr=Math.abs(Zr)/60,(Ka?"+":"-")+("0000"+(Zr/60*100+Zr%60)).slice(-4)},"%Z":Zr=>Zr.lc,"%%":()=>"%"},V=V.replace(/%%/g,"\0\0"),ua)V.includes(Ta)&&(V=V.replace(new RegExp(Ta,"g"),ua[Ta](ie)));return Ta=function(Zr){var Ka=Array(g1(Zr)+1);return ZE(Zr,Ka,0,Ka.length),Ka}(V=V.replace(/\0\0/g,"%")),Ta.length>$?0:(CP(Ta,v),Ta.length-1)}function DP(v,$,V,ie){return L2(v>>>0,$>>>0,V>>>0,ie>>>0)}Ae||function(){for(var v=T.numThreads-1;v--;)GE();ty.unshift(()=>{__++,function($){Ae?$():Promise.all(lh.map(VE)).then($)}(()=>ST())})}();for(var R2=Array(256),jT=0;256>jT;++jT)R2[jT]=String.fromCharCode(jT);d2=R2,uh=T.BindingError=class extends Error{constructor(v){super(v),this.name="BindingError"}},T.InternalError=class extends Error{constructor(v){super(v),this.name="InternalError"}},N_.push(0,1,void 0,1,null,1,!0,1,!1,1),T.count_emval_handles=()=>N_.length/2-5-w1.length;var FP=[f1,zE,KE,YE,QE,JE,e2,t2,r2,n2,o2,s2,i2,a2,l2,u2,T2,E2,$2,A2,S2,I2,C2,D2],xa=function(){function v(V,ie){return xa=V.exports,xa=function(){var ve=xa,vt={};for(let[On,Fo]of Object.entries(ve))vt[On]=typeof Fo=="function"?(...sa)=>{FT.push(On);try{return Fo(...sa)}finally{Nd||(FT.pop(),L_&&ch===1&&FT.length===0&&(ch=0,ry+=1,DT(q2),typeof Fibers<"u"&&Fibers.sc()))}}:Fo;return vt}(),xa=function(){var ve=xa,vt=Fo=>sa=>Fo(sa)>>>0,On=Fo=>()=>Fo()>>>0;return(ve=Object.assign({},ve)).Ca=vt(ve.Ca),ve.fb=On(ve.fb),ve.gb=vt(ve.gb),ve.emscripten_main_runtime_thread_id=On(ve.emscripten_main_runtime_thread_id),ve.sb=vt(ve.sb),ve.tb=On(ve.tb),ve}(),NE.push(xa.ib),wd.unshift(xa.Ba),fu=ie,ST(),xa}var $=RE();if(__++,T.instantiateWasm)try{return T.instantiateWasm($,v)}catch(V){wa(`Module.instantiateWasm callback failed with error: ${V}`),N(V)}return c1||(c1=T.locateFile?DE("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":T.locateFile?T.locateFile("ort-wasm-simd-threaded.jsep.wasm",Do):Do+"ort-wasm-simd-threaded.jsep.wasm":new URL(i("./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"),i.b).href),function(V,ie){var ve=c1;return aa||typeof WebAssembly.instantiateStreaming!="function"||DE(ve)||FE(ve)||typeof fetch!="function"?LE(ve,V,ie):fetch(ve,{credentials:"same-origin"}).then(vt=>WebAssembly.instantiateStreaming(vt,V).then(ie,function(On){return wa(`wasm streaming compile failed: ${On}`),wa("falling back to ArrayBuffer instantiation"),LE(ve,V,ie)}))}($,function(V){v(V.instance,V.module)}).catch(N),{}}(),j2=v=>(j2=xa.Ca)(v),z2=()=>(z2=xa.Da)();T._OrtInit=(v,$)=>(T._OrtInit=xa.Ea)(v,$),T._OrtGetLastError=(v,$)=>(T._OrtGetLastError=xa.Fa)(v,$),T._OrtCreateSessionOptions=(v,$,V,ie,ve,vt,On,Fo,sa,ua)=>(T._OrtCreateSessionOptions=xa.Ga)(v,$,V,ie,ve,vt,On,Fo,sa,ua),T._OrtAppendExecutionProvider=(v,$)=>(T._OrtAppendExecutionProvider=xa.Ha)(v,$),T._OrtAddFreeDimensionOverride=(v,$,V)=>(T._OrtAddFreeDimensionOverride=xa.Ia)(v,$,V),T._OrtAddSessionConfigEntry=(v,$,V)=>(T._OrtAddSessionConfigEntry=xa.Ja)(v,$,V),T._OrtReleaseSessionOptions=v=>(T._OrtReleaseSessionOptions=xa.Ka)(v),T._OrtCreateSession=(v,$,V)=>(T._OrtCreateSession=xa.La)(v,$,V),T._OrtReleaseSession=v=>(T._OrtReleaseSession=xa.Ma)(v),T._OrtGetInputOutputCount=(v,$,V)=>(T._OrtGetInputOutputCount=xa.Na)(v,$,V),T._OrtGetInputName=(v,$)=>(T._OrtGetInputName=xa.Oa)(v,$),T._OrtGetOutputName=(v,$)=>(T._OrtGetOutputName=xa.Pa)(v,$),T._OrtFree=v=>(T._OrtFree=xa.Qa)(v),T._OrtCreateTensor=(v,$,V,ie,ve,vt)=>(T._OrtCreateTensor=xa.Ra)(v,$,V,ie,ve,vt),T._OrtGetTensorData=(v,$,V,ie,ve)=>(T._OrtGetTensorData=xa.Sa)(v,$,V,ie,ve),T._OrtReleaseTensor=v=>(T._OrtReleaseTensor=xa.Ta)(v),T._OrtCreateRunOptions=(v,$,V,ie)=>(T._OrtCreateRunOptions=xa.Ua)(v,$,V,ie),T._OrtAddRunConfigEntry=(v,$,V)=>(T._OrtAddRunConfigEntry=xa.Va)(v,$,V),T._OrtReleaseRunOptions=v=>(T._OrtReleaseRunOptions=xa.Wa)(v),T._OrtCreateBinding=v=>(T._OrtCreateBinding=xa.Xa)(v),T._OrtBindInput=(v,$,V)=>(T._OrtBindInput=xa.Ya)(v,$,V),T._OrtBindOutput=(v,$,V,ie)=>(T._OrtBindOutput=xa.Za)(v,$,V,ie),T._OrtClearBoundOutputs=v=>(T._OrtClearBoundOutputs=xa._a)(v),T._OrtReleaseBinding=v=>(T._OrtReleaseBinding=xa.$a)(v),T._OrtRunWithBinding=(v,$,V,ie,ve)=>(T._OrtRunWithBinding=xa.ab)(v,$,V,ie,ve),T._OrtRun=(v,$,V,ie,ve,vt,On,Fo)=>(T._OrtRun=xa.bb)(v,$,V,ie,ve,vt,On,Fo),T._OrtEndProfiling=v=>(T._OrtEndProfiling=xa.cb)(v),T._JsepOutput=(v,$,V)=>(T._JsepOutput=xa.db)(v,$,V),T._JsepGetNodeName=v=>(T._JsepGetNodeName=xa.eb)(v);var zT,jw=()=>(jw=xa.fb)(),NT=T._malloc=v=>(NT=T._malloc=xa.gb)(v),R_=T._free=v=>(R_=T._free=xa.hb)(v),A1=(v,$,V,ie,ve,vt)=>(A1=xa.kb)(v,$,V,ie,ve,vt),N2=()=>(N2=xa.lb)(),U2=(v,$,V,ie,ve)=>(U2=xa.mb)(v,$,V,ie,ve),S1=v=>(S1=xa.nb)(v),UT=v=>(UT=xa.ob)(v),W2=()=>(W2=xa.pb)(),V2=(v,$)=>(V2=xa.qb)(v,$),WT=v=>(WT=xa.rb)(v),I1=v=>(I1=xa.sb)(v),C1=()=>(C1=xa.tb)(),G2=T.dynCall_ii=(v,$)=>(G2=T.dynCall_ii=xa.vb)(v,$),K2=v=>(K2=xa.wb)(v),q2=()=>(q2=xa.xb)(),H2=v=>(H2=xa.yb)(v),X2=()=>(X2=xa.zb)();function Y2(){0<__||(Ae?(U(T),Ae||IT(wd),startWorker(T)):(IT(ty),0<__||zT||(zT=!0,T.calledRun=!0,Nd||(Ae||IT(wd),U(T),Ae||IT(Sd)))))}return T.___start_em_js=881730,T.___stop_em_js=881952,T.stackSave=()=>C1(),T.stackRestore=v=>WT(v),T.stackAlloc=v=>I1(v),T.UTF8ToString=$d,T.stringToUTF8=Lw,T.lengthBytesUTF8=g1,ah=function v(){zT||Y2(),zT||(ah=v)},Y2(),ae}),Oo=Lr,((o=globalThis.self)==null?void 0:o.name)==="em-pthread"&&Lr()}),Po,Ko,jo,ri,Yo,la,da,na,ha=p(()=>{var o,d;Sa(),Po=import.meta.url??(typeof document<"u"?(o=document.currentScript)==null?void 0:o.src:typeof self<"u"?(d=self.location)==null?void 0:d.href:void 0),Ko=typeof location>"u"?void 0:location.origin,jo=(_,m)=>{try{let g=m??Po;return(g?new URL(_,g):new URL(_)).origin===Ko}catch{return!1}},ri=async _=>{let m=await(await fetch(_,{credentials:"same-origin"})).blob();return URL.createObjectURL(m)},Yo=(So(),l(Na)).default,la=async()=>{if(!Po)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(jo(Po))return[void 0,Yo()];let _=await ri(Po);return[_,Yo(_)]},da=(tr(),l(Ie)).default,na=async(_,m,g)=>[void 0,da]}),Wt,$o,Io,ma,Ba,eu,wu,Oa,bu=p(()=>{ha(),$o=!1,Io=!1,ma=!1,Ba=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},eu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},wu=async o=>{if($o)return Promise.resolve();if(Io)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ma)throw new Error("previous call to 'initializeWebAssembly()' failed.");Io=!0;let d=o.initTimeout,_=o.numThreads;if(!eu())throw new Error("WebAssembly SIMD is not supported in the current environment.");let m=Ba();_>1&&!m&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+_+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),o.numThreads=_=1);let g=o.wasmPaths,y=typeof g=="string"?g:void 0,b=g==null?void 0:g.mjs,E=(b==null?void 0:b.href)??b,M=g==null?void 0:g.wasm,P=(M==null?void 0:M.href)??M,U=o.wasmBinary,[N,T]=await na(E,y,_>1),ae=!1,ue=[];if(d>0&&ue.push(new Promise(fe=>{setTimeout(()=>{ae=!0,fe()},d)})),ue.push(new Promise((fe,Ae)=>{let Le={numThreads:_};U?Le.wasmBinary=U:(P||y)&&(Le.locateFile=(Oe,pt)=>P??(y??pt)+Oe),T(Le).then(Oe=>{Io=!1,$o=!0,Wt=Oe,fe(),N&&URL.revokeObjectURL(N)},Oe=>{Io=!1,ma=!0,Ae(Oe)})})),await Promise.race(ue),ae)throw new Error(`WebAssembly backend initializing failed due to timeout: ${d}ms`)},Oa=()=>{if($o&&Wt)return Wt;throw new Error("WebAssembly is not initialized yet.")}}),tu,Bd,_u,m_=p(()=>{bu(),tu=(o,d)=>{let _=Oa(),m=_.lengthBytesUTF8(o)+1,g=_._malloc(m);return _.stringToUTF8(o,g,m),d.push(g),g},Bd=(o,d,_,m)=>{if(typeof o=="object"&&o!==null){if(_.has(o))throw new Error("Circular reference in options");_.add(o)}Object.entries(o).forEach(([g,y])=>{let b=d?d+g:g;if(typeof y=="object")Bd(y,b+".",_,m);else if(typeof y=="string"||typeof y=="number")m(b,y.toString());else if(typeof y=="boolean")m(b,y?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof y}`)})},_u=o=>{let d=Oa(),_=d.stackSave();try{let m=d.stackAlloc(8);d._OrtGetLastError(m,m+4);let g=d.HEAP32[m/4],y=d.HEAPU32[m/4+1],b=y?d.UTF8ToString(y):"";throw new Error(`${o} ERROR_CODE: ${g}, ERROR_MESSAGE: ${b}`)}finally{d.stackRestore(_)}}}),o_,Id=p(()=>{bu(),m_(),o_=o=>{let d=Oa(),_=0,m=[],g=o||{};try{if((o==null?void 0:o.logSeverityLevel)===void 0)g.logSeverityLevel=2;else if(typeof o.logSeverityLevel!="number"||!Number.isInteger(o.logSeverityLevel)||o.logSeverityLevel<0||o.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${o.logSeverityLevel}`);if((o==null?void 0:o.logVerbosityLevel)===void 0)g.logVerbosityLevel=0;else if(typeof o.logVerbosityLevel!="number"||!Number.isInteger(o.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${o.logVerbosityLevel}`);(o==null?void 0:o.terminate)===void 0&&(g.terminate=!1);let y=0;return(o==null?void 0:o.tag)!==void 0&&(y=tu(o.tag,m)),_=d._OrtCreateRunOptions(g.logSeverityLevel,g.logVerbosityLevel,!!g.terminate,y),_===0&&_u("Can't create run options."),(o==null?void 0:o.extra)!==void 0&&Bd(o.extra,"",new WeakSet,(b,E)=>{let M=tu(b,m),P=tu(E,m);d._OrtAddRunConfigEntry(_,M,P)!==0&&_u(`Can't set a run config entry: ${b} - ${E}.`)}),[_,m]}catch(y){throw _!==0&&d._OrtReleaseRunOptions(_),m.forEach(b=>d._free(b)),y}}}),M_,s_,P_,k_,O_,i_=p(()=>{bu(),m_(),M_=o=>{switch(o){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${o}`)}},s_=o=>{switch(o){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${o}`)}},P_=o=>{o.extra||(o.extra={}),o.extra.session||(o.extra.session={});let d=o.extra.session;d.use_ort_model_bytes_directly||(d.use_ort_model_bytes_directly="1"),o.executionProviders&&o.executionProviders.some(_=>(typeof _=="string"?_:_.name)==="webgpu")&&(o.enableMemPattern=!1)},k_=(o,d,_)=>{for(let m of d){let g=typeof m=="string"?m:m.name;switch(g){case"webnn":if(g="WEBNN",typeof m!="string"){let b=m==null?void 0:m.deviceType;if(b){let E=tu("deviceType",_),M=tu(b,_);Oa()._OrtAddSessionConfigEntry(o,E,M)!==0&&_u(`Can't set a session config entry: 'deviceType' - ${b}.`)}}break;case"webgpu":if(g="JS",typeof m!="string"){let b=m;if(b!=null&&b.preferredLayout){if(b.preferredLayout!=="NCHW"&&b.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${b.preferredLayout}`);let E=tu("preferredLayout",_),M=tu(b.preferredLayout,_);Oa()._OrtAddSessionConfigEntry(o,E,M)!==0&&_u(`Can't set a session config entry: 'preferredLayout' - ${b.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${g}`)}let y=tu(g,_);Oa()._OrtAppendExecutionProvider(o,y)!==0&&_u(`Can't append execution provider: ${g}.`)}},O_=o=>{let d=Oa(),_=0,m=[],g=o||{};P_(g);try{let y=M_(g.graphOptimizationLevel??"all"),b=s_(g.executionMode??"sequential"),E=typeof g.logId=="string"?tu(g.logId,m):0,M=g.logSeverityLevel??2;if(!Number.isInteger(M)||M<0||M>4)throw new Error(`log serverity level is not valid: ${M}`);let P=g.logVerbosityLevel??0;if(!Number.isInteger(P)||P<0||P>4)throw new Error(`log verbosity level is not valid: ${P}`);let U=typeof g.optimizedModelFilePath=="string"?tu(g.optimizedModelFilePath,m):0;if(_=d._OrtCreateSessionOptions(y,!!g.enableCpuMemArena,!!g.enableMemPattern,b,!!g.enableProfiling,0,E,M,P,U),_===0&&_u("Can't create session options."),g.executionProviders&&k_(_,g.executionProviders,m),g.enableGraphCapture!==void 0){if(typeof g.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${g.enableGraphCapture}`);let N=tu("enableGraphCapture",m),T=tu(g.enableGraphCapture.toString(),m);d._OrtAddSessionConfigEntry(_,N,T)!==0&&_u(`Can't set a session config entry: 'enableGraphCapture' - ${g.enableGraphCapture}.`)}if(g.freeDimensionOverrides)for(let[N,T]of Object.entries(g.freeDimensionOverrides)){if(typeof N!="string")throw new Error(`free dimension override name must be a string: ${N}`);if(typeof T!="number"||!Number.isInteger(T)||T<0)throw new Error(`free dimension override value must be a non-negative integer: ${T}`);let ae=tu(N,m);d._OrtAddFreeDimensionOverride(_,ae,T)!==0&&_u(`Can't set a free dimension override: ${N} - ${T}.`)}return g.extra!==void 0&&Bd(g.extra,"",new WeakSet,(N,T)=>{let ae=tu(N,m),ue=tu(T,m);d._OrtAddSessionConfigEntry(_,ae,ue)!==0&&_u(`Can't set a session config entry: ${N} - ${T}.`)}),[_,m]}catch(y){throw _!==0&&d._OrtReleaseSessionOptions(_),m.forEach(b=>d._free(b)),y}}}),Pd,Ad,Ld,g_,Rd,a_,l_,b_,ya=p(()=>{Pd=o=>{switch(o){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${o}`)}},Ad=o=>{switch(o){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${o}`)}},Ld=(o,d)=>{let _=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][o],m=typeof d=="number"?d:d.reduce((g,y)=>g*y,1);return _>0?Math.ceil(m*_):void 0},g_=o=>{switch(o){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${o}`)}},Rd=o=>{switch(o){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${o}`)}},a_=o=>o==="float32"||o==="float16"||o==="int32"||o==="int64"||o==="uint32"||o==="uint8"||o==="bool"||o==="uint4"||o==="int4",l_=o=>o==="float32"||o==="float16"||o==="int32"||o==="int64"||o==="uint32"||o==="uint64"||o==="int8"||o==="uint8"||o==="bool",b_=o=>{switch(o){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${o}`)}}}),u_,$_=p(()=>{Sa(),u_=async o=>{if(typeof o=="string"){let d=await fetch(o);if(!d.ok)throw new Error(`failed to load external data file: ${o}`);let _=d.headers.get("Content-Length"),m=_?parseInt(_,10):0;if(m<1073741824)return new Uint8Array(await d.arrayBuffer());{if(!d.body)throw new Error(`failed to load external data file: ${o}, no response body.`);let g=d.body.getReader(),y;try{y=new ArrayBuffer(m)}catch(E){if(E instanceof RangeError){let M=Math.ceil(m/65536);y=new WebAssembly.Memory({initial:M,maximum:M}).buffer}else throw E}let b=0;for(;;){let{done:E,value:M}=await g.read();if(E)break;let P=M.byteLength;new Uint8Array(y,b,P).set(M),b+=P}return new Uint8Array(y,0,m)}}else return o instanceof Blob?new Uint8Array(await o.arrayBuffer()):o instanceof Uint8Array?o:new Uint8Array(o)}}),A_,y_,w_,S_,d_,I_,Pt,L=p(()=>{ya(),A_=["V","I","W","E","F"],y_=(o,d)=>{console.log(`[${A_[o]},${new Date().toISOString()}]${d}`)},d_=(o,d)=>{w_=o,S_=d},I_=(o,d)=>{let _=Rd(o),m=Rd(w_);_>=m&&y_(_,typeof d=="function"?d():d)},Pt=(...o)=>{S_&&I_(...o)}}),we,st=p(()=>{ya(),we=(o,d)=>new(g_(d))(o)}),Mt=p(()=>{}),Lt,tn,Zo,Js,Xs,oa,va,Wa,$a,hu=p(()=>{L(),Mt(),Lt=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),tn=[],Zo=o=>Math.ceil(o/16)*16,Js=o=>{for(let d=0;d<tn.length;d++){let _=tn[d];if(o<=_)return _}return Math.ceil(o/16)*16},Xs=1,oa=()=>Xs++,va=async(o,d,_,m)=>{let g=Zo(_),y=o.device.createBuffer({size:g,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let b=o.getCommandEncoder();o.endComputePass(),b.copyBufferToBuffer(d,0,y,0,g),o.flush(),await y.mapAsync(GPUMapMode.READ);let E=y.getMappedRange();if(m){let M=m();return M.set(new Uint8Array(E,0,_)),M}else return new Uint8Array(E.slice(0,_))}finally{y.destroy()}},Wa=class{constructor(o){this.backend=o,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[d]of Lt)tn.push(d),this.freeBuffers.set(d,[]),this.freeUniformBuffers.set(d,[])}upload(o,d){let _=d.buffer,m=d.byteOffset,g=d.byteLength,y=Zo(g),b=this.storageCache.get(o);if(!b)throw new Error("gpu data for uploading does not exist");if(b.originalSize!==g)throw new Error(`inconsistent data size. gpu data size=${b.originalSize}, data size=${g}`);let E=this.backend.device.createBuffer({mappedAtCreation:!0,size:y,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),M=E.getMappedRange();new Uint8Array(M).set(new Uint8Array(_,m,g)),E.unmap();let P=this.backend.getCommandEncoder();this.backend.endComputePass(),P.copyBufferToBuffer(E,0,b.gpuData.buffer,0,y),Pt("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${o})`),this.buffersForUploadingPending.push(E)}memcpy(o,d){let _=this.storageCache.get(o);if(!_)throw new Error("source gpu data for memcpy does not exist");let m=this.storageCache.get(d);if(!m)throw new Error("destination gpu data for memcpy does not exist");if(_.originalSize!==m.originalSize)throw new Error("inconsistent source and destination gpu data size");let g=Zo(_.originalSize),y=this.backend.getCommandEncoder();this.backend.endComputePass(),y.copyBufferToBuffer(_.gpuData.buffer,0,m.gpuData.buffer,0,g)}registerExternalBuffer(o,d,_){let m;if(_){if(m=_[0],o===_[1])return Pt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${d}) => id=${m}, buffer is the same, skip.`),m;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else m=oa();return this.storageCache.set(m,{gpuData:{id:m,type:0,buffer:o},originalSize:d}),Pt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${d}) => id=${m}, registered.`),m}unregisterExternalBuffer(o){o!==void 0&&(this.storageCache.delete(o),Pt("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${o}`))}create(o,d=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let _=Js(o),m,g=(d&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,y=(d&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(g||y){let E=(g?this.freeBuffers:this.freeUniformBuffers).get(_);E?E.length>0?m=E.pop():m=this.backend.device.createBuffer({size:_,usage:d}):m=this.backend.device.createBuffer({size:_,usage:d})}else m=this.backend.device.createBuffer({size:_,usage:d});let b={id:oa(),type:0,buffer:m};return this.storageCache.set(b.id,{gpuData:b,originalSize:o}),Pt("verbose",()=>`[WebGPU] GpuDataManager.create(size=${o}) => id=${b.id}`),b}get(o){var d;return(d=this.storageCache.get(o))==null?void 0:d.gpuData}release(o){let d=this.storageCache.get(o);if(!d)throw new Error("releasing data does not exist");return Pt("verbose",()=>`[WebGPU] GpuDataManager.release(id=${o}), gpuDataId=${d.gpuData.id}`),this.storageCache.delete(o),this.buffersPending.push(d.gpuData.buffer),d.originalSize}async download(o,d){let _=this.storageCache.get(o);if(!_)throw new Error("data does not exist");await va(this.backend,_.gpuData.buffer,_.originalSize,d)}refreshPendingBuffers(){for(let o of this.buffersForUploadingPending)o.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let o of this.buffersPending){let d=Lt.get(o.size);if((o.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let _=this.freeBuffers.get(o.size)||[];d===void 0||_.length>=d?o.destroy():_.push(o)}else if((o.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let _=this.freeUniformBuffers.get(o.size)||[];d===void 0||_.length>=d?o.destroy():_.push(o)}else o.destroy()}this.buffersPending=[]}else{let o=this.capturedPendingBuffers.get(this.backend.currentSessionId);o||(o=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,o));for(let d of this.buffersPending)o.push(d);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(o=>{o.forEach(d=>{d.destroy()})}),this.freeUniformBuffers.forEach(o=>{o.forEach(d=>{d.destroy()})}),this.storageCache.forEach(o=>{o.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(o=>{o.forEach(d=>{d.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(o){let d=this.capturedPendingBuffers.get(o);d&&(d.forEach(_=>{_.destroy()}),this.capturedPendingBuffers.delete(o))}},$a=(...o)=>new Wa(...o)}),Au,ka,Va=p(()=>{Au=class{constructor(o){Object.assign(this,o)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(o=>`${this[o]}`).join(";")),this.key}},ka=o=>new Au(o)}),Gu,xd,wr,Su,zu,ba,vd,fa=p(()=>{Gu=class{static calcMatMulShape(o,d){return o[1]!==d[0]?void 0:[o[0],d[1]]}},xd=class{static calcShape(o,d,_=!1){let m=o.length,g=d.length;if(m===0)return d;if(g===0)return o;let y=Math.max(o.length,d.length),b=new Array(y);if(_){if(m<2||g<2)return;let E=Gu.calcMatMulShape([o[m-2],o[m-1]],[d[g-2],d[g-1]]);if(E===void 0)return;[b[y-2],b[y-1]]=E}for(let E=_?3:1;E<=y;E++){let M=m-E<0?1:o[m-E],P=g-E<0?1:d[g-E];if(M!==P&&M>1&&P>1)return;let U=Math.max(M,P);if(M&&P)b[y-E]=Math.max(M,P);else{if(U>1)return;b[y-E]=0}}return b}static isValidBroadcast(o,d){let _=o.length,m=d.length;if(_>m)return!1;for(let g=1;g<=_;g++)if(o[_-g]!==1&&o[_-g]!==d[m-g])return!1;return!0}},wr=class GT{static size(d){return GT.getSizeFromDimensionRange(d,0,d.length)}static convertShape(d,_=4){let m=d.length;if(m===0)return[];let g=new Array(m),y=m-1;for(;y>=0;){if(d[y]%_===0){g[y]=d[y]/_;break}if(_%d[y]!==0)throw new Error("cannot convert shape");g[y]=1,_/=d[y],y--}for(y--;y>=0;y--)g[y]=d[y];return g}static sizeFromDimension(d,_){if(_<0||_>d.length)throw new Error(`invalid dimension of ${_} for sizeFromDimension as Tensor has ${d.length} dimensions.`);return GT.getSizeFromDimensionRange(d,_,d.length)}static sizeToDimension(d,_){if(_<0||_>d.length)throw new Error(`invalid dimension of ${_} for sizeToDimension as Tensor has ${d.length} dimensions.`);return GT.getSizeFromDimensionRange(d,0,_)}static getSizeFromDimensionRange(d,_,m){let g=1;for(let y=_;y<m;y++){if(d[y]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");g*=d[y]}return g}static computeStrides(d){let _=d.length;if(_===0)return[];if(_===1)return[1];let m=new Array(_);m[_-1]=1,m[_-2]=d[_-1];for(let g=_-3;g>=0;--g)m[g]=m[g+1]*d[g+1];return m}static normalizeAxis(d,_){if(d<-_&&d>=_)throw new Error("unsupported axis for this operation.");return d<0?d+_:d}static normalizeAxes(d,_){return d.map(m=>this.normalizeAxis(m,_??d.length))}static sortBasedOnPerm(d,_){return _?_.map(m=>d[m]):d.slice().reverse()}static padShape(d,_){let m=d.length;return d.map((g,y)=>g+_[y]+_[y+m])}static areEqual(d,_){return d.length!==_.length?!1:d.every((m,g)=>m===_[g])}},Su=class Vv{static adjustPoolAttributes(d,_,m,g,y,b){if(!d&&m.length!==_.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(d)for(let E=0;E<_.length-2;E++)E>=m.length?m.push(_[E+2]):m[E]=_[E+2];for(let E=0;E<m.length;E++)if(E<g.length){if(g[E]<0)throw new Error("strides should be greater than or equal to 1")}else g.push(1);for(let E=0;E<m.length;E++)if(E<y.length){if(y[E]<0)throw new Error("dilations should be greater than or equal to 1")}else y.push(1);for(let E=0;E<m.length*2;E++)if(E<b.length){if(b[E]<0)throw new Error("pad should be greater than or equal to 1")}else b.push(0);for(let E=0;E<m.length;E++){if(m[E]<=0)throw new Error("kernel shapes need to be greater than 0");if(b[E]>=m[E]||b[E+m.length]>=m[E])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(d,_,m,g,y,b,E){if(E){if(y.length!==2*(d.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(_.length!==d.length-2)throw new Error("length of strides should be the length of data dimensions");if(g.length!==d.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let M=0;M<d.length-2;M++)Vv.adjustPadAndReturnShape(d[M+(b?1:2)],_[M],m[M],g[M],y,M,M+d.length-2,E)}}static computePoolOutputShape(d,_,m,g,y,b,E){if(_.length<=0)throw new Error("input shape must be of size greater than 0");let M=[_[0],_[1]];return Vv.computeShapeHelper(d,_,M,m,g,y,b,E),M}static computeConvOutputShape(d,_,m,g,y,b,E){if(d.length<=0||_.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let M=[d[0],_[0]];return Vv.computeShapeHelper(!1,d,M,m,g,y,b,E),M}static computeShapeHelper(d,_,m,g,y,b,E,M){if(d)for(let P=0;P<_.length-2;P++)m.push(1);else for(let P=0;P<_.length-2;P++)m.push(Vv.adjustPadAndReturnShape(_[P+2],g[P],y[P],b[P],E,P,P+_.length-2,M))}static adjustPadAndReturnShape(d,_,m,g,y,b,E,M){let P=m*(g-1)+1;if(M&&M!=="NOTSET")switch(M){case"VALID":return y[b]=0,y[E]=0,Math.floor((d-P)/_+1);case"SAME_LOWER":case"SAME_UPPER":if(m!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let U=((d+_-1)/_-1)*_+g-d;return y[b]=Math.floor(M==="SAME_LOWER"?(U+1)/2:U/2),y[E]=U-y[b],Math.floor((d+U-g)/_+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((d+y[b]+y[E]-P)/_+1)}},zu=class{static getShapeOfGemmResult(o,d,_,m,g){if(o.length!==2||_.length!==2)throw new Error("shape need to be of size 2");let y,b,E;d?(y=o[1],b=o[0]):(y=o[0],b=o[1]);let M=-1;if(m?(E=_[0],M=1):(E=_[1],M=0),_[M]!==b)throw new Error("dimension mismatch");if(y<=0||E<=0||b<=0)throw new Error("invalid shape specified");if(g&&!xd.isValidBroadcast(g,[y,E]))throw new Error("gemm: invalid bias shape for broadcast");return[y,E,b]}},ba=-34028234663852886e22,vd=34028234663852886e22}),Du,xu,Fa,Ga,qs,La,t_,Cd,Dd,ca,C_,S,be,wt,Jt,Ir,Lo,Xo=p(()=>{ya(),fa(),Du=64,xu=(o,d)=>{if(d===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(o){case 10:return d>1?`vec${d}<f16>`:"f16";case 1:return d>1?`vec${d}<f32>`:"f32";case 6:return d>1?`vec${d}<i32>`:"i32";case 12:return d>1?`vec${d}<u32>`:"u32";case 7:if(d>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(d>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(d!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${o}`)}},Fa=(o,d=1)=>{let _=xu(o,d);return typeof _=="string"?_:_[0]},Ga=(o,d=1)=>{let _=xu(o,d);return typeof _=="string"?_:_[1]},qs=(...o)=>{let d=[];return o.forEach(_=>{_.length!==0&&d.push({type:12,data:_},{type:12,data:wr.computeStrides(_)})}),d},La=o=>o%4===0?4:o%2===0?2:1,t_=(o="f32",d,_="0")=>!d||d===1?`${o}(${_})`:`vec${d}<${o}>(${_})`,Cd=(o,d,_)=>o==="f32"?_:d===1?`f32(${_})`:`vec${d}<f32>(${_})`,Dd=(o,d)=>d===4?`(${o}.x + ${o}.y + ${o}.z + ${o}.w)`:d===2?`(${o}.x + ${o}.y)`:d===3?`(${o}.x + ${o}.y + ${o}.z)`:o,ca=(o,d,_,m)=>o.startsWith("uniforms.")&&_>4?typeof d=="string"?m==="f16"?`${o}[(${d}) / 8][(${d}) % 8 / 4][(${d}) % 8 % 4]`:`${o}[(${d}) / 4][(${d}) % 4]`:m==="f16"?`${o}[${Math.floor(d/8)}][${Math.floor(d%8/4)}][${d%8%4}]`:`${o}[${Math.floor(d/4)}][${d%4}]`:_>1?`${o}[${d}]`:o,C_=(o,d,_,m,g)=>{let y=typeof _=="number",b=y?_:_.length,E=[...new Array(b).keys()],M=b<2?"u32":b<=4?`vec${b}<u32>`:`array<u32, ${b}>`,P=xu(d,g),U=typeof P=="string"?P:P[1],N=typeof P=="string"?P:P[0],T={indices:M,value:U,storage:N,tensor:d},ae=on=>typeof on=="string"?on:`${on}u`,ue={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},fe=y?"uniforms.":"",Ae=`${fe}${o}_shape`,Le=`${fe}${o}_strides`,Oe="";for(let on=0;on<b-1;on++)Oe+=`
    let dim${on} = current / ${ca(Le,on,b)};
    let rest${on} = current % ${ca(Le,on,b)};
    indices[${on}] = dim${on};
    current = rest${on};
    `;Oe+=`indices[${b-1}] = current;`;let pt=b<2?"":`
  fn o2i_${o}(offset: u32) -> ${T.indices} {
    var indices: ${T.indices};
    var current = offset;
    ${Oe}
    return indices;
  }`,lt=on=>(ue.offsetToIndices=!0,b<2?on:`o2i_${o}(${on})`),ft=[];if(b>=2)for(let on=b-1;on>=0;on--)ft.push(`${ca(Le,on,b)} * (indices[${on}])`);let nn=b<2?"":`
  fn i2o_${o}(indices: ${T.indices}) -> u32 {
    return ${ft.join("+")};
  }`,Er=on=>(ue.indicesToOffset=!0,b<2?on:`i2o_${o}(${on})`),Do=(...on)=>b===0?"0u":`${T.indices}(${on.map(ae).join(",")})`,aa=(on,Zs)=>b<2?`${on}`:`${ca(on,Zs,b)}`,pa=(on,Zs,Ma)=>b<2?`${on}=${Ma};`:`${ca(on,Zs,b)}=${Ma};`,Ia={},Da=(on,Zs)=>{ue.broadcastedIndicesToOffset=!0;let Ma=`${Zs.name}broadcastedIndicesTo${o}Offset`;if(Ma in Ia)return`${Ma}(${on})`;let pu=[];for(let Uu=b-1;Uu>=0;Uu--){let hd=Zs.indicesGet("outputIndices",Uu+Zs.rank-b);pu.push(`${aa(Le,Uu)} * (${hd} % ${aa(Ae,Uu)})`)}return Ia[Ma]=`fn ${Ma}(outputIndices: ${Zs.type.indices}) -> u32 {
             return ${pu.length>0?pu.join("+"):"0u"};
           }`,`${Ma}(${on})`},wa=(on,Zs)=>(()=>{if(T.storage===T.value)return`${o}[${on}]=${Zs};`;if(T.storage==="vec2<u32>"&&T.value==="i32")return`${o}[${on}]=vec2<u32>(u32(${Zs}), select(0u, 0xFFFFFFFFu, ${Zs} < 0));`;if(T.storage==="vec2<u32>"&&T.value==="u32")return`${o}[${on}]=vec2<u32>(u32(${Zs}), 0u);`;if(T.storage==="u32"&&T.value==="vec4<bool>")return`${o}[${on}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Zs}));`;throw new Error(`not supported combination of storage type ${T.storage} and value type ${T.value} yet`)})(),uu=on=>(()=>{if(T.storage===T.value)return`${o}[${on}]`;if(T.storage==="vec2<u32>"&&T.value==="i32")return`i32(${o}[${on}].x)`;if(T.storage==="vec2<u32>"&&T.value==="u32")return`u32(${o}[${on}].x)`;if(T.storage==="u32"&&T.value==="vec4<bool>")return`vec4<bool>(bool(${o}[${on}] & 0xFFu), bool(${o}[${on}] & 0xFF00u), bool(${o}[${on}] & 0xFF0000u), bool(${o}[${on}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${T.storage} and value type ${T.value} yet`)})(),yu=b<2?"":`
  fn get_${o}ByIndices(indices: ${T.indices}) -> ${U} {
    return ${uu(`i2o_${o}(indices)`)};
  }`,Ra=b<2?"":(()=>{let on=E.map(Ma=>`d${Ma}: u32`).join(", "),Zs=E.map(Ma=>`d${Ma}`).join(", ");return`
  fn get_${o}(${on}) -> ${U} {
    return get_${o}ByIndices(${Do(Zs)});
  }`})(),fu=(...on)=>{if(on.length!==b)throw new Error(`indices length must be ${b}`);let Zs=on.map(ae).join(",");return b===0?uu("0u"):b===1?uu(Zs[0]):(ue.get=!0,ue.getByIndices=!0,ue.indicesToOffset=!0,`get_${o}(${Zs})`)},ga=on=>b<2?uu(on):(ue.getByIndices=!0,ue.indicesToOffset=!0,`get_${o}ByIndices(${on})`),Ea=b<2?"":`
  fn set_${o}ByIndices(indices: ${T.indices}, value: ${U}) {
    ${wa(`i2o_${o}(indices)`,"value")}
  }`,Xa=b<2?"":(()=>{let on=E.map(Ma=>`d${Ma}: u32`).join(", "),Zs=E.map(Ma=>`d${Ma}`).join(", ");return`
  fn set_${o}(${on}, value: ${U}) {
    set_${o}ByIndices(${Do(Zs)}, value);
  }`})();return{impl:()=>{let on=[],Zs=!1;return ue.offsetToIndices&&(on.push(pt),Zs=!0),ue.indicesToOffset&&(on.push(nn),Zs=!0),ue.broadcastedIndicesToOffset&&(Object.values(Ia).forEach(Ma=>on.push(Ma)),Zs=!0),ue.set&&(on.push(Xa),Zs=!0),ue.setByIndices&&(on.push(Ea),Zs=!0),ue.get&&(on.push(Ra),Zs=!0),ue.getByIndices&&(on.push(yu),Zs=!0),!y&&Zs&&on.unshift(`const ${Ae} = ${T.indices}(${_.join(",")});`,`const ${Le} = ${T.indices}(${wr.computeStrides(_).join(",")});`),on.join(`
`)},type:T,offsetToIndices:lt,indicesToOffset:Er,broadcastedIndicesToOffset:Da,indices:Do,indicesGet:aa,indicesSet:pa,set:(...on)=>{if(on.length!==b+1)throw new Error(`indices length must be ${b}`);let Zs=on[b];if(typeof Zs!="string")throw new Error("value must be string");let Ma=on.slice(0,b).map(ae).join(",");return b===0?wa("0u",Zs):b===1?wa(Ma[0],Zs):(ue.set=!0,ue.setByIndices=!0,ue.indicesToOffset=!0,`set_${o}(${Ma}, ${Zs})`)},setByOffset:wa,setByIndices:(on,Zs)=>b<2?wa(on,Zs):(ue.setByIndices=!0,ue.indicesToOffset=!0,`set_${o}ByIndices(${on}, ${Zs});`),get:fu,getByOffset:uu,getByIndices:ga,usage:m,name:o,strides:Le,shape:Ae,rank:b}},S=(o,d,_,m=1)=>C_(o,d,_,"input",m),be=(o,d,_,m=1)=>C_(o,d,_,"output",m),wt=(o,d,_,m=1)=>C_(o,d,_,"internal",m),Jt=class{constructor(o,d){this.normalizedDispatchGroup=o,this.limits=d,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(o){return`if (global_idx >= ${typeof o=="number"?`${o}u`:o}) { return; }`}mainStart(o=Du){let d=typeof o=="number"?o:o[0],_=typeof o=="number"?1:o[1],m=typeof o=="number"?1:o[2];if(d>this.limits.maxComputeWorkgroupSizeX||_>this.limits.maxComputeWorkgroupSizeY||m>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${d}, ${_}, ${m}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(d*_*m>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${d}, ${_}, ${m}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let g=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,y=g?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,b=g?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${d*_*m}u + local_idx;`;return`@compute @workgroup_size(${d}, ${_}, ${m})
  fn main(${y}) {
    ${b}
  `}appendVariableUniforms(o){o.rank!==0&&(o.shape.startsWith("uniforms.")&&this.uniforms.push({name:o.shape.replace("uniforms.",""),type:"u32",length:o.rank}),o.strides.startsWith("uniforms.")&&this.uniforms.push({name:o.strides.replace("uniforms.",""),type:"u32",length:o.rank}))}declareVariable(o,d){if(o.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(o),this.appendVariableUniforms(o);let _=o.usage==="input"?"read":"read_write",m=o.type.storage;return`@group(0) @binding(${d}) var<storage, ${_}> ${o.name}: array<${m}>;`}declareVariables(...o){return o.map(d=>this.declareVariable(d,this.variableIndex++)).join(`
`)}registerInternalVariable(o){if(o.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(o),this.appendVariableUniforms(o)}registerInternalVariables(...o){return o.forEach(d=>this.registerInternalVariable(d)),this}registerUniform(o,d,_=1){return this.uniforms.push({name:o,type:d,length:_}),this}registerUniforms(o){return this.uniforms=this.uniforms.concat(o),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let o=[];for(let{name:d,type:_,length:m}of this.uniforms)if(m&&m>4)_==="f16"?o.push(`@align(16) ${d}:array<mat2x4<${_}>, ${Math.ceil(m/8)}>`):o.push(`${d}:array<vec4<${_}>, ${Math.ceil(m/4)}>`);else{let g=m==null||m===1?_:`vec${m}<${_}>`;o.push(`${d}:${g}`)}return`
      struct Uniforms { ${o.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(o=>o.impl()).join(`
`)+this.internalVariables.map(o=>o.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let o=d=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(d)];return this.uniforms.map(d=>[o(d.type),d.length??1])}},Ir=(o,d)=>new Jt(o,d),Lo=(o,d)=>{let _=o.length,m=[];for(let g=0;g<_;g++){let y=_-1-g,b=o[y]||1;(d[d.length-1-g]||1)>1&&b===1&&m.unshift(y)}return m}}),gu,Bu,Pu,md,fh,Td,In,qa,ru=p(()=>{ya(),fa(),Va(),Xo(),gu=o=>{if(!o||o.length!==1)throw new Error("Transpose requires 1 input.")},Bu=(o,d)=>d&&d.length!==o?[...new Array(o).keys()].reverse():d,Pu=(o,d)=>wr.sortBasedOnPerm(o,Bu(o.length,d)),md=(o,d,_,m)=>{let g=`fn perm(i: ${m.type.indices}) -> ${_.type.indices} {
    var a: ${_.type.indices};`;for(let y=0;y<d;++y)g+=_.indicesSet("a",o[y],`i[${y}]`);return g+="return a;}"},fh=(o,d)=>{let _=[],m=[];for(let g=0;g<o.length;++g)o[g]!==1&&_.push(o[g]),o[d[g]]!==1&&m.push(d[g]);return{newShape:_,newPerm:m}},Td=(o,d)=>{let _=o.dataType,m=o.dims.length,g=Bu(m,d),y=Pu(o.dims,g),{newShape:b,newPerm:E}=fh(o.dims,g),M=wr.areEqual(E,[2,3,1]),P=wr.areEqual(E,[3,1,2]),U=b.length===2&&E[0]>E[1]||M||P,N=U?b:o.dims,T=y;U&&(N=M?[b[0],b[1]*b[2]]:P?[b[0]*b[1],b[2]]:b,T=[N[1],N[0]]);let ae=S("a",_,N.length),ue=be("output",_,T.length),fe=16,Ae;return U?Ae=Le=>`
  ${Le.registerUniform("output_size","u32").declareVariables(ae,ue)}
  var<workgroup> tile : array<array<${ue.type.value}, ${fe+1}>, ${fe}>;
  ${Le.mainStart([fe,fe,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${fe} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${fe}u + local_id.x;
    let input_row = workgroup_id_x * ${fe}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${ae.getByIndices(`${ae.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${fe}u + local_id.x;
    let output_row = workgroup_id_y * ${fe}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${ue.setByIndices(`${ue.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`:Ae=Le=>`
  ${Le.registerUniform("output_size","u32").declareVariables(ae,ue)}

  ${md(g,m,ae,ue)}

  ${Le.mainStart()}
    ${Le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${ue.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${ue.setByOffset("global_idx",ae.getByIndices("aIndices"))}
  }`,{name:U?"TransposeShared":"Transpose",shaderCache:{hint:`${d}`,inputDependencies:["rank"]},getRunData:()=>{let Le=wr.size(y);return{outputs:[{dims:y,dataType:o.dataType}],dispatchGroup:U?{x:Math.ceil(T[1]/fe),y:Math.ceil(T[0]/fe)}:{x:Math.ceil(Le/64)},programUniforms:[{type:12,data:Le},...qs(N,T)]}},getShaderSource:Ae}},In=(o,d)=>{gu(o.inputs),o.compute(Td(o.inputs[0],d.perm))},qa=o=>ka({perm:o.perm})}),r_,U_,zw,Nw,Uw,sy,Ww,Vw,iy,Gw,Ud,ay,Kw,qw,ly,Hw,Xw,uy,Yw,Qw,dy,Gv=p(()=>{ya(),fa(),Xo(),wy(),ru(),r_={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},U_={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},zw={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Nw={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Uw=(o,d)=>{let _=[];for(let m=d-o;m<d;++m)_.push(m);return _},sy=(o,d)=>{let _=[],m=o.length;for(let y=0;y<m;y++)d.indexOf(y)===-1&&_.push(o[y]);let g=d.map(y=>o[y]);return[_,g]},Ww=(o,d)=>{let _=o.length+d.length,m=[],g=0;for(let y=0;y<_;y++)d.indexOf(y)===-1?m.push(o[g++]):m.push(1);return m},Vw=(o,d)=>{for(let _=0;_<o.length;++_)if(o[o.length-_-1]!==d-1-_)return!1;return!0},iy=(o,d)=>{let _=[];if(!Vw(o,d)){for(let m=0;m<d;++m)o.indexOf(m)===-1&&_.push(m);o.forEach(m=>_.push(m))}return _},Gw=(o,d,_,m,g,y,b)=>{let E=_[0].dims,M=wr.size(y),P=wr.size(b),U=S("_A",_[0].dataType,E),N=be("output",g,y),T=32,ae=`
          var<workgroup> aBestValues : array<f32, ${T}>;
       `;return{name:o,shaderCache:d,getShaderSource:ue=>`
        ${ue.registerUniform("reduceSize","u32").declareVariables(U,N)}
        ${ae}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${ue.mainStart(T)}

          let outputIndex = global_idx / ${T};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${zw[m]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${T}) {
           let candidate = f32(${U.getByOffset("offset + k")});
           bestValue = ${r_[m]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${T}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${U_[m]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${N.setByOffset("outputIndex",`${m==="mean"?`${N.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${N.type.storage}(${Nw[m]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:y,dataType:g}],dispatchGroup:{x:M},programUniforms:[{type:12,data:P}]})}},Ud=(o,d,_,m)=>{let g=o.inputs.length===1?_:py(o.inputs,_),y=g.axes;y.length===0&&!g.noopWithEmptyAxes&&(y=o.inputs[0].dims.map((ae,ue)=>ue));let b=wr.normalizeAxes(y,o.inputs[0].dims.length),E=b,M=o.inputs[0],P=iy(E,o.inputs[0].dims.length);P.length>0&&(M=o.compute(Td(o.inputs[0],P),{inputs:[0],outputs:[-1]})[0],E=Uw(E.length,M.dims.length));let[U,N]=sy(M.dims,E),T=U;g.keepDims&&(T=Ww(U,b)),o.compute(Gw(d,{hint:g.cacheKey,inputDependencies:["type"]},[M],m,o.inputs[0].dataType,T,N),{inputs:[M]})},ay=(o,d)=>{Ud(o,"ReduceMeanShared",d,"mean")},Kw=(o,d)=>{Ud(o,"ReduceL1Shared",d,"l1")},qw=(o,d)=>{Ud(o,"ReduceL2Shared",d,"l2")},ly=(o,d)=>{Ud(o,"ReduceLogSumExpShared",d,"logSumExp")},Hw=(o,d)=>{Ud(o,"ReduceMaxShared",d,"max")},Xw=(o,d)=>{Ud(o,"ReduceMinShared",d,"min")},uy=(o,d)=>{Ud(o,"ReduceProdShared",d,"prod")},Yw=(o,d)=>{Ud(o,"ReduceSumShared",d,"sum")},Qw=(o,d)=>{Ud(o,"ReduceSumSquareShared",d,"sumSquare")},dy=(o,d)=>{Ud(o,"ReduceLogSumShared",d,"logSum")}}),Wd,cy,Eh,py,zd,Zw,Jw,_y,e0,t0,hy,r0,n0,fy,o0,Vd,my,s0,i0,gy,a0,l0,by,u0,d0,yy,wy=p(()=>{ya(),fa(),Va(),Xo(),Gv(),Wd=o=>{if(!o||o.length===0||o.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(o.length===2&&o[1].dims.length!==1)throw new Error("Invalid axes input dims.")},cy=o=>["","",`var value = ${o.getByIndices("input_indices")};`,""],Eh=(o,d,_,m,g,y,b=!1,E=!1)=>{let M=[],P=_[0].dims,U=P.length,N=wr.normalizeAxes(g,U),T=!E&&N.length===0;P.forEach((fe,Ae)=>{T||N.indexOf(Ae)>=0?b&&M.push(1):M.push(fe)});let ae=M.length,ue=wr.size(M);return{name:o,shaderCache:d,getShaderSource:fe=>{let Ae=[],Le=S("_A",_[0].dataType,U),Oe=be("output",y,ae),pt=m(Le,Oe,N),lt=pt[2];for(let ft=0,nn=0;ft<U;ft++)T||N.indexOf(ft)>=0?(b&&nn++,lt=`for(var j${ft}: u32 = 0; j${ft} < ${P[ft]}; j${ft}++) {
                  ${pt[2].includes("last_index")?`let last_index = j${ft};`:""}
                  ${Le.indicesSet("input_indices",ft,`j${ft}`)}
                  ${lt}
                }`):(Ae.push(`${Le.indicesSet("input_indices",ft,Oe.indicesGet("output_indices",nn))};`),nn++);return`

        ${fe.registerUniform("output_size","u32").declareVariables(Le,Oe)}

        ${fe.mainStart()}
          ${fe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${Le.type.indices};
          let output_indices = ${Oe.offsetToIndices("global_idx")};

          ${Ae.join(`
`)}
          ${pt[0]}       // init ops for reduce max/min
          ${pt[1]}
          ${lt}
          ${pt[3]}
          ${pt.length===4?Oe.setByOffset("global_idx","value"):pt.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:M,dataType:y}],dispatchGroup:{x:Math.ceil(ue/64)},programUniforms:[{type:12,data:ue},...qs(P,M)]})}},py=(o,d)=>{let _=[];return o[1].dims[0]>0&&o[1].getBigInt64Array().forEach(m=>_.push(Number(m))),ka({axes:_,keepDims:d.keepDims,noopWithEmptyAxes:d.noopWithEmptyAxes})},zd=(o,d,_,m)=>{let g=o.inputs,y=g.length===1?_:py(g,_);o.compute(Eh(d,{hint:y.cacheKey,inputDependencies:["rank"]},[g[0]],y.noopWithEmptyAxes&&y.axes.length===0?cy:m,y.axes,g[0].dataType,y.keepDims,y.noopWithEmptyAxes),{inputs:[0]})},Zw=(o,d)=>{Wd(o.inputs),zd(o,"ReduceLogSum",d,(_,m)=>[`var value = ${m.type.storage}(0);`,"",`value += ${_.getByIndices("input_indices")};`,"value = log(value);"])},Jw=(o,d)=>{Wd(o.inputs),zd(o,"ReduceL1",d,(_,m)=>[`var value = ${m.type.storage}(0);`,"",`value += abs(${_.getByIndices("input_indices")});`,""])},_y=(o,d)=>{Wd(o.inputs),zd(o,"ReduceL2",d,(_,m)=>[`var t = ${m.type.value}(0); var value = ${m.type.value}(0);`,"",`t = ${_.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},e0=(o,d)=>{Wd(o.inputs),zd(o,"ReduceLogSumExp",d,(_,m)=>[`var value = ${m.type.storage}(0);`,"",`value += exp(${_.getByIndices("input_indices")});`,"value = log(value);"])},t0=(o,d)=>{Wd(o.inputs),zd(o,"ReduceMax",d,(_,m,g)=>{let y=[];for(let b=0;b<_.rank;b++)(g.indexOf(b)>=0||g.length===0)&&y.push(_.indicesSet("input_indices",b,0));return[`${y.join(`
`)}`,`var value = ${_.getByIndices("input_indices")};`,`value = max(value, ${_.getByIndices("input_indices")});`,""]})},hy=(o,d)=>{Wd(o.inputs),zd(o,"ReduceMean",d,(_,m,g)=>{let y=1;for(let b=0;b<_.rank;b++)(g.indexOf(b)>=0||g.length===0)&&(y*=o.inputs[0].dims[b]);return["var sum = f32(0);","",`sum += f32(${_.getByIndices("input_indices")});`,`let value = ${m.type.value}(sum / ${y});`]})},r0=(o,d)=>{Wd(o.inputs),zd(o,"ReduceMin",d,(_,m,g)=>{let y=[];for(let b=0;b<_.rank;b++)(g.indexOf(b)>=0||g.length===0)&&y.push(`input_indices[${b}] = 0;`);return[`${y.join(`
`)}`,`var value = ${_.getByIndices("input_indices")};`,`value = min(value, ${_.getByIndices("input_indices")});`,""]})},n0=(o,d)=>{Wd(o.inputs),zd(o,"ReduceProd",d,(_,m)=>[`var value = ${m.type.storage}(1);`,"",`value *= ${_.getByIndices("input_indices")};`,""])},fy=(o,d)=>{Wd(o.inputs),zd(o,"ReduceSum",d,(_,m)=>[`var value = ${m.type.storage}(0);`,"",`value += ${_.getByIndices("input_indices")};`,""])},o0=(o,d)=>{Wd(o.inputs),zd(o,"ReduceSumSquare",d,(_,m)=>[`var t = ${m.type.value}(0); var value = ${m.type.value}(0);`,"",`t = ${_.getByIndices("input_indices")}; value += t * t;`,""])},Vd=(o,d,_)=>{if(d.length===0)return _;let m=1,g=1;for(let y=0;y<d.length;y++)d.indexOf(y)===-1?m*=o[y]:g*=o[y];return g<32&&m>1024},my=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?hy(o,d):ay(o,d)},s0=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?Jw(o,d):Kw(o,d)},i0=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?_y(o,d):qw(o,d)},gy=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?e0(o,d):ly(o,d)},a0=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?t0(o,d):Hw(o,d)},l0=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?r0(o,d):Xw(o,d)},by=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?n0(o,d):uy(o,d)},u0=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?fy(o,d):Yw(o,d)},d0=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?o0(o,d):Qw(o,d)},yy=(o,d)=>{Vd(o.inputs[0].dims,d.axes,d.noopWithEmptyAxes)?Zw(o,d):dy(o,d)}}),xy,vy,c0,Ty,p0=p(()=>{ya(),Va(),wy(),xy=o=>{if(!o||o.length===0||o.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(o[0].dataType!==1)throw new Error("Invalid input type.")},vy=(o,d)=>{xy(o.inputs);let _=(m,g,y)=>{let b=[];for(let E=0;E<m.rank;E++)(y.indexOf(E)>=0||y.length===0)&&b.push(`input_indices[${E}] = 0;`);return[`${b.join(`
`)}`,`var value = ${m.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${m.getByIndices("input_indices")} ${d.selectLastIndex>0?"<=":"<"} value) {
         value = ${m.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",g.setByOffset("global_idx","best_index")]};o.compute(Eh("ArgMin",{hint:d.cacheKey,inputDependencies:["rank"]},[o.inputs[0]],_,[d.axis],7,d.keepDims),{inputs:[0]})},c0=(o,d)=>{xy(o.inputs);let _=(m,g,y)=>{let b=[];for(let E=0;E<m.rank;E++)(y.indexOf(E)>=0||y.length===0)&&b.push(`input_indices[${E}] = 0;`);return[`${b.join(`
`)}`,`var value = ${m.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${m.getByIndices("input_indices")} ${d.selectLastIndex>0?">=":">"} value) {
         value = ${m.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",g.setByOffset("global_idx","best_index")]};o.compute(Eh("argMax",{hint:d.cacheKey,inputDependencies:["rank"]},[o.inputs[0]],_,[d.axis],7,d.keepDims),{inputs:[0]})},Ty=o=>ka(o)}),_0,h0,Ey,f0,W_,My,m0,Py=p(()=>{ya(),fa(),Mt(),Xo(),_0=(o,d)=>{let _=o[0],m=o[1],g=o[2],y=o[3],b=o[4],E=o[5];if(b&&E)throw new Error("Attention cannot have both past and attention_bias");if(_.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let M=_.dims[0],P=_.dims[1],U=_.dims[2];if(g.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(m.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(m.dims[0]!==U)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(g.dims[0]!==m.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let N=g.dims[0]/3,T=N,ae=T;if(d.qkvHiddenSizes.length>0){if(d.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let pt of d.qkvHiddenSizes)if(pt%d.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");N=d.qkvHiddenSizes[0],T=d.qkvHiddenSizes[1],ae=d.qkvHiddenSizes[2]}let ue=P;if(N!==T)throw new Error("qkv_hidden_sizes first element should be same as the second");if(g.dims[0]!==N+T+ae)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let fe=0;if(b){if(T!==ae)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(b.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(b.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(b.dims[1]!==M)throw new Error('Input "past" second dimension must be batch_size');if(b.dims[2]!==d.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(b.dims[4]!==T/d.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');d.pastPresentShareBuffer||(fe=b.dims[3])}let Ae=ue+fe,Le=-1,Oe=0;if(y)throw new Error("Mask not supported");if(b)throw new Error("past is not supported");if(E){if(E.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(E.dims[0]!==M||E.dims[1]!==d.numHeads||E.dims[2]!==P||E.dims[3]!==Ae)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:M,sequenceLength:P,pastSequenceLength:fe,kvSequenceLength:ue,totalSequenceLength:Ae,maxSequenceLength:Le,inputHiddenSize:U,hiddenSize:N,vHiddenSize:ae,headSize:Math.floor(N/d.numHeads),vHeadSize:Math.floor(ae/d.numHeads),numHeads:d.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:d.maskFilterValue,maskType:Oe,scale:d.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},h0=(o,d,_)=>{let m=La(_),g=64,y=_/m;y<g&&(g=32);let b=Math.ceil(_/m/g),E=[{type:1,data:1/_},{type:12,data:y},{type:12,data:b}],M=Fa(o.dataType,m),P=Ga(1,m),U=["type"],N=T=>{let ae=be("x",o.dataType,o.dims,m),ue=Ga(o.dataType),fe=[{name:"d_inv",type:"f32"},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${g}>;
  var<workgroup> thread_sum: array<f32, ${g}>;
  ${T.registerUniforms(fe).declareVariables(ae)}
  ${T.mainStart([g,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${g}) * uniforms.d_comp + local_offset;

    var thread_max_vector = ${P}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${P}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(m){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${m}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${g}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${P}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${P}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(m){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${m}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${g}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${ae.type.value}(${ue}(uniforms.d_inv));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${P}(x[offset + i]);
        x[offset + i] = ${ae.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${g};${M};${m}`,inputDependencies:U},getShaderSource:N,getRunData:()=>({outputs:[],dispatchGroup:{x:d},programUniforms:E})}},Ey=(o,d,_,m,g,y,b,E)=>{let M=E+y.kvSequenceLength,P=[y.batchSize,y.numHeads,y.sequenceLength,M],U=y.kvNumHeads===void 0&&o>1&&m,N=U?[y.batchSize,y.numHeads,M,y.headSize]:void 0,T=b.scale===0?1/Math.sqrt(y.headSize):b.scale,ae=La(y.headSize),ue=y.headSize/ae,fe=12,Ae={x:Math.ceil(M/fe),y:Math.ceil(y.sequenceLength/fe),z:y.batchSize*y.numHeads},Le=[{type:12,data:y.sequenceLength},{type:12,data:ue},{type:12,data:M},{type:12,data:y.numHeads},{type:1,data:T},{type:12,data:E},{type:12,data:y.kvSequenceLength}],Oe=U&&m&&wr.size(m.dims)>0,pt=["type","type"];Oe&&pt.push("type"),g&&pt.push("type");let lt=[{dims:P,dataType:d.dataType,gpuDataType:0}];U&&lt.push({dims:N,dataType:d.dataType,gpuDataType:0});let ft=nn=>{let Er=S("q",d.dataType,d.dims,ae),Do=S("key",_.dataType,_.dims,ae),aa=[Er,Do];if(Oe){let uu=S("past_key",m.dataType,m.dims,ae);aa.push(uu)}g&&aa.push(S("attention_bias",g.dataType,g.dims));let pa=be("output",d.dataType,P),Ia=[pa];U&&Ia.push(be("present_key",d.dataType,N,ae));let Da=Ga(1,ae),wa=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${fe}u;

  var<workgroup> tileQ: array<${Er.type.storage}, ${fe*fe}>;
  var<workgroup> tileK: array<${Er.type.storage}, ${fe*fe}>;
  ${nn.registerUniforms(wa).declareVariables(...aa,...Ia)}
  ${nn.mainStart([fe,fe,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${Oe&&U?`
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`:`
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`}
    ${U?"let presentKeyOffset = headIdx * uniforms.N * uniforms.K;":""}
    var value = ${Da}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${Oe&&U?`
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`:"tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];"}
      ${U?"present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];":""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${Da}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(ae){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${ae}`)}})()};
        output[outputIdx] = ${pa.type.value} (sum * uniforms.alpha) + ${g?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${ae};${g!==void 0};${m!==void 0};${o}`,inputDependencies:pt},getRunData:()=>({outputs:lt,dispatchGroup:Ae,programUniforms:Le}),getShaderSource:ft}},f0=(o,d,_,m,g,y)=>{let b=y+g.kvSequenceLength,E=g.nReps?g.nReps:1,M=g.vHiddenSize*E,P=g.kvNumHeads==null&&o>1&&m,U=P?[g.batchSize,g.numHeads,b,g.headSize]:void 0,N=[g.batchSize,g.sequenceLength,M],T=12,ae={x:Math.ceil(g.vHeadSize/T),y:Math.ceil(g.sequenceLength/T),z:g.batchSize*g.numHeads},ue=[{type:12,data:g.sequenceLength},{type:12,data:b},{type:12,data:g.vHeadSize},{type:12,data:g.numHeads},{type:12,data:M},{type:12,data:y},{type:12,data:g.kvSequenceLength}],fe=P&&m&&wr.size(m.dims)>0,Ae=["type","type"];fe&&Ae.push("type");let Le=[{dims:N,dataType:d.dataType,gpuDataType:0}];P&&Le.push({dims:U,dataType:d.dataType,gpuDataType:0});let Oe=pt=>{let lt=S("probs",d.dataType,d.dims),ft=S("v",_.dataType,_.dims),nn=[lt,ft];fe&&nn.push(S("past_value",m.dataType,m.dims));let Er=[be("output",d.dataType,N)];P&&Er.push(be("present_value",d.dataType,U));let Do=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${T}u;
  var<workgroup> tileQ: array<${lt.type.value}, ${T*T}>;
  var<workgroup> tileK: array<${lt.type.value}, ${T*T}>;
  ${pt.registerUniforms(Do).declareVariables(...nn,...Er)}
  ${pt.mainStart([T,T,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${fe&&P?`
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `:`
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `}
    ${P?"let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${lt.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${fe&&P?`
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `:`
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `}
        ${P?"present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];":""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${m!==void 0};${o}`,inputDependencies:Ae},getRunData:()=>({outputs:Le,dispatchGroup:ae,programUniforms:ue}),getShaderSource:Oe}},W_=(o,d,_,m,g,y,b,E,M,P,U)=>{let N=Math.min(o.outputCount,1+(b?1:0)+(E?1:0)),T=P.kvNumHeads!==void 0||N>1?P.pastSequenceLength:0,ae=T+P.kvSequenceLength,ue=M&&wr.size(M.dims)>0?M:void 0,fe=[d,_];P.kvNumHeads===void 0&&N>1&&b&&wr.size(b.dims)>0&&fe.push(b),ue&&fe.push(ue);let Ae=o.compute(Ey(N,d,_,b,ue,P,U,T),{inputs:fe,outputs:P.kvNumHeads===void 0&&N>1?[-1,1]:[-1]})[0];o.compute(h0(Ae,P.batchSize*P.numHeads*P.sequenceLength,ae),{inputs:[Ae],outputs:[]});let Le=[Ae,m];P.kvNumHeads===void 0&&N>1&&E&&wr.size(E.dims)>0&&Le.push(E),o.compute(f0(N,Ae,m,E,P,T),{inputs:Le,outputs:P.kvNumHeads===void 0&&N>1?[0,2]:[0]})},My=(o,d)=>{let _=[d.batchSize,d.numHeads,d.sequenceLength,d.headSize],m=d.sequenceLength,g=d.inputHiddenSize,y=d.headSize,b=12,E={x:Math.ceil(d.headSize/b),y:Math.ceil(d.sequenceLength/b),z:d.batchSize*d.numHeads},M=[o.inputs[0],o.inputs[1],o.inputs[2]],P=[{type:12,data:m},{type:12,data:g},{type:12,data:y},{type:12,data:d.numHeads},{type:12,data:d.headSize},{type:12,data:d.hiddenSize},{type:12,data:d.hiddenSize+d.hiddenSize+d.vHiddenSize}],U=N=>{let T=be("output_q",M[0].dataType,_),ae=be("output_k",M[0].dataType,_),ue=be("output_v",M[0].dataType,_),fe=S("input",M[0].dataType,M[0].dims),Ae=S("weight",M[1].dataType,M[1].dims),Le=S("bias",M[2].dataType,M[2].dims),Oe=fe.type.storage,pt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${b}u;
  var<workgroup> tileInput: array<${Oe}, ${b*b}>;
  var<workgroup> tileWeightQ: array<${Oe}, ${b*b}>;
  var<workgroup> tileWeightK: array<${Oe}, ${b*b}>;
  var<workgroup> tileWeightV: array<${Oe}, ${b*b}>;
  ${N.registerUniforms(pt).declareVariables(fe,Ae,Le,T,ae,ue)}
  ${N.mainStart([b,b,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${Oe}(0);
    var valueK = ${Oe}(0);
    var valueV = ${Oe}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return o.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:_,dataType:o.inputs[0].dataType,gpuDataType:0},{dims:_,dataType:o.inputs[0].dataType,gpuDataType:0},{dims:_,dataType:o.inputs[0].dataType,gpuDataType:0}],dispatchGroup:E,programUniforms:P}),getShaderSource:U},{inputs:M,outputs:[-1,-1,-1]})},m0=(o,d)=>{let _=_0(o.inputs,d),[m,g,y]=My(o,_);return W_(o,m,g,y,o.inputs[4],void 0,void 0,void 0,o.inputs[5],_,d)}}),ky,g0,b0,Oy,Kv=p(()=>{ii(),ya(),fa(),Va(),Xo(),ky=(o,d)=>{if(!o||o.length!==5)throw new Error("BatchNormalization requires 5 inputs");let _=(m,g,y)=>{let b=g.length;if(b!==m.length)throw new Error(`${y}: num dimensions != ${b}`);g.forEach((E,M)=>{if(E!==m[M])throw new Error(`${y}: dim[${M}] do not match`)})};if(o[0].dims.length>1){let m=d.format==="NHWC"?d.spatial?o[0].dims.slice(-1):o[0].dims.slice(-1).concat(o[0].dims.slice(1,o[0].dims.length-1)):o[0].dims.slice(1,d.spatial?2:void 0);_(o[1].dims,m,"Invalid input scale"),_(o[2].dims,m,"Invalid input B"),_(o[3].dims,m,"Invalid input mean"),_(o[4].dims,m,"Invalid input var")}else _(o[1].dims,[1],"Invalid input scale"),_(o[2].dims,[1],"Invalid input B"),_(o[3].dims,[1],"Invalid input mean"),_(o[4].dims,[1],"Invalid input var")},g0=(o,d)=>{let{epsilon:_,spatial:m,format:g}=d,y=o[0].dims,b=m?La(y[y.length-1]):1,E=g==="NHWC"&&y.length>1?b:1,M=wr.size(y)/b,P=m,U=P?y.length:y,N=S("x",o[0].dataType,o[0].dims,b),T=S("scale",o[1].dataType,o[1].dims,E),ae=S("bias",o[2].dataType,o[2].dims,E),ue=S("inputMean",o[3].dataType,o[3].dims,E),fe=S("inputVar",o[4].dataType,o[4].dims,E),Ae=be("y",o[0].dataType,U,b),Le=()=>{let pt="";if(m)pt=`let cOffset = ${y.length===1?"0u":g==="NHWC"?`outputIndices[${y.length-1}] / ${b}`:"outputIndices[1]"};`;else if(g==="NCHW")pt=`
            ${Ae.indicesSet("outputIndices","0","0")}
            let cOffset = ${Ae.indicesToOffset("outputIndices")};`;else{pt=`var cIndices = ${T.type.indices}(0);
                       cIndices[0] = outputIndices[${y.length-1}];`;for(let lt=1;lt<T.rank;lt++)pt+=`cIndices[${lt}] = outputIndices[${lt}];`;pt+=`let cOffset = ${T.indicesToOffset("cIndices")};`}return pt},Oe=pt=>`
  const epsilon = ${_};
  ${pt.registerUniform("outputSize","u32").declareVariables(N,T,ae,ue,fe,Ae)}
  ${pt.mainStart()}
  ${pt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Ae.offsetToIndices(`global_idx * ${b}`)};
    ${Le()}
    let scale = ${T.getByOffset("cOffset")};
    let bias = ${ae.getByOffset("cOffset")};
    let inputMean = ${ue.getByOffset("cOffset")};
    let inputVar = ${fe.getByOffset("cOffset")};
    let x = ${N.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Ae.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${d.epsilon}_${d.format}_${m}_${b}`,inputDependencies:P?["rank","type","type","type","type"]:void 0},getShaderSource:Oe,getRunData:()=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(M/64)},programUniforms:P?[{type:12,data:M},...qs(y)]:[{type:12,data:M}]})}},b0=o=>ka(o),Oy=(o,d)=>{let{inputs:_,outputCount:m}=o,g=b0({...d,outputCount:m});if(X.webgpu.validateInputContent&&ky(_,g),d.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");o.compute(g0(_,g))}}),y0,$y,w0,qv=p(()=>{fa(),Xo(),y0=o=>{if(o[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(o[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(o[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(o[0].dims[2]!==o[1].dims[0])throw new Error("last dimension of input and bias are not the same")},$y=o=>{let d=o[0].dims,_=o[0].dims[2],m=wr.size(d)/4,g=o[0].dataType,y=S("input",g,d,4),b=S("bias",g,[_],4),E=S("residual",g,d,4),M=be("output",g,d,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:d,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:P=>`
  const channels = ${_}u / 4;
  ${P.declareVariables(y,b,E,M)}

  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes(m)}
    let value = ${y.getByOffset("global_idx")}
      + ${b.getByOffset("global_idx % channels")} + ${E.getByOffset("global_idx")};
    ${M.setByOffset("global_idx","value")}
  }`}},w0=o=>{y0(o.inputs),o.compute($y(o.inputs))}}),x0,Ha,Ay,v0,T0,E0,M0,Sy,P0,k0,O0,$0,Iy,A0,S0,Cy,V_,I0,G_,C0,D0,Dy,F0,B0,Fy,L0,R0,kh,j0,z0,By,Ly,N0,Ry,U0,jy,W0,Xh,zy,V0,G0,Ny,K0,q0,Uy,Wy=p(()=>{ya(),fa(),Va(),Xo(),x0=(o,d,_,m,g,y,b)=>{let E=Math.ceil(d/4),M="";typeof g=="string"?M=`${g}(a)`:M=g("a");let P=S("inputData",_,[E],4),U=be("outputData",m,[E],4),N=[{name:"vec_size",type:"u32"}];return b&&N.push(...b),`
      ${o.registerUniforms(N).declareVariables(P,U)}

  ${y??""}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${P.getByOffset("global_idx")};
    ${U.setByOffset("global_idx",M)}
  }`},Ha=(o,d,_,m,g,y=o.dataType,b,E)=>{let M=[{type:12,data:Math.ceil(wr.size(o.dims)/4)}];return b&&M.push(...b),{name:d,shaderCache:{hint:g,inputDependencies:["type"]},getShaderSource:P=>x0(P,wr.size(o.dims),o.dataType,y,_,m,E),getRunData:P=>({outputs:[{dims:o.dims,dataType:y}],dispatchGroup:{x:Math.ceil(wr.size(P[0].dims)/64/4)},programUniforms:M})}},Ay=o=>{o.compute(Ha(o.inputs[0],"Abs","abs"))},v0=o=>{o.compute(Ha(o.inputs[0],"Acos","acos"))},T0=o=>{o.compute(Ha(o.inputs[0],"Acosh","acosh"))},E0=o=>{o.compute(Ha(o.inputs[0],"Asin","asin"))},M0=o=>{o.compute(Ha(o.inputs[0],"Asinh","asinh"))},Sy=o=>{o.compute(Ha(o.inputs[0],"Atan","atan"))},P0=o=>{o.compute(Ha(o.inputs[0],"Atanh","atanh"))},k0=o=>ka(o),O0=(o,d)=>{let _;switch(d.to){case 10:_="vec4<f16>";break;case 1:_="vec4<f32>";break;case 12:_="vec4<u32>";break;case 6:_="vec4<i32>";break;case 9:_="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${d.to}`)}o.compute(Ha(o.inputs[0],"Cast",_,void 0,d.cacheKey,d.to))},$0=o=>{let d,_,m=o.length>=2&&o[1].data!==0,g=o.length>=3&&o[2].data!==0;switch(o[0].dataType){case 1:d=m?o[1].getFloat32Array()[0]:-34028234663852886e22,_=g?o[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:d=m?o[1].getUint16Array()[0]:64511,_=g?o[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return ka({min:d,max:_})},Iy=(o,d)=>{let _=d||$0(o.inputs),m=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"Clip",g=>`clamp(${g}, vec4<${m}>(uniforms.min), vec4<${m}>(uniforms.max))`,void 0,_.cacheKey,void 0,[{type:o.inputs[0].dataType,data:_.min},{type:o.inputs[0].dataType,data:_.max}],[{name:"min",type:m},{name:"max",type:m}]),{inputs:[0]})},A0=o=>{o.compute(Ha(o.inputs[0],"Ceil","ceil"))},S0=o=>{o.compute(Ha(o.inputs[0],"Cos","cos"))},Cy=o=>{o.compute(Ha(o.inputs[0],"Cosh","cosh"))},V_=o=>ka(o),I0=(o,d)=>{let _=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"Elu",m=>`elu_vf32(${m})`,`
  const elu_alpha_ = ${_}(${d.alpha});

  fn elu_f32(a: ${_}) -> ${_} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${_}>) -> vec4<${_}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,d.cacheKey))},G_=(o="f32")=>`
const r0: ${o} = 0.3275911;
const r1: ${o} = 0.254829592;
const r2: ${o} = -0.284496736;
const r3: ${o} = 1.421413741;
const r4: ${o} = -1.453152027;
const r5: ${o} = 1.061405429;

fn erf_vf32(v: vec4<${o}>) -> vec4<${o}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,C0=o=>{let d=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"Erf",_=>`erf_vf32(${_})`,G_(d)))},D0=o=>{o.compute(Ha(o.inputs[0],"Exp","exp"))},Dy=o=>{o.compute(Ha(o.inputs[0],"Floor","floor"))},F0=o=>{let d=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"Gelu",_=>`0.5 * ${_} * (1.0 + erf_vf32(${_} * 0.7071067811865475))`,G_(d)))},B0=(o,d)=>{let _=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"LeakyRelu",m=>`select(leaky_relu_alpha_ * ${m}, ${m}, ${m} >= vec4<${_}>(0.0))`,`const leaky_relu_alpha_ = ${_}(${d.alpha});`,d.cacheKey))},Fy=o=>{o.compute(Ha(o.inputs[0],"Not",d=>`!${d}`))},L0=o=>{o.compute(Ha(o.inputs[0],"Neg",d=>`-${d}`))},R0=o=>{o.compute(Ha(o.inputs[0],"Reciprocal",d=>`1.0/${d}`))},kh=o=>{let d=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"Relu",_=>`select(vec4<${d}>(0.0), ${_}, ${_} > vec4<${d}>(0.0))`))},j0=o=>{o.compute(Ha(o.inputs[0],"Sigmoid",d=>`(1.0 / (1.0 + exp(-${d})))`))},z0=o=>ka(o),By=(o,d)=>{let _=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"HardSigmoid",m=>`max(vec4<${_}>(0.0), min(vec4<${_}>(1.0), ${d.alpha} * ${m} + vec4<${_}>(${d.beta})))`,void 0,d.cacheKey))},Ly=o=>{o.compute(Ha(o.inputs[0],"Sin","sin"))},N0=o=>{o.compute(Ha(o.inputs[0],"Sinh","sinh"))},Ry=o=>{o.compute(Ha(o.inputs[0],"Sqrt","sqrt"))},U0=o=>{o.compute(Ha(o.inputs[0],"Tan","tan"))},jy=o=>`sign(${o}) * (1 - exp(-2 * abs(${o}))) / (1 + exp(-2 * abs(${o})))`,W0=o=>{o.compute(Ha(o.inputs[0],"Tanh",jy))},Xh=(o="f32")=>`
const fast_gelu_a: ${o} = 0.5;
const fast_gelu_b: ${o} = 0.7978845608028654;
const fast_gelu_c: ${o} = 0.035677408136300125;

fn tanh_v(v: vec4<${o}>) -> vec4<${o}> {
  return ${jy("v")};
}
`,zy=o=>`(fast_gelu_a + fast_gelu_a * tanh_v(${o} * (fast_gelu_c * ${o} * ${o} + fast_gelu_b))) * ${o}`,V0=o=>{let d=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"FastGelu",zy,Xh(d),void 0,o.inputs[0].dataType))},G0=(o,d)=>{let _=Ga(o.inputs[0].dataType);return o.compute(Ha(o.inputs[0],"ThresholdedRelu",m=>`select(vec4<${_}>(0.0), ${m}, ${m} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${_}>(${d.alpha});`,d.cacheKey)),0},Ny=o=>{o.compute(Ha(o.inputs[0],"Log","log"))},K0=(o,d)=>`
const alpha = vec4<${o}>(${d});
const one = ${o}(1.0);
const zero = ${o}(0.0);

fn quick_gelu_impl(x: vec4<${o}>) -> vec4<${o}> {
  let v = x *alpha;
  var x1 : vec4<${o}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,q0=o=>`quick_gelu_impl(${o})`,Uy=(o,d)=>{let _=Ga(o.inputs[0].dataType);o.compute(Ha(o.inputs[0],"QuickGelu",q0,K0(_,d.alpha),d.cacheKey,o.inputs[0].dataType))}}),H0,Vy,X0,Hv=p(()=>{fa(),Xo(),Wy(),H0=o=>{if(o[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(o[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(o[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(o[0].dims[2]!==o[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Vy=o=>{let d=o[0].dims.slice();d[2]=d[2]/2;let _=S("input",o[0].dataType,o[0].dims,4),m=S("bias",o[0].dataType,[o[0].dims[2]],4),g=be("output",o[0].dataType,d,4),y=wr.size(d)/4,b=Fa(o[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:d,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)}}),getShaderSource:E=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${o[0].dims[2]/4/2}u;

  ${E.declareVariables(_,m,g)}

  ${G_(b)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes(y)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${g.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},X0=o=>{H0(o.inputs),o.compute(Vy(o.inputs))}}),Gy,Y0,Gd,Ky,Q0,Z0,qy,J0,ex,tx,rx,Om,nx,Xv=p(()=>{ya(),fa(),Xo(),Gy=(o,d,_,m,g,y,b,E,M,P,U,N)=>{let T,ae;typeof E=="string"?T=ae=(Oe,pt)=>`${E}((${Oe}),(${pt}))`:typeof E=="function"?T=ae=E:(T=E.scalar,ae=E.vector);let ue=be("outputData",U,m.length,4),fe=S("aData",M,d.length,4),Ae=S("bData",P,_.length,4),Le;if(g)if(y){let Oe=wr.size(d)===1,pt=wr.size(_)===1,lt=d.length>0&&d[d.length-1]%4===0,ft=_.length>0&&_[_.length-1]%4===0;Oe||pt?Le=ue.setByOffset("global_idx",ae(Oe?`${fe.type.value}(${fe.getByOffset("0")}.x)`:fe.getByOffset("global_idx"),pt?`${Ae.type.value}(${Ae.getByOffset("0")}.x)`:Ae.getByOffset("global_idx"))):Le=`
            let outputIndices = ${ue.offsetToIndices("global_idx * 4u")};
            let offsetA = ${fe.broadcastedIndicesToOffset("outputIndices",ue)};
            let offsetB = ${Ae.broadcastedIndicesToOffset("outputIndices",ue)};
            ${ue.setByOffset("global_idx",ae(b||lt?fe.getByOffset("offsetA / 4u"):`${fe.type.value}(${fe.getByOffset("offsetA / 4u")}[offsetA % 4u])`,b||ft?Ae.getByOffset("offsetB / 4u"):`${Ae.type.value}(${Ae.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else Le=ue.setByOffset("global_idx",ae(fe.getByOffset("global_idx"),Ae.getByOffset("global_idx")));else{if(!y)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let Oe=(pt,lt,ft="")=>{let nn=`aData[indexA${lt}][componentA${lt}]`,Er=`bData[indexB${lt}][componentB${lt}]`;return`
            let outputIndices${lt} = ${ue.offsetToIndices(`global_idx * 4u + ${lt}u`)};
            let offsetA${lt} = ${fe.broadcastedIndicesToOffset(`outputIndices${lt}`,ue)};
            let offsetB${lt} = ${Ae.broadcastedIndicesToOffset(`outputIndices${lt}`,ue)};
            let indexA${lt} = offsetA${lt} / 4u;
            let indexB${lt} = offsetB${lt} / 4u;
            let componentA${lt} = offsetA${lt} % 4u;
            let componentB${lt} = offsetB${lt} % 4u;
            ${pt}[${lt}] = ${ft}(${T(nn,Er)});
          `};U===9?Le=`
            var data = vec4<u32>(0);
            ${Oe("data",0,"u32")}
            ${Oe("data",1,"u32")}
            ${Oe("data",2,"u32")}
            ${Oe("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Le=`
            ${Oe("outputData[global_idx]",0)}
            ${Oe("outputData[global_idx]",1)}
            ${Oe("outputData[global_idx]",2)}
            ${Oe("outputData[global_idx]",3)}
          `}return`
        ${o.registerUniform("vec_size","u32").declareVariables(fe,Ae,ue)}

        ${N??""}

        ${o.mainStart()}
        ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${Le}
      }`},Y0=(o,d,_,m,g,y,b=_.dataType)=>{let E=!wr.areEqual(_.dims,m.dims),M=_.dims,P=wr.size(_.dims),U=!1,N=!1,T=[E];if(E){let ae=xd.calcShape(_.dims,m.dims,!1);if(!ae)throw new Error("Can't perform binary op on the given tensors");M=ae,P=wr.size(M);let ue=wr.size(_.dims)===1,fe=wr.size(m.dims)===1,Ae=_.dims.length>0&&_.dims[_.dims.length-1]%4===0,Le=m.dims.length>0&&m.dims[m.dims.length-1]%4===0;T.push(ue),T.push(fe),T.push(Ae),T.push(Le);let Oe=1;for(let pt=1;pt<M.length;pt++){let lt=_.dims[_.dims.length-pt]??1,ft=m.dims[m.dims.length-pt]??1;if(lt===ft)Oe*=lt;else break}Oe%4===0?(N=!0,U=!0):(ue||fe||Ae||Le)&&(U=!0)}else U=!0;return T.push(U),{name:o,shaderCache:{hint:d+T.map(ae=>ae.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:ae=>Gy(ae,_.dims,m.dims,M,U,E,N,g,_.dataType,m.dataType,b,y),getRunData:()=>({outputs:[{dims:M,dataType:b}],dispatchGroup:{x:Math.ceil(P/64/4)},programUniforms:[{type:12,data:Math.ceil(wr.size(M)/4)},...qs(_.dims,m.dims,M)]})}},Gd=(o,d,_,m,g,y)=>{o.compute(Y0(d,g??"",o.inputs[0],o.inputs[1],_,m,y))},Ky=o=>{Gd(o,"Add",(d,_)=>`${d}+${_}`)},Q0=o=>{Gd(o,"Div",(d,_)=>`${d}/${_}`)},Z0=o=>{Gd(o,"Equal",{scalar:(d,_)=>`u32(${d}==${_})`,vector:(d,_)=>`vec4<u32>(${d}==${_})`},void 0,void 0,9)},qy=o=>{Gd(o,"Mul",(d,_)=>`${d}*${_}`)},J0=o=>{let d=S("input",o.inputs[0].dataType,o.inputs[0].dims).type.value;Gd(o,"Pow",{scalar:(_,m)=>`pow_custom(${_},${m})`,vector:(_,m)=>`pow_vector_custom(${_},${m})`},`
    fn pow_custom(a : ${d}, b : ${d}) -> ${d} {
      if (b == ${d}(0.0)) {
        return ${d}(1.0);
      } else if (a < ${d}(0.0) && f32(b) != floor(f32(b))) {
        return ${d}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${d}(1.0), round(f32(abs(b) % ${d}(2.0))) != 1.0) * ${d}(${d==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${d}>, b : vec4<${d}>) -> vec4<${d}> {
      // TODO: implement vectorized pow
      return vec4<${d}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},ex=o=>{Gd(o,"Sub",(d,_)=>`${d}-${_}`)},tx=o=>{Gd(o,"Greater",{scalar:(d,_)=>`u32(${d}>${_})`,vector:(d,_)=>`vec4<u32>(${d}>${_})`},void 0,void 0,9)},rx=o=>{Gd(o,"Less",{scalar:(d,_)=>`u32(${d}<${_})`,vector:(d,_)=>`vec4<u32>(${d}<${_})`},void 0,void 0,9)},Om=o=>{Gd(o,"GreaterOrEqual",{scalar:(d,_)=>`u32(${d}>=${_})`,vector:(d,_)=>`vec4<u32>(${d}>=${_})`},void 0,void 0,9)},nx=o=>{Gd(o,"LessOrEqual",{scalar:(d,_)=>`u32(${d}<=${_})`,vector:(d,_)=>`vec4<u32>(${d}<=${_})`},void 0,void 0,9)}}),ox,sx,ix,Hy,ax,lx,ux=p(()=>{ya(),fa(),Va(),Xo(),ox=(o,d)=>{if(!o||o.length<1)throw new Error("too few inputs");let _=0,m=o[_],g=m.dataType,y=m.dims.length;o.forEach((b,E)=>{if(E!==_){if(b.dataType!==g)throw new Error("input tensors should be one type");if(b.dims.length!==y)throw new Error("input tensors should have the same shape");b.dims.forEach((M,P)=>{if(P!==d&&M!==m.dims[P])throw new Error("non concat dimensions must match")})}})},sx=(o,d)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${o}u>(${d});
    for (var i: u32 = 0u; i < ${o}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${o}u;
  }`,ix=(o,d)=>{let _=o.length,m=[];for(let g=0;g<_;++g){let y=d.setByOffset("global_idx",o[g].getByIndices("indices"));_===1?m.push(y):g===0?m.push(`if (inputIndex == ${g}u) { ${y} }`):g===_-1?m.push(`else { ${y} }`):m.push(`else if (inputIndex == ${g}) { ${y} }`)}return m.join(`
`)},Hy=(o,d,_,m)=>{let g=wr.size(_),y=new Array(o.length),b=new Array(o.length),E=0,M=[],P=[],U=[{type:12,data:g}];for(let fe=0;fe<o.length;++fe)E+=o[fe].dims[d],y[fe]=E,P.push(o[fe].dims.length),b[fe]=S(`input${fe}`,m,P[fe]),M.push("rank"),U.push({type:12,data:y[fe]});for(let fe=0;fe<o.length;++fe)U.push(...qs(o[fe].dims));U.push(...qs(_));let N=be("output",m,_.length),T=N.indicesGet("indices",d),ae=Array.from(Array(y.length).keys()).map(fe=>`uniforms.sizeInConcatAxis${fe}`).join(","),ue=fe=>`

  ${(()=>{fe.registerUniform("outputSize","u32");for(let Ae=0;Ae<o.length;Ae++)fe.registerUniform(`sizeInConcatAxis${Ae}`,"u32");return fe.declareVariables(...b,N)})()}

  ${sx(y.length,ae)}

  ${fe.mainStart()}
    ${fe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${N.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${T});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${y.length}u>(${ae});
      ${T} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${ix(b,N)}
  }`;return{name:"Concat",shaderCache:{hint:`${d}`,inputDependencies:M},getRunData:()=>({outputs:[{dims:_,dataType:m}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:U}),getShaderSource:ue}},ax=(o,d)=>{let _=o.inputs,m=_[0].dims,g=wr.normalizeAxis(d.axis,m.length);ox(_,g);let y=m.slice();y[g]=_.reduce((E,M)=>E+(M.dims.length>g?M.dims[g]:0),0);let b=_.filter(E=>wr.size(E.dims)>0);o.compute(Hy(b,g,y,_[0].dataType),{inputs:b})},lx=o=>ka({axis:o.axis})}),x_,v_,T_,Xy,c_=p(()=>{ya(),fa(),x_=(o,d,_="f32")=>{switch(o.activation){case"Relu":return`value = max(value, ${d}(0.0));`;case"Sigmoid":return`value = (${d}(1.0) / (${d}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${d}(${_}(uniforms.clip_min)), ${d}(${_}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${d}(0.0), min(${d}(1.0), ${_}(uniforms.alpha) * value + ${_}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${_}(uniforms.alpha) * value, value, value >= ${d}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${o.activation}`)}},v_=(o,d)=>{o.activation==="Clip"?d.push({type:1,data:o.clipMax},{type:1,data:o.clipMin}):o.activation==="HardSigmoid"?d.push({type:1,data:o.alpha},{type:1,data:o.beta}):o.activation==="LeakyRelu"&&d.push({type:1,data:o.alpha})},T_=(o,d)=>{o.activation==="Clip"?d.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):o.activation==="HardSigmoid"?d.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):o.activation==="LeakyRelu"&&d.push({name:"alpha",type:"f32"})},Xy=o=>{let d=(o==null?void 0:o.activation)||"";if(d==="HardSigmoid"){let[_,m]=(o==null?void 0:o.activation_params)||[.2,.5];return{activation:d,alpha:_,beta:m}}else if(d==="Clip"){let[_,m]=(o==null?void 0:o.activation_params)||[ba,vd];return{activation:d,clipMax:m,clipMin:_}}else if(d==="LeakyRelu"){let[_]=(o==null?void 0:o.activation_params)||[.01];return{activation:d,alpha:_}}return{activation:d}}}),Ed,Yy,K_=p(()=>{Ed=(o,d)=>{switch(o){case 1:return d;case 2:return`vec2<${d}>`;case 3:return`vec3<${d}>`;case 4:return`vec4<${d}>`;default:throw new Error(`${o}-component is not supported.`)}},Yy=o=>`
      ${o?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Qy,dx=p(()=>{Qy=o=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${o}.x), i32(${o}.y), i32(${o}.z), 1));
}
`}),Zy,cx,dg,hg,px,Rg,_x,Jy,jg=p(()=>{ya(),fa(),Xo(),c_(),K_(),Zy=(o,d)=>o?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${d?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${d?", batchIndices":""});
        `,cx=(o,d)=>o?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${d===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${d===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${d===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,dg=(o,d,_="f32",m,g=!1,y=32,b=!1,E=32)=>{let M=d[1]*o[1],P=d[0]*o[0],U=g?M:y,N=g?y:M,T=U/d[0],ae=y/d[1];if(!((g&&T===4&&o[1]===4||!g&&(T===3||T===4))&&U%d[0]===0&&y%d[1]===0&&o[0]===4))throw new Error(`If transposeA ${g} is true, innerElementSize ${T} and workPerThread[1] ${o[1]} must be 4.
      Otherwise, innerElementSize ${T} must be 3 or 4.
  tileAWidth ${U} must be divisible by workgroupSize[0]${d[0]}. tileInner ${y} must be divisible by workgroupSize[1] ${d[1]}. colPerThread ${o[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${T}<${_}>, ${U/T}>, ${N}>;
var<workgroup> mm_Bsub: array<array<vec4<${_}>, ${P/o[0]}>, ${y}>;

const rowPerThread = ${o[1]};
const colPerThread = ${o[0]};
const innerElementSize = ${T};
const tileInner = ${y};

@compute @workgroup_size(${d[0]}, ${d[1]}, ${d[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${b?"0":"i32(globalId.z)"};
  ${m?`let batchIndices = ${m.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${M};

  let num_tiles = ${b?`${Math.ceil(E/y)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${b?`i32(globalId.z) * ${E}`:"0"};

  var acc: array<vec4<${_}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${ae};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Zy(g,m)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${ae}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${m?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${T===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${cx(g,T)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},hg=(o,d)=>o?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${d?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${d?", batchIndices":""});
            `,px=o=>o?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Rg=(o,d,_="f32",m,g=!1,y=32,b=!1,E=32,M=!1)=>{let P=o[1]*d[1],U=o[0]*d[0],N=g?P:y,T=g?y:P;if(!(T%d[1]===0&&N%d[0]===0&&y%d[1]===0))throw new Error(`tileAHight ${T} must be divisible by workgroupSize[1]${d[1]}, tileAWidth ${N} must be divisible by workgroupSize[0]${d[0]}, tileInner ${y} must be divisible by workgroupSize[1]${d[1]}`);let ae=T/d[1],ue=N/d[0],fe=y/d[1],Ae=M?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${P};
    let globalColStart = i32(workgroupId.x) * ${U};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${T}; inputRow = inputRow + ${d[1]}) {
        for (var inputCol = localCol; inputCol < ${N}; inputCol = inputCol + ${d[0]}) {
          ${hg(g,m)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${d[1]}) {
            for (var inputCol = localCol; inputCol < ${U}; inputCol = inputCol + ${d[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${m?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${_}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${d[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${g?`mm_Asub[k][localRow + innerRow * ${d[1]}];`:`mm_Asub[localRow + innerRow * ${d[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${d[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${d[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${P};

let tileRowA = i32(localId.y) * ${ae};
let tileColA = i32(localId.x) * ${ue};
let tileRowB = i32(localId.y) * ${fe};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${ae}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${ue}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${hg(g,m)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${fe}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${m?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${_}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${px(g)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${_}, ${N}>, ${T}>;
  var<workgroup> mm_Bsub : array<array<${_}, ${U}>, ${y}>;
  const rowPerThread = ${o[1]};
  const colPerThread = ${o[0]};
  const tileInner = ${y};

@compute @workgroup_size(${d[0]}, ${d[1]}, ${d[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${b?"0":"i32(globalId.z)"};
    ${m?`let batchIndices = ${m.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${b?`${Math.ceil(E/y)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${b?`i32(globalId.z) * ${E}`:"0"};

    var acc : array<array<${_}, colPerThread>, rowPerThread>;
    ${Ae}
  }
`},_x=(o,d,_,m,g,y=!1)=>{let[b,E,M]=g,[P,U,N,T]=m,ae=Lo(b,M),ue=Lo(E,M),fe=Fa(m[0].type.tensor),Ae=()=>{let Oe=U.rank,pt=P.rank,lt=`var aIndices: ${U.type.indices};`;for(let ft=Oe-2-1,nn=pt-1;ft>=0;ft--,nn--)lt+=`
aIndices[${ft}] = ${pt>1?`batchIndices[${nn}]`:"batchIndices"};`;return ae.forEach(ft=>{lt+=`
aIndices[${ft}] = 0;`}),lt+=`
aIndices[${Oe-2}] = u32(row);
                   aIndices[${Oe-1}] = u32(colIn);`,lt},Le=()=>{let Oe=N.rank,pt=P.rank,lt=`var bIndices: ${N.type.indices};`;for(let ft=Oe-2-1,nn=pt-1;ft>=0;ft--,nn--)lt+=`
bIndices[${ft}] = ${pt>1?`batchIndices[${nn}]`:"batchIndices"};`;return ue.forEach(ft=>{lt+=`
bIndices[${ft}] = 0;`}),lt+=`
bIndices[${Oe-2}] = u32(row);
                   bIndices[${Oe-1}] = u32(colIn);`,lt};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${P.type.indices}) -> ${Ed(o,fe)} {
      var value = ${Ed(o,fe)}(0.0);
      let col = colIn * ${o};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${Ae()}
        value = ${U.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${P.type.indices}) -> ${Ed(o,fe)} {
      var value = ${Ed(o,fe)}(0.0);
      let col = colIn * ${o};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${Le()}
        value = ${N.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ed(o,fe)}) {
      let col = colIn * ${o};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${d?`value = value + ${y?"bias[colIn]":`${Ed(o,fe)}(bias[row])`};`:""}
        ${_}
        ${T.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Jy=(o,d,_,m,g=!1,y)=>{let b=o[0].dims,E=o[1].dims,M=b.slice(0,-2),P=E.slice(0,-2),U=m?m.slice(0,-2):_.slice(0,-2),N=wr.size(U),T=b[b.length-2],ae=b[b.length-1],ue=E[E.length-1],fe=ae%4===0&&ue%4===0,Ae=T<=8?[4,1,1]:[4,4,1],Le=[8,8,1],Oe=[Math.ceil(ue/Le[0]/Ae[0]),Math.ceil(T/Le[1]/Ae[1]),Math.ceil(N/Le[2]/Ae[2])],pt=fe?4:1,lt=[...M,T,ae/pt],ft=lt.length,nn=[...P,ae,ue/pt],Er=nn.length,Do=[N,T,ue/pt],aa=[{type:6,data:T},{type:6,data:ue},{type:6,data:ae}];v_(d,aa),aa.push(...qs(U,lt,nn));let pa=["rank","rank"],Ia=o.length>2;Ia&&(aa.push(...qs(o[2].dims)),pa.push("rank")),aa.push(...qs(Do));let Da=wa=>{let uu=U.length,yu=wt("batchDims",o[0].dataType,uu,1),Ra=Fa(o[0].dataType),fu=S("a",o[0].dataType,ft,pt),ga=S("b",o[1].dataType,Er,pt),Ea=be("result",o[0].dataType,Do.length,pt),Xa=[fu,ga];if(Ia){let Uu=g?pt:1;Xa.push(S("bias",o[2].dataType,o[2].dims.length,Uu))}let on=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];T_(d,on);let Zs=Fa(Ea.type.tensor),Ma=x_(d,Ea.type.value,Zs),pu=_x(pt,Ia,Ma,[yu,fu,ga,Ea],[M,P,U],g);return`
  ${wa.registerUniforms(on).registerInternalVariables(yu).declareVariables(...Xa,Ea)}
  ${pu}
  ${fe?dg(Ae,Le,Ra,yu):Rg(Ae,Le,Ra,yu)}
                   `};return{name:"MatMul",shaderCache:{hint:`${Ae};${d.activation};${fe};${g}`,inputDependencies:pa},getRunData:()=>({outputs:[{dims:y?y(_):_,dataType:o[0].dataType}],dispatchGroup:{x:Oe[0],y:Oe[1],z:Oe[2]},programUniforms:aa}),getShaderSource:Da}}}),hx,ew,Yv=p(()=>{ya(),L(),Xo(),c_(),K_(),dx(),jg(),hx=(o,d,_,m,g=!1,y,b=4,E=4,M=4,P="f32")=>{let U=aa=>{switch(aa){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${P}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${aa} is not supported.`)}},N=aa=>{switch(aa){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${aa} is not supported.`)}},T=o?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,ae=o?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,ue=o?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",fe=o?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Ae=o?"row":"col",Le=o?"col":"row",Oe=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Ae} / outWidth;
    let outCol = ${Ae} % outWidth;

    let WRow = ${Le} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${Le} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${Le} % inChannels;
    var resData = ${Ed(b,P)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${ue} && xCol >= 0 && xCol < ${fe}) {
      ${T}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${U(b)}
    }
    return resData;`,pt=o?d&&m?`
    let col = colIn * ${b};
    ${Oe}`:`
    let col = colIn * ${b};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${Oe}
    }
    return ${Ed(b,P)}(0.0);`:m&&_?`
    let col = colIn * ${b};
    ${Oe}`:`
    let col = colIn * ${b};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${Oe}
    }
    return ${Ed(b,P)}(0.0);`,lt=`${N(E)}`,ft=Ed(M,P),nn=Ed(o?b:E,P),Er=Ed(o?E:b,P),Do=x_(y,ft,P);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${nn} {
      ${o?pt:lt}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Er} {
      ${o?lt:pt}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${ft}) {
      let col = colIn * ${M};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${ae}
      ${Yy(g)}
      ${Do}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},ew=(o,d,_,m,g,y,b,E,M)=>{let P=d.format==="NHWC",U=P?o[0].dims[3]:o[0].dims[1],N=_[0],T=P?_[2]:_[3],ae=P?_[1]:_[2],ue=P?_[3]:_[1],fe=P&&(U%4===0||U%3===0)&&ue%4===0,Ae=P?ue:T*ae,Le=P?T*ae:ue,Oe=[8,8,1],pt=m<=8?[4,1,1]:[4,4,1],lt=[Math.ceil(Ae/Oe[0]/pt[0]),Math.ceil(Le/Oe[1]/pt[1]),Math.ceil(N/Oe[2]/pt[2])];Pt("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${lt}`);let ft=fe?P&&U%4!==0?3:4:1,nn=Oe[1]*pt[1],Er=Oe[0]*pt[0],Do=Math.max(Oe[0]*ft,Oe[1]),aa=m%nn===0,pa=g%Er===0,Ia=y%Do===0,Da=fe?[ft,4,4]:[1,1,1],wa=[{type:6,data:m},{type:6,data:g},{type:6,data:y},{type:6,data:[d.pads[0],d.pads[1]]},{type:6,data:d.strides},{type:6,data:d.dilations}];v_(d,wa),wa.push(...qs(o[0].dims,o[1].dims));let uu=["rank","rank"];b&&(wa.push(...qs(o[2].dims)),uu.push("rank")),wa.push(...qs(_));let yu=Ra=>{let fu=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];T_(d,fu);let ga=fe?4:1,Ea=Fa(o[0].dataType),Xa=`
      fn setOutputAtIndex(flatIndex : i32, value : ${fe?`vec4<${Ea}>`:Ea}) {
        result[flatIndex] = ${fe?`vec4<${Ea}>`:Ea}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${fe?`vec4<${Ea}>`:Ea}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${fe?"/ 4":""}, value);
      }`,on=S("x",o[0].dataType,o[0].dims.length,ft===3?1:ft),Zs=S("w",o[1].dataType,o[1].dims.length,ga),Ma=[on,Zs],pu=be("result",o[0].dataType,_.length,ga);if(b){let Uu=S("bias",o[2].dataType,o[2].dims.length,ga);Ma.push(Uu),Xa+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${fe?`vec4<${Ea}>`:Ea} {
          return bias[coords.${P?"w":"y"}${fe?"/ 4":""}];
        }`}return`
        ${Qy("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Ra.registerUniforms(fu).declareVariables(...Ma,pu)}
        ${Xa}
        ${hx(P,aa,pa,Ia,b,d,Da[0],Da[1],Da[2],Ea)}
        ${fe?dg(pt,Oe,Ea,void 0,!P,Do):Rg(pt,Oe,Ea,void 0,!P,Do,!1,void 0,E)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${d.cacheKey};${ft};${fe};${aa};${pa};${Ia};${nn};${Er};${Do}`,inputDependencies:uu},getRunData:()=>({outputs:[{dims:M?M(_):_,dataType:o[0].dataType}],dispatchGroup:{x:lt[0],y:lt[1],z:lt[2]},programUniforms:wa}),getShaderSource:yu}}}),fx,zg,q_,mx,p_,gx,bx,yx,Qv=p(()=>{ya(),L(),fa(),Xo(),c_(),K_(),fx=o=>{let d=1;for(let _=0;_<o.length;_++)d*=o[_];return d},zg=o=>typeof o=="number"?[o,o,o]:o,q_=(o,d)=>d<=1?o:o+(o-1)*(d-1),mx=(o,d,_,m=1)=>{let g=q_(d,m);return Math.floor((o[0]*(_-1)-_+g)/2)},p_=(o,d,_,m,g)=>{g==null&&(g=mx(o,d[0],m[0]));let y=[0,0,0,_];for(let b=0;b<3;b++)o[b]+2*g>=d[b]&&(y[b]=Math.trunc((o[b]-d[b]+2*g)/m[b]+1));return y},gx=(o,d,_,m,g,y,b,E,M,P)=>{let U,N,T,ae;if(o==="VALID"&&(o=0),typeof o=="number"){U={top:o,bottom:o,left:o,right:o,front:o,back:o};let ue=p_([d,_,m,1],[E,M,P],1,[g,y,b],o);N=ue[0],T=ue[1],ae=ue[2]}else if(Array.isArray(o)){if(!o.every((fe,Ae,Le)=>fe===Le[0]))throw Error(`Unsupported padding parameter: ${o}`);U={top:o[0],bottom:o[1],left:o[2],right:o[3],front:o[4],back:o[5]};let ue=p_([d,_,m,1],[E,M,P],1,[g,y,b],o[0]);N=ue[0],T=ue[1],ae=ue[2]}else if(o==="SAME_UPPER"){N=Math.ceil(d/g),T=Math.ceil(_/y),ae=Math.ceil(m/b);let ue=(N-1)*g+E-d,fe=(T-1)*y+M-_,Ae=(ae-1)*b+P-m,Le=Math.floor(ue/2),Oe=ue-Le,pt=Math.floor(fe/2),lt=fe-pt,ft=Math.floor(Ae/2),nn=Ae-ft;U={top:pt,bottom:lt,left:ft,right:nn,front:Le,back:Oe}}else throw Error(`Unknown padding parameter: ${o}`);return{padInfo:U,outDepth:N,outHeight:T,outWidth:ae}},bx=(o,d,_,m,g,y=!1,b="channelsLast")=>{let E,M,P,U,N;if(b==="channelsLast")[E,M,P,U,N]=o;else if(b==="channelsFirst")[E,N,M,P,U]=o;else throw new Error(`Unknown dataFormat ${b}`);let[T,,ae,ue,fe]=d,[Ae,Le,Oe]=zg(_),[pt,lt,ft]=zg(m),nn=q_(ae,pt),Er=q_(ue,lt),Do=q_(fe,ft),{padInfo:aa,outDepth:pa,outHeight:Ia,outWidth:Da}=gx(g,M,P,U,Ae,Le,Oe,nn,Er,Do),wa=y?T*N:T,uu=[0,0,0,0,0];return b==="channelsFirst"?uu=[E,wa,pa,Ia,Da]:b==="channelsLast"&&(uu=[E,pa,Ia,Da,wa]),{batchSize:E,dataFormat:b,inDepth:M,inHeight:P,inWidth:U,inChannels:N,outDepth:pa,outHeight:Ia,outWidth:Da,outChannels:wa,padInfo:aa,strideDepth:Ae,strideHeight:Le,strideWidth:Oe,filterDepth:ae,filterHeight:ue,filterWidth:fe,effectiveFilterDepth:nn,effectiveFilterHeight:Er,effectiveFilterWidth:Do,dilationDepth:pt,dilationHeight:lt,dilationWidth:ft,inShape:o,outShape:uu,filterShape:d}},yx=(o,d,_,m,g,y)=>{let b=y==="channelsLast";b?o[0].dims[3]:o[0].dims[1];let E=[64,1,1],M={x:_.map((Ae,Le)=>Le)},P=[Math.ceil(fx(M.x.map(Ae=>_[Ae]))/E[0]),1,1];Pt("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${P}`);let U=1,N=wr.size(_),T=[{type:12,data:N},{type:12,data:m},{type:12,data:g},{type:12,data:d.strides},{type:12,data:d.dilations}];v_(d,T),T.push(...qs(o[0].dims,o[1].dims));let ae=["rank","rank"],ue=o.length===3;ue&&(T.push(...qs(o[2].dims)),ae.push("rank")),T.push(...qs(_));let fe=Ae=>{let Le=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:m.length},{name:"pads",type:"u32",length:g.length},{name:"strides",type:"u32",length:d.strides.length},{name:"dilations",type:"u32",length:d.dilations.length}];T_(d,Le);let Oe=1,pt=Fa(o[0].dataType),lt=S("x",o[0].dataType,o[0].dims.length,U),ft=S("W",o[1].dataType,o[1].dims.length,Oe),nn=[lt,ft],Er=be("result",o[0].dataType,_.length,Oe),Do="";if(ue){let Ia=S("bias",o[2].dataType,o[2].dims.length,Oe);nn.push(Ia),Do+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${pt} {
          return bias[${b?ca("coords",4,5):ca("coords",1,5)}];
        }`}let aa=Ed(U,pt),pa=x_(d,aa,pt);return`
            ${Do}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${lt.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${ft.getByIndices("aIndices")};
            }
          ${Ae.registerUniforms(Le).declareVariables(...nn,Er)}
          ${Ae.mainStart()}
          ${Ae.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${Er.offsetToIndices("global_idx")};
              let batch = ${ca("coords",0,lt.rank)};
              let d2 = ${b?ca("coords",lt.rank-1,lt.rank):ca("coords",1,lt.rank)};
              let xFRCCorner = vec3<u32>(${b?ca("coords",1,lt.rank):ca("coords",2,lt.rank)},
              ${b?ca("coords",2,lt.rank):ca("coords",3,lt.rank)},
              ${b?ca("coords",3,lt.rank):ca("coords",4,lt.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${b?ca("uniforms.x_shape",1,lt.rank):ca("uniforms.x_shape",2,lt.rank)};
              let xShapeZ = ${b?ca("uniforms.x_shape",2,lt.rank):ca("uniforms.x_shape",3,lt.rank)};
              let xShapeW = ${b?ca("uniforms.x_shape",3,lt.rank):ca("uniforms.x_shape",4,lt.rank)};
              let xShapeU = ${b?ca("uniforms.x_shape",4,lt.rank):ca("uniforms.x_shape",1,lt.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${b?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${b?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${b?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${b?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${ue?"value = value + getBiasByOutputCoords(coords)":""};
              ${pa}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${d.cacheKey};${b};${U};${ue}`,inputDependencies:ae},getRunData:()=>({outputs:[{dims:_,dataType:o[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]},programUniforms:T}),getShaderSource:fe}}}),tw,wx,Zv=p(()=>{ya(),fa(),Xo(),c_(),tw=(o,d,_,m)=>{let g=o.length>2,y=g?"value += b[output_channel];":"",b=o[0].dims,E=o[1].dims,M=d.format==="NHWC",P=M?_[3]:_[1],U=P/d.group,N=M&&U>=4?La(P):1,T=wr.size(_)/N,ae=[{type:12,data:T},{type:12,data:d.dilations},{type:12,data:[d.strides[0],d.strides[1]]},{type:12,data:[d.pads[0],d.pads[1]]},{type:12,data:U}];v_(d,ae),ae.push(...qs(b,[E[0],E[1],E[2],E[3]/N]));let ue=g?["rank","rank","rank"]:["rank","rank"];ae.push(...qs([_[0],_[1],_[2],_[3]/N]));let fe=Ae=>{let Le=be("output",o[0].dataType,_.length,N),Oe=Fa(Le.type.tensor),pt=x_(d,Le.type.value,Oe),lt=S("x",o[0].dataType,b.length),ft=S("w",o[1].dataType,E.length,N),nn=[lt,ft];g&&nn.push(S("b",o[2].dataType,o[2].dims,N));let Er=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:d.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];T_(d,Er);let Do=M?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${lt.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${ft.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${lt.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${ft.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${Ae.registerUniforms(Er).declareVariables(...nn,Le)}

  ${Ae.mainStart()}
    ${Ae.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${Le.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${M?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${M?1:2}], outputIndices[${M?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${N} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${M?2:1}];

    var value: ${Le.type.value} = ${Le.type.value}(0);
    ${Do}
    ${y}
    ${pt}
    ${Le.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${d.cacheKey}_${N}`,inputDependencies:ue},getRunData:()=>({outputs:[{dims:m?m(_):_,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:ae}),getShaderSource:fe}},wx=(o,d,_,m)=>{let g=o.length>2,y=La(_[3]),b=La(_[2]),E=wr.size(_)/y/b,M=[o[0].dims[0],o[0].dims[1],o[0].dims[2],o[0].dims[3]/y],P=[o[1].dims[0],o[1].dims[1],o[1].dims[2],o[1].dims[3]/y],U=[_[0],_[1],_[2],_[3]/y],N=[{type:12,data:E},{type:6,data:[d.strides[0],d.strides[1]]},{type:6,data:[d.pads[0],d.pads[1]]}];v_(d,N),N.push(...qs(M,P,U));let T=(b-1)*d.strides[1]+P[1],ae=ue=>{let fe=be("output",o[0].dataType,U.length,y),Ae=Fa(fe.type.tensor),Le=x_(d,fe.type.value,Ae),Oe=S("x",o[0].dataType,M.length,y),pt=S("w",o[1].dataType,P.length,y),lt=[Oe,pt];g&&lt.push(S("b",o[2].dataType,o[2].dims,y));let ft=g?"value += b[output_channel];":"",nn=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return T_(d,nn),`
  ${ue.registerUniforms(nn).declareVariables(...lt,fe)}
  ${ue.mainStart()}
    ${ue.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${b}u;
    let col = (index1 % width1) * ${b}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${Oe.type.value}, ${T}>;
    var values: array<${fe.type.value}, ${b}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${P[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${T}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${Oe.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${Oe.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${P[1]}; w_width++) {
          let w_val = ${pt.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${b}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${b}u; i++) {
      var value = values[i];
      ${ft}
      ${Le}
      ${fe.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${d.cacheKey};${y};${b};${T};${P[0]};${P[1]}`,inputDependencies:g?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:m?m(_):_,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:N}),getShaderSource:ae}}}),rw,xx,Wg,vx=p(()=>{ya(),fa(),jg(),Xo(),c_(),rw=(o,d,_,m,g=!1,y)=>{let b=o[0].dims,E=o[1].dims,M=b[b.length-2],P=E[E.length-1],U=b[b.length-1],N=La(P),T=La(U),ae=La(M),ue=wr.size(_)/N/ae,fe=o.length>2,Ae=m?m.slice(0,-2):_.slice(0,-2),Le=[wr.size(Ae),M,P],Oe=[{type:12,data:ue},{type:12,data:M},{type:12,data:P},{type:12,data:U}];v_(d,Oe),Oe.push(...qs(Ae,b,E)),fe&&Oe.push(...qs(o[2].dims)),Oe.push(...qs(Le));let pt=lt=>{let ft=wt("batch_dims",o[0].dataType,Ae.length),nn=S("a",o[0].dataType,b.length,T),Er=S("b",o[1].dataType,E.length,N),Do=be("output",o[0].dataType,Le.length,N),aa=Fa(Do.type.tensor),pa=x_(d,Do.type.value,aa),Ia=[nn,Er],Da="";if(fe){let Xa=g?N:1;Ia.push(S("bias",o[2].dataType,o[2].dims.length,Xa)),Da=`${g?`value += bias[col / ${Xa}];`:`value += ${Do.type.value}(bias[row + i]);`}`}let wa=b.slice(0,-2),uu=E.slice(0,-2),yu=Lo(wa,Ae),Ra=Lo(uu,Ae),fu=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];T_(d,fu);let ga=(Xa,on)=>{let Zs=Xa.rank,Ma=Xa.name;if(Zs===2)return`var ${Ma}_indices = ${Xa.type.indices}(0u, 0u);`;let pu=ft.rank,Uu=`var ${Ma}_indices: ${Xa.type.indices};`;for(let hd=Zs-2-1,ih=pu-1;hd>=0;hd--,ih--)Uu+=`
${Ma}_indices[${hd}] = ${pu>1?`batch_indices[${ih}]`:"batch_indices"};`;return on.forEach(hd=>{Uu+=`
${Ma}_indices[${hd}] = 0;`}),Uu+=`${Ma}_indices[${Zs-2}] = 0u;
                     ${Ma}_indices[${Zs-1}] = 0u;`,Uu},Ea=()=>{let Xa=`var a_data: ${nn.type.value};`;for(let on=0;on<T;on++)Xa+=`
              let b_data${on} = b[(b_offset + (k + ${on}) * uniforms.N + col) / ${N}];`;for(let on=0;on<ae;on++){Xa+=`a_data = a[(a_offset + (row + ${on}) * uniforms.K + k) / ${T}];`;for(let Zs=0;Zs<T;Zs++)Xa+=`
            values[${on}] = fma(${Er.type.value}(a_data${T===1?"":`[${Zs}]`}), b_data${Zs}, values[${on}]);
`}return Xa};return`
  ${lt.registerUniforms(fu).registerInternalVariables(ft).declareVariables(...Ia,Do)}
  ${lt.mainStart()}
    ${lt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${N})) * ${N};
    var index1 = global_idx / (uniforms.N / ${N});
    let stride1 = uniforms.M / ${ae};
    let row = (index1 % stride1) * ${ae};
    let batch = index1 / stride1;

    ${_.length===2?"":`let batch_indices = ${ft.offsetToIndices("batch")};`}
    ${ga(nn,yu)}
    let a_offset = ${nn.indicesToOffset("a_indices")};
    ${ga(Er,Ra)}
    let b_offset = ${Er.indicesToOffset("b_indices")};
    var values: array<${Do.type.value}, ${ae}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${T}) {
      ${Ea()}
    }
    for (var i = 0u; i < ${ae}u; i++) {
      var value = values[i];
      ${Da}
      ${pa}
      let cur_indices = ${Do.type.indices}(batch, row + i, col);
      let offset = ${Do.indicesToOffset("cur_indices")};
      ${Do.setByOffset(`offset / ${N}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${d.activation};${N};${T};${ae};${g}`,inputDependencies:fe?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:y?y(_):_,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(ue/64)},programUniforms:Oe}),getShaderSource:pt}},xx=o=>{if(!o||o.length!==2)throw new Error("MatMul requires 2 inputs.");if(o[0].dims[o[0].dims.length-1]!==o[1].dims[o[1].dims.length-2])throw new Error("shared dimension does not match.")},Wg=o=>{xx(o.inputs);let d=xd.calcShape(o.inputs[0].dims,o.inputs[1].dims,!0);if(!d)throw new Error("Can't use matmul on the given tensors");let _=d[d.length-1],m=o.inputs[0].dims[o.inputs[0].dims.length-1];_<8&&m<8?o.compute(rw(o.inputs,{activation:""},d)):o.compute(Jy(o.inputs,{activation:""},d))}}),Tx,Vg,H_,Kg,nw,ow,Ex,qg,sw,Jv=p(()=>{fa(),Yv(),Qv(),jg(),Zv(),c_(),vx(),ru(),Tx=(o,d,_,m,g,y)=>{let b=o[0],E=o.slice(y?1:2,y?3:4),M=E.length,P=d[0],U=d.slice(2).map((T,ae)=>T+(T-1)*(_[ae]-1)),N=E.map((T,ae)=>T+m[ae]+m[ae+M]).map((T,ae)=>Math.floor((T-U[ae]+g[ae])/g[ae]));return N.splice(0,0,b),N.splice(y?3:1,0,P),N},Vg=[2,3,1,0],H_=(o,d)=>{if(!o||o.length!==2&&o.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(o[0].dims.length>5)throw new Error("greater than 5D is not supported");if(o[0].dims.length!==o[1].dims.length)throw new Error("filter does not have same dimension as input");let _=o[0].dims[d.format==="NHWC"?o[0].dims.length-1:1],m=o[1].dims[1]*d.group;if(_!==m)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(o.length===3&&(o[2].dims.length!==1||o[1].dims[0]!==o[2].dims[0]))throw new Error("invalid bias");let g=o[0].dims.length-2;if(d.dilations.length!==g)throw new Error(`dilations should be ${g}D`);if(d.strides.length!==g)throw new Error(`strides should be ${g}D`);if(d.pads.length!==g*2)throw new Error(`pads should be ${g*2}D`);if(d.kernelShape.length!==0&&d.kernelShape.length!==o[1].dims.length-2)throw new Error("invalid kernel shape")},Kg=(o,d)=>{let _=o.kernelShape.slice();_.length<d[1].dims.length-2&&_.push(...Array(d[1].dims.length-2-_.length).fill(0));for(let y=2;y<d[1].dims.length;++y)_[y-2]===0&&(_[y-2]=d[1].dims[y]);let m=o.pads.slice();Su.adjustPadsBasedOnAutoPad(d[0].dims,o.strides,o.dilations,_,m,o.format==="NHWC",o.autoPad);let g=Object.assign({},o);return Object.assign(g,{kernelShape:_,pads:m}),g},nw=o=>{let d=Xy(o),_=o.format,m=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][o.auto_pad],g=o.dilations,y=o.group,b=o.kernel_shape,E=o.pads,M=o.strides,P=o.w_is_const();return{autoPad:m,format:_,dilations:g,group:y,kernelShape:b,pads:E,strides:M,wIsConst:P,...d,cacheKey:`${o.format};${d.activation};`}},ow=(o,d,_,m)=>{let g=_.format==="NHWC",y=Tx(d[0].dims,d[1].dims,_.dilations,_.pads,_.strides,g);if(_.group!==1){let nn=[d[0]];if(g){let Er=o.kernelCustomData.wT??o.compute(Td(d[1],Vg),{inputs:[1],outputs:[_.wIsConst?-2:-1]})[0];_.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=Er),nn.push(Er)}else nn.push(d[1]);d.length===3&&nn.push(d[2]),!o.adapterInfo.isArchitecture("ampere")&&g&&d[1].dims[0]===_.group&&d[1].dims[1]===1&&_.dilations[0]===1&&_.dilations[1]===1?o.compute(wx(nn,_,y,m),{inputs:nn}):o.compute(tw(nn,_,y,m),{inputs:nn});return}let b=d.length===3,E=d[0].dims[g?1:2],M=d[0].dims[g?2:3],P=d[0].dims[g?3:1],U=d[1].dims[2],N=d[1].dims[3],T=y[g?1:2],ae=y[g?2:3],ue=y[g?3:1],fe=g&&U===E&&N===M&&_.pads[0]===0&&_.pads[1]===0;if(fe||U===1&&N===1&&_.dilations[0]===1&&_.dilations[1]===1&&_.strides[0]===1&&_.strides[1]===1&&_.pads[0]===0&&_.pads[1]===0){let nn=y[0],Er,Do,aa,pa=[];if(g){let wa=o.kernelCustomData.wT??o.compute(Td(d[1],Vg),{inputs:[1],outputs:[_.wIsConst?-2:-1]})[0];if(_.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=wa),fe){let uu=E*M*P;Er=d[0].reshape([1,nn,uu]),Do=wa.reshape([1,uu,ue]),aa=[1,nn,ue]}else Er=d[0].reshape([nn,E*M,P]),Do=wa.reshape([1,P,ue]),aa=[nn,T*ae,ue];pa.push(Er),pa.push(Do)}else Er=d[0].reshape([nn,P,E*M]),Do=d[1].reshape([1,ue,P]),aa=[nn,ue,T*ae],pa.push(Do),pa.push(Er);b&&pa.push(d[2]);let Ia=aa[2],Da=pa[0].dims[pa[0].dims.length-1];Ia<8&&Da<8?o.compute(rw(pa,_,y,aa,g,m),{inputs:pa}):o.compute(Jy(pa,_,y,aa,g,m),{inputs:pa});return}let Ae=!0,Le=o.kernelCustomData.wT??o.compute(Td(d[1],Vg),{inputs:[1],outputs:[_.wIsConst?-2:-1]})[0];_.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=Le);let Oe=[d[0],Le];b&&Oe.push(d[2]);let pt=g?T*ae:ue,lt=g?ue:T*ae,ft=U*N*P;o.compute(ew(Oe,_,y,pt,lt,ft,b,Ae,m),{inputs:Oe})},Ex=(o,d)=>{let _=d.format==="NHWC",m=[o.inputs[0].reshape(_?[o.inputs[0].dims[0],1,o.inputs[0].dims[1],o.inputs[0].dims[2]]:[o.inputs[0].dims[0],o.inputs[0].dims[1],1,o.inputs[0].dims[2]]),o.inputs[1].reshape([o.inputs[1].dims[0],o.inputs[1].dims[1],1,o.inputs[1].dims[2]])];o.inputs.length===3&&m.push(o.inputs[2]);let g=[0,d.pads[0],0,d.pads[1]],y=[1].concat(d.strides),b=[1].concat(d.dilations),E=[1].concat(d.kernelShape),M=Kg({...d,pads:g,strides:y,dilations:b,kernelShape:E},m);ow(o,m,M,P=>_?[P[0],P[2],P[3]]:[P[0],P[1],P[3]])},qg=(o,d,_)=>{let m=_.format==="NHWC"?"channelsLast":"channelsFirst",g=Kg(_,d),y=_.autoPad==="NOTSET"?_.pads:_.autoPad,b=bx(d[0].dims,d[1].dims,_.strides,_.dilations,y,!1,m);o.compute(yx(d,g,b.outShape,[b.filterDepth,b.filterHeight,b.filterWidth],[b.padInfo.front,b.padInfo.top,b.padInfo.left],m))},sw=(o,d)=>{if(H_(o.inputs,d),o.inputs[0].dims.length===3)Ex(o,d);else if(o.inputs[0].dims.length===5)qg(o,o.inputs,d);else{let _=Kg(d,o.inputs);ow(o,o.inputs,_)}}}),Mx,eT,tT=p(()=>{ya(),L(),Xo(),c_(),K_(),dx(),jg(),Mx=(o,d=!1,_,m,g=4)=>{let y=Ae=>{switch(Ae){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${m}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${Ae} is not supported.`)}},b=o?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,E=o?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,M=o?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",P=o?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",U=o?"row":"col",N=o?"col":"row",T=`
      let inChannels = ${o?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${U} / outWidth;
      let outCol = ${U} % outWidth;

      let WRow = ${N} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${N} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${M}) || fract(xR) > 0.0) {
        return ${m}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${P}) || fract(xC) > 0.0) {
        return ${m}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${N} % inChannels;
      ${b}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${g}];`,ae=o?`
      let col = colIn * ${g};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${T}
      }
      return ${m}(0.0);`:`
      let col = colIn * ${g};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${T}
      }
      return ${m}(0.0);`,ue=`
      let col = colIn * ${g};
      let inChannels = ${o?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${o?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${y(g)}
      }
      return ${m}(0.0);
      `,fe=x_(_,m);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${m} {
    ${o?ae:ue}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${m} {
    ${o?ue:ae}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${m}) {
    let col = colIn * ${g};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${E}
      ${Yy(d)}
      ${fe}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${g}] = value;
    }
  }`},eT=(o,d,_,m,g,y,b,E)=>{let M=d.format==="NHWC",P=M?o[0].dims[3]:o[0].dims[1],U=_[0],N=M?_[2]:_[3],T=M?_[1]:_[2],ae=M?_[3]:_[1],ue=M&&P%4===0&&P%3&&ae%4===0,fe=M?ae:N*T,Ae=M?N*T:ae,Le=[8,8,1],Oe=m<=8?[4,1,1]:[4,4,1],pt=[Math.ceil(fe/Le[0]/Oe[0]),Math.ceil(Ae/Le[1]/Oe[1]),Math.ceil(U/Le[2]/Oe[2])];Pt("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${pt}`);let lt=ue?4:1,ft=Math.max(Le[0]*lt,Le[1]),nn=ue?4:1,Er=[d.kernelShape[M?1:2],d.kernelShape[M?2:3]],Do=[Er[0]+(d.dilations[0]<=1?0:(Er[0]-1)*(d.dilations[0]-1)),Er[1]+(d.dilations[1]<=1?0:(Er[1]-1)*(d.dilations[1]-1))],aa=[Do[0]-1-Math.floor((d.pads[0]+d.pads[2])/2),Do[1]-1-Math.floor((d.pads[1]+d.pads[3])/2)],pa=[{type:6,data:m},{type:6,data:g},{type:6,data:y},{type:6,data:d.strides},{type:6,data:d.dilations},{type:6,data:Er},{type:6,data:aa}];v_(d,pa),pa.push(...qs(o[0].dims,o[1].dims));let Ia=["rank","rank"];b&&(pa.push(...qs(o[2].dims)),Ia.push("rank")),pa.push(...qs(_));let Da=wa=>{let uu=S("x",o[0].dataType,o[0].dims.length,nn),yu=S("w",o[1].dataType,o[1].dims.length,1),Ra=be("result",o[0].dataType,_.length,nn),fu=[uu,yu],ga="";if(b){let on=S("bias",o[2].dataType,o[2].dims.length,nn);fu.push(on),ga+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${on.type.value} {
            return bias[coords.${M?"w":"y"}${ue?"/ 4":""}];
          }`}let Ea=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:Er.length},{name:"pads",type:"i32",length:aa.length}];T_(d,Ea);let Xa=Fa(o[0].dataType,1);if(Xa!=="f16"&&Xa!=="f32")throw new Error(`elemType ${Xa} is not supported.`);return`
        ${Qy("uniforms.result_strides")}
        ${wa.registerUniforms(Ea).declareVariables(...fu,Ra)};
        ${ga}
        ${Mx(M,b,d,uu.type.value,lt)}
        ${ue?dg(Oe,Le,Xa,void 0,!M,ft):Rg(Oe,Le,Xa,void 0,!M,ft,!1,void 0,E)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${d.cacheKey};${Oe};${Le};${ue}`,inputDependencies:Ia},getRunData:()=>({outputs:[{dims:_,dataType:o[0].dataType}],dispatchGroup:{x:pt[0],y:pt[1],z:pt[2]},programUniforms:pa}),getShaderSource:Da}}}),Px,iw,X_=p(()=>{ya(),L(),fa(),Xo(),Px=(o,d,_,m,g,y=!1,b,E,M=!1)=>{let P=M?1:2,U=M?2:3,N=M?3:1,T=y?2:1,ae=`
  fn setOutputAtIndex(flatIndex : u32, value : ${y?`vec4<${b}>`:b}) {
    result[flatIndex] = ${y?`vec4<${b}>`:b}(value);
  }`;m&&(ae+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${y?`vec4<${b}>`:b} {
      return bias[coords.${M?"w":"y"}${y?"/ 4":""}];
    }`);let ue=y?4:1,fe=S("W",d[1].dataType,d[1].dims.length,ue),Ae=S("Dy",d[0].dataType,d[0].dims.length,ue),Le=[Ae,fe];m&&Le.push(S("bias",d[2].dataType,[_[N]].length,ue));let Oe=be("result",d[0].dataType,_.length,ue),pt=`{
        let batch: u32 = ${g?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${g?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${g?"global_id.y":"workgroup_id.y"} * ${T};
        let d1: u32 = ${g?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${b}>, ${T}>;
        for (var i = 0; i < ${T}; i++) {
          dotProd[i] = vec4<${b}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${b}(dyCorner.x) + ${b}(wR)) / ${b}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${b}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${b}(dyCorner.y) + ${b}(wC)) / ${b}(uniforms.strides.y);
            let dyC2 = (${b}(dyCorner.y) + 1.0 + ${b}(wC)) / ${b}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${b}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${b}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Ae.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${b}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Ae.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${b}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${N}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Ae.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${b}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${fe.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Ae.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${b}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${T}; i = i + 1) {
          let value = dotProd[i] + ${m?"bias[c+i]":`vec4<${b}>(0.0)`};
          ${Oe.set("batch","r","c + i","d1","value")};
        }
      }`,lt=`
          let outputIndices = ${Oe.offsetToIndices("global_idx")};
          let batch = ${Oe.indicesGet("outputIndices",0)};
          let d1 = ${Oe.indicesGet("outputIndices",N)};
          let r = ${Oe.indicesGet("outputIndices",P)};
          let c = ${Oe.indicesGet("outputIndices",U)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${b}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${b}(dyRCorner) + ${b}(wR)) / ${b}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${b}(uniforms.Dy_shape[${P}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${b}(dyCCorner) + ${b}(wC)) / ${b}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${b}(uniforms.Dy_shape[${U}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${M?Ae.get("batch","idyR","idyC","inputChannel"):Ae.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${fe.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${m?"bias[d1]":`${b}(0.0)`};
          ${Oe.setByOffset("global_idx","value")};
        `;return`
  ${o.registerUniforms(E).declareVariables(...Le,Oe)}
  ${ae}

    ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${y?pt:lt}}`},iw=(o,d,_)=>{let m=o.length>2,g=d.outputShape,y=wr.size(g),b=[Math.ceil(y/64),1,1];Pt("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${b}`);let E=d.format==="NHWC",M=["rank","rank"],P=[d.strides[0],d.strides[1]],U=[d.kernelShape[E?1:2],d.kernelShape[E?2:3]],N=[d.dilations[0],d.dilations[1]],T=[U[0]+(d.dilations[0]<=1?0:(d.kernelShape[E?1:2]-1)*(d.dilations[0]-1)),U[1]+(d.dilations[1]<=1?0:(d.kernelShape[E?2:3]-1)*(d.dilations[1]-1))],ae=[T[0]-1-Math.floor((d.pads[0]+d.pads[2])/2),T[1]-1-Math.floor(d.pads[1]+d.pads[3])/2],ue=!1,fe=d.group,Ae=o[1].dims,Le=Ae[0]/fe,Oe=Ae[1],pt=[{type:12,data:y},{type:12,data:P},{type:12,data:U},{type:12,data:N},{type:12,data:T},{type:6,data:ae},{type:12,data:Le},{type:12,data:Oe},...qs(o[0].dims,o[1].dims)];m&&(pt.push(...qs(o[2].dims)),M.push("rank")),pt.push(...qs(g));let lt=b[1]===1&&b[2]===1,ft=nn=>{let Er=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:P.length},{name:"filter_dims",type:"u32",length:U.length},{name:"dilations",type:"u32",length:U.length},{name:"effective_filter_dims",type:"u32",length:T.length},{name:"pads",type:"i32",length:ae.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Do=Fa(o[0].dataType);return`${Px(nn,o,g,m,lt,ue,Do,Er,E)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${d.cacheKey};`,inputDependencies:M},getRunData:()=>({dispatchGroup:{x:b[0],y:b[1],z:b[2]},outputs:[{dims:_?_(g):g,dataType:o[0].dataType}],programUniforms:pt}),getShaderSource:ft}}}),kx,Ox,$x,aw,Ax,Hg,rT,Sx,Ix,Cx,nT=p(()=>{tT(),X_(),c_(),ru(),kx=(o,d,_,m,g,y)=>(o-1)*d+_+(m-1)*g+1-y,Ox=(o,d,_,m,g)=>{let y=Math.floor(o/2);d==="SAME_UPPER"?(_[m]=y,_[g]=o-y):d==="SAME_LOWER"&&(_[m]=o-y,_[g]=y)},$x=(o,d,_,m,g,y,b,E,M,P)=>{let U=o.length-2,N=P.length===0;M.length<U&&M.push(...Array(U-M.length).fill(0));let T=o[0],ae=d[E?3:1]*g;for(let ue=0,fe=o.length-U-(E?1:0);ue<U;++ue,++fe){let Ae=o[fe],Le=N?Ae*b[ue]:P[ue],Oe=kx(Ae,b[ue],y[ue],d[fe],_[ue],Le);Ox(Oe,m,y,ue,ue+U),N&&P.push(b[ue]*(Ae-1)+M[ue]+(d[fe]-1)*_[ue]+1-y[ue]-y[ue+U])}P.splice(0,0,T),P.splice(E?3:1,0,ae)},aw=(o,d)=>{let _=o.kernelShape.slice();if(o.kernelShape.length===0||o.kernelShape.reduce((N,T)=>N*T,1)===0){_.length=0;for(let N=2;N<d[1].dims.length;++N)_.push(d[1].dims[N])}let m=o.format==="NHWC";_.splice(0,0,d[1].dims[0]),_.splice(m?3:1,0,d[1].dims[1]);let g=o.pads.slice(),y=o.outputShape.slice(),b=o.outputPadding.slice(),E=d[0].dims,M=o.dilations.slice();if(M.reduce((N,T)=>N+T,0)===0){let N=d[0].dims.length-2;M=new Array(N).fill(1)}let P=o.strides.slice();if(P.reduce((N,T)=>N+T,0)===0){let N=d[0].dims.length-2;P=new Array(N).fill(1)}$x(E,_,M,o.autoPad,o.group,g,P,m,b,y);let U=Object.assign({},o);return Object.assign(U,{kernelShape:_,pads:g,outputPadding:b,outputShape:y,dilations:M,strides:P}),U},Ax=o=>{let d=Xy(o),_=o.format,m=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof o.autoPad>"u"?0:o.autoPad],g=o.dilations,y=o.group,b=o.kernelShape,E=o.pads,M=o.strides,P=o.wIsConst(),U=o.outputPadding,N=o.outputShape;return{autoPad:m,format:_,dilations:g,group:y,kernelShape:b,outputPadding:U,outputShape:N,pads:E,strides:M,wIsConst:P,...d,cacheKey:`${o.format};${d.activation};`}},Hg=(o,d)=>{if(!o||o.length!==2&&o.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(o[0].dims.length!==4&&o[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(o[0].dims.length!==o[1].dims.length)throw new Error("filter does not have same dimension as input");let _=o[0].dims[d.format==="NHWC"?o[0].dims.length-1:1],m=o[1].dims[0];if(_!==m)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let g=o[1].dims[1]*d.group;if(o.length===3&&(o[2].dims.length!==1||o[2].dims[0]!==g))throw new Error("invalid bias");let y=o[0].dims.length-2;if(d.dilations.reduce((b,E)=>b+E,0)>0&&d.dilations.length!==y)throw new Error(`dilations should be ${y}D`);if(d.strides.reduce((b,E)=>b+E,0)>0&&d.strides.length!==y)throw new Error(`strides should be ${y}D`);if(d.pads.reduce((b,E)=>b+E,0)>0&&d.pads.length!==y*2)throw new Error(`pads should be ${y*2}D`);if(d.outputPadding.length!==y&&d.outputPadding.length!==0)throw new Error(`output_padding should be ${y}D`);if(d.kernelShape.reduce((b,E)=>b+E,0)>0&&d.kernelShape.length!==0&&d.kernelShape.length!==o[1].dims.length-2)throw new Error("invalid kernel shape");if(d.outputShape.length!==0&&d.outputShape.length!==o[0].dims.length-2)throw new Error("invalid output shape")},rT=[2,3,1,0],Sx=(o,d,_)=>{let m=aw(_,d),g=_.format==="NHWC",y=m.outputShape,b=y[g?3:1],E=d[0].dims[g?3:1];if(m.group!==1||b===1&&E===1){o.compute(iw(d,m));return}let M=y[g?1:2],P=y[g?2:3],U=d[1].dims[2],N=d[1].dims[3],T=g?M*P:b,ae=g?b:M*P,ue=U*N*E,fe=!0,Ae=o.kernelCustomData.wT??o.compute(Td(d[1],rT),{inputs:[1],outputs:[_.wIsConst?-2:-1]})[0];_.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=Ae);let Le=[d[0],Ae],Oe=d.length===3;Oe&&(!g&&d[2].dims.length===1?Le.push(d[2].reshape([d[2].dims[0],1,1])):Le.push(d[2])),o.compute(eT(Le,m,y,T,ae,ue,Oe,fe),{inputs:Le})},Ix=(o,d)=>{let _=d.format==="NHWC",m=[o.inputs[0].reshape(_?[o.inputs[0].dims[0],1,o.inputs[0].dims[1],o.inputs[0].dims[2]]:[o.inputs[0].dims[0],o.inputs[0].dims[1],1,o.inputs[0].dims[2]]),o.inputs[1].reshape([o.inputs[1].dims[0],o.inputs[1].dims[1],1,o.inputs[1].dims[2]])];o.inputs.length===3&&m.push(o.inputs[2]);let g=d.kernelShape;(g.length===0||g[0]===0)&&(g=[o.inputs[1].dims[2]]);let y=d.dilations;(y.length===0||y[0]===0)&&(y=[1]);let b=d.strides;(b.length===0||b[0]===0)&&(b=[1]);let E=d.pads;E.length===0&&(E=[0,0]),E=[0,E[0],0,E[1]],b=[1].concat(b),y=[1].concat(y),g=[1].concat(g);let M=aw({...d,pads:E,strides:b,dilations:y,kernelShape:g},m);o.compute(iw(m,M,P=>_?[P[0],P[2],P[3]]:[P[0],P[1],P[3]]))},Cx=(o,d)=>{Hg(o.inputs,d),o.inputs[0].dims.length===3?Ix(o,d):Sx(o,o.inputs,d)}}),Dx,lw,Fx,oT=p(()=>{ya(),fa(),Va(),Xo(),Dx=(o,d,_,m)=>{let g=wr.size(d),y=d.length,b=S("input",o,y),E=be("output",o,y),M=_.dataType===6?_.getInt32Array()[0]:Number(_.getBigInt64Array()[0]),P=wr.normalizeAxis(M,y),U=N=>{let T=` i32(${b.indicesGet("inputIndices","uniforms.axis")}) `,ae=ca("uniforms.input_shape","uniforms.axis",y),ue=m.reverse?T+(m.exclusive?" + 1":""):"0",fe=m.reverse?ae:T+(m.exclusive?"":" + 1");return`
                ${N.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(b,E)}
                ${N.mainStart()}
                  ${N.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${E.offsetToIndices("global_idx")};
                  var sum = ${E.type.value}(0);
                  let first : i32 = ${ue};
                  let last : i32 = ${fe};
                  for (var i : i32 = first; i < last; i++) {
                    ${b.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${b.getByIndices("inputIndices")};
                  }
                  ${E.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:m.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:o}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},{type:12,data:P},...qs(d,d)]}),getShaderSource:U}},lw=(o,d)=>{let _=o.inputs[0].dims,m=o.inputs[0].dataType,g=o.inputs[1];o.compute(Dx(m,_,g,d),{inputs:[0]})},Fx=o=>{let d=o.exclusive===1,_=o.reverse===1;return ka({exclusive:d,reverse:_})}}),uw,Bx,Lx,dw,Rx,sT=p(()=>{ya(),fa(),Va(),Xo(),uw=o=>{if(!o||o.length!==1)throw new Error("DepthToSpace requires 1 input.");if(o[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Bx=(o,d,_,m)=>{let g=[];g.push(`fn perm(i: ${m.type.indices}) -> ${_.type.indices} {
    var a: ${_.type.indices};`);for(let y=0;y<d;++y)g.push(_.indicesSet("a",o[y],`i[${y}]`));return g.push("return a;}"),g.join(`
`)},Lx=(o,d)=>{let _,m,g,y,b,E,M=d.format==="NHWC",P=d.blocksize,U=d.mode==="DCR";M?([_,m,g,y]=o.dims,b=U?[_,m,g,P,P,y/P**2]:[_,m,g,y/P**2,P,P],E=U?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([_,m,g,y]=[o.dims[0],o.dims[2],o.dims[3],o.dims[1]],b=U?[_,P,P,y/P**2,m,g]:[_,y/P**2,P,P,m,g],E=U?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let N=o.reshape(b),T=N.dims.length,ae=o.dataType,ue=S("a",ae,T),fe=be("output",ae,T),Ae=Le=>`
  ${Le.registerUniform("output_size","u32").declareVariables(ue,fe)}

  ${Bx(E,T,ue,fe)}

  ${Le.mainStart()}
    ${Le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${fe.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${fe.setByOffset("global_idx",ue.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${o.dims};${d.blocksize};${d.mode}`,inputDependencies:["rank"]},getRunData:Le=>{let Oe=M?[_,m*P,g*P,y/P**2]:[_,y/P**2,m*P,g*P],pt=wr.size(Oe),lt=N.dims,ft=wr.sortBasedOnPerm(lt,E);return{outputs:[{dims:Oe,dataType:Le[0].dataType}],dispatchGroup:{x:Math.ceil(pt/64)},programUniforms:[{type:12,data:pt},...qs(lt,ft)]}},getShaderSource:Ae}},dw=(o,d)=>{uw(o.inputs),o.compute(Lx(o.inputs[0],d))},Rx=o=>ka({blocksize:o.blocksize,mode:o.mode,format:o.format})}),j_,Y_,cw,jx,zx,pw,Xg,Nx,Ux,Wx,_w,iT=p(()=>{ya(),fa(),Va(),Xo(),j_="[a-zA-Z]|\\.\\.\\.",Y_="("+j_+")+",cw="^"+Y_+"$",jx="("+Y_+",)*"+Y_,zx="^"+jx+"$",pw=class{constructor(o=-1){this.symbolToIndices=new Map,this.inputIndex=o}addSymbol(o,d){let _=this.symbolToIndices.get(o);_===void 0?_=[d]:_.push(d),this.symbolToIndices.set(o,_)}},Xg=class{constructor(o,d){var g;this.equation=d,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[_,m]=d.includes("->")?d.split("->",2):[d,""];if(!_.match(RegExp(zx)))throw new Error("Invalid LHS term");if(_.split(",").forEach((y,b)=>{let E=o[b].dims.slice();if(!y.match(RegExp(cw)))throw new Error("Invalid LHS term");let M=this.processTerm(y,!0,E,b);this.lhs.push(M)}),m==="")m+=[...this.symbolToInfo.entries()].filter(([y,b])=>b.count===1||y==="...").map(([y])=>y).join("");else if(!m.match(RegExp(Y_)))throw new Error("Invalid RHS");(g=m.match(RegExp(j_,"g")))==null||g.forEach(y=>{if(y==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let b=this.symbolToInfo.get(y);if(b===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(b.dimValue)}}),this.rhs=this.processTerm(m,!1,this.outputDims)}addSymbol(o,d,_){let m=this.symbolToInfo.get(o);if(m!==void 0){if(m.dimValue!==d&&m.count!==1)throw new Error("Dimension mismatch");m.count++,m.inputIndices.push(_)}else m={count:1,dimValue:d,inputIndices:[_]};this.symbolToInfo.set(o,m)}processTerm(o,d,_,m=-1){let g=_.length,y=!1,b=[],E=0;if(!o.match(RegExp(cw))&&!d&&o!=="")throw new Error("Invalid LHS term");let M=o.match(RegExp(j_,"g")),P=new pw(m);return M==null||M.forEach((U,N)=>{if(U==="..."){if(y)throw new Error("Only one ellipsis is allowed per input term");y=!0;let T=g-M.length+1;if(T<0)throw new Error("Ellipsis out of bounds");if(b=_.slice(E,E+T),this.hasEllipsis){if(this.ellipsisDims.length!==b.length||this.ellipsisDims.toString()!==b.toString())throw new Error("Ellipsis dimensions mismatch")}else if(d)this.hasEllipsis=!0,this.ellipsisDims=b;else throw new Error("Ellipsis must be specified in the LHS");for(let ae=0;ae<b.length;ae++){let ue=String.fromCharCode(48+ae);P.addSymbol(ue,N+ae),this.addSymbol(ue,_[E++],m)}}else P.addSymbol(U,N+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(U,_[E++],m)}),P}},Nx=o=>o+"_max",Ux=(o,d,_,m)=>{let g=o.map(P=>P.length).map((P,U)=>S(`input${U}`,d,P)),y=wr.size(m),b=be("output",d,m.length),E=[..._.symbolToInfo.keys()].filter(P=>!_.rhs.symbolToIndices.has(P)),M=P=>{let U=[],N="var prod = 1.0;",T="var sum = 0.0;",ae="sum += prod;",ue=[],fe=[],Ae=[],Le=[],Oe=_.symbolToInfo.size===_.rhs.symbolToIndices.size;_.symbolToInfo.forEach((lt,ft)=>{var nn;if(_.rhs.symbolToIndices.has(ft)){let Er=(nn=_.rhs.symbolToIndices.get(ft))==null?void 0:nn[0];Er!==void 0&&_.lhs.forEach((Do,aa)=>{if(lt.inputIndices.includes(aa)){let pa=Do.symbolToIndices.get(ft);if(pa===void 0)throw new Error("Invalid symbol error");pa.forEach(Ia=>{U.push(`${g[aa].indicesSet(`input${aa}Indices`,Ia,b.indicesGet("outputIndices",Er))}`)})}})}else _.lhs.forEach((Er,Do)=>{if(lt.inputIndices.includes(Do)){let aa=Er.symbolToIndices.get(ft);if(aa===void 0)throw new Error("Invalid symbol error");aa.forEach(pa=>{ue.push(`${g[Do].indicesSet(`input${Do}Indices`,pa,`${ft}`)}`)}),Le.push(`prod *= ${g[Do].getByIndices(`input${Do}Indices`)};`)}}),fe.push(`for(var ${ft}: u32 = 0; ${ft} < uniforms.${Nx(ft)}; ${ft}++) {`),Ae.push("}")});let pt=Oe?[...U,`let sum = ${g.map((lt,ft)=>lt.getByIndices(`input${ft}Indices`)).join(" * ")};`]:[...U,T,...fe,...ue,N,...Le,ae,...Ae];return`
            ${P.registerUniforms(E.map(lt=>({name:`${Nx(lt)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...g,b)}

            ${P.mainStart()}
            ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${b.offsetToIndices("global_idx")};
            ${g.map((lt,ft)=>`var input${ft}Indices: ${g[ft].type.indices};`).join(`
`)}
            ${pt.join(`
`)};
            ${b.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:_.equation,inputDependencies:o.map(()=>"rank")},getRunData:()=>{let P=E.filter(N=>_.symbolToInfo.has(N)).map(N=>{var T;return{type:12,data:((T=_.symbolToInfo.get(N))==null?void 0:T.dimValue)||0}});P.push({type:12,data:y});let U=o.map((N,T)=>[...qs(N)]).reduce((N,T)=>N.concat(T),P);return U.push(...qs(m)),{outputs:[{dims:m,dataType:d}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:U}},getShaderSource:M}},Wx=(o,d)=>{let _=new Xg(o.inputs,d.equation),m=_.outputDims,g=o.inputs.map((y,b)=>y.dims);o.compute(Ux(g,o.inputs[0].dataType,_,m))},_w=o=>{let d=o.equation.replace(/\s+/g,"");return ka({equation:d})}}),Vx,Yg,Gx,Kx,hw,KT=p(()=>{ya(),fa(),Xo(),Vx=o=>{if(!o||o.length!==2)throw new Error("Expand requires 2 input.");let d=o[0].dims,_=Array.from(o[1].getBigInt64Array(),Number),m=_.length<d.length?0:_.length-d.length,g=d.length<_.length?0:d.length-_.length;for(;m<_.length&&g<d.length;++m,++g)if(_[m]!==d[g]&&_[m]!==1&&d[g]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Yg=(o,d)=>{let _=o.length-d.length,m=[];for(let g=0;g<_;++g)m.push(o[g]);for(let g=0;g<d.length;++g)m.push(d[g]===1?o[g+_]:d[g]);return m},Gx=(o,d)=>o.length>d.length?Yg(o,d):Yg(d,o),Kx=o=>{let d=o[0].dims,_=Array.from(o[1].getBigInt64Array(),Number),m=Gx(d,_),g=o[0].dataType,y=g===9?4:1,b=Math.ceil(wr.size(m)/y),E=P=>{let U=S("input",g,d.length,y),N=be("output",g,m.length,y),T;if(g===9){let ae=(ue,fe,Ae="")=>`
          let outputIndices${fe} = ${N.offsetToIndices(`outputOffset + ${fe}u`)};
          let offset${fe} = ${U.broadcastedIndicesToOffset(`outputIndices${fe}`,N)};
          let index${fe} = offset${fe} / 4u;
          let component${fe} = offset${fe} % 4u;
          ${ue}[${fe}] = ${Ae}(${U.getByOffset(`index${fe}`)}[component${fe}]);
        `;T=`
        let outputOffset = global_idx * ${y};
        var data = vec4<u32>(0);
        ${ae("data",0,"u32")}
        ${ae("data",1,"u32")}
        ${ae("data",2,"u32")}
        ${ae("data",3,"u32")}
        ${N.setByOffset("global_idx","data")}
      }`}else T=`
        let outputIndices = ${N.offsetToIndices("global_idx")};
        let inputOffset = ${U.broadcastedIndicesToOffset("outputIndices",N)};
        ${N.setByOffset("global_idx",U.getByOffset("inputOffset"))}
      }`;return`
    ${P.registerUniform("vec_size","u32").declareVariables(U,N)}
    ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${T}`},M=[{type:12,data:b},...qs(d,m)];return{name:"Expand",shaderCache:{hint:`${m.length}`,inputDependencies:["rank"]},getShaderSource:E,getRunData:()=>({outputs:[{dims:m,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:M})}},hw=o=>{Vx(o.inputs),o.compute(Kx(o.inputs),{inputs:[0]})}}),aT,fw,qx=p(()=>{ya(),fa(),Xo(),Wy(),aT=o=>{let d=o[0].dataType,_=wr.size(o[0].dims),m=wr.size(o[1].dims),g=m%4===0,y=b=>{let E=S("x",d,[1],4),M=S("bias",d,[1],4),P=be("y",d,[1],4),U=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],N=ae=>`
      let bias${ae}_offset: u32 = (global_idx * 4 + ${ae}) % uniforms.bias_size;
      let bias${ae} = ${M.getByOffset(`bias${ae}_offset / 4`)}[bias${ae}_offset % 4];`,T=g?`
      let bias = ${M.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${N(0)}${N(1)}${N(2)}${N(3)}
      let bias = ${E.type.value}(bias0, bias1, bias2, bias3);`;return`${b.registerUniforms(U).declareVariables(E,M,P)}

    ${Xh(Ga(d))}

    ${b.mainStart(Du)}
      ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${E.getByOffset("global_idx")};
      ${T}
      let x_in = x + bias;
      ${P.setByOffset("global_idx",zy("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${g}`,inputDependencies:["type","type"]},getShaderSource:y,getRunData:b=>({outputs:[{dims:b[0].dims,dataType:b[0].dataType}],programUniforms:[{type:12,data:Math.ceil(_/4)},{type:12,data:m}],dispatchGroup:{x:Math.ceil(_/Du/4)}})}},fw=o=>{o.inputs.length<2||wr.size(o.inputs[1].dims)===0?V0(o):o.compute(aT(o.inputs))}}),Hx,Xx,mw,Yx,lT=p(()=>{ya(),fa(),Va(),Xo(),Hx=o=>{if(!o||o.length!==2)throw new Error("Gather requires 2 inputs.")},Xx=(o,d)=>{let _=o[0].dims,m=o[1].dims,g=_.length,y=wr.normalizeAxis(d.axis,g),b=_.slice(0);b.splice(y,1,...m);let E=_[y],M=o[0].dataType===9?4:1,P=Math.ceil(wr.size(b)/M),U=[{type:12,data:P},{type:6,data:E},{type:12,data:y},...qs(o[0].dims,o[1].dims,b)],N=T=>{let ae=S("data",o[0].dataType,o[0].dims.length,M),ue=S("inputIndices",o[1].dataType,o[1].dims.length),fe=be("output",o[0].dataType,b.length,M),Ae=Oe=>{let pt=m.length,lt=`var indicesIndices${Oe}  = ${ue.type.indices}(0);`;for(let ft=0;ft<pt;ft++)lt+=`${pt>1?`indicesIndices${Oe}[${ft}]`:`indicesIndices${Oe}`} = ${b.length>1?`outputIndices${Oe}[uniforms.axis + ${ft}]`:`outputIndices${Oe}`};`;lt+=`
          var idx${Oe} = ${ue.getByIndices(`indicesIndices${Oe}`)};
          if (idx${Oe} < 0) {
            idx${Oe} = idx${Oe} + uniforms.axisDimLimit;
          }
          var dataIndices${Oe} : ${ae.type.indices};
        `;for(let ft=0,nn=0;ft<g;ft++)ft===y?(lt+=`${g>1?`dataIndices${Oe}[${ft}]`:`dataIndices${Oe}`} = u32(idx${Oe});`,nn+=pt):(lt+=`${g>1?`dataIndices${Oe}[${ft}]`:`dataIndices${Oe}`} = ${b.length>1?`outputIndices${Oe}[${nn}]`:`outputIndices${Oe}`};`,nn++);return lt},Le;if(o[0].dataType===9){let Oe=(pt,lt,ft="")=>`
          let outputIndices${lt} = ${fe.offsetToIndices(`outputOffset + ${lt}u`)};
          ${Ae(lt)};
          let offset${lt} = ${ae.indicesToOffset(`dataIndices${lt}`)};
          let index${lt} = offset${lt} / 4u;
          let component${lt} = offset${lt} % 4u;
          ${pt}[${lt}] = ${ft}(${ae.getByOffset(`index${lt}`)}[component${lt}]);
        `;Le=`
        let outputOffset = global_idx * ${M};
        var value = vec4<u32>(0);
        ${Oe("value",0,"u32")}
        ${Oe("value",1,"u32")}
        ${Oe("value",2,"u32")}
        ${Oe("value",3,"u32")}
        ${fe.setByOffset("global_idx","value")}
      `}else Le=`
      let outputIndices = ${fe.offsetToIndices("global_idx")};
      ${Ae("")};
      let value = ${ae.getByIndices("dataIndices")};
      ${fe.setByOffset("global_idx","value")};
      `;return`
      ${T.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(ae,ue,fe)}
      ${T.mainStart()}
        ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${Le}
      }`};return{name:"Gather",shaderCache:{hint:d.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:b,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(P/64)},programUniforms:U}),getShaderSource:N}},mw=o=>ka({axis:o.axis}),Yx=(o,d)=>{let _=o.inputs;Hx(_),o.compute(Xx(o.inputs,d))}}),gw,Qx,Zx,bw,uT=p(()=>{ya(),fa(),Va(),Xo(),gw=(o,d)=>{if(o.length<3||o.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let _=wr.normalizeAxis(d.quantizeAxis,o[0].dims.length),m=d.blockSize,g=o[0],y=o[2],b=o.length===4?o[3]:void 0;if(y.dims.length!==g.dims.length||!g.dims.map((E,M)=>M===_?Math.ceil(E/m)===y.dims[M]:E===y.dims[M]).reduce((E,M)=>E&&M,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(b){if(b.dataType!==g.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(b.dims.length!==y.dims.length||!b.dims.map((E,M)=>E===y.dims[M]).reduce((E,M)=>E&&M,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Qx=(o,d)=>{let _=o[0].dims,m=o[1].dims,g=_.length,y=wr.normalizeAxis(d.gatherAxis,g),b=wr.normalizeAxis(d.quantizeAxis,g),E=_.slice(0);E.splice(y,1,...m);let M=wr.size(E),P=o[2].dataType,U=o[0].dataType===22,N=[{type:12,data:M},{type:12,data:b},{type:12,data:y},{type:12,data:d.blockSize},...qs(...o.map((ae,ue)=>ae.dims),E)],T=ae=>{let ue=S("data",o[0].dataType,o[0].dims.length),fe=S("inputIndices",o[1].dataType,o[1].dims.length),Ae=S("scales",o[2].dataType,o[2].dims.length),Le=o.length>3?S("zeroPoint",o[3].dataType,o[3].dims.length):void 0,Oe=be("output",P,E.length),pt=[ue,fe,Ae];Le&&pt.push(Le);let lt=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${ae.registerUniforms(lt).declareVariables(...pt,Oe)}
        ${ae.mainStart()}
        let output_indices = ${Oe.offsetToIndices("global_idx")};
        var indices_indices = ${fe.type.indices}(0);
        ${m.length>1?`
          for (var i: u32 = 0; i < ${m.length}; i++) {
            let index = ${Oe.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${fe.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${Oe.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${ue.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${Oe.indicesGet("output_indices","i")};
          ${ue.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${fe.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${_[y]};
        }
        ${ue.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${E.length}; i++) {
          let index = ${Oe.indicesGet("output_indices",`i + ${m.length} - 1`)};
          ${ue.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${ue.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${ue.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${U?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${Ae.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${Ae.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${Ae.getByIndices("scale_indices")};
        ${Le?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${Le.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${Le.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${U?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Ga(P)}(quantized_data - zero_point) * scale;
        ${Oe.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${d.cacheKey};${o.filter((ae,ue)=>ue!==1).map(ae=>ae.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:o.length},(ae,ue)=>"rank")},getRunData:()=>({outputs:[{dims:E,dataType:P}],dispatchGroup:{x:Math.ceil(M/64)},programUniforms:N}),getShaderSource:T}},Zx=(o,d)=>{let _=o.inputs;gw(_,d),o.compute(Qx(o.inputs,d))},bw=o=>ka({blockSize:o.blockSize,gatherAxis:o.gatherAxis,quantizeAxis:o.quantizeAxis})}),Jx,ev,tv,nu,qT=p(()=>{ya(),fa(),Va(),Xo(),Jx=o=>{if(!o||o.length!==2)throw new Error("GatherElements requires 2 inputs.");if(o[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(o[0].dims.length!==o[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},ev=(o,d)=>{let _=o[0].dims,m=o[0].dataType,g=_.length,y=o[1].dims,b=o[1].dataType,E=wr.normalizeAxis(d.axis,g),M=_[E],P=y.slice(0),U=wr.size(P),N=S("input",m,g),T=S("indicesInput",b,y.length),ae=be("output",m,P.length),ue=[{type:12,data:U},{type:6,data:M},{type:12,data:E}];return ue.push(...qs(_,y,P)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:P,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(U/64)},programUniforms:ue}),getShaderSource:fe=>`
      ${fe.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(N,T,ae)}
      ${fe.mainStart()}
      ${fe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${ae.offsetToIndices("global_idx")};

      var idx = ${T.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${N.type.indices}(outputIndices);
      ${N.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${N.getByIndices("inputIndices")};

      ${ae.setByOffset("global_idx","value")};
  }`}},tv=o=>ka({axis:o.axis}),nu=(o,d)=>{let _=o.inputs;Jx(_),o.compute(ev(o.inputs,d))}}),dT,cT,yw,rv,pT=p(()=>{ya(),fa(),Xo(),dT=o=>{if(!o)throw new Error("Input is missing");if(o.length<2||o.length>3)throw new Error("Invaid input number.");if(o.length===3&&o[2].dims.length>2)throw new Error("Invalid input shape of C");if(o[0].dataType!==o[1].dataType||o.length===3&&o[0].dataType!==o[2].dataType)throw new Error("Input types are mismatched")},cT=(o,d)=>{let _=o[0].dims.slice(),m=o[1].dims.slice(),[g,y,b]=zu.getShapeOfGemmResult(_,d.transA,m,d.transB,o.length===3?o[2].dims:void 0),E=[g,y];if(!E)throw new Error("Can't use gemm on the given tensors");let M=wr.size(E),P=[{type:12,data:M},{type:12,data:g},{type:12,data:y},{type:12,data:b},{type:1,data:d.alpha},{type:1,data:d.beta}],U=["type","type"];o.length===3&&(P.push(...qs(o[2].dims)),U.push("rank")),P.push(...qs(E));let N=T=>{let ae="";d.transA&&d.transB?ae="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":d.transA&&!d.transB?ae="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!d.transA&&d.transB?ae="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!d.transA&&!d.transB&&(ae="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let ue=d.alpha===1?"":"value *= uniforms.alpha;",fe=S("a",o[0].dataType,o[0].dims),Ae=S("b",o[1].dataType,o[1].dims),Le=fe.type.value,Oe=null,pt=[fe,Ae];o.length===3&&(Oe=S("c",o[2].dataType,o[2].dims.length),pt.push(Oe));let lt=be("output",o[0].dataType,E.length);pt.push(lt);let ft=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${T.registerUniforms(ft).declareVariables(...pt)}

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${Le}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${ae}
    }

    ${ue}
    ${Oe!=null?`let cOffset = ${Oe.broadcastedIndicesToOffset("vec2(m, n)",lt)}; value += ${Le}(uniforms.beta) * ${Oe.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${d.cacheKey}`,inputDependencies:U},getRunData:()=>({outputs:[{dims:E,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(M/64)},programUniforms:P}),getShaderSource:N}},yw=o=>{let d=o.transA,_=o.transB,m=o.alpha,g=o.beta;return{transA:d,transB:_,alpha:m,beta:g,cacheKey:`${o.transA};${o.transB};${o.alpha===1}`}},rv=(o,d)=>{dT(o.inputs),o.compute(cT(o.inputs,d))}}),kd,nv,ww,Qg,ov,Q_,xw,_T=p(()=>{ya(),fa(),Va(),Mt(),Py(),Xo(),ru(),kd=(o,d)=>o.length>d&&o[d].dims.length>0?o[d]:void 0,nv=(o,d)=>{let _=o[0],m=kd(o,1),g=kd(o,2),y=kd(o,3),b=kd(o,4),E=kd(o,5),M=kd(o,6),P=kd(o,7);if(_.dims.length!==3&&_.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let U=_.dims[0],N=_.dims[1],T=_.dims.length===3?_.dims[2]:d.numHeads*_.dims[4],ae=N,ue=0,fe=0,Ae=Math.floor(T/d.numHeads);if(M&&P&&wr.size(M.dims)&&wr.size(P.dims)){if(M.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(M.dims[0]!==U||M.dims[1]!==d.numHeads||M.dims[3]!==Ae)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(P.dims[0]!==U||P.dims[1]!==d.numHeads||P.dims[3]!==Ae)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(M.dims[2]!==P.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(P.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');ue=M.dims[2],fe=M.dims[2]}else if(M&&wr.size(M.dims)||P&&wr.size(P.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let Le;if(m&&wr.size(m.dims)>0){if(_.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(m.dims.length<3||m.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(_.dims[0]!==m.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(m.dims.length===3){if(m.dims[2]!==_.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');Le=2,ae=m.dims[1]}else if(m.dims.length===5){if(m.dims[2]!==d.numHeads||m.dims[3]!==2||m.dims[4]!==Ae)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(g)throw new Error('Expect "value" be none when "key" has packed kv format.');Le=5,ae=m.dims[1]}else{if(m.dims[1]!==d.numHeads||m.dims[3]!==Ae)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');Le=0,ae=m.dims[2]}}else{if(_.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(_.dims[2]!==d.numHeads||_.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');Le=3}if(y&&wr.size(y.dims)>0){if(y.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(m&&m.dims.length===5&&m.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let Oe=ue+ae,pt=0;if(b&&wr.size(b.dims)>0){pt=8;let Er=b.dims;throw Er.length===1?Er[0]===U?pt=1:Er[0]===3*U+2&&(pt=3):Er.length===2&&Er[0]===U&&Er[1]===Oe&&(pt=5),pt===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let lt=!1,ft=T;if(g&&wr.size(g.dims)>0){if(g.dims.length!==3&&g.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(_.dims[0]!==g.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(g.dims.length===3){if(ae!==g.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');ft=g.dims[2]}else{if(ae!==g.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');ft=g.dims[1]*g.dims[3],lt=!0}}let nn=!1;if(b&&wr.size(b.dims)>0)throw new Error("Key padding mask is not supported");if(E&&wr.size(E.dims)>0){if(E.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(E.dims[0]!==U||E.dims[1]!==d.numHeads||E.dims[2]!==N||E.dims[3]!==Oe)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:U,sequenceLength:N,pastSequenceLength:ue,kvSequenceLength:ae,totalSequenceLength:Oe,maxSequenceLength:fe,inputHiddenSize:0,hiddenSize:T,vHiddenSize:ft,headSize:Ae,vHeadSize:Math.floor(ft/d.numHeads),numHeads:d.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:d.maskFilterValue,maskType:pt,scale:d.scale,broadcastResPosBias:nn,passPastInKv:lt,qkvFormat:Le}},ww=o=>ka({...o}),Qg=ka({perm:[0,2,1,3]}),ov=(o,d,_,m,g,y,b)=>{let E=[m,g,y],M=wr.size(E),P=[{type:12,data:M},{type:12,data:b},{type:12,data:y}],U=N=>{let T=be("qkv_with_bias",d.dataType,E),ae=S("qkv",d.dataType,E),ue=S("bias",_.dataType,E),fe=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${N.registerUniforms(fe).declareVariables(ae,ue,T)}
  ${N.mainStart()}
    ${N.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return o.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:E,dataType:d.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(M/64)},programUniforms:P}),getShaderSource:U},{inputs:[d,_],outputs:[-1]})[0]},Q_=(o,d,_,m,g,y,b,E)=>{let M=y;if(b&&wr.size(b.dims)>0){if(m===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return M=ov(o,y,b,d,m,_*g,E),M=M.reshape([d,m,_,g]),_===1||m===1?M:o.compute(Td(M,Qg.perm),{inputs:[M],outputs:[-1]})[0]}else return y.dims.length===3&&(M=y.reshape([d,m,_,g])),_===1||m===1?M:o.compute(Td(M,Qg.perm),{inputs:[M],outputs:[-1]})[0]},xw=(o,d)=>{let _=nv(o.inputs,d),m=o.inputs[0],g=kd(o.inputs,1),y=kd(o.inputs,2),b=kd(o.inputs,3),E=kd(o.inputs,4),M=kd(o.inputs,5),P=kd(o.inputs,6),U=kd(o.inputs,7);if(m.dims.length===5)throw new Error("Packed QKV is not implemented");if((g==null?void 0:g.dims.length)===5)throw new Error("Packed KV is not implemented");let N=g&&y&&g.dims.length===4&&y.dims.length===4,T=Q_(o,_.batchSize,_.numHeads,_.sequenceLength,_.headSize,m,b,0);if(N)return W_(o,T,g,y,E,void 0,P,U,M,_,d);if(!g||!y)throw new Error("key and value must be provided");let ae=Q_(o,_.batchSize,_.numHeads,_.kvSequenceLength,_.headSize,g,b,_.hiddenSize),ue=Q_(o,_.batchSize,_.numHeads,_.kvSequenceLength,_.vHeadSize,y,b,2*_.hiddenSize);W_(o,T,ae,ue,E,void 0,P,U,M,_,d)}}),sv,iv,av,vw,lv,uv=p(()=>{ya(),fa(),Xo(),sv=o=>Array.from(o.getBigInt64Array(),Number),iv=o=>{if(!o||o.length!==2)throw new Error("Tile requires 2 inputs.");if(o[0].dataType!==1&&o[0].dataType!==10&&o[0].dataType!==6&&o[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(o[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(o[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(sv(o[1]).length!==o[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},av=(o,d)=>{let _=[];for(let m=0;m<o.length;++m)_.push(o[m]*d[m]);return _},vw=(o,d)=>{let _=o[0].dims,m=d??sv(o[1]),g=av(_,m),y=wr.size(g),b=o[0].dataType,E=S("input",b,_.length),M=be("output",b,g.length),P=U=>`
      const inputShape = ${E.indices(..._)};
      ${U.registerUniform("output_size","u32").declareVariables(E,M)}
      ${U.mainStart()}
      ${U.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${M.offsetToIndices("global_idx")};
      var input_indices: ${E.type.indices};
      for (var i = 0; i < ${_.length}; i++) {
        let input_dim_i = ${E.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${M.indicesGet("output_indices","i")}  % input_dim_i;

        ${E.indicesSet("input_indices","i","input_dim_value")}
      }
      ${M.setByOffset("global_idx",E.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${m}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:g,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...qs(o[0].dims,g)]}),getShaderSource:P}},lv=o=>{iv(o.inputs),o.compute(vw(o.inputs),{inputs:[0]})}}),dv,Tw,cv,pv,Ew,_v,hT=p(()=>{ya(),fa(),Va(),Py(),Xo(),_T(),uv(),ru(),dv=(o,d)=>{let _=o[0],m=o[1],g=o[2],y=o[3],b=o[4];if(_.dims.length!==3&&_.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let E=!1,M=_.dims[0],P=_.dims[1],U=_.dims.length===3?E?_.dims[2]/3:_.dims[2]:d.numHeads*_.dims[4],N=P,T=0,ae=0,ue=Math.floor(U/d.numHeads),fe=y&&y.dims.length!==0,Ae=b&&b.dims.length!==0,Le=!0;if(fe&&Ae){if(y.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(b.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');T=y.dims[1],ae=y.dims[1]}else if(fe||Ae)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let Oe;if(m){if(_.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(m.dims.length<3||m.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(_.dims[0]!==m.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(m.dims.length===3){if(_.dims[2]%m.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');Oe=2,N=m.dims[1]}else if(m.dims.length===5){if(m.dims[2]!==d.numHeads||m.dims[3]!==2||m.dims[4]!==ue)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(g)throw new Error('Expect "value" be none when "key" has packed kv format.');Oe=5,N=m.dims[1]}else{if(m.dims[1]!==d.numHeads||m.dims[3]!==ue)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');Oe=0,N=m.dims[2]}}else{if(_.dims.length!==3&&_.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(_.dims.length===5&&(_.dims[2]!==d.numHeads||_.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');Oe=3}let pt=0,lt=!1,ft=U;if(g){if(g.dims.length!==3&&g.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(_.dims[0]!==g.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(g.dims.length===3){if(N!==g.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');ft=g.dims[2]}else{if(N!==g.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');ft=g.dims[1]*g.dims[3],lt=!0}}let nn=T+N;return{batchSize:M,sequenceLength:P,pastSequenceLength:T,kvSequenceLength:N,totalSequenceLength:nn,maxSequenceLength:ae,inputHiddenSize:0,hiddenSize:U,vHiddenSize:ft,headSize:ue,vHeadSize:Math.floor(ft/d.kvNumHeads),numHeads:d.numHeads,kvNumHeads:d.kvNumHeads,nReps:d.numHeads/d.kvNumHeads,pastPresentShareBuffer:!1,maskType:pt,scale:d.scale,broadcastResPosBias:!1,passPastInKv:lt,qkvFormat:Oe,isPastkvBSNH:Le}},Tw=(o,d,_,m)=>{let g=[m.batchSize,m.totalSequenceLength,m.kvNumHeads,m.headSize],y=4,b=wr.size(g)/y,E=m.totalSequenceLength,M=be("present_kv",_,g.length,y),P=S("new_kv",o.dataType,o.dims.length,y),U=d?S("past_kv",d.dataType,d.dims.length,y):void 0,N=Math.ceil(m.headSize/y),T={x:E,y:o.dims[0],z:1},ae=d?["rank","rank"]:["rank"],ue=[{type:12,data:b},{type:12,data:m.pastSequenceLength},{type:12,data:m.kvSequenceLength},{type:12,data:m.totalSequenceLength}],fe=[P];U?(ue.push(...qs(o.dims),...qs(d.dims),...qs(g)),fe.push(U)):ue.push(...qs(o.dims),...qs(g));let Ae=[{name:"output_size",type:"u32"},{name:"past_seqlen",type:"u32"},{name:"new_seqlen",type:"u32"},{name:"present_seqlen",type:"u32"}],Le=`      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`,Oe=`      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`,pt=d?`if (s < past_seqlen) {
        ${Le}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${Oe}
        }`:`if (s < past_seqlen + uniforms.new_seqlen) {
          ${Oe}
        }`,lt=ft=>`

  ${ft.registerUniforms(Ae).declareVariables(...fe,M)}
  ${ft.mainStart([N,m.kvNumHeads,1])}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${M.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${m.kvNumHeads}u;
    let H = ${N}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${m.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${pt}
  }`;return{name:"ConcatPastNew",shaderCache:{hint:`${m.kvNumHeads}${N}${!!d}`,inputDependencies:ae},getRunData:()=>({outputs:[{dims:g,dataType:_}],dispatchGroup:T,programUniforms:ue}),getShaderSource:lt}},cv=o=>ka({...o}),pv=ka({perm:[0,2,1,3]}),Ew=(o,d,_,m,g)=>{let y=d,b=m.kvNumHeads,E=m.nReps;return d.dims.length===3&&m.kvSequenceLength!==0&&(y=d.reshape([m.batchSize,m.kvSequenceLength,b,m.headSize])),_?y=o.compute(Tw(y,_,y.dataType,m),{inputs:[y,_],outputs:[m.isPastkvBSNH?g:-1]})[0]:y=o.compute(Tw(y,void 0,y.dataType,m),{inputs:[y],outputs:[m.isPastkvBSNH?g:-1]})[0],E!==1&&(y=o.compute(vw([y],[1,1,1,E]),{inputs:[y],outputs:[-1]})[0],y=y.reshape([m.batchSize,m.totalSequenceLength,b*E,m.headSize])),o.compute(Td(y,pv.perm),{inputs:[y],outputs:[-1]})[0]},_v=(o,d)=>{var M;let _=dv(o.inputs,d);if(o.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((M=o.inputs[1])==null?void 0:M.dims.length)===5)throw new Error("Packed KV is not implemented");let m=Q_(o,_.batchSize,_.numHeads,_.sequenceLength,_.headSize,o.inputs[0],void 0,0),g=o.inputs[3]&&o.inputs[3].dims.length!==0?o.inputs[3]:void 0,y=o.inputs[4]&&o.inputs[4].dims.length!==0?o.inputs[4]:void 0,b=Ew(o,o.inputs[1],g,_,1),E=Ew(o,o.inputs[2],y,_,2);W_(o,m,b,E,void 0,void 0,void 0,void 0,void 0,_,d)}}),Mw,hv,fv,mv,fT=p(()=>{ya(),fa(),ru(),Xo(),Mw=(o,d,_,m,g,y,b,E)=>{let M=La(y),P=M===1?"f32":`vec${M}f`,U=M===1?"vec2f":`mat2x${M}f`,N=g*b,T=[g,b,y/M],ae=[g,b,2],ue=["rank","type","type"],fe=[];fe.push(...qs(T,ae));let Ae=Le=>{let Oe=S("x",d.dataType,3,M),pt=S("scale",_.dataType,_.dims),lt=S("bias",m.dataType,m.dims),ft=be("output",1,3,2),nn=[Oe,pt,lt,ft],Er=64;return`
  var<workgroup> workgroup_shared : array<${U}, ${Er}>;
  const workgroup_size = ${Er}u;
  ${Le.declareVariables(...nn)}
  ${Le.mainStart(Er)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${P}(0);
    var squared_sum = ${P}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${P}(${Oe.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${U}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Dd("workgroup_shared[0][0]",M)} / f32(hight * ${M});
      let squared_sum_final = ${Dd("workgroup_shared[0][1]",M)} / f32(hight * ${M});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${E}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return o.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${M};${E}`,inputDependencies:ue},getRunData:()=>({outputs:[{dims:ae,dataType:1}],dispatchGroup:{x:N},programUniforms:fe}),getShaderSource:Ae},{inputs:[d,_,m],outputs:[-1]})[0]},hv=(o,d,_)=>{let m=d[0].dims,g=m,y=2,b=m[0],E=m[1],M=wr.sizeFromDimension(m,y),P=La(M),U=wr.size(g)/P,N=Mw(o,d[0],d[1],d[2],b,M,E,_.epsilon),T=[b,E,M/P],ae=[b,E],ue=["type","none"],fe=Ae=>{let Le=S("x",d[0].dataType,T.length,P),Oe=S("scale_shift",1,ae.length,2),pt=be("output",d[0].dataType,T.length,P),lt=[Le,Oe,pt];return`
  ${Ae.registerUniform("output_size","u32").declareVariables(...lt)}
  ${Ae.mainStart()}
  ${Ae.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${pt.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${Oe.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${Le.getByOffset("global_idx")} * ${pt.type.value}(scale_shift.x) + ${pt.type.value}(scale_shift.y);
      ${pt.setByOffset("global_idx","value")};
  }`};o.compute({name:"InstanceNormalization",shaderCache:{hint:`${P}`,inputDependencies:ue},getRunData:()=>({outputs:[{dims:g,dataType:d[0].dataType}],dispatchGroup:{x:Math.ceil(U/64)},programUniforms:[{type:12,data:U},...qs(T,ae,T)]}),getShaderSource:fe},{inputs:[d[0],N]})},fv=(o,d,_)=>{let m=d[0].dims,g=m,y=m[0],b=m[m.length-1],E=wr.sizeFromDimension(m,1)/b,M=La(b),P=wr.size(g)/M,U=[{type:12,data:E},{type:12,data:Math.floor(b/M)}],N=["type","type"],T=[0,m.length-1];for(let Ae=0;Ae<m.length-2;Ae++)T.push(Ae+1);let ae=o.compute(Td(o.inputs[0],T),{inputs:[o.inputs[0]],outputs:[-1]})[0],ue=Mw(o,ae,d[1],d[2],y,E,b,_.epsilon),fe=Ae=>{let Le=Fa(d[0].dataType),Oe=M===1?"vec2f":`mat${M}x2f`,pt=nn=>{let Er=nn===0?"x":"y",Do=M===1?"f32":`vec${M}f`;switch(M){case 1:return`${Le}(${Do}(scale.${Er}))`;case 2:return`vec2<${Le}>(${Do}(scale[0].${Er}, scale[1].${Er}))`;case 4:return`vec4<${Le}>(${Do}(scale[0].${Er}, scale[1].${Er}, scale[2].${Er}, scale[3].${Er}))`;default:throw new Error(`Not supported compoents ${M}`)}},lt=S("input",d[0].dataType,d[0].dims,M),ft=be("output",d[0].dataType,g,M);return`
  @group(0) @binding(0) var<storage, read> input : array<${lt.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${Oe}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ft.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${Ae.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${pt(0)}, ${pt(1)});
  }`};o.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${M}`,inputDependencies:N},getRunData:()=>({outputs:[{dims:g,dataType:d[0].dataType}],dispatchGroup:{x:Math.ceil(P/64)},programUniforms:U}),getShaderSource:fe},{inputs:[d[0],ue]})},mv=(o,d)=>{d.format==="NHWC"?fv(o,o.inputs,d):hv(o,o.inputs,d)}}),mT,Pw,gv,gT=p(()=>{ya(),fa(),Xo(),mT=o=>{if(!o||o.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Pw=(o,d,_)=>{let m=d.simplified,g=o[0].dims,y=o[1],b=!m&&o[2],E=g,M=wr.normalizeAxis(d.axis,g.length),P=wr.sizeToDimension(g,M),U=wr.sizeFromDimension(g,M),N=wr.size(y.dims),T=b?wr.size(b.dims):0;if(N!==U||b&&T!==U)throw new Error(`Size of X.shape()[axis:] == ${U}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${N} and bias size of ${T}`);let ae=[];for(let ft=0;ft<g.length;++ft)ft<M?ae.push(g[ft]):ae.push(1);let ue=La(U),fe=["type","type"],Ae=[{type:12,data:P},{type:1,data:U},{type:12,data:Math.floor(U/ue)},{type:1,data:d.epsilon}];b&&fe.push("type");let Le=_>1,Oe=_>2,pt=ft=>{let nn=Fa(o[0].dataType),Er=[S("x",o[0].dataType,o[0].dims,ue),S("scale",y.dataType,y.dims,ue)];b&&Er.push(S("bias",b.dataType,b.dims,ue)),Er.push(be("output",o[0].dataType,E,ue)),Le&&Er.push(be("mean_data_output",1,ae)),Oe&&Er.push(be("inv_std_output",1,ae));let Do=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${ft.registerUniforms(Do).declareVariables(...Er)}
  ${ft.mainStart()}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${t_("f32",ue)};
    var mean_square_vector = ${t_("f32",ue)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Cd(nn,ue,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Dd("mean_vector",ue)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Dd("mean_square_vector",ue)} / uniforms.norm_size ${m?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Cd(nn,ue,"x[j + offset]")};
      let f32scale = ${Cd(nn,ue,"scale[j]")};
      output[j + offset] = ${Er[0].type.value}((f32input ${m?"":"- mean"}) * inv_std_dev * f32scale
        ${b?`+ ${Cd(nn,ue,"bias[j]")}`:""}
      );
    }

    ${Le?"mean_data_output[global_idx] = mean":""};
    ${Oe?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},lt=[{dims:E,dataType:o[0].dataType}];return Le&&lt.push({dims:ae,dataType:1}),Oe&&lt.push({dims:ae,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${ue};${_};${m}`,inputDependencies:fe},getRunData:()=>({outputs:lt,dispatchGroup:{x:Math.ceil(P/64)},programUniforms:Ae}),getShaderSource:pt}},gv=(o,d)=>{mT(o.inputs),o.compute(Pw(o.inputs,d,o.outputCount))}}),bv,yv,wv,xv,vv,bT=p(()=>{ya(),fa(),Va(),Xo(),bv=(o,d)=>{if(o.length<3||o.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let _=o[0],m=_.dims.length;if(_.dims[m-1]!==d.k)throw new Error("The last dim of input shape does not match the k value");let g=Math.floor((d.k+d.blockSize-1)/d.blockSize),y=d.blockSize/8*d.bits,b=o[1];if(!wr.areEqual(b.dims,[d.n,g,y]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let E=o[2].dims;if(wr.size(E)!==d.n*g)throw new Error("scales input size error.");if(o.length===4){let M=o[3].dims,P=d.bits>4?d.n*g:d.n*Math.floor((g+1)/2);if(wr.size(M)!==P)throw new Error("zeroPoints input size error.")}},yv=(o,d)=>{let _=o[0].dims,m=_.length,g=_[m-2],y=d.k,b=d.n,E=_.slice(0,m-2),M=wr.size(E),P=o[1].dims[2]/4,U=o[0].dataType,N=La(d.k),T=La(P),ae=La(b),ue=E.concat([g,b]),fe=g>1&&b/ae%2===0?2:1,Ae=wr.size(ue)/ae/fe,Le=64,Oe=[],pt=[M,g,y/N],lt=wr.convertShape(o[1].dims).slice();lt.splice(-1,1,P/T),Oe.push(...qs(pt)),Oe.push(...qs(lt)),Oe.push(...qs(o[2].dims)),o.length===4&&Oe.push(...qs(wr.convertShape(o[3].dims)));let ft=[M,g,b/ae];Oe.push(...qs(ft));let nn=Er=>{let Do=pt.length,aa=S("a",o[0].dataType,Do,N),pa=S("b",12,lt.length,T),Ia=S("scales",o[2].dataType,o[2].dims.length),Da=[aa,pa,Ia],wa=o.length===4?S("zero_points",12,o[3].dims.length):void 0;wa&&Da.push(wa);let uu=ft.length,yu=be("output",o[0].dataType,uu,ae),Ra=Fa(o[0].dataType),fu=(()=>{switch(N){case 1:return`array<${Ra}, 8>`;case 2:return`mat4x2<${Ra}>`;case 4:return`mat2x4<${Ra}>`;default:throw new Error(`${N}-component is not supported.`)}})(),ga=()=>{let on=`
          // reuse a data
            var input_offset = ${aa.indicesToOffset(`${aa.type.indices}(batch, row, word_offset)`)};
            var a_data: ${fu};
            for (var j: u32 = 0; j < ${8/N}; j++) {
              a_data[j] = ${aa.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let Zs=0;Zs<ae*fe;Zs++)on+=`
            b_value = ${T===1?`b${Zs}_data`:`b${Zs}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${fu}(${Array.from({length:4},(Ma,pu)=>`${Ra}(b_value_lower[${pu}]), ${Ra}(b_value_upper[${pu}])`).join(", ")});
            b_dequantized_values = ${N===1?`${fu}(${Array.from({length:8},(Ma,pu)=>`(b_quantized_values[${pu}] - ${wa?`zero_point${Zs}`:"zero_point"}) * scale${Zs}`).join(", ")});`:`(b_quantized_values - ${fu}(${Array(8).fill(`${wa?`zero_point${Zs}`:"zero_point"}`).join(",")})) * scale${Zs};`};
            workgroup_shared[local_id.x * ${fe} + ${Math.floor(Zs/ae)}]${ae>1?`[${Zs%ae}]`:""} += ${Array.from({length:8/N},(Ma,pu)=>`${N===1?`a_data[${pu}] * b_dequantized_values[${pu}]`:`dot(a_data[${pu}], b_dequantized_values[${pu}])`}`).join(" + ")};
          `;return on},Ea=()=>{let on=`
            var col_index = col * ${ae};
            ${wa?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Ra}(8);`}
            `;for(let Zs=0;Zs<ae*fe;Zs++)on+=`
            let scale${Zs} = ${Ia.getByOffset("col_index * nBlocksPerCol + block")};
            ${wa?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${wa.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${Zs} = ${Ra}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return on},Xa=()=>{let on=`col_index = col * ${ae};`;for(let Zs=0;Zs<ae*fe;Zs++)on+=`
            let b${Zs}_data = ${pa.getByIndices(`${pa.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return on+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${fu};
            var b_dequantized_values: ${fu};`,on};return`
        var<workgroup> workgroup_shared: array<${yu.type.value}, ${fe*Le}>;
        ${Er.declareVariables(...Da,yu)}
        ${Er.mainStart([Le,1,1])}
          let output_indices = ${yu.offsetToIndices(`(global_idx / ${Le}) * ${fe}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${Le}) {
            //process one block
            var word_offset: u32 = block * ${d.blockSize/N};
            ${Ea()}
            for (var word: u32 = 0; word < ${P}; word += ${T}) {
              ${Xa()}
              for (var i: u32 = 0; i < ${T}; i++) {
                ${ga()}
                word_offset += ${8/N};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${fe}) {
            var output_value: ${yu.type.value} = ${yu.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${Le}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${fe};
            }
            ${yu.setByIndices(`${yu.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${d.blockSize};${d.bits};${N};${T};${ae};${fe};${Le}`,inputDependencies:Array(o.length).fill("rank")},getRunData:()=>({outputs:[{dims:ue,dataType:U}],dispatchGroup:{x:Ae},programUniforms:Oe}),getShaderSource:nn}},wv=(o,d)=>{let _=o[0].dims,m=_.length,g=_[m-2],y=d.k,b=d.n,E=_.slice(0,m-2),M=wr.size(E),P=o[1].dims[2]/4,U=o[0].dataType,N=La(d.k),T=La(P),ae=E.concat([g,b]),ue=128,fe=b%8===0?8:b%4===0?4:1,Ae=ue/fe,Le=Ae*T*8,Oe=Le/N,pt=Le/d.blockSize,lt=wr.size(ae)/fe,ft=[],nn=[M,g,y/N],Er=wr.convertShape(o[1].dims).slice();Er.splice(-1,1,P/T),ft.push(...qs(nn)),ft.push(...qs(Er)),ft.push(...qs(o[2].dims)),o.length===4&&ft.push(...qs(wr.convertShape(o[3].dims)));let Do=[M,g,b];ft.push(...qs(Do));let aa=pa=>{let Ia=nn.length,Da=S("a",o[0].dataType,Ia,N),wa=S("b",12,Er.length,T),uu=S("scales",o[2].dataType,o[2].dims.length),yu=[Da,wa,uu],Ra=o.length===4?S("zero_points",12,o[3].dims.length):void 0;Ra&&yu.push(Ra);let fu=Do.length,ga=be("output",o[0].dataType,fu),Ea=Fa(o[0].dataType),Xa=()=>{switch(N){case 1:return`
          let a_data0 = vec4<${Ea}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${Ea}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${Ea}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${Ea}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${N}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${Da.type.value}, ${Oe}>;
        var<workgroup> inter_results: array<array<${ga.type.value}, ${Ae}>, ${fe}>;
        ${pa.declareVariables(...yu,ga)}
        ${pa.mainStart([Ae,fe,1])}
          let output_indices = ${ga.offsetToIndices(`workgroup_index * ${fe}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${pt} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${Oe};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${Oe}; a_offset += ${ue})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${Da.getByIndices(`${Da.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${Da.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${pt} + local_id.x;
            ${Ra?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${Ra.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${Ea}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Ea}(8);`}
            let scale = ${uu.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${wa.getByIndices(`${wa.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${d.blockSize/N};
            for (var i: u32 = 0; i < ${T}; i++) {
              ${Xa()}
              let b_value = ${T===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${Ea}>(${Array.from({length:4},(on,Zs)=>`${Ea}(b_value_lower[${Zs}]), ${Ea}(b_value_upper[${Zs}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${Ea}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(on,Zs)=>`${`dot(a_data${Zs}, b_dequantized_values[${Zs}])`}`).join(" + ")};
              word_offset += ${8/N};
            }
            workgroupBarrier();
          }

          if (local_idx < ${fe}) {
            var output_value: ${ga.type.value} = ${ga.type.value}(0);
            for (var b = 0u; b < ${Ae}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${ga.setByIndices(`${ga.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${d.blockSize};${N};${T};${Ae};${fe}`,inputDependencies:Array(o.length).fill("rank")},getRunData:()=>({outputs:[{dims:ae,dataType:U}],dispatchGroup:{x:lt},programUniforms:ft}),getShaderSource:aa}},xv=(o,d)=>{bv(o.inputs,d),d.blockSize===32&&o.adapterInfo.isVendor("intel")&&o.adapterInfo.isArchitecture("gen-12lp")?o.compute(wv(o.inputs,d)):o.compute(yv(o.inputs,d))},vv=o=>ka(o)}),Tv,Ev,Mv,Pv,kv,Ov,$v,Av,Sv,yT=p(()=>{ya(),fa(),Xo(),Tv=o=>{if(!o||o.length<1)throw new Error("Too few inputs");if(o[0].dataType!==1&&o[0].dataType!==10)throw new Error("Input type must be float or float16.");if(o.length>=2){let d=o[0].dims.length*2===o[1].dims[0];if(o.length===4&&(d=o[3].dims[0]*2===o[1].dims[0]),!d)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Ev=(o,d,_)=>{let m="";for(let g=d-1;g>=0;--g)m+=`
            k = i32(${o.indicesGet("indices",g)}) - ${ca("uniforms.pads",g,_)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${ca("uniforms.x_shape",g,d)})) {
              break;
            }
            offset += k * i32(${ca("uniforms.x_strides",g,d)});
        `;return`
          value = ${o.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${m}
            value = x[offset];
          }
      `},Mv=(o,d,_)=>{let m="";for(let g=d-1;g>=0;--g)m+=`
                k = i32(${o.indicesGet("indices",g)}) - ${ca("uniforms.pads",g,_)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${ca("uniforms.x_shape",g,d)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${ca("uniforms.x_shape",g,d)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${ca("uniforms.x_strides",g,d)});
            `;return`
              var offset = 0;
              var k = 0;
              ${m}
              value = x[offset];
          `},Pv=(o,d,_)=>{let m="";for(let g=d-1;g>=0;--g)m+=`
                k = i32(${o.indicesGet("indices",g)}) - ${ca("uniforms.pads",g,_)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${ca("uniforms.x_shape",g,d)})) {
                  k = i32(${ca("uniforms.x_shape",g,d)}) - 1;
                }
                offset += k * i32(${ca("uniforms.x_strides",g,d)});
            `;return`
              var offset = 0;
              var k = 0;
              ${m}
              value = x[offset];
          `},kv=(o,d,_)=>{let m="";for(let g=d-1;g>=0;--g)m+=`
                k = i32(${o.indicesGet("indices",g)}) - ${ca("uniforms.pads",g,_)};
                if (k < 0)  {
                  k += i32(${ca("uniforms.x_shape",g,d)}]);
                }
                if (k >= i32(${ca("uniforms.x_shape",g,d)})) {
                  k -= i32(${ca("uniforms.x_shape",g,d)});
                }
                offset += k * i32(${ca("uniforms.x_strides",g,d)});
            `;return`
              var offset = 0;
              var k = 0;
              ${m}
              value = x[offset];
          `},Ov=(o,d,_)=>{switch(_.mode){case 0:return Ev(o,d,_.pads.length);case 1:return Mv(o,d,_.pads.length);case 2:return Pv(o,d,_.pads.length);case 3:return kv(o,d,_.pads.length);default:throw new Error("Invalid mode")}},$v=(o,d)=>{let _=wr.padShape(o[0].dims.slice(),d.pads),m=o[0].dims,g=wr.size(_),y=[{type:12,data:g},{type:6,data:d.pads}],b=o.length>=3&&o[2].data;d.mode===0&&y.push({type:b?o[2].dataType:1,data:d.value}),y.push(...qs(o[0].dims,_));let E=["rank"],M=P=>{let U=be("output",o[0].dataType,_.length),N=S("x",o[0].dataType,m.length),T=N.type.value,ae=Ov(U,m.length,d),ue=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:d.pads.length}];return d.mode===0&&ue.push({name:"constant_value",type:b?T:"f32"}),`
            ${P.registerUniforms(ue).declareVariables(N,U)}
            ${P.mainStart()}
            ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${U.offsetToIndices("global_idx")};

            var value = ${T}(0);
            ${ae}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${d.mode}${b}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:_,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(wr.size(_)/64)},programUniforms:y}),getShaderSource:M}},Av=(o,d)=>{if(o.length>1){let _=o[1].getBigInt64Array(),m=o.length>=3&&o[2].data?o[2].dataType===10?o[2].getUint16Array()[0]:o[2].getFloat32Array()[0]:0,g=o[0].dims.length,y=new Int32Array(2*g).fill(0);if(o.length>=4){let E=o[3].getBigInt64Array();for(let M=0;M<E.length;M++)y[Number(E[M])]=Number(_[M]),y[Number(E[M])+g]=Number(_[M+E.length])}else _.forEach((E,M)=>y[Number(M)]=Number(E));let b=[];return y.forEach(E=>b.push(E)),{mode:d.mode,value:m,pads:b}}else return d},Sv=(o,d)=>{Tv(o.inputs);let _=Av(o.inputs,d);o.compute($v(o.inputs,_),{inputs:[0]})}}),Z_,kw,Ow,$w,Aw,Iv,Cv,Sw,Iw,wT,Ca,Cw,_d,gd,bd,D_,xT,Dv,Fv,C=p(()=>{ii(),ya(),fa(),Xo(),Z_=o=>{if(X.webgpu.validateInputContent&&(!o||o.length!==1))throw new Error("Pool ops requires 1 input.")},kw=(o,d,_)=>{let m=d.format==="NHWC",g=o.dims.slice();m&&g.splice(1,0,g.pop());let y=Object.hasOwnProperty.call(d,"dilations"),b=d.kernelShape.slice(),E=d.strides.slice(),M=y?d.dilations.slice():[],P=d.pads.slice();Su.adjustPoolAttributes(_,g,b,E,M,P);let U=Su.computePoolOutputShape(_,g,E,M,b,P,d.autoPad),N=Object.assign({},d);y?Object.assign(N,{kernelShape:b,strides:E,pads:P,dilations:M,cacheKey:d.cacheKey}):Object.assign(N,{kernelShape:b,strides:E,pads:P,cacheKey:d.cacheKey});let T=U.slice();return T.push(T.splice(1,1)[0]),[N,m?T:U]},Ow=(o,d)=>{let _=d.format==="NHWC",m=wr.size(o),g=wr.size(d.kernelShape),y=[{type:12,data:m},{type:12,data:g}],b=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(d.kernelShape.length<=2){let E=d.kernelShape[d.kernelShape.length-1],M=d.strides[d.strides.length-1],P=d.pads[d.pads.length/2-1],U=d.pads[d.pads.length-1],N=!!(P+U);y.push({type:12,data:E},{type:12,data:M},{type:12,data:P},{type:12,data:U}),b.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let T=!1;if(d.kernelShape.length===2){let ae=d.kernelShape[d.kernelShape.length-2],ue=d.strides[d.strides.length-2],fe=d.pads[d.pads.length/2-2],Ae=d.pads[d.pads.length-2];T=!!(fe+Ae),y.push({type:12,data:ae},{type:12,data:ue},{type:12,data:fe},{type:12,data:Ae}),b.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[y,b,!0,N,T]}else{if(_)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let E=wr.computeStrides(d.kernelShape);y.push({type:12,data:E},{type:12,data:d.pads},{type:12,data:d.strides}),b.push({name:"kernelStrides",type:"u32",length:E.length},{name:"pads",type:"u32",length:d.pads.length},{name:"strides",type:"u32",length:d.strides.length});let M=d.pads.reduce((P,U)=>P+U);return[y,b,!!M,!1,!1]}},$w=(o,d,_,m,g,y,b,E,M,P,U,N)=>{let T=g.format==="NHWC",ae=d.type.value,ue=be("output",d.type.tensor,m);if(g.kernelShape.length<=2){let fe="",Ae="",Le="",Oe=_-(T?2:1);if(U?fe=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${Oe}] = indices[${Oe}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${Oe}] < 0 || xIndices[${Oe}]
                      >= uniforms.x_shape[${Oe}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${d.indicesToOffset("xIndices")}];
                  ${y}
                }`:fe=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${Oe}] = indices[${Oe}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${d.indicesToOffset("xIndices")}];
                  ${y}
                }`,g.kernelShape.length===2){let pt=_-(T?3:2);N?Ae=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${pt}] = indices[${pt}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${pt}] < 0 || xIndices[${pt}] >= uniforms.x_shape[${pt}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Ae=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${pt}] = indices[${pt}] * uniforms.sh - uniforms.phStart + j;
                `,Le=`
              }
            `}return`
            ${o.registerUniforms(M).declareVariables(d,ue)}

            ${o.mainStart()}
              ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${ue.offsetToIndices("global_idx")};
              var xIndices = ${ue.offsetToIndices("global_idx")};

              var value = ${ae}(${E});
              var pad = 0;
              ${Ae}
              ${fe}
              ${Le}
              ${b}

              output[global_idx] = value;
            }`}else{if(T)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let fe=g.kernelShape.length,Ae=g.pads.length,Le="";return P?Le=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${d.indicesToOffset("xIndices")}];
                ${y}
              }`:Le=`
              }
              let x_val = x[${d.indicesToOffset("xIndices")}];
              ${y}
            `,`
            ${o.registerUniforms(M).declareVariables(d,ue)}

            ${o.mainStart()}
              ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${ue.offsetToIndices("global_idx")};
              var xIndices = ${ue.offsetToIndices("global_idx")};

              var offsets: array<u32, ${fe}>;

              var value = ${ae}(${E});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${fe-1}u; j++) {
                  offsets[j] = offset / ${ca("uniforms.kernelStrides","j",fe)};
                  offset -= offsets[j] * ${ca("uniforms.kernelStrides","j",fe)};
                }
                offsets[${fe-1}] = offset;

                isPad = false;
                for (var j = ${_-fe}u; j < ${_}u; j++) {
                  xIndices[j] = indices[j] * ${ca("uniforms.strides",`j - ${_-fe}u`,fe)}
                    + offsets[j - ${_-fe}u] - ${ca("uniforms.pads","j - 2u",Ae)};
                  ${Le}
              }
              ${b}

              output[global_idx] = value;
            }`}},Aw=o=>`${o.format};${o.ceilMode};${o.autoPad};${o.kernelShape.length}`,Iv=o=>`${Aw(o)};${o.countIncludePad}`,Cv=o=>`${Aw(o)};${o.storageOrder};${o.dilations}`,Sw=o=>({format:o.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][o.auto_pad],ceilMode:o.ceil_mode,kernelShape:o.kernel_shape,strides:o.strides,pads:o.pads}),Iw=(o,d,_,m)=>{let[g,y]=kw(d,m,_),b=S("x",d.dataType,d.dims.length),E=b.type.value,M="value += x_val;",P="";g.countIncludePad?P+=`value /= ${E}(uniforms.kernelSize);`:P+=`value /= ${E}(i32(uniforms.kernelSize) - pad);`;let[U,N,T,ae,ue]=Ow(y,g);U.push(...qs(d.dims,y));let fe=["rank"];return{name:o,shaderCache:{hint:`${m.cacheKey};${T};${ae};${ue}`,inputDependencies:fe},getRunData:()=>({outputs:[{dims:y,dataType:d.dataType}],dispatchGroup:{x:Math.ceil(wr.size(y)/64)},programUniforms:U}),getShaderSource:Ae=>$w(Ae,b,d.dims.length,y.length,g,M,P,0,N,T,ae,ue)}},wT=o=>{let d=o.count_include_pad!==0,_=Sw(o);if(_.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let m={countIncludePad:d,..._,cacheKey:""};return{...m,cacheKey:Iv(m)}},Ca=(o,d)=>{Z_(o.inputs),o.compute(Iw("AveragePool",o.inputs[0],!1,d))},Cw={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},_d=o=>{let d=o.format;return{format:d,...Cw,cacheKey:d}},gd=(o,d)=>{Z_(o.inputs),o.compute(Iw("GlobalAveragePool",o.inputs[0],!0,d))},bd=(o,d,_,m)=>{let[g,y]=kw(d,m,_),b=`
      value = max(x_val, value);
    `,E="",M=S("x",d.dataType,d.dims.length),P=["rank"],[U,N,T,ae,ue]=Ow(y,g);return U.push(...qs(d.dims,y)),{name:o,shaderCache:{hint:`${m.cacheKey};${T};${ae};${ue}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:y,dataType:d.dataType}],dispatchGroup:{x:Math.ceil(wr.size(y)/64)},programUniforms:U}),getShaderSource:fe=>$w(fe,M,d.dims.length,y.length,g,b,E,d.dataType===10?-65504:-1e5,N,T,ae,ue)}},D_=(o,d)=>{Z_(o.inputs),o.compute(bd("MaxPool",o.inputs[0],!1,d))},xT=o=>{let d=o.storage_order,_=o.dilations,m=Sw(o);if(d!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(m.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let g={storageOrder:d,dilations:_,...m,cacheKey:""};return{...g,cacheKey:Cv(g)}},Dv=o=>{let d=o.format;return{format:d,...Cw,cacheKey:d}},Fv=(o,d)=>{Z_(o.inputs),o.compute(bd("GlobalMaxPool",o.inputs[0],!0,d))}}),te,$e,ar,rn,Qr=p(()=>{ya(),fa(),Va(),Xo(),te=(o,d)=>{if(o.length<2||o.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(o.length===3&&o[1].dims===o[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(o.length===3&&o[0].dataType!==o[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(o[0].dataType===6&&o.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(o[1].dims.length!==0&&o[1].dims.length!==1&&o[1].dims.length!==o[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(o.length>2){if(o[0].dataType!==o[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(o[1].dims.length!==o[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!o[1].dims.map((_,m)=>_===o[2].dims[m]).reduce((_,m)=>_&&m,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(d.blockSize>0){if(o[1].dims.length===0||o[1].dims.length===1&&o[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!o[1].dims.map((g,y)=>y===d.axis||g===o[0].dims[y]).reduce((g,y)=>g&&y,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(o[1].dims.length!==o[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let _=o[0].dims[d.axis],m=o[1].dims[d.axis];if(d.blockSize<Math.ceil(_/m)||d.blockSize>Math.ceil(_/(m-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},$e=(o,d)=>{let _=wr.normalizeAxis(d.axis,o[0].dims.length),m=o[0].dataType,g=m===3,y=o[0].dims,b=o[1].dataType,E=wr.size(y),M=m===3||m===2,P=M?[Math.ceil(wr.size(o[0].dims)/4)]:o[0].dims,U=o[1].dims,N=o.length>2?o[2]:void 0,T=N?M?[Math.ceil(wr.size(N.dims)/4)]:N.dims:void 0,ae=U.length===0||U.length===1&&U[0]===1,ue=ae===!1&&U.length===1,fe=La(E),Ae=ae&&(!M||fe===4),Le=Ae?fe:1,Oe=Ae&&!M?fe:1,pt=S("input",M?12:m,P.length,Oe),lt=S("scale",b,U.length),ft=N?S("zero_point",M?12:m,T.length):void 0,nn=be("output",b,y.length,Le),Er=[pt,lt];ft&&Er.push(ft);let Do=[P,U];N&&Do.push(T);let aa=[{type:12,data:E/Le},{type:12,data:_},{type:12,data:d.blockSize},...qs(...Do,y)],pa=Ia=>{let Da=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${Ia.registerUniforms(Da).declareVariables(...Er,nn)}
      ${Ia.mainStart()}
          ${Ia.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${nn.offsetToIndices("global_idx")};

          // Set input x
          ${M?`
            let input = ${pt.getByOffset("global_idx / 4")};
            let x_vec = ${g?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${Le===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${pt.getByOffset("global_idx")};`};

          // Set scale input
          ${ae?`let scale_value= ${lt.getByOffset("0")}`:ue?`
            let scale_index = ${nn.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${lt.getByOffset("scale_index")};`:`
            var scale_indices: ${lt.type.indices} = output_indices;
            let index = ${lt.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${lt.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${lt.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${ft?ae?M?`
                let zero_point_input = ${ft.getByOffset("0")};
                let zero_point_vec =  ${g?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${ft.getByOffset("0")}`:ue?M?`
                let zero_point_index = ${nn.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${ft.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${g?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${nn.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${ft.getByOffset("zero_point_index")};`:M?`
                let zero_point_offset = ${lt.indicesToOffset("scale_indices")};
                let zero_point_input = ${ft.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${g?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${ft.getByIndices("scale_indices")};`:`let zero_point_value = ${M?g?"i32":"u32":pt.type.value}(0);`};
      // Compute and write output
      ${nn.setByOffset("global_idx",`${nn.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:d.cacheKey,inputDependencies:ft?["rank","rank","rank"]:["rank","rank"]},getShaderSource:pa,getRunData:()=>({outputs:[{dims:y,dataType:b}],dispatchGroup:{x:Math.ceil(E/Le/64),y:1,z:1},programUniforms:aa})}},ar=(o,d)=>{te(o.inputs,d),o.compute($e(o.inputs,d))},rn=o=>ka({axis:o.axis,blockSize:o.blockSize})}),Qo,ea,_a,Pa=p(()=>{ii(),ya(),Xo(),Qo=(o,d,_)=>{let m=o===d,g=o<d&&_<0,y=o>d&&_>0;if(m||g||y)throw new Error("Range these inputs' contents are invalid.")},ea=(o,d,_,m)=>{let g=Math.abs(Math.ceil((d-o)/_)),y=[g],b=g,E=[{type:12,data:b},{type:m,data:o},{type:m,data:_},...qs(y)],M=P=>{let U=be("output",m,y.length),N=U.type.value,T=[{name:"outputSize",type:"u32"},{name:"start",type:N},{name:"delta",type:N}];return`
        ${P.registerUniforms(T).declareVariables(U)}
        ${P.mainStart()}
        ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${N}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${m}`},getShaderSource:M,getRunData:()=>({outputs:[{dims:y,dataType:m}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:E})}},_a=o=>{let d=0,_=0,m=0;o.inputs[0].dataType===6?(d=o.inputs[0].getInt32Array()[0],_=o.inputs[1].getInt32Array()[0],m=o.inputs[2].getInt32Array()[0]):o.inputs[0].dataType===1&&(d=o.inputs[0].getFloat32Array()[0],_=o.inputs[1].getFloat32Array()[0],m=o.inputs[2].getFloat32Array()[0]),X.webgpu.validateInputContent&&Qo(d,_,m),o.compute(ea(d,_,m,o.inputs[0].dataType),{inputs:[]})}}),Ja,ou,ja,Aa,fl,Za,za,iu,Fd,yd,Eu,Ou,Iu,Od,E_,Zg,Dw,HT,n_,J_=p(()=>{ya(),fa(),Va(),Xo(),Ja=(o,d)=>{if(o.every(_=>_>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),o.length>0){if(d.mode==="linear"){if(!(o.length===2||o.length===3||o.length===4&&o[0]===1&&o[1]===1||o.length===4&&o[0]===1&&o[3]===1||o.length===5&&o[0]===1&&o[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(d.mode==="cubic"&&!(o.length===2||o.length===4&&o[0]===1&&o[1]===1||o.length===4&&o[0]===1&&o[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},ou=(o,d,_)=>{d.every(g=>g>=0&&g<_||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let m=new Array(_).fill(1);return d.forEach((g,y)=>m[g]=o[y]),m},ja=(o,d,_,m,g,y)=>{let[b,E,M]=_>10?[1,2,3]:[-1,o.length>1?1:-1,-1],P=o[0].dims.length;if(b>0&&o.length>b&&o[b].dims.length>0)o[b].getFloat32Array().forEach(U=>y.push(U));else if(d.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(E>0&&o.length>E&&o[E].dims.length===1&&o[E].dims[0]>0){if(o[E].getFloat32Array().forEach(U=>m.push(U)),m.length!==0&&m.length!==P&&_>=18&&m.length!==d.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ja(m,d),d.axes.length>0&&ou(m,d.axes,P).forEach((U,N)=>m[N]=U)}if(M>0&&o.length>M&&o[M].dims.length===1&&o[M].dims[0]>0&&(o[M].getBigInt64Array().forEach(U=>g.push(Number(U))),g.length!==0&&g.length!==P&&_>=18&&g.length!==d.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(d.axes.length>0){if(m.length!==0&&m.length!==d.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(g.length!==0&&g.length!==d.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof m<"u"&&typeof g<"u"&&m.length>0&&g.length>P)throw new Error("Resize requires only of scales or sizes to be specified")},Aa=(o,d)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${d} { `+(()=>{switch(o){case"asymmetric":return`return ${d}(xResized) / ${d}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${d}(xResized) + 0.5) / ${d}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${d}(xResized) + 0.5) / ${d}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${d}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${d}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${d}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${d}(roiStart) * ${d}(lengthOriginal - 1) +
                        (${d}(xResized) * ${d}(roiEnd - roiStart) * ${d}(lengthOriginal - 1)) /
                        ${d}(lengthResized - 1);
                  } else {
                    return 0.5 * ${d}(roiStart + roiEnd) * ${d}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${d}xScale * ${d}(lengthResized);
                  const adjustment = ${d}(lengthResized) / outputWidth;
                  const center = ${d}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${d}(xResized) + 0.5) / ${d}(xScale)) - 0.5;`;case"half_pixel":return`return ((${d}(xResized) + 0.5) / ${d}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${o} is not supported`)}})()+"}",fl=(o,d,_)=>`fn getNearestPixelFromOriginal(xOriginal: ${_}, isDownSample: bool) -> ${_} {`+(()=>{switch(o){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(d<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${o} is not supported`)}})()+"}",Za=(o,d,_)=>{let m=new Array(_).fill(0).concat(new Array(_).fill(1)),g=o.length===0?m:o.slice();return d.length>0?(d.forEach((y,b)=>{m[y]=g[b],m[b+_]=g[d.length+b]}),m):g},za=(o,d,_,m)=>{let g=[];if(_.length>0)if(m.length>0){if(o.forEach(y=>g.push(y)),Math.max(...m)>o.length)throw new Error("axes is out of bound");m.forEach((y,b)=>g[y]=_[b])}else _.forEach(y=>g.push(y));else{if(d.length===0)throw new Error("Resize requires either scales or sizes.");g=o.map((y,b)=>Math.round(y*d[b]))}return g},iu=(o,d,_)=>{let m=(()=>{switch(_.keepAspectRatioPolicy){case"not_larger":return _.axes.length>0?Math.min(..._.axes.map(y=>d[y]),Number.MAX_VALUE):Math.min(...d,Number.MAX_VALUE);case"not_smaller":return _.axes.length>0?Math.max(..._.axes.map(y=>d[y]),Number.MIN_VALUE):Math.max(...d,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${_.keepAspectRatioPolicy} is not supported`)}})();d.fill(1,0,d.length);let g=o.slice();return _.axes.length>0?(_.axes.forEach(y=>d[y]=m),_.axes.forEach(y=>g[y]=Math.round(o[y]*d[y]))):(d.fill(m,0,d.length),g.forEach((y,b)=>g[b]=Math.round(y*d[b]))),g},Fd=(o,d,_,m,g)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${o.type.indices}) -> array<${o.type.value}, ${_.length}> {
      var original_indices: array<${o.type.value}, ${_.length}>;
      for (var i:u32 = 0; i < ${_.length}; i++) {
        var output_index = ${o.indicesGet("output_indices","i")};
        var scale = ${ca("uniforms.scales","i",m)};
        var roi_low = ${ca("uniforms.roi","i",g)};
        var roi_hi = ${ca("uniforms.roi",`i + ${d.length}`,g)};
        if (scale == 1.0) {
          original_indices[i] = ${o.type.value}(output_index);
        } else {
          var input_shape_i = ${ca("uniforms.input_shape","i",d.length)};
          var output_shape_i = ${ca("uniforms.output_shape","i",_.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,yd=(o,d,_,m,g,y,b)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${d.type.indices}) -> ${o.type.indices} {
      var input_indices: ${o.type.indices};
      for (var i:u32 = 0; i < ${m.length}; i++) {
        var output_index = ${d.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${ca("uniforms.scales","i",g)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${ca("uniforms.roi","i",y)};
          var roi_hi = ${ca("uniforms.roi",`i + ${_.length}`,y)};
          var input_shape_i = ${ca("uniforms.input_shape","i",_.length)};
          var output_shape_i = ${ca("uniforms.output_shape","i",m.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${b} || (original_idx >= 0 && original_idx < ${d.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${d.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${o.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Eu=(o,d)=>`
    fn checkInputIndices(input_indices: ${o.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${d.length}; i++) {
        var input_index = ${o.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${ca("uniforms.input_shape","i",d.length)}) {
          return false;
        }
      }
      return true;
    }`,Ou=(o,d,_,m)=>o.rank>m?`
    ${o.indicesSet("input_indices",d,"channel")};
    ${o.indicesSet("input_indices",_,"batch")};
`:"",Iu=(o,d,_,m,g)=>{let[y,b,E,M]=_.length===2?[-1,0,1,-1]:[0,2,3,1],P=o.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${P} {
      var input_indices: ${o.type.indices};
      ${o.indicesSet("input_indices",b,`max(0, min(row, ${_[b]} - 1))`)};
      ${o.indicesSet("input_indices",E,`max(0, min(col, ${_[E]} - 1))`)};
      ${Ou(o,M,y,2)}
      return ${o.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${d.type.indices}) -> ${P} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${P} = originalIndices[${b}];
      var col:${P} = originalIndices[${E}];
      ${m?`if (row < 0 || row > (${_[b]} - 1) || col < 0 || col > (${_[E]} - 1)) {
        return ${g};
      }`:""};
      row = max(0, min(row, ${_[b]} - 1));
      col = max(0, min(col, ${_[E]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${_.length>2?`u32(originalIndices[${M}])`:"0"};
      var batch: u32 =  ${_.length>2?`u32(originalIndices[${y}])`:"0"};
      var x11: ${P} = getInputValue(batch, channel, row1, col1);
      var x12: ${P} = getInputValue(batch, channel, row1, col2);
      var x21: ${P} = getInputValue(batch, channel, row2, col1);
      var x22: ${P} = getInputValue(batch, channel, row2, col2);
      var dx1: ${P} = abs(row - ${P}(row1));
      var dx2: ${P} = abs(${P}(row2) - row);
      var dy1: ${P} = abs(col - ${P}(col1));
      var dy2: ${P} = abs(${P}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Od=(o,d,_,m,g,y,b,E,M,P)=>{let U=_.length===2,[N,T]=U?[0,1]:[2,3],ae=o.type.value,ue=fe=>{let Ae=fe===N?"row":"col";return`
      fn ${Ae}CubicInterpolation(input_indices: ${o.type.indices}, output_indices: ${d.type.indices}) -> ${ae} {
        var output_index = ${d.indicesGet("output_indices",fe)};
        var originalIdx: ${ae} = getOriginalCoordinateFromResizedCoordinate(output_index, ${g[fe]},
        ${m[fe]}, ${_[fe]}, ${y[fe]}, ${y[fe]} + ${_.length});
        var fractOriginalIdx: ${ae} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${E} && (originalIdx < 0 || originalIdx > (${_[fe]} - 1))) {
          return ${M};
        }
        var data: array<${ae}, 4> = array<${ae}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Ae}: ${ae} = originalIdx + ${ae}(i);
          if (${Ae} < 0 || ${Ae} >= ${_[fe]}) {
            ${P?`coefs[i + 1] = 0.0;
                        continue;`:E?`return ${M};`:`${Ae} = max(0, min(${Ae}, ${_[fe]} - 1));`};
          }
        var input_indices_copy: ${o.type.indices} = input_indices;
          ${o.indicesSet("input_indices_copy",fe,`u32(${Ae})`)};
          data[i + 1] = ${fe===N?o.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${ue(N)};
    ${ue(T)};
  fn getCubicInterpolationCoefs(s: ${ae}) -> array<${ae}, 4> {
    var absS = abs(s);
    var coeffs: array<${ae}, 4> = array<${ae}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${ae} = 1.0 - absS;
    var twoMinusAbsS: ${ae} = 2.0 - absS;
    var onePlusAbsS: ${ae} = 1.0 + absS;
    coeffs[0] = ((${b} * onePlusAbsS - 5 * ${b}) * onePlusAbsS + 8 * ${b}) * onePlusAbsS - 4 * ${b};
    coeffs[1] = ((${b} + 2) * absS - (${b} + 3)) * absS * absS + 1;
    coeffs[2] = ((${b} + 2) * oneMinusAbsS - (${b} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${b} * twoMinusAbsS - 5 * ${b}) * twoMinusAbsS + 8 * ${b}) * twoMinusAbsS - 4 * ${b};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${ae}, 4>, coefs: array<${ae}, 4>) -> ${ae} {
    var coefsSum: ${ae} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${d.type.indices}) -> ${ae} {
    var input_indices: ${o.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},E_=(o,d,_,m,g)=>{let[y,b,E,M,P]=_.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],U=o.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${U} {
      var input_indices: ${o.type.indices};
      ${o.indicesSet("input_indices",b,`max(0, min(depth, ${_[b]} - 1))`)};
      ${o.indicesSet("input_indices",E,`max(0, min(height, ${_[E]} - 1))`)};
      ${o.indicesSet("input_indices",M,`max(0, min(width, ${_[M]} - 1))`)};
      ${Ou(o,P,y,3)}
      return ${o.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${d.type.indices}) -> ${U} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${U} = originalIndices[${b}];
      var height:${U} = originalIndices[${E}];
      var width:${U} = originalIndices[${M}];
      ${m?`if (depth < 0 || depth > (${_[b]} - 1) || height < 0 || height > (${_[E]} - 1) || width < 0 || (width > ${_[M]} - 1)) {
      return ${g};
        }`:""};

    depth = max(0, min(depth, ${_[b]} - 1));
      height = max(0, min(height, ${_[E]} - 1));
      width = max(0, min(width, ${_[M]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${_.length>3?`u32(originalIndices[${P}])`:"0"};
      var batch: u32 =  ${_.length>3?`u32(originalIndices[${y}])`:"0"};

      var x111: ${U} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${U} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${U} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${U} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${U} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${U} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${U} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${U} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${U} = abs(depth - ${U}(depth1));
      var dx2: ${U} = abs(${U}(depth2) - depth);
      var dy1: ${U} = abs(height - ${U}(height1));
      var dy2: ${U} = abs(${U}(height2) - height);
      var dz1: ${U} = abs(width - ${U}(width1));
      var dz2: ${U} = abs(${U}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Zg=(o,d,_,m,g,y)=>{let b=o.dims,E=Za(y,d.axes,b.length),M=za(b,m,g,d.axes),P=m.slice();m.length===0&&(P=b.map((Oe,pt)=>Oe===0?1:M[pt]/Oe),d.keepAspectRatioPolicy!=="stretch"&&(M=iu(b,P,d)));let U=be("output",o.dataType,M.length),N=S("input",o.dataType,b.length),T=wr.size(M),ae=b.length===M.length&&b.every((Oe,pt)=>Oe===M[pt]),ue=d.coordinateTransformMode==="tf_crop_and_resize",fe=d.extrapolationValue,Ae=N.type.value,Le=Oe=>`
      ${ae?"":`
      ${Aa(d.coordinateTransformMode,Ae)};
      ${(()=>{switch(d.mode){case"nearest":return`
              ${Eu(N,b)};
              ${fl(d.nearestMode,_,Ae)};
              ${yd(N,U,b,M,P.length,E.length,ue)};
              `;case"linear":return`
              ${Fd(U,b,M,P.length,E.length)};
              ${(()=>{if(b.length===2||b.length===4)return`${Iu(N,U,b,ue,fe)}`;if(b.length===3||b.length===5)return`${E_(N,U,b,ue,fe)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(b.length===2||b.length===4)return`${Od(N,U,b,M,P,E,d.cubicCoeffA,ue,d.extrapolationValue,d.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${Oe.registerUniform("output_size","u32").registerUniform("scales","f32",P.length).registerUniform("roi","f32",E.length).declareVariables(N,U)}
      ${Oe.mainStart()}
        ${Oe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${ae?"output[global_idx] = input[global_idx];":`
        let output_indices = ${U.offsetToIndices("global_idx")};
        var input_indices: ${N.type.indices};
        ${(()=>{switch(d.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${N.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${d.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${b.length===2||b.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${d.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${d.cacheKey}|${_}|${P.length>0?P:""}|${g.length>0?g:""}|${E.length>0?E:""}|${ae}|${b}`,inputDependencies:["rank"]},getShaderSource:Le,getRunData:()=>({outputs:[{dims:M,dataType:o.dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},{type:1,data:P},{type:1,data:E},...qs(b,M)]})}},Dw=o=>{let d=o.customDataBuffer;return new Uint32Array(d,d.byteOffset,1)[0]},HT=(o,d)=>{let _=[],m=[],g=[],y=Dw(o);if(d.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");ja(o.inputs,d,y,_,m,g),o.compute(Zg(o.inputs[0],d,y,_,m,g),{inputs:[0]})},n_=o=>{let d=o.antialias,_=o.axes,m=o.coordinateTransformMode,g=o.cubicCoeffA,y=o.excludeOutside!==0,b=o.extrapolationValue,E=o.keepAspectRatioPolicy,M=o.mode,P=o.nearestMode===""?"simple":o.nearestMode;return ka({antialias:d,axes:_,coordinateTransformMode:m,cubicCoeffA:g,excludeOutside:y,extrapolationValue:b,keepAspectRatioPolicy:E,mode:M,nearestMode:P})}}),vT,TT,ET,MT=p(()=>{ya(),fa(),Va(),Xo(),vT=(o,d)=>{let[_,m,g,y]=o,{numHeads:b,rotaryEmbeddingDim:E}=d;if(_.dims.length!==3&&_.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${_.dims.length}`);if(!wr.areEqual(m.dims,[])&&!wr.areEqual(m.dims,[1])&&m.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${m.dims.length}`);if(g.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${g.dims.length}`);if(y.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${y.dims.length}`);if(!wr.areEqual(g.dims,y.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(E>0&&b===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let M=_.dims[0],P=_.dims[_.dims.length-2],U=g.dims[0],N=wr.sizeFromDimension(_.dims,1)/P,T=E===0?g.dims[1]*2:N/b;if(E>T)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(m.dims.length===2){if(M!==m.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${m.dims[0]}`);if(P!==m.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${m.dims[1]}`)}if(T/2!==g.dims[1]&&E/2!==g.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${g.dims[1]}`);if(P>U)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},TT=(o,d)=>{let{interleaved:_,numHeads:m,rotaryEmbeddingDim:g,scale:y}=d,b=o[0].dims[0],E=wr.sizeFromDimension(o[0].dims,1),M=o[0].dims[o[0].dims.length-2],P=E/M,U=o[2].dims[1],N=g===0?U*2:P/m,T=new Array(b,M,P/N,N-U),ae=wr.computeStrides(T),ue=[{type:1,data:y},{type:12,data:T},{type:12,data:ae},...o[0].dims.length===3?new Array({type:12,data:[E,P,N,1]}):[],...o[0].dims.length===4?new Array({type:12,data:[E,N,M*N,1]}):[],...qs(o[0].dims,o[1].dims,o[2].dims,o[3].dims,o[0].dims)],fe=Ae=>{let Le=S("input",o[0].dataType,o[0].dims.length),Oe=S("position_ids",o[1].dataType,o[1].dims.length),pt=S("cos_cache",o[2].dataType,o[2].dims.length),lt=S("sin_cache",o[3].dataType,o[3].dims.length),ft=be("output",o[0].dataType,o[0].dims.length);return Ae.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:T.length},{name:"global_strides",type:"u32",length:ae.length},{name:"input_output_strides",type:"u32",length:ae.length}]),`
        ${Ae.declareVariables(Le,Oe,pt,lt,ft)}

        ${Ae.mainStart(Du)}
          let half_rotary_emb_dim = uniforms.${pt.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${Ae.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${Oe.broadcastedIndicesToOffset("bsnh.xy",be("",Oe.type.tensor,2))};
            let position_id =
                u32(${Oe.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${_});
            let j = i + select(half_rotary_emb_dim, 1, ${_});
            let re = ${Le.getByOffset("i")} * ${pt.get("position_id","bsnh[3]")} -
                ${Le.getByOffset("j")} * ${lt.get("position_id","bsnh[3]")};
            ${ft.setByOffset("i","re")}
            let im = ${Le.getByOffset("i")} * ${lt.get("position_id","bsnh[3]")} +
                ${Le.getByOffset("j")} * ${pt.get("position_id","bsnh[3]")};
            ${ft.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${ft.setByOffset("k",Le.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:ka({interleaved:_}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:fe,getRunData:()=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(wr.size(T)/Du)},programUniforms:ue})}},ET=(o,d)=>{vT(o.inputs,d),o.compute(TT(o.inputs,d))}}),B1,L1,R1,oM=p(()=>{ya(),fa(),Xo(),B1=o=>{if(!o||o.length<3)throw new Error("layerNorm requires at least 3 inputs.");let d=o[0],_=o[1],m=o[2];if(d.dataType!==_.dataType||d.dataType!==m.dataType)throw new Error("All inputs must have the same data type");if(d.dims.length!==3&&d.dims.length!==2)throw new Error("Input must be 2D or 3D");if(_.dims.length!==3&&_.dims.length!==2)throw new Error("Skip must be 2D or 3D");let g=d.dims[d.dims.length-1],y=d.dims[d.dims.length-2];if(_.dims[_.dims.length-1]!==g)throw new Error("Skip must have the same hidden size as input");if(_.dims[_.dims.length-2]!==y)throw new Error("Skip must have the same sequence length as input");if(m.dims.length!==1)throw new Error("Gamma must be 1D");if(m.dims[m.dims.length-1]!==g)throw new Error("Gamma must have the same hidden size as input");if(o.length>3){let b=o[3];if(b.dims.length!==1)throw new Error("Beta must be 1D");if(b.dims[b.dims.length-1]!==g)throw new Error("Beta must have the same hidden size as input")}if(o.length>4){let b=o[4];if(b.dims.length!==1)throw new Error("Bias must be 1D");if(b.dims[b.dims.length-1]!==g)throw new Error("Bias must have the same hidden size as input")}},L1=(o,d,_,m)=>{let g=d.simplified,y=o[0].dims,b=wr.size(y),E=y,M=b,P=y.slice(-1)[0],U=m?y.slice(0,-1).concat(1):[],N=!g&&o.length>3,T=o.length>4,ae=m&&_>1,ue=m&&_>2,fe=_>3,Ae=64,Le=La(P),Oe=[{type:12,data:M},{type:12,data:Le},{type:12,data:P},{type:1,data:d.epsilon}],pt=ft=>{let nn=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],Er=[S("x",o[0].dataType,o[0].dims,Le),S("skip",o[1].dataType,o[1].dims,Le),S("gamma",o[2].dataType,o[2].dims,Le)];N&&Er.push(S("beta",o[3].dataType,o[3].dims,Le)),T&&Er.push(S("bias",o[4].dataType,o[4].dims,Le)),Er.push(be("output",o[0].dataType,E,Le)),ae&&Er.push(be("mean_output",1,U)),ue&&Er.push(be("inv_std_output",1,U)),fe&&Er.push(be("input_skip_bias_sum",o[0].dataType,E,Le));let Do=Fa(o[0].dataType),aa=Fa(1,Le);return`

      ${ft.registerUniforms(nn).declareVariables(...Er)}
      var<workgroup> sum_shared : array<${aa}, ${Ae}>;
      var<workgroup> sum_squared_shared : array<${aa}, ${Ae}>;

      ${ft.mainStart([Ae,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${Ae};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${Ae};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${Ae-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${T?"bias[offset1d + i]":Do+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${fe?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Cd(Do,Le,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${Ae};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Dd("sum",Le)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Dd("square_sum",Le)} / f32(uniforms.hidden_size) ${g?"":"- mean * mean"} + uniforms.epsilon);
        ${ae?"mean_output[global_idx] = mean;":""}
        ${ue?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${g?"":`- ${Do}(mean)`}) *
            ${Do}(inv_std_dev) * gamma[offset1d + i]
            ${N?"+ beta[offset1d + i]":""};
        }
      }`},lt=[{dims:E,dataType:o[0].dataType}];return _>1&&lt.push({dims:U,dataType:1}),_>2&&lt.push({dims:U,dataType:1}),_>3&&lt.push({dims:y,dataType:o[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${Le};${ae};${ue};${fe}`,inputDependencies:o.map((ft,nn)=>"type")},getShaderSource:pt,getRunData:()=>({outputs:lt,dispatchGroup:{x:Math.ceil(M/P)},programUniforms:Oe})}},R1=(o,d)=>{B1(o.inputs);let _=[0];o.outputCount>1&&_.push(-3),o.outputCount>2&&_.push(-3),o.outputCount>3&&_.push(3),o.compute(L1(o.inputs,d,o.outputCount,!1),{outputs:_})}}),j1,Bv,z1,XT,N1,U1,W1,V1,sM=p(()=>{ya(),fa(),Va(),Xo(),j1=(o,d)=>{if(!o||o.length<1)throw new Error("too few inputs");if(d.axes.length!==0){if(d.axes.length!==d.starts.length||d.axes.length!==d.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(d.starts.length!==d.ends.length)throw new Error("starts and ends must have the same length");o.slice(1).forEach((_,m)=>{if(o[m+1].dataType!==6&&o[m+1].dataType!==7)throw new Error(`Input ${m} must be an array of int32 or int64`)})},Bv=(o,d)=>{let _=[];if(o.length>d)if(o[d].dataType===7)o[d].getBigInt64Array().forEach(m=>_.push(Number(m)));else if(o[d].dataType===6)o[d].getInt32Array().forEach(m=>_.push(Number(m)));else throw new Error(`Input ${d} must be an array of int32 or int64`);return _},z1=(o,d)=>{if(o.length>1){let _=Bv(o,1),m=Bv(o,2),g=Bv(o,3);return g.length===0&&(g=[...Array(o[0].dims.length).keys()]),ka({starts:_,ends:m,axes:g})}else return d},XT=(o,d,_,m,g)=>{let y=o;return o<0&&(y+=_[m[d]]),g[d]<0?Math.max(0,Math.min(y,_[m[d]]-1)):Math.max(0,Math.min(y,_[m[d]]))},N1=(o,d,_)=>`fn calculateInputIndices(output_indices: ${d.type.indices}) -> ${o.type.indices} {
          var input_indices: ${o.type.indices};
          var carry = 0u;
          for (var i = ${_.length}; i >= 0; i--) {
            let input_shape_i = ${ca("uniforms.input_shape","i",_.length)};
            let steps_i = ${ca("uniforms.steps","i",_.length)};
            let signs_i = ${ca("uniforms.signs","i",_.length)};
            let starts_i = ${ca("uniforms.starts","i",_.length)};
            var output_index = ${d.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${o.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,U1=(o,d)=>{let _=o[0].dims,m=wr.size(_),g=d.axes.length>0?wr.normalizeAxes(d.axes,_.length):[...Array(_.length).keys()],y=Bv(o,4);y.forEach(Le=>Le!==0||(()=>{throw new Error("step cannot be 0")})),y.length===0&&(y=Array(g.length).fill(1));let b=d.starts.map((Le,Oe)=>XT(Le,Oe,_,g,y)),E=d.ends.map((Le,Oe)=>XT(Le,Oe,_,g,y));if(g.length!==b.length||g.length!==E.length)throw new Error("start, ends and axes should have the same number of elements");if(g.length!==_.length)for(let Le=0;Le<_.length;++Le)g.includes(Le)||(b.splice(Le,0,0),E.splice(Le,0,_[Le]),y.splice(Le,0,1));let M=y.map(Le=>Math.sign(Le));y.forEach((Le,Oe,pt)=>{if(Le<0){let lt=(E[Oe]-b[Oe])/Le,ft=b[Oe],nn=ft+lt*y[Oe];b[Oe]=nn,E[Oe]=ft,pt[Oe]=-Le}});let P=_.slice(0);g.forEach((Le,Oe)=>{P[Le]=Math.ceil((E[Le]-b[Le])/y[Le])});let U={dims:P,dataType:o[0].dataType},N=be("output",o[0].dataType,P.length),T=S("input",o[0].dataType,o[0].dims.length),ae=wr.size(P),ue=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:b.length},{name:"signs",type:"i32",length:M.length},{name:"steps",type:"u32",length:y.length}],fe=[{type:12,data:ae},{type:12,data:b},{type:6,data:M},{type:12,data:y},...qs(o[0].dims,P)],Ae=Le=>`
      ${Le.registerUniforms(ue).declareVariables(T,N)}
        ${N1(T,N,_)}
        ${Le.mainStart()}
          ${Le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${N.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${N.setByOffset("global_idx",T.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${M.length}_${b.length}_${y.length}`,inputDependencies:["rank"]},getShaderSource:Ae,getRunData:()=>({outputs:[U],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:fe})}},W1=(o,d)=>{j1(o.inputs,d);let _=z1(o.inputs,d);o.compute(U1(o.inputs,_),{inputs:[0]})},V1=o=>{let d=o.starts,_=o.ends,m=o.axes;return ka({starts:d,ends:_,axes:m})}}),G1,K1,q1,H1,iM=p(()=>{ya(),fa(),Va(),ru(),Xo(),G1=o=>{if(!o||o.length!==1)throw new Error("Softmax op requires 1 input.")},K1=(o,d)=>{let _=o.inputs[0],m=_.dims,g=wr.size(m),y=64,b=m.length,E=wr.normalizeAxis(d.axis,b),M=E<m.length-1,P,U=[];M?(U=Array.from({length:b},(Er,Do)=>Do),U[E]=b-1,U[b-1]=E,P=o.compute(Td(_,U),{inputs:[_],outputs:[-1]})[0]):P=_;let N=P.dims,T=N[b-1],ae=g/T,ue=La(T),fe=T/ue,Ae=(Er,Do)=>Do===4?`max(max(${Er}.x, ${Er}.y), max(${Er}.z, ${Er}.w))`:Do===2?`max(${Er}.x, ${Er}.y)`:Do===3?`max(max(${Er}.x, ${Er}.y), ${Er}.z)`:Er,Le=S("x",P.dataType,P.dims,ue),Oe=be("result",P.dataType,P.dims,ue),pt=Le.type.value,lt=Fa(P.dataType)==="f32"?`var threadMax = ${pt}(-3.402823e+38f);`:`var threadMax = ${pt}(-65504.0h);`,ft=Er=>`
      var<workgroup> rowMaxShared : ${pt};
      var<workgroup> rowSumShared : ${pt};
      var<workgroup> threadShared : array<${pt}, ${y}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${pt} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${pt}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${Er.registerUniform("packedCols","i32").declareVariables(Le,Oe)}
      ${Er.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${y};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${lt}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${pt}(${Ae("threadShared[0]",ue)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${pt}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${pt}(${Dd("threadShared[0]",ue)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,nn=o.compute({name:"Softmax",shaderCache:{hint:`${ue}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:N,dataType:P.dataType}],dispatchGroup:{x:ae},programUniforms:[{type:6,data:fe}]}),getShaderSource:ft},{inputs:[P],outputs:[M?-1:0]})[0];M&&o.compute(Td(nn,U),{inputs:[nn]})},q1=(o,d)=>{G1(o.inputs),K1(o,d)},H1=o=>ka({axis:o.axis})}),X1,Y1,Q1,Z1,J1,eE,tE,aM=p(()=>{ya(),fa(),Va(),Xo(),X1=o=>{if(!o||o.length<1)throw new Error("too few inputs")},Y1=(o,d)=>{let _=[],m=d.numOutputs;return o[1].dims[0]>0&&(o[1].getBigInt64Array().forEach(g=>_.push(Number(g))),m=_.length),ka({numOutputs:m,axis:d.axis,splitSizes:_})},Q1=o=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${o}u; i += 1u ) {
    if (index < ${ca("uniforms.size_in_split_axis","i",o)}) {
        return i;
    }
    }
    return ${o}u;
}`,Z1=o=>{let d=o.length,_=[];for(let m=0;m<d;++m){let g=o[m].setByIndices("indices","input[global_idx]");d===1?_.push(g):m===0?_.push(`if (output_number == ${m}u) { ${g} }`):m===d-1?_.push(`else { ${g} }`):_.push(`else if (output_number == ${m}) { ${g} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${o[0].type.indices}, global_idx: u32) {
        ${_.join(`
`)}
      }`},J1=(o,d)=>{let _=o[0].dims,m=wr.size(_),g=o[0].dataType,y=wr.normalizeAxis(d.axis,_.length),b=new Array(d.numOutputs),E=S("input",g,_.length),M=new Array(d.numOutputs),P=[],U=[],N=0,T=[{type:12,data:m}];for(let ue=0;ue<d.numOutputs;ue++){N+=d.splitSizes[ue],M[ue]=N;let fe=_.slice();fe[y]=d.splitSizes[ue],U.push(fe),b[ue]=be(`output${ue}`,g,fe.length),P.push({dims:U[ue],dataType:o[0].dataType})}T.push({type:12,data:M},...qs(_,...U));let ae=ue=>`
  ${ue.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",M.length).declareVariables(E,...b)}
  ${Q1(M.length)}
  ${Z1(b)}

  ${ue.mainStart()}
    ${ue.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${E.offsetToIndices("global_idx")};
    var index = ${E.indicesGet("indices",y)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${ca("uniforms.size_in_split_axis","output_number - 1u",M.length)};
      ${E.indicesSet("indices",y,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:d.cacheKey,inputDependencies:["rank"]},getShaderSource:ae,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(m/64)},programUniforms:T})}},eE=(o,d)=>{X1(o.inputs);let _=o.inputs.length===1?d:Y1(o.inputs,d);o.compute(J1(o.inputs,_),{inputs:[0]})},tE=o=>{let d=o.axis,_=o.splitSizes,m=o.numOutputs<0?_.length:o.numOutputs;if(m!==_.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ka({axis:d,numOutputs:m,splitSizes:_})}}),rE,nE,oE,lM=p(()=>{ya(),fa(),Xo(),rE=(o,d,_,m,g)=>{let y=be("output_data",g,_.length,4),b=S("a_data",d[1].dataType,d[1].dims.length,4),E=S("b_data",d[2].dataType,d[2].dims.length,4),M=S("c_data",d[0].dataType,d[0].dims.length,4),P,U=(N,T,ae)=>`select(${T}, ${N}, ${ae})`;if(!m)P=y.setByOffset("global_idx",U(b.getByOffset("global_idx"),E.getByOffset("global_idx"),M.getByOffset("global_idx")));else{let N=(T,ae,ue="")=>{let fe=`a_data[index_a${ae}][component_a${ae}]`,Ae=`b_data[index_b${ae}][component_b${ae}]`,Le=`bool(c_data[index_c${ae}] & (0xffu << (component_c${ae} * 8)))`;return`
            let output_indices${ae} = ${y.offsetToIndices(`global_idx * 4u + ${ae}u`)};
            let offset_a${ae} = ${b.broadcastedIndicesToOffset(`output_indices${ae}`,y)};
            let offset_b${ae} = ${E.broadcastedIndicesToOffset(`output_indices${ae}`,y)};
            let offset_c${ae} = ${M.broadcastedIndicesToOffset(`output_indices${ae}`,y)};
            let index_a${ae} = offset_a${ae} / 4u;
            let index_b${ae} = offset_b${ae} / 4u;
            let index_c${ae} = offset_c${ae} / 4u;
            let component_a${ae} = offset_a${ae} % 4u;
            let component_b${ae} = offset_b${ae} % 4u;
            let component_c${ae} = offset_c${ae} % 4u;
            ${T}[${ae}] = ${ue}(${U(fe,Ae,Le)});
          `};g===9?P=`
            var data = vec4<u32>(0);
            ${N("data",0,"u32")}
            ${N("data",1,"u32")}
            ${N("data",2,"u32")}
            ${N("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:P=`
            ${N("output_data[global_idx]",0)}
            ${N("output_data[global_idx]",1)}
            ${N("output_data[global_idx]",2)}
            ${N("output_data[global_idx]",3)}
          `}return`
        ${o.registerUniform("vec_size","u32").declareVariables(M,b,E,y)}
        ${o.mainStart()}
        ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${P}
      }`},nE=o=>{let d=o[1].dims,_=o[2].dims,m=o[0].dims,g=o[1].dataType,y=!(wr.areEqual(d,_)&&wr.areEqual(_,m)),b=d,E=wr.size(d);if(y){let P=xd.calcShape(xd.calcShape(d,_,!1),m,!1);if(!P)throw new Error("Can't perform where op on the given tensors");b=P,E=wr.size(b)}let M=Math.ceil(E/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:P=>rE(P,o,b,y,g),getRunData:()=>({outputs:[{dims:b,dataType:g}],dispatchGroup:{x:Math.ceil(E/64/4)},programUniforms:[{type:12,data:M},...qs(m,d,_,b)]})}},oE=o=>{o.compute(nE(o.inputs))}}),sE,uM=p(()=>{p0(),Py(),Kv(),qv(),Hv(),Xv(),ux(),Jv(),nT(),oT(),sT(),iT(),KT(),qx(),lT(),uT(),qT(),pT(),hT(),fT(),gT(),vx(),bT(),_T(),yT(),C(),Qr(),Pa(),wy(),J_(),MT(),oM(),sM(),iM(),aM(),uv(),ru(),Wy(),lM(),sE=new Map([["Abs",[Ay]],["Acos",[v0]],["Acosh",[T0]],["Add",[Ky]],["ArgMax",[c0,Ty]],["ArgMin",[vy,Ty]],["Asin",[E0]],["Asinh",[M0]],["Atan",[Sy]],["Atanh",[P0]],["Attention",[m0]],["AveragePool",[Ca,wT]],["BatchNormalization",[Oy]],["BiasAdd",[w0]],["BiasSplitGelu",[X0]],["Cast",[O0,k0]],["Ceil",[A0]],["Clip",[Iy]],["Concat",[ax,lx]],["Conv",[sw,nw]],["ConvTranspose",[Cx,Ax]],["Cos",[S0]],["Cosh",[Cy]],["CumSum",[lw,Fx]],["DepthToSpace",[dw,Rx]],["DequantizeLinear",[ar,rn]],["Div",[Q0]],["Einsum",[Wx,_w]],["Elu",[I0,V_]],["Equal",[Z0]],["Erf",[C0]],["Exp",[D0]],["Expand",[hw]],["FastGelu",[fw]],["Floor",[Dy]],["FusedConv",[sw,nw]],["Gather",[Yx,mw]],["GatherElements",[nu,tv]],["GatherBlockQuantized",[Zx,bw]],["Gelu",[F0]],["Gemm",[rv,yw]],["GlobalAveragePool",[gd,_d]],["GlobalMaxPool",[Fv,Dv]],["Greater",[tx]],["GreaterOrEqual",[Om]],["GroupQueryAttention",[_v,cv]],["HardSigmoid",[By,z0]],["InstanceNormalization",[mv]],["LayerNormalization",[gv]],["LeakyRelu",[B0,V_]],["Less",[rx]],["LessOrEqual",[nx]],["Log",[Ny]],["MatMul",[Wg]],["MatMulNBits",[xv,vv]],["MaxPool",[D_,xT]],["Mul",[qy]],["MultiHeadAttention",[xw,ww]],["Neg",[L0]],["Not",[Fy]],["Pad",[Sv]],["Pow",[J0]],["QuickGelu",[Uy,V_]],["Range",[_a]],["Reciprocal",[R0]],["ReduceMin",[l0]],["ReduceMean",[my]],["ReduceMax",[a0]],["ReduceSum",[u0]],["ReduceProd",[by]],["ReduceL1",[s0]],["ReduceL2",[i0]],["ReduceLogSum",[yy]],["ReduceLogSumExp",[gy]],["ReduceSumSquare",[d0]],["Relu",[kh]],["Resize",[HT,n_]],["RotaryEmbedding",[ET]],["Sigmoid",[j0]],["Sin",[Ly]],["Sinh",[N0]],["Slice",[W1,V1]],["SkipLayerNormalization",[R1]],["Split",[eE,tE]],["Sqrt",[Ry]],["Softmax",[q1,H1]],["Sub",[ex]],["Tan",[U0]],["Tanh",[W0]],["ThresholdedRelu",[G0,V_]],["Tile",[lv]],["Transpose",[In,qa]],["Where",[oE]]])}),iE,dM=p(()=>{ii(),L(),Xo(),iE=class{constructor(o){this.backend=o,this.repo=new Map,this.attributesBound=!1}getArtifact(o){return this.repo.get(o)}setArtifact(o,d){this.repo.set(o,d)}run(o,d,_,m,g){Jr(o.programInfo.name);let y=this.backend.device,b=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let E=[];for(let P of d)E.push({binding:E.length,resource:{buffer:P.buffer}});for(let P of _)E.push({binding:E.length,resource:{buffer:P.buffer}});g&&E.push({binding:E.length,resource:g});let M=y.createBindGroup({layout:o.computePipeline.getBindGroupLayout(0),entries:E,label:o.programInfo.name});if(this.backend.sessionStatus==="capturing"){let P={kernelId:this.backend.currentKernelId,computePipeline:o.computePipeline,bindGroup:M,dispatchGroup:m};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(P)}b.setPipeline(o.computePipeline),b.setBindGroup(0,M),b.dispatchWorkgroups(...m),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),en(o.programInfo.name)}dispose(){}build(o,d){Jr(o.name);let _=this.backend.device,m=[];_.features.has("shader-f16")&&m.push("enable f16;");let g=Ir(d,this.backend.device.limits),y=o.getShaderSource(g),b=`${m.join(`
`)}
${g.additionalImplementations}
${y}`,E=_.createShaderModule({code:b,label:o.name});Pt("verbose",()=>`[WebGPU] ${o.name} shader code: ${b}`);let M=_.createComputePipeline({compute:{module:E,entryPoint:"main"},layout:"auto",label:o.name});return en(o.name),{programInfo:o,computePipeline:M,uniformVariablesInfo:g.variablesInfo}}normalizeDispatchGroupSize(o){let d=typeof o=="number"?o:o.x,_=typeof o=="number"?1:o.y||1,m=typeof o=="number"?1:o.z||1,g=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(d<=g&&_<=g&&m<=g)return[d,_,m];let y=d*_*m,b=Math.ceil(Math.sqrt(y));if(b>g){if(b=Math.ceil(Math.cbrt(y)),b>g)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[b,b,b]}else return[b,b,1]}}}),aE,lE,uE,dE,cM=p(()=>{ii(),ya(),L(),st(),hu(),uM(),dM(),aE=(o,d)=>{if(d.length!==o.length)throw new Error(`inputDependencies length ${d.length} is not equal to inputTensors length ${o.length}.`);let _=[];for(let m=0;m<o.length;++m){let g=o[m].dataType;switch(d[m]){case"none":{_.push("");break}case"type":{_.push(`${g}`);break}case"rank":{let y=o[m].dims.length;_.push(`${g};${y}`);break}case"dims":{let y=o[m].dims.join(",");_.push(`${g};${y}`);break}default:throw new Error(`unsupported input dependency: ${d[m]}`)}}return _.join("|")},lE=(o,d,_)=>{var g,y;let m=o.name;return(g=o.shaderCache)!=null&&g.hint&&(m+="["+o.shaderCache.hint+"]"),m+=":"+_+`:${aE(d,((y=o.shaderCache)==null?void 0:y.inputDependencies)??new Array(d.length).fill("dims"))}`,m},uE=class{constructor(o){o&&(this.architecture=o.architecture,this.vendor=o.vendor)}isArchitecture(o){return this.architecture===o}isVendor(o){return this.vendor===o}},dE=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let o=this.kernelCustomData.get(this.currentKernelId);return o||(o={},this.kernelCustomData.set(this.currentKernelId,o)),o}async initialize(o,d){this.env=o;let _=[],m={requiredLimits:{maxComputeWorkgroupStorageSize:d.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:d.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:d.limits.maxStorageBufferBindingSize,maxBufferSize:d.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:d.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:d.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:d.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:d.limits.maxComputeWorkgroupSizeZ},requiredFeatures:_};d.features.has("chromium-experimental-timestamp-query-inside-passes")?_.push("chromium-experimental-timestamp-query-inside-passes"):d.features.has("timestamp-query")&&_.push("timestamp-query"),d.features.has("shader-f16")&&_.push("shader-f16"),this.device=await d.requestDevice(m),this.adapterInfo=new uE(d.info||await d.requestAdapterInfo()),this.gpuDataManager=$a(this),this.programManager=new iE(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,d_(o.logLevel,!!o.debug),this.device.onuncapturederror=g=>{g.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${g.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:d,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let o=this.getCommandEncoder(),d={};this.queryType==="at-passes"&&(d.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=o.beginComputePass(d)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Jr(),this.endComputePass();let o;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),o=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(o,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,o,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&o.mapAsync(GPUMapMode.READ).then(()=>{var m;let d=new BigUint64Array(o.getMappedRange()),_=this.pendingQueries.get(o);for(let g=0;g<d.length/2;g++){let y=_[g],b=y.kernelId,E=this.kernels.get(b),M=E.kernelType,P=E.kernelName,U=y.programName,N=y.inputTensorViews,T=y.outputTensorViews,ae=d[g*2],ue=d[g*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=ae);let fe=Number(ae-this.queryTimeBase),Ae=Number(ue-this.queryTimeBase);if(!Number.isSafeInteger(fe)||!Number.isSafeInteger(Ae))throw new RangeError("incorrect timestamp range");if((m=this.env.webgpu.profiling)!=null&&m.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:N.map(Le=>({dims:Le.dims,dataType:Ad(Le.dataType)})),outputsMetadata:T.map(Le=>({dims:Le.dims,dataType:Ad(Le.dataType)})),kernelId:b,kernelType:M,kernelName:P,programName:U,startTime:fe,endTime:Ae});else{let Le="";N.forEach((pt,lt)=>{Le+=`input[${lt}]: [${pt.dims}] | ${Ad(pt.dataType)}, `});let Oe="";T.forEach((pt,lt)=>{Oe+=`output[${lt}]: [${pt.dims}] | ${Ad(pt.dataType)}, `}),console.log(`[profiling] kernel "${b}|${M}|${P}|${U}" ${Le}${Oe}execution time: ${Ae-fe} ns`)}Kr("GPU",`${U}::${ae}::${ue}`)}o.unmap(),this.pendingQueries.delete(o)}),en()}run(o,d,_,m,g,y){Jr(o.name);let b=[];for(let Oe=0;Oe<d.length;++Oe){let pt=d[Oe].data;if(pt===0)continue;let lt=this.gpuDataManager.get(pt);if(!lt)throw new Error(`no GPU data for input: ${pt}`);b.push(lt)}let{outputs:E,dispatchGroup:M,programUniforms:P}=o.getRunData(d),U=_.length===0?E.map((Oe,pt)=>pt):_;if(U.length!==E.length)throw new Error(`Output size ${U.length} must be equal to ${E.length}.`);let N=[],T=[];for(let Oe=0;Oe<E.length;++Oe){if(!Number.isInteger(U[Oe])||U[Oe]<-3||U[Oe]>=y)throw new Error(`Invalid output index: ${U[Oe]}`);if(U[Oe]===-3)continue;let pt=U[Oe]===-1,lt=U[Oe]===-2,ft=pt||lt?g(E[Oe].dataType,E[Oe].dims):m(U[Oe],E[Oe].dataType,E[Oe].dims);if(N.push(ft),ft.data===0)continue;let nn=this.gpuDataManager.get(ft.data);if(!nn)throw new Error(`no GPU data for output: ${ft.data}`);if(pt&&this.temporaryData.push(nn),lt){let Er=this.kernelPersistentData.get(this.currentKernelId);Er||(Er=[],this.kernelPersistentData.set(this.currentKernelId,Er)),Er.push(nn)}T.push(nn)}if(b.length!==d.length||T.length!==N.length){if(T.length===0)return en(o.name),N;throw new Error(`Program ${o.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let ae;if(P){let Oe=0,pt=[];P.forEach(Er=>{let Do=typeof Er.data=="number"?[Er.data]:Er.data;if(Do.length===0)return;let aa=Er.type===10?2:4,pa,Ia;Er.type===10?(Ia=Do.length>4?16:Do.length>2?8:Do.length*aa,pa=Do.length>4?16:aa*Do.length):(Ia=Do.length<=2?Do.length*aa:16,pa=16),Oe=Math.ceil(Oe/Ia)*Ia,pt.push(Oe);let Da=Er.type===10?8:4;Oe+=Do.length>4?Math.ceil(Do.length/Da)*pa:Do.length*aa});let lt=16;Oe=Math.ceil(Oe/lt)*lt;let ft=new ArrayBuffer(Oe);P.forEach((Er,Do)=>{let aa=pt[Do],pa=typeof Er.data=="number"?[Er.data]:Er.data;if(Er.type===6)new Int32Array(ft,aa,pa.length).set(pa);else if(Er.type===12)new Uint32Array(ft,aa,pa.length).set(pa);else if(Er.type===10)new Uint16Array(ft,aa,pa.length).set(pa);else if(Er.type===1)new Float32Array(ft,aa,pa.length).set(pa);else throw new Error(`Unsupported uniform type: ${Ad(Er.type)}`)});let nn=this.gpuDataManager.create(Oe,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(nn.buffer,0,ft,0,Oe),this.gpuDataManager.release(nn.id),ae={offset:0,size:Oe,buffer:nn.buffer}}let ue=this.programManager.normalizeDispatchGroupSize(M),fe=ue[1]===1&&ue[2]===1,Ae=lE(o,d,fe),Le=this.programManager.getArtifact(Ae);if(Le||(Le=this.programManager.build(o,ue),this.programManager.setArtifact(Ae,Le),Pt("info",()=>`[artifact] key: ${Ae}, programName: ${o.name}`)),P&&Le.uniformVariablesInfo){if(P.length!==Le.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${Le.uniformVariablesInfo.length}, got ${P.length} in program "${Le.programInfo.name}".`);for(let Oe=0;Oe<P.length;Oe++){let pt=P[Oe],lt=pt.type,ft=typeof pt.data=="number"?1:pt.data.length,[nn,Er]=Le.uniformVariablesInfo[Oe];if(lt!==nn||ft!==Er)throw new Error(`Uniform variable ${Oe} mismatch: expect type ${nn} with size ${Er}, got type ${lt} with size ${ft} in program "${Le.programInfo.name}".`)}}if(Pt("info",()=>`[ProgramManager] run "${o.name}" (key=${Ae}) with ${ue[0]}x${ue[1]}x${ue[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let Oe={kernelId:this.currentKernelId,programName:Le.programInfo.name,inputTensorViews:d,outputTensorViews:N};this.pendingKernels.push(Oe),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(Oe)}return this.programManager.run(Le,b,T,ue,ae),en(o.name),N}upload(o,d){this.gpuDataManager.upload(o,d)}memcpy(o,d){this.gpuDataManager.memcpy(o,d)}async download(o,d){await this.gpuDataManager.download(o,d)}alloc(o){return this.gpuDataManager.create(o).id}free(o){return this.gpuDataManager.release(o)}createKernel(o,d,_,m){let g=sE.get(o);if(!g)throw new Error(`kernel not implemented: ${o}`);let y={kernelType:o,kernelName:m,kernelEntry:g[0],attributes:[g[1],_]};this.kernels.set(d,y)}releaseKernel(o){let d=this.kernelPersistentData.get(o);if(d){for(let _ of d)this.gpuDataManager.release(_.id);this.kernelPersistentData.delete(o)}this.kernelCustomData.delete(o),this.kernels.delete(o)}computeKernel(o,d,_){let m=this.kernels.get(o);if(!m)throw new Error(`kernel not created: ${o}`);let g=m.kernelType,y=m.kernelName,b=m.kernelEntry,E=m.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${g}] ${y}" is not allowed to be called recursively`);this.currentKernelId=o,E[0]&&(E[1]=E[0](E[1]),E[0]=void 0),Pt("info",()=>`[WebGPU] Start to run kernel "[${g}] ${y}"...`);let M=this.env.debug;this.temporaryData=[];try{return M&&this.device.pushErrorScope("validation"),b(d,E[1]),0}catch(P){return _.push(Promise.resolve(`[WebGPU] Kernel "[${g}] ${y}" failed. ${P}`)),1}finally{M&&_.push(this.device.popErrorScope().then(P=>P?`GPU validation error for kernel "[${g}] ${y}": ${P.message}`:null));for(let P of this.temporaryData)this.gpuDataManager.release(P.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(o,d,_,m){let g=this.sessionExternalDataMapping.get(o);g||(g=new Map,this.sessionExternalDataMapping.set(o,g));let y=g.get(d),b=this.gpuDataManager.registerExternalBuffer(_,m,y);return g.set(d,[b,_]),b}unregisterBuffers(o){let d=this.sessionExternalDataMapping.get(o);d&&(d.forEach(_=>this.gpuDataManager.unregisterExternalBuffer(_[0])),this.sessionExternalDataMapping.delete(o))}getBuffer(o){let d=this.gpuDataManager.get(o);if(!d)throw new Error(`no GPU data for buffer: ${o}`);return d.buffer}createDownloader(o,d,_){return async()=>{let m=await va(this,o,d);return we(m.buffer,_)}}writeTimestamp(o){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,o)}setQueryType(){var o;this.queryType="none",(((o=this.env.webgpu.profiling)==null?void 0:o.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Pt("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Pt("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Pt("info","replay"),this.sessionStatus="replaying";let o=this.capturedCommandList.get(this.currentSessionId),d=this.capturedPendingKernels.get(this.currentSessionId),_=o.length;this.pendingKernels=[];for(let m=0;m<_;m++){let g=this.getComputePassEncoder(),y=o[m];this.writeTimestamp(this.pendingDispatchNumber*2),g.setPipeline(y.computePipeline),g.setBindGroup(0,y.bindGroup),g.dispatchWorkgroups(...y.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(d[m]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(o){this.unregisterBuffers(o),this.capturedCommandList.has(o)&&this.capturedCommandList.delete(o),this.capturedPendingKernels.has(o)&&this.capturedPendingKernels.delete(o),this.gpuDataManager.onReleaseSession(o)}onRunStart(o){this.currentSessionId=o,this.setQueryType()}}}),cE,YT,QT,pE,_E,pM=p(()=>{L(),cE=1,YT=()=>cE++,QT=class{constructor(o,d){this.mlContext=o,this.tensorEntry=d,this.tensorCache=d?[d]:[]}get tensor(){var o;return(o=this.tensorEntry)==null?void 0:o[0]}get context(){if(!this.mlContext)throw new Error("MLContext has not been set.");return this.mlContext}set context(o){if(this.mlContext&&this.mlContext!==o)throw new Error("MLTensor in use in a different MLContext.");this.mlContext=o}destroy(){for(let[o]of this.tensorCache)o.destroy();this.tensorCache=[],this.tensorEntry=void 0}trySelectTensor(o,d){for(let[_,m,g]of this.tensorCache)if(d===_){if(this.context!==o)throw new Error("MLTensor cannot be registered with a different MLContext.");return this.tensorEntry=[_,m,g],!0}return!1}async ensureTensor(o,d,_){var y;if(this.tensorEntry){let[b,E,M]=this.tensorEntry;if(E===o&&M.every((P,U)=>P===d[U]))return b}for(let[b,E,M]of this.tensorCache)if(E===o&&M.every((P,U)=>P===d[U])){if(_&&this.tensorEntry){Pt("verbose",()=>`[WebNN] Slowdown may occur, having to copy existing tensor {dataType: ${o}, shape: ${d}}`);let P=await this.context.readTensor(this.tensorEntry[0]);this.context.writeTensor(b,P)}return this.tensorEntry=[b,E,M],b}Pt("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${o}, shape: ${d}}`);let m=MLTensorUsage.READ|MLTensorUsage.WRITE,g=await this.context.createTensor({dataType:o,shape:d,dimensions:d,usage:m});return this.tensorEntry=[g,o,d],this.tensorCache.push(this.tensorEntry),this.activeUpload&&((y=this.mlContext)==null||y.writeTensor(g,this.activeUpload),this.activeUpload=void 0),g}upload(o){var d;if(!this.tensorEntry){this.activeUpload=new Uint8Array(o);return}(d=this.mlContext)==null||d.writeTensor(this.tensorEntry[0],o)}async download(o){if(this.activeUpload)if(o){o instanceof ArrayBuffer?new Uint8Array(o).set(this.activeUpload):new Uint8Array(o.buffer,o.byteOffset,o.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.tensorEntry)throw new Error("Tensor has not been created.");return o?this.context.readTensor(this.tensorEntry[0],o):this.context.readTensor(this.tensorEntry[0])}},pE=class{constructor(o){this.backend=o,this.tensorsById=new Map,this.tensorIdsByContext=new Map}reserveTensorId(){let o=YT();return this.tensorsById.set(o,new QT),o}releaseTensorId(o){let d=this.tensorsById.get(o);if(d){d.destroy(),this.tensorsById.delete(o);for(let[_,m]of this.tensorIdsByContext)if(m.has(o)){m.delete(o),m.size===0&&this.tensorIdsByContext.delete(_);break}}}async ensureTensor(o,d,_,m){var y;Pt("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${o}, dataType: ${d}, shape: ${_}, copyOld: ${m}}`);let g=this.tensorsById.get(o);if(!g)throw new Error("Tensor not found.");return g.context=this.backend.currentContext,this.tensorIdsByContext.has(this.backend.currentContext)||this.tensorIdsByContext.set(this.backend.currentContext,new Set),(y=this.tensorIdsByContext.get(this.backend.currentContext))==null||y.add(o),g.ensureTensor(d,_,m)}upload(o,d){this.tensorsById.get(o).upload(d)}async download(o,d){return Pt("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${o}, dstBuffer: ${d==null?void 0:d.byteLength}}`),this.tensorsById.get(o).download(d)}releaseTensorsForContext(o){let d=this.tensorIdsByContext.get(o);if(d){for(let _ of d)this.tensorsById.get(_).destroy(),this.tensorsById.delete(_);this.tensorIdsByContext.delete(o)}}registerTensor(o,d,_,m){for(let[b,E]of this.tensorsById)if(E.trySelectTensor(o,d))return b;let g=YT();this.tensorsById.set(g,new QT(o,[d,_,m]));let y=this.tensorIdsByContext.get(o);return y||(y=new Set,this.tensorIdsByContext.set(o,y)),y.add(g),g}},_E=(...o)=>new pE(...o)}),ZT,hE,_M=p(()=>{ya(),bu(),st(),pM(),L(),ZT=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),hE=class{constructor(o){this.tensorManager=_E(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,d_(o.logLevel,!!o.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(o){this.activeSessionId=o}get currentContext(){let o=this.getMLContext(this.currentSessionId);if(!o)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return o}registerMLContext(o,d){this.mlContextBySessionId.set(o,d);let _=this.sessionIdsByMLContext.get(d);_||(_=new Set,this.sessionIdsByMLContext.set(d,_)),_.add(o)}onReleaseSession(o){let d=this.mlContextBySessionId.get(o);if(!d)return;this.mlContextBySessionId.delete(o);let _=this.sessionIdsByMLContext.get(d);_.delete(o),_.size===0&&(this.sessionIdsByMLContext.delete(d),this.tensorManager.releaseTensorsForContext(d))}getMLContext(o){return this.mlContextBySessionId.get(o)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(o){Pt("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${o}}`),this.tensorManager.releaseTensorId(o)}async ensureTensor(o,d,_,m){let g=ZT.get(d);if(!g)throw new Error(`Unsupported ONNX data type: ${d}`);return this.tensorManager.ensureTensor(o,g,_,m)}uploadTensor(o,d){if(!Oa().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Pt("verbose",()=>`[WebNN] uploadTensor {tensorId: ${o}, data: ${d.byteLength}}`),this.tensorManager.upload(o,d)}async downloadTensor(o,d){return this.tensorManager.download(o,d)}createMLTensorDownloader(o,d){return async()=>{let _=await this.tensorManager.download(o);return we(_,d)}}registerMLTensor(o,d,_){let m=ZT.get(d);if(!m)throw new Error(`Unsupported ONNX data type: ${d}`);let g=this.tensorManager.registerTensor(this.currentContext,o,m,_);return Pt("verbose",()=>`[WebNN] registerMLTensor {tensor: ${o}, dataType: ${m}, dimensions: ${_}} -> {tensorId: ${g}}`),g}flush(){}}}),fE={};t(fE,{init:()=>gE});var PT,mE,gE,hM=p(()=>{ya(),cM(),L(),fa(),_M(),PT=class nM{constructor(d,_,m,g){this.module=d,this.dataType=_,this.data=m,this.dims=g}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let d=wr.size(this.dims);return d===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,d)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let d=wr.size(this.dims);return d===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,d)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let d=wr.size(this.dims);return d===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,d)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let d=wr.size(this.dims);return d===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,d)}reshape(d){if(wr.size(d)!==wr.size(this.dims))throw new Error("Invalid new shape");return new nM(this.module,this.dataType,this.data,d)}},mE=class{constructor(o,d,_){this.module=o,this.backend=d,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=d.adapterInfo;let m=o.HEAPU32,g=_>>>2;this.opKernelContext=m[g++];let y=m[g++];this.outputCount=m[g++],this.customDataOffset=m[g++],this.customDataSize=m[g++];let b=[];for(let E=0;E<y;E++){let M=m[g++],P=m[g++],U=m[g++],N=[];for(let T=0;T<U;T++)N.push(m[g++]);b.push(new PT(o,M,P,N))}this.inputs=b}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(o,d){var b;let _=((b=d==null?void 0:d.inputs)==null?void 0:b.map(E=>typeof E=="number"?this.inputs[E]:E))??this.inputs,m=(d==null?void 0:d.outputs)??[],g=(E,M,P)=>new PT(this.module,M,this.output(E,P),P),y=(E,M)=>{let P=Ld(E,M);if(!P)throw new Error(`Unsupported data type: ${E}`);let U=P>0?this.backend.gpuDataManager.create(P).id:0;return new PT(this.module,E,U,M)};return this.backend.run(o,_,m,g,y,this.outputCount)}output(o,d){let _=this.module.stackSave();try{let m=this.module.stackAlloc((1+d.length)*4),g=m>>2;this.module.HEAPU32[g++]=d.length;for(let y=0;y<d.length;y++)this.module.HEAPU32[g++]=d[y];return this.module._JsepOutput(this.opKernelContext,o,m)}catch(m){throw new Error(`Failed to generate kernel's output[${o}] with dims [${d}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${m}`)}finally{this.module.stackRestore(_)}}},gE=async(o,d,_,m)=>{let g=d.jsepInit;if(!g)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(o==="webgpu"){let y=new dE;await y.initialize(_,m),g("webgpu",[y,b=>y.alloc(b),b=>y.free(b),(b,E,M,P=!1)=>{if(P)Pt("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${b}, dst=${E}, size=${M}`),y.memcpy(b,E);else{Pt("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${b}, gpuDataId=${E}, size=${M}`);let U=d.HEAPU8.subarray(b>>>0,(b>>>0)+M);y.upload(E,U)}},async(b,E,M)=>{Pt("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${b}, dataOffset=${E}, size=${M}`),await y.download(b,()=>d.HEAPU8.subarray(E>>>0,(E>>>0)+M))},(b,E,M)=>y.createKernel(b,E,M,d.UTF8ToString(d._JsepGetNodeName(E))),b=>y.releaseKernel(b),(b,E,M,P)=>{Pt("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${M}, kernel=${b}, contextDataOffset=${E}`);let U=new mE(d,y,E);return y.computeKernel(b,U,P)},()=>y.captureBegin(),()=>y.captureEnd(),()=>y.replay()])}else{let y=new hE(_);g("webnn",[y,()=>y.reserveTensorId(),b=>y.releaseTensorId(b),async(b,E,M,P)=>y.ensureTensor(b,E,M,P),(b,E)=>{y.uploadTensor(b,E)},async(b,E)=>y.downloadTensor(b,E)])}}}),bE,JT,e1,nh,yE,kT,t1,r1,n1,o1,s1,i1,wE=p(()=>{Id(),i_(),ya(),bu(),m_(),$_(),bE=(o,d)=>{Oa()._OrtInit(o,d)!==0&&_u("Can't initialize onnxruntime.")},JT=async o=>{bE(o.wasm.numThreads,Rd(o.logLevel))},e1=async(o,d)=>{{let _=(hM(),l(fE)).init;if(d==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let m=o.webgpu.adapter;if(m){if(typeof m.limits!="object"||typeof m.features!="object"||typeof m.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let g=o.webgpu.powerPreference;if(g!==void 0&&g!=="low-power"&&g!=="high-performance")throw new Error(`Invalid powerPreference setting: "${g}"`);let y=o.webgpu.forceFallbackAdapter;if(y!==void 0&&typeof y!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${y}"`);if(m=await navigator.gpu.requestAdapter({powerPreference:g,forceFallbackAdapter:y}),!m)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await _("webgpu",Oa(),o,m)}if(d==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await _("webnn",Oa(),o)}}},nh=new Map,yE=o=>{let d=Oa(),_=d.stackSave();try{let m=d.stackAlloc(8);return d._OrtGetInputOutputCount(o,m,m+4)!==0&&_u("Can't get session input/output count."),[d.HEAP32[m/4],d.HEAP32[m/4+1]]}finally{d.stackRestore(_)}},kT=o=>{let d=Oa(),_=d._malloc(o.byteLength);if(_===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${o.byteLength}.`);return d.HEAPU8.set(o,_),[_,o.byteLength]},t1=async(o,d)=>{var N,T;let _,m,g=Oa();Array.isArray(o)?[_,m]=o:o.buffer===g.HEAPU8.buffer?[_,m]=[o.byteOffset,o.byteLength]:[_,m]=kT(o);let y=0,b=0,E=0,M=[],P=[],U=[];try{if([b,M]=O_(d),(d==null?void 0:d.externalData)&&g.mountExternalData){let lt=[];for(let ft of d.externalData){let nn=typeof ft=="string"?ft:ft.path;lt.push(u_(typeof ft=="string"?ft:ft.data).then(Er=>{g.mountExternalData(nn,Er)}))}await Promise.all(lt)}for(let lt of(d==null?void 0:d.executionProviders)??[])if((typeof lt=="string"?lt:lt.name)==="webnn"){if(g.shouldTransferToMLTensor=!1,g.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof lt!="string"){let ft=lt,nn=ft==null?void 0:ft.context,Er=ft==null?void 0:ft.gpuDevice,Do=ft==null?void 0:ft.deviceType,aa=ft==null?void 0:ft.numThreads,pa=ft==null?void 0:ft.powerPreference;nn?g.currentContext=nn:Er?g.currentContext=await navigator.ml.createContext(Er):g.currentContext=await navigator.ml.createContext({deviceType:Do,numThreads:aa,powerPreference:pa})}else g.currentContext=await navigator.ml.createContext();break}y=await g._OrtCreateSession(_,m,b),y===0&&_u("Can't create a session."),g.currentContext&&(g.jsepRegisterMLContext(y,g.currentContext),g.currentContext=void 0,g.shouldTransferToMLTensor=!0);let[ae,ue]=yE(y),fe=!!(d!=null&&d.enableGraphCapture),Ae=[],Le=[],Oe=[];for(let lt=0;lt<ae;lt++){let ft=g._OrtGetInputName(y,lt);ft===0&&_u("Can't get an input name."),P.push(ft),Ae.push(g.UTF8ToString(ft))}for(let lt=0;lt<ue;lt++){let ft=g._OrtGetOutputName(y,lt);ft===0&&_u("Can't get an output name."),U.push(ft);let nn=g.UTF8ToString(ft);Le.push(nn);{if(fe&&(d==null?void 0:d.preferredOutputLocation)===void 0){Oe.push("gpu-buffer");continue}let Er=typeof(d==null?void 0:d.preferredOutputLocation)=="string"?d.preferredOutputLocation:((N=d==null?void 0:d.preferredOutputLocation)==null?void 0:N[nn])??"cpu";if(Er!=="cpu"&&Er!=="cpu-pinned"&&Er!=="gpu-buffer"&&Er!=="ml-tensor")throw new Error(`Not supported preferred output location: ${Er}.`);if(fe&&Er!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Er}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);Oe.push(Er)}}let pt=null;return Oe.some(lt=>lt==="gpu-buffer"||lt==="ml-tensor")&&(E=g._OrtCreateBinding(y),E===0&&_u("Can't create IO binding."),pt={handle:E,outputPreferredLocations:Oe,outputPreferredLocationsEncoded:Oe.map(lt=>b_(lt))}),nh.set(y,[y,P,U,pt,fe,!1]),[y,Ae,Le]}catch(ae){throw P.forEach(ue=>g._OrtFree(ue)),U.forEach(ue=>g._OrtFree(ue)),E!==0&&g._OrtReleaseBinding(E),y!==0&&g._OrtReleaseSession(y),ae}finally{g._free(_),b!==0&&g._OrtReleaseSessionOptions(b),M.forEach(ae=>g._free(ae)),(T=g.unmountExternalData)==null||T.call(g)}},r1=o=>{var M;let d=Oa(),_=nh.get(o);if(!_)throw new Error(`cannot release session. invalid session id: ${o}`);let[m,g,y,b,E]=_;b&&(E&&d._OrtClearBoundOutputs(b.handle),d._OrtReleaseBinding(b.handle)),(M=d.jsepOnReleaseSession)==null||M.call(d,o),g.forEach(P=>d._OrtFree(P)),y.forEach(P=>d._OrtFree(P)),d._OrtReleaseSession(m),nh.delete(o)},n1=(o,d,_,m,g,y=!1)=>{if(!o){d.push(0);return}let b=Oa(),E=o[0],M=o[1],P=o[3],U,N;if(E==="string"&&(P==="gpu-buffer"||P==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(y&&P!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${g} when enableGraphCapture is true.`);if(P==="gpu-buffer"){let ue=o[2].gpuBuffer;N=Ld(Pd(E),M);let fe=b.jsepRegisterBuffer;if(!fe)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');U=fe(m,g,ue,N)}else if(P==="ml-tensor"){let ue=o[2].mlTensor;N=Ld(Pd(E),M);let fe=b.jsepRegisterMLTensor;if(!fe)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');U=fe(ue,Pd(E),M)}else{let ue=o[2];if(Array.isArray(ue)){N=4*ue.length,U=b._malloc(N),_.push(U);let fe=U/4;for(let Ae=0;Ae<ue.length;Ae++){if(typeof ue[Ae]!="string")throw new TypeError(`tensor data at index ${Ae} is not a string`);b.HEAPU32[fe++]=tu(ue[Ae],_)}}else N=ue.byteLength,U=b._malloc(N),_.push(U),b.HEAPU8.set(new Uint8Array(ue.buffer,ue.byteOffset,N),U)}let T=b.stackSave(),ae=b.stackAlloc(4*M.length);try{let ue=ae/4;M.forEach(Ae=>b.HEAP32[ue++]=Ae);let fe=b._OrtCreateTensor(Pd(E),U,N,ae,M.length,b_(P));fe===0&&_u(`Can't create tensor for input/output. session=${m}, index=${g}.`),d.push(fe)}finally{b.stackRestore(T)}},o1=async(o,d,_,m,g,y)=>{var pa,Ia;let b=Oa(),E=nh.get(o);if(!E)throw new Error(`cannot run inference. invalid session id: ${o}`);let M=E[0],P=E[1],U=E[2],N=E[3],T=E[4],ae=E[5],ue=d.length,fe=m.length,Ae=0,Le=[],Oe=[],pt=[],lt=[],ft=b.stackSave(),nn=b.stackAlloc(ue*4),Er=b.stackAlloc(ue*4),Do=b.stackAlloc(fe*4),aa=b.stackAlloc(fe*4);try{(pa=b.jsepOnRunStart)==null||pa.call(b,M),[Ae,Le]=o_(y);for(let ga=0;ga<ue;ga++)n1(_[ga],Oe,lt,o,d[ga],T);for(let ga=0;ga<fe;ga++)n1(g[ga],pt,lt,o,ue+m[ga],T);let Da=nn/4,wa=Er/4,uu=Do/4,yu=aa/4;for(let ga=0;ga<ue;ga++)b.HEAPU32[Da++]=Oe[ga],b.HEAPU32[wa++]=P[d[ga]];for(let ga=0;ga<fe;ga++)b.HEAPU32[uu++]=pt[ga],b.HEAPU32[yu++]=U[m[ga]];if(N&&!ae){let{handle:ga,outputPreferredLocations:Ea,outputPreferredLocationsEncoded:Xa}=N;if(P.length!==ue)throw new Error(`input count from feeds (${ue}) is expected to be always equal to model's input count (${P.length}).`);for(let on=0;on<ue;on++){let Zs=d[on];await b._OrtBindInput(ga,P[Zs],Oe[on])!==0&&_u(`Can't bind input[${on}] for session=${o}.`)}for(let on=0;on<fe;on++){let Zs=m[on];(Ia=g[on])!=null&&Ia[3]?b._OrtBindOutput(ga,U[Zs],pt[on],0)!==0&&_u(`Can't bind pre-allocated output[${on}] for session=${o}.`):b._OrtBindOutput(ga,U[Zs],0,Xa[Zs])!==0&&_u(`Can't bind output[${on}] to ${Ea[on]} for session=${o}.`)}nh.set(o,[M,P,U,N,T,!0])}let Ra;N?Ra=await b._OrtRunWithBinding(M,N.handle,fe,Do,Ae):Ra=await b._OrtRun(M,Er,nn,ue,aa,fe,Do,Ae),Ra!==0&&_u("failed to call OrtRun().");let fu=[];for(let ga=0;ga<fe;ga++){let Ea=b.HEAPU32[Do/4+ga];if(Ea===pt[ga]){fu.push(g[ga]);continue}let Xa=b.stackSave(),on=b.stackAlloc(4*4),Zs=!1,Ma,pu=0;try{b._OrtGetTensorData(Ea,on,on+4,on+8,on+12)!==0&&_u(`Can't access output tensor data on index ${ga}.`);let Uu=on/4,hd=b.HEAPU32[Uu++];pu=b.HEAPU32[Uu++];let ih=b.HEAPU32[Uu++],AT=b.HEAPU32[Uu++],Nd=[];for(let wd=0;wd<AT;wd++)Nd.push(b.HEAPU32[ih/4+wd]);b._OrtFree(ih);let Md=Nd.reduce((wd,Sd)=>wd*Sd,1);Ma=Ad(hd);let ty=N==null?void 0:N.outputPreferredLocations[m[ga]];if(Ma==="string"){if(ty==="gpu-buffer"||ty==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let wd=[],Sd=pu/4;for(let __=0;__<Md;__++){let ah=b.HEAPU32[Sd++],ST=__===Md-1?void 0:b.HEAPU32[Sd]-ah;wd.push(b.UTF8ToString(ah,ST))}fu.push([Ma,Nd,wd,"cpu"])}else if(ty==="gpu-buffer"&&Md>0){let wd=b.jsepGetBuffer;if(!wd)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Sd=wd(pu),__=Ld(hd,Md);if(__===void 0||!a_(Ma))throw new Error(`Unsupported data type: ${Ma}`);Zs=!0,fu.push([Ma,Nd,{gpuBuffer:Sd,download:b.jsepCreateDownloader(Sd,__,Ma),dispose:()=>{b._OrtReleaseTensor(Ea)}},"gpu-buffer"])}else if(ty==="ml-tensor"&&Md>0){let wd=b.jsepEnsureTensor;if(!wd)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Ld(hd,Md)===void 0||!l_(Ma))throw new Error(`Unsupported data type: ${Ma}`);let Sd=await wd(pu,hd,Nd,!1);Zs=!0,fu.push([Ma,Nd,{mlTensor:Sd,download:b.jsepCreateMLTensorDownloader(pu,Ma),dispose:()=>{b.jsepReleaseTensorId(pu),b._OrtReleaseTensor(Ea)}},"ml-tensor"])}else{let wd=g_(Ma),Sd=new wd(Md);new Uint8Array(Sd.buffer,Sd.byteOffset,Sd.byteLength).set(b.HEAPU8.subarray(pu,pu+Sd.byteLength)),fu.push([Ma,Nd,Sd,"cpu"])}}finally{b.stackRestore(Xa),Ma==="string"&&pu&&b._free(pu),Zs||b._OrtReleaseTensor(Ea)}}return N&&!T&&(b._OrtClearBoundOutputs(N.handle),nh.set(o,[M,P,U,N,T,!1])),fu}finally{b.stackRestore(ft),Oe.forEach(Da=>b._OrtReleaseTensor(Da)),pt.forEach(Da=>b._OrtReleaseTensor(Da)),lt.forEach(Da=>b._free(Da)),Ae!==0&&b._OrtReleaseRunOptions(Ae),Le.forEach(Da=>b._free(Da))}},s1=o=>{let d=Oa(),_=nh.get(o);if(!_)throw new Error("invalid session id");let m=_[0],g=d._OrtEndProfiling(m);g===0&&_u("Can't get an profile file name."),d._OrtFree(g)},i1=o=>{let d=[];for(let _ of o){let m=_[2];!Array.isArray(m)&&"buffer"in m&&d.push(m.buffer)}return d}}),sh,e_,Fw,Lv,Rv,OT,a1,$T,Jg,ey,xE,vE,TE,EE,ME,PE,kE,OE,$E=p(()=>{ii(),wE(),bu(),ha(),sh=()=>!!X.wasm.proxy&&typeof document<"u",Fw=!1,Lv=!1,Rv=!1,$T=new Map,Jg=(o,d)=>{let _=$T.get(o);_?_.push(d):$T.set(o,[d])},ey=()=>{if(Fw||!Lv||Rv||!e_)throw new Error("worker not ready")},xE=o=>{switch(o.data.type){case"init-wasm":Fw=!1,o.data.err?(Rv=!0,a1[1](o.data.err)):(Lv=!0,a1[0]()),OT&&(URL.revokeObjectURL(OT),OT=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let d=$T.get(o.data.type);o.data.err?d.shift()[1](o.data.err):d.shift()[0](o.data.out);break}}},vE=async()=>{if(!Lv){if(Fw)throw new Error("multiple calls to 'initWasm()' detected.");if(Rv)throw new Error("previous call to 'initWasm()' failed.");if(Fw=!0,sh())return new Promise((o,d)=>{e_==null||e_.terminate(),la().then(([_,m])=>{try{e_=m,e_.onerror=y=>d(y),e_.onmessage=xE,a1=[o,d];let g={type:"init-wasm",in:X};e_.postMessage(g),OT=_}catch(g){d(g)}},d)});try{await wu(X.wasm),await JT(X),Lv=!0}catch(o){throw Rv=!0,o}finally{Fw=!1}}},TE=async o=>{if(sh())return ey(),new Promise((d,_)=>{Jg("init-ep",[d,_]);let m={type:"init-ep",in:{epName:o,env:X}};e_.postMessage(m)});await e1(X,o)},EE=async o=>sh()?(ey(),new Promise((d,_)=>{Jg("copy-from",[d,_]);let m={type:"copy-from",in:{buffer:o}};e_.postMessage(m,[o.buffer])})):kT(o),ME=async(o,d)=>{if(sh()){if(d!=null&&d.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ey(),new Promise((_,m)=>{Jg("create",[_,m]);let g={type:"create",in:{model:o,options:{...d}}},y=[];o instanceof Uint8Array&&y.push(o.buffer),e_.postMessage(g,y)})}else return t1(o,d)},PE=async o=>{if(sh())return ey(),new Promise((d,_)=>{Jg("release",[d,_]);let m={type:"release",in:o};e_.postMessage(m)});r1(o)},kE=async(o,d,_,m,g,y)=>{if(sh()){if(_.some(b=>b[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(g.some(b=>b))throw new Error("pre-allocated output tensor is not supported for proxy.");return ey(),new Promise((b,E)=>{Jg("run",[b,E]);let M=_,P={type:"run",in:{sessionId:o,inputIndices:d,inputs:M,outputIndices:m,options:y}};e_.postMessage(P,i1(M))})}else return o1(o,d,_,m,g,y)},OE=async o=>{if(sh())return ey(),new Promise((d,_)=>{Jg("end-profiling",[d,_]);let m={type:"end-profiling",in:o};e_.postMessage(m)});s1(o)}}),l1,AE,SE,fM=p(()=>{ii(),$E(),ya(),Sa(),$_(),l1=(o,d)=>{switch(o.location){case"cpu":return[o.type,o.dims,o.data,"cpu"];case"gpu-buffer":return[o.type,o.dims,{gpuBuffer:o.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[o.type,o.dims,{mlTensor:o.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${o.location} for ${d()}`)}},AE=o=>{switch(o[3]){case"cpu":return new Ze(o[0],o[2],o[1]);case"gpu-buffer":{let d=o[0];if(!a_(d))throw new Error(`not supported data type: ${d} for deserializing GPU tensor`);let{gpuBuffer:_,download:m,dispose:g}=o[2];return Ze.fromGpuBuffer(_,{dataType:d,dims:o[1],download:m,dispose:g})}case"ml-tensor":{let d=o[0];if(!l_(d))throw new Error(`not supported data type: ${d} for deserializing MLTensor tensor`);let{mlTensor:_,download:m,dispose:g}=o[2];return Ze.fromMLTensor(_,{dataType:d,dims:o[1],download:m,dispose:g})}default:throw new Error(`invalid data location: ${o[3]}`)}},SE=class{async fetchModelAndCopyToWasmMemory(o){return EE(await u_(o))}async loadModel(o,d){Jr();let _;typeof o=="string"?_=await this.fetchModelAndCopyToWasmMemory(o):_=o,[this.sessionId,this.inputNames,this.outputNames]=await ME(_,d),en()}async dispose(){return PE(this.sessionId)}async run(o,d,_){Jr();let m=[],g=[];Object.entries(o).forEach(N=>{let T=N[0],ae=N[1],ue=this.inputNames.indexOf(T);if(ue===-1)throw new Error(`invalid input '${T}'`);m.push(ae),g.push(ue)});let y=[],b=[];Object.entries(d).forEach(N=>{let T=N[0],ae=N[1],ue=this.outputNames.indexOf(T);if(ue===-1)throw new Error(`invalid output '${T}'`);y.push(ae),b.push(ue)});let E=m.map((N,T)=>l1(N,()=>`input "${this.inputNames[g[T]]}"`)),M=y.map((N,T)=>N?l1(N,()=>`output "${this.outputNames[b[T]]}"`):null),P=await kE(this.sessionId,g,E,b,M,_),U={};for(let N=0;N<P.length;N++)U[this.outputNames[b[N]]]=y[N]??AE(P[N]);return en(),U}startProfiling(){}endProfiling(){OE(this.sessionId)}}}),IE={};t(IE,{OnnxruntimeWebAssemblyBackend:()=>d1,initializeFlags:()=>u1,wasmBackend:()=>CE});var u1,d1,CE,mM=p(()=>{ii(),$E(),fM(),ha(),u1=()=>{if((typeof X.wasm.initTimeout!="number"||X.wasm.initTimeout<0)&&(X.wasm.initTimeout=0),X.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof X.wasm.proxy!="boolean"&&(X.wasm.proxy=!1),typeof X.wasm.trace!="boolean"&&(X.wasm.trace=!1),typeof X.wasm.numThreads!="number"||!Number.isInteger(X.wasm.numThreads)||X.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)X.wasm.numThreads=1;else{let o=typeof navigator>"u"?h("node:os").cpus().length:navigator.hardwareConcurrency;X.wasm.numThreads=Math.min(4,Math.ceil((o||1)/2))}},d1=class{async init(o){u1(),await vE(),await TE(o)}async createInferenceSessionHandler(o,d){let _=new SE;return await _.loadModel(o,d),Promise.resolve(_)}},CE=new d1});ii(),ii(),ii();var gM="1.20.0-dev.20241016-2b8fc5529b",bM=ia;{let o=(mM(),l(IE)).wasmBackend;I("webgpu",o,5),I("webnn",o,5),I("cpu",o,10),I("wasm",o,10)}Object.defineProperty(X.versions,"web",{value:gM,enumerable:!0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},"./src/backends/onnx.js":(e,r,i)=>{var s;i.r(r),i.d(r,{Tensor:()=>h.Tensor,createInferenceSession:()=>A,deviceToExecutionProviders:()=>I,isONNXProxy:()=>Q,isONNXTensor:()=>Z});var c=i("./src/env.js"),n=i("?2ce3"),a=i("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),h=i("./node_modules/onnxruntime-common/dist/esm/index.js");const p=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),t=[];let u,l;const f=Symbol.for("onnxruntime");if(f in globalThis)l=globalThis[f];else if(c.apis.IS_NODE_ENV){switch(l=n??(s||(s=i.t(n,2))),process.platform){case"win32":t.push("dml");break;case"linux":process.arch==="x64"&&t.push("cuda");break}t.push("cpu"),u=["cpu"]}else l=a,c.apis.IS_WEBNN_AVAILABLE&&t.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),c.apis.IS_WEBGPU_AVAILABLE&&t.push("webgpu"),t.push("wasm"),u=["wasm"];const x=l.InferenceSession;function I(re=null){if(!re)return u;switch(re){case"auto":return t;case"gpu":return t.filter(se=>["webgpu","cuda","dml","webnn-gpu"].includes(se))}if(t.includes(re))return[p[re]??re];throw new Error(`Unsupported device: "${re}". Should be one of: ${t.join(", ")}.`)}let R=null;async function A(re,se,ee){R&&await R;const ce=x.create(re,se);R??(R=ce);const X=await ce;return X.config=ee,X}function Z(re){return re instanceof l.Tensor}const K=l==null?void 0:l.env;K!=null&&K.wasm&&(K.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${c.env.version}/dist/`,K.wasm.proxy=!1,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(K.wasm.numThreads=1)),K!=null&&K.webgpu&&(K.webgpu.powerPreference="high-performance");function Q(){var re;return(re=K==null?void 0:K.wasm)==null?void 0:re.proxy}c.env.backends.onnx=K},"./src/configs.js":(e,r,i)=>{i.r(r),i.d(r,{AutoConfig:()=>t,PretrainedConfig:()=>p,getKeyValueShapes:()=>h});var s=i("./src/utils/core.js"),c=i("./src/utils/hub.js");async function n(u,l){return await(0,c.getModelJSON)(u,"config.json",!0,l)}function a(u){const l={};let f={};switch(u.model_type){case"llava":case"paligemma":case"florence2":f=a(u.text_config);break;case"moondream1":f=a(u.phi_config);break;case"musicgen":f=a(u.decoder);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":l.num_heads="n_head",l.num_layers="n_layer",l.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"phi":case"phi3":case"falcon":l.num_heads="num_attention_heads",l.num_layers="num_hidden_layers",l.hidden_size="hidden_size";break;case"llama":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":l.num_heads="num_key_value_heads",l.num_layers="num_hidden_layers",l.hidden_size="hidden_size",l.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":l.num_heads="num_key_value_heads",l.num_layers="num_hidden_layers",l.dim_kv="head_dim";break;case"openelm":l.num_heads="num_kv_heads",l.num_layers="num_transformer_layers",l.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":l.num_heads="num_heads",l.num_layers="num_layers",l.hidden_size="hidden_size";break;case"bloom":l.num_heads="n_head",l.num_layers="n_layer",l.hidden_size="hidden_size";break;case"mpt":l.num_heads="n_heads",l.num_layers="n_layers",l.hidden_size="d_model";break;case"t5":case"mt5":case"longt5":l.num_decoder_layers="num_decoder_layers",l.num_decoder_heads="num_heads",l.decoder_dim_kv="d_kv",l.num_encoder_layers="num_layers",l.num_encoder_heads="num_heads",l.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":l.num_decoder_layers="decoder_layers",l.num_decoder_heads="decoder_attention_heads",l.decoder_hidden_size="d_model",l.num_encoder_layers="encoder_layers",l.num_encoder_heads="encoder_attention_heads",l.encoder_hidden_size="d_model";break;case"speecht5":l.num_decoder_layers="decoder_layers",l.num_decoder_heads="decoder_attention_heads",l.decoder_hidden_size="hidden_size",l.num_encoder_layers="encoder_layers",l.num_encoder_heads="encoder_attention_heads",l.encoder_hidden_size="hidden_size";break;case"trocr":l.num_encoder_layers=l.num_decoder_layers="decoder_layers",l.num_encoder_heads=l.num_decoder_heads="decoder_attention_heads",l.encoder_hidden_size=l.decoder_hidden_size="d_model";break;case"musicgen_decoder":l.num_encoder_layers=l.num_decoder_layers="num_hidden_layers",l.num_encoder_heads=l.num_decoder_heads="num_attention_heads",l.encoder_hidden_size=l.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const I=a(u.decoder),R="num_decoder_layers"in I,A=(0,s.pick)(u,["model_type","is_encoder_decoder"]);return R?(A.num_decoder_layers=I.num_decoder_layers,A.num_decoder_heads=I.num_decoder_heads,A.decoder_hidden_size=I.decoder_hidden_size,A.num_encoder_layers=I.num_encoder_layers,A.num_encoder_heads=I.num_encoder_heads,A.encoder_hidden_size=I.encoder_hidden_size):(A.num_layers=I.num_layers,A.num_heads=I.num_heads,A.hidden_size=I.hidden_size),A}const x={...f,...(0,s.pick)(u,["model_type","multi_query","is_encoder_decoder"])};for(const I in l)x[I]=u[l[I]];return x}function h(u,{prefix:l="past_key_values"}={}){const f={},x=u.normalized_config,I=1;if(x.is_encoder_decoder&&"num_encoder_heads"in x&&"num_decoder_heads"in x){const R=x.encoder_dim_kv??x.encoder_hidden_size/x.num_encoder_heads,A=x.decoder_dim_kv??x.decoder_hidden_size/x.num_decoder_heads,Z=[I,x.num_encoder_heads,0,R],K=[I,x.num_decoder_heads,0,A];for(let Q=0;Q<x.num_decoder_layers;++Q)f[`${l}.${Q}.encoder.key`]=Z,f[`${l}.${Q}.encoder.value`]=Z,f[`${l}.${Q}.decoder.key`]=K,f[`${l}.${Q}.decoder.value`]=K}else{const R=x.num_heads,A=x.num_layers,Z=x.dim_kv??x.hidden_size/(x.num_attention_heads??R);if(x.model_type==="falcon"){const K=[I*R,0,Z];for(let Q=0;Q<A;++Q)f[`${l}.${Q}.key`]=K,f[`${l}.${Q}.value`]=K}else if(x.multi_query){const K=[I*R,0,2*Z];for(let Q=0;Q<A;++Q)f[`${l}.${Q}.key_value`]=K}else if(x.model_type==="bloom"){const K=[I*R,Z,0],Q=[I*R,0,Z];for(let re=0;re<A;++re)f[`${l}.${re}.key`]=K,f[`${l}.${re}.value`]=Q}else if(x.model_type==="openelm")for(let K=0;K<A;++K){const Q=[I,R[K],0,Z];f[`${l}.${K}.key`]=Q,f[`${l}.${K}.value`]=Q}else{const K=[I,R,0,Z];for(let Q=0;Q<A;++Q)f[`${l}.${Q}.key`]=K,f[`${l}.${Q}.value`]=K}}return f}class p{constructor(l){_r(this,"model_type",null);_r(this,"is_encoder_decoder",!1);_r(this,"max_position_embeddings");_r(this,"transformers.js_config");Object.assign(this,l),this.normalized_config=a(this)}static async from_pretrained(l,{progress_callback:f=null,config:x=null,cache_dir:I=null,local_files_only:R=!1,revision:A="main"}={}){x&&!(x instanceof p)&&(x=new p(x));const Z=x??await n(l,{progress_callback:f,config:x,cache_dir:I,local_files_only:R,revision:A});return new this(Z)}}class t{static async from_pretrained(...l){return p.from_pretrained(...l)}}},"./src/env.js":(e,r,i)=>{var X;i.r(r),i.d(r,{apis:()=>A,env:()=>ee});var s=i("?569f"),c=i("?3f59"),n=i("?154a");const a="3.0.0",h=typeof self<"u",p=h&&self.constructor.name==="DedicatedWorkerGlobalScope",t=h&&"caches"in self,u=typeof navigator<"u"&&"gpu"in navigator,l=typeof navigator<"u"&&"ml"in navigator,f=typeof process<"u",x=f&&((X=process==null?void 0:process.release)==null?void 0:X.name)==="node",I=!ce(s),R=!ce(c),A=Object.freeze({IS_BROWSER_ENV:h,IS_WEBWORKER_ENV:p,IS_WEB_CACHE_AVAILABLE:t,IS_WEBGPU_AVAILABLE:u,IS_WEBNN_AVAILABLE:l,IS_PROCESS_AVAILABLE:f,IS_NODE_ENV:x,IS_FS_AVAILABLE:I,IS_PATH_AVAILABLE:R}),Z=I&&R,K=Z?c.dirname(c.dirname(n.fileURLToPath(import.meta.url))):"./",Q=Z?c.join(K,"/.cache/"):null,re="/models/",se=Z?c.join(K,re):re,ee={version:a,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!h,localModelPath:se,useFS:I,useBrowserCache:t,useFSCache:I,cacheDir:Q,useCustomCache:!1,customCache:null};function ce(Re){return Object.keys(Re).length===0}},"./src/generation/configuration_utils.js":(e,r,i)=>{i.r(r),i.d(r,{GenerationConfig:()=>c});var s=i("./src/utils/core.js");class c{constructor(a){_r(this,"max_length",20);_r(this,"max_new_tokens",null);_r(this,"min_length",0);_r(this,"min_new_tokens",null);_r(this,"early_stopping",!1);_r(this,"max_time",null);_r(this,"do_sample",!1);_r(this,"num_beams",1);_r(this,"num_beam_groups",1);_r(this,"penalty_alpha",null);_r(this,"use_cache",!0);_r(this,"temperature",1);_r(this,"top_k",50);_r(this,"top_p",1);_r(this,"typical_p",1);_r(this,"epsilon_cutoff",0);_r(this,"eta_cutoff",0);_r(this,"diversity_penalty",0);_r(this,"repetition_penalty",1);_r(this,"encoder_repetition_penalty",1);_r(this,"length_penalty",1);_r(this,"no_repeat_ngram_size",0);_r(this,"bad_words_ids",null);_r(this,"force_words_ids",null);_r(this,"renormalize_logits",!1);_r(this,"constraints",null);_r(this,"forced_bos_token_id",null);_r(this,"forced_eos_token_id",null);_r(this,"remove_invalid_values",!1);_r(this,"exponential_decay_length_penalty",null);_r(this,"suppress_tokens",null);_r(this,"begin_suppress_tokens",null);_r(this,"forced_decoder_ids",null);_r(this,"guidance_scale",null);_r(this,"num_return_sequences",1);_r(this,"output_attentions",!1);_r(this,"output_hidden_states",!1);_r(this,"output_scores",!1);_r(this,"return_dict_in_generate",!1);_r(this,"pad_token_id",null);_r(this,"bos_token_id",null);_r(this,"eos_token_id",null);_r(this,"encoder_no_repeat_ngram_size",0);_r(this,"decoder_start_token_id",null);_r(this,"generation_kwargs",{});Object.assign(this,(0,s.pick)(a,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,r,i)=>{i.r(r),i.d(r,{ClassifierFreeGuidanceLogitsProcessor:()=>Z,ForcedBOSTokenLogitsProcessor:()=>p,ForcedEOSTokenLogitsProcessor:()=>t,LogitsProcessor:()=>n,LogitsProcessorList:()=>h,LogitsWarper:()=>a,MinLengthLogitsProcessor:()=>I,MinNewTokensLengthLogitsProcessor:()=>R,NoBadWordsLogitsProcessor:()=>A,NoRepeatNGramLogitsProcessor:()=>f,RepetitionPenaltyLogitsProcessor:()=>x,SuppressTokensAtBeginLogitsProcessor:()=>u,TemperatureLogitsWarper:()=>K,TopKLogitsWarper:()=>re,TopPLogitsWarper:()=>Q,WhisperTimeStampLogitsProcessor:()=>l});var s=i("./src/utils/generic.js");i("./src/utils/tensor.js");var c=i("./src/utils/maths.js");class n extends s.Callable{_call(ee,ce){throw Error("`_call` should be implemented in a subclass")}}class a extends s.Callable{_call(ee,ce){throw Error("`_call` should be implemented in a subclass")}}class h extends s.Callable{constructor(){super(),this.processors=[]}push(ee){this.processors.push(ee)}extend(ee){this.processors.push(...ee)}_call(ee,ce){let X=ce;for(const Re of this.processors)X=Re(ee,X);return X}[Symbol.iterator](){return this.processors.values()}}class p extends n{constructor(ee){super(),this.bos_token_id=ee}_call(ee,ce){for(let X=0;X<ee.length;++X)if(ee[X].length===1){const Re=ce[X].data;Re.fill(-1/0),Re[this.bos_token_id]=0}return ce}}class t extends n{constructor(ee,ce){super(),this.max_length=ee,this.eos_token_id=Array.isArray(ce)?ce:[ce]}_call(ee,ce){for(let X=0;X<ee.length;++X)if(ee[X].length===this.max_length-1){const Re=ce[X].data;Re.fill(-1/0);for(const De of this.eos_token_id)Re[De]=0}return ce}}class u extends n{constructor(ee,ce){super(),this.begin_suppress_tokens=ee,this.begin_index=ce}_call(ee,ce){for(let X=0;X<ee.length;++X)if(ee[X].length===this.begin_index){const Re=ce[X].data;for(const De of this.begin_suppress_tokens)Re[De]=-1/0}return ce}}class l extends n{constructor(ee,ce){super(),this.eos_token_id=Array.isArray(ee.eos_token_id)?ee.eos_token_id[0]:ee.eos_token_id,this.no_timestamps_token_id=ee.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=ce.length,ce.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=ee.max_initial_timestamp_index}_call(ee,ce){for(let X=0;X<ee.length;++X){const Re=ce[X].data;if(Re[this.no_timestamps_token_id]=-1/0,ee[X].length===this.begin_index-1){Re.fill(-1/0),Re[this.timestamp_begin]=0;continue}const De=ee[X].slice(this.begin_index),et=De.length>=1&&De[De.length-1]>=this.timestamp_begin,nt=De.length<2||De[De.length-2]>=this.timestamp_begin;if(et&&(nt?Re.subarray(this.timestamp_begin).fill(-1/0):Re.subarray(0,this.eos_token_id).fill(-1/0)),ee[X].length===this.begin_index&&this.max_initial_timestamp_index!==null){const Dt=this.timestamp_begin+this.max_initial_timestamp_index;Re.subarray(Dt+1).fill(-1/0)}const it=(0,c.log_softmax)(Re),_t=Math.log(it.subarray(this.timestamp_begin).map(Math.exp).reduce((Dt,Ge)=>Dt+Ge)),gt=(0,c.max)(it.subarray(0,this.timestamp_begin))[0];_t>gt&&Re.subarray(0,this.timestamp_begin).fill(-1/0)}return ce}}class f extends n{constructor(ee){super(),this.no_repeat_ngram_size=ee}getNgrams(ee){const ce=ee.length,X=[];for(let De=0;De<ce+1-this.no_repeat_ngram_size;++De){const et=[];for(let nt=0;nt<this.no_repeat_ngram_size;++nt)et.push(ee[De+nt]);X.push(et.map(Number))}const Re=new Map;for(const De of X){const et=De.slice(0,De.length-1),nt=JSON.stringify(et),it=Re.get(nt)??[];it.push(De[De.length-1]),Re.set(nt,it)}return Re}getGeneratedNgrams(ee,ce){const X=ce.slice(ce.length+1-this.no_repeat_ngram_size,ce.length);return ee.get(JSON.stringify(X.map(Number)))??[]}calcBannedNgramTokens(ee){const ce=[];if(ee.length+1<this.no_repeat_ngram_size)return ce;{const X=this.getNgrams(ee);return this.getGeneratedNgrams(X,ee)}}_call(ee,ce){for(let X=0;X<ee.length;++X){const Re=ce[X].data,De=this.calcBannedNgramTokens(ee[X]);for(const et of De)Re[et]=-1/0}return ce}}class x extends n{constructor(ee){super(),this.penalty=ee}_call(ee,ce){for(let X=0;X<ee.length;++X){const Re=ce[X].data;for(const De of ee[X]){const et=Number(De);Re[et]<0?Re[et]*=this.penalty:Re[et]/=this.penalty}}return ce}}class I extends n{constructor(ee,ce){super(),this.min_length=ee,this.eos_token_id=Array.isArray(ce)?ce:[ce]}_call(ee,ce){for(let X=0;X<ee.length;++X)if(ee[X].length<this.min_length){const Re=ce[X].data;for(const De of this.eos_token_id)Re[De]=-1/0}return ce}}class R extends n{constructor(ee,ce,X){super(),this.prompt_length_to_skip=ee,this.min_new_tokens=ce,this.eos_token_id=Array.isArray(X)?X:[X]}_call(ee,ce){for(let X=0;X<ee.length;++X)if(ee[X].length-this.prompt_length_to_skip<this.min_new_tokens){const De=ce[X].data;for(const et of this.eos_token_id)De[et]=-1/0}return ce}}class A extends n{constructor(ee,ce){super(),this.bad_words_ids=ee,this.eos_token_id=Array.isArray(ce)?ce:[ce]}_call(ee,ce){for(let X=0;X<ee.length;++X){const Re=ce[X].data,De=ee[X];for(const et of this.bad_words_ids){let nt=!0;for(let it=1;it<=et.length-1&&et.length<De.length;++it)if(et.at(-it-1)!=De.at(-it)){nt=!1;break}nt&&(Re[et.at(-1)]=-1/0)}}return ce}}class Z extends n{constructor(ee){if(super(),ee<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${ee}.`);this.guidance_scale=ee}_call(ee,ce){if(ce.dims[0]!==2*ee.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${ce.dims[0]} for the logits and ${ee.length} for the input ids.`);const X=ee.length,Re=ce.slice([0,X],null),De=ce.slice([X,ce.dims[0]],null);for(let et=0;et<De.data.length;++et)De.data[et]+=(Re.data[et]-De.data[et])*this.guidance_scale;return De}}class K extends a{constructor(ee){super(),this.temperature=ee}_call(ee,ce){const X=ce.data;for(let Re=0;Re<X.length;++Re)X[Re]/=this.temperature;return ce}}class Q extends a{constructor(ee,{filter_value:ce=-1/0,min_tokens_to_keep:X=1}={}){if(super(),ee<0||ee>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${ee}`);if(!Number.isInteger(X)||X<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${X}`);this.top_p=ee,this.filter_value=ce,this.min_tokens_to_keep=X}}class re extends a{constructor(ee,{filter_value:ce=-1/0,min_tokens_to_keep:X=1}={}){if(super(),!Number.isInteger(ee)||ee<0)throw new Error(`\`top_k\` must be a positive integer, but is ${ee}`);this.top_k=Math.max(ee,X),this.filter_value=ce}}},"./src/generation/logits_sampler.js":(e,r,i)=>{i.r(r),i.d(r,{LogitsSampler:()=>a});var s=i("./src/utils/generic.js"),c=i("./src/utils/tensor.js"),n=i("./src/utils/maths.js");i("./src/generation/configuration_utils.js");class a extends s.Callable{constructor(l){super(),this.generation_config=l}async _call(l){return this.sample(l)}async sample(l){throw Error("sample should be implemented in subclasses.")}getLogits(l,f){let x=l.dims.at(-1),I=l.data;if(f===-1)I=I.slice(-x);else{let R=f*x;I=I.slice(R,R+x)}return I}randomSelect(l){let f=0;for(let I=0;I<l.length;++I)f+=l[I];let x=Math.random()*f;for(let I=0;I<l.length;++I)if(x-=l[I],x<=0)return I;return 0}static getSampler(l){if(l.do_sample)return new p(l);if(l.num_beams>1)return new t(l);if(l.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${l.num_return_sequences}.`);return new h(l)}}class h extends a{async sample(l){const f=(0,n.max)(l.data)[1];return[[BigInt(f),0]]}}class p extends a{async sample(l){let f=l.dims.at(-1);this.generation_config.top_k>0&&(f=Math.min(this.generation_config.top_k,f));const[x,I]=await(0,c.topk)(l,f),R=(0,n.softmax)(x.data);return Array.from({length:this.generation_config.num_beams},()=>{const A=this.randomSelect(R);return[I.data[A],Math.log(R[A])]})}}class t extends a{async sample(l){let f=l.dims.at(-1);this.generation_config.top_k>0&&(f=Math.min(this.generation_config.top_k,f));const[x,I]=await(0,c.topk)(l,f),R=(0,n.softmax)(x.data);return Array.from({length:this.generation_config.num_beams},(A,Z)=>[I.data[Z],Math.log(R[Z])])}}},"./src/generation/stopping_criteria.js":(e,r,i)=>{i.r(r),i.d(r,{EosTokenCriteria:()=>h,InterruptableStoppingCriteria:()=>p,MaxLengthCriteria:()=>a,StoppingCriteria:()=>c,StoppingCriteriaList:()=>n});var s=i("./src/utils/generic.js");class c extends s.Callable{_call(u,l){throw Error("StoppingCriteria needs to be subclassed")}}class n extends s.Callable{constructor(){super(),this.criteria=[]}push(u){this.criteria.push(u)}extend(u){u instanceof n?u=u.criteria:u instanceof c&&(u=[u]),this.criteria.push(...u)}_call(u,l){const f=new Array(u.length).fill(!1);for(const x of this.criteria){const I=x(u,l);for(let R=0;R<f.length;++R)f[R]||(f[R]=I[R])}return f}[Symbol.iterator](){return this.criteria.values()}}class a extends c{constructor(u,l=null){super(),this.max_length=u,this.max_position_embeddings=l}_call(u){return u.map(l=>l.length>=this.max_length)}}class h extends c{constructor(u){super(),Array.isArray(u)||(u=[u]),this.eos_token_id=u}_call(u,l){return u.map(f=>{const x=f.at(-1);return this.eos_token_id.some(I=>x==I)})}}class p extends c{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(u,l){return new Array(u.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,r,i)=>{i.r(r),i.d(r,{BaseStreamer:()=>a,TextStreamer:()=>p,WhisperTextStreamer:()=>t});var s=i("./src/utils/core.js"),c=i("./src/tokenizers.js"),n=i("./src/env.js");class a{put(l){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const h=n.apis.IS_PROCESS_AVAILABLE?u=>process.stdout.write(u):u=>console.log(u);class p extends a{constructor(l,{skip_prompt:f=!1,callback_function:x=null,token_callback_function:I=null,decode_kwargs:R={},...A}={}){super(),this.tokenizer=l,this.skip_prompt=f,this.callback_function=x??h,this.token_callback_function=I,this.decode_kwargs={...R,...A},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(l){var R;if(l.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt){this.next_tokens_are_prompt=!1;return}const f=l[0];(R=this.token_callback_function)==null||R.call(this,f),this.token_cache=(0,s.mergeArrays)(this.token_cache,f);const x=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let I;x.endsWith(`
`)?(I=x.slice(this.print_len),this.token_cache=[],this.print_len=0):x.length>0&&(0,c.is_chinese_char)(x.charCodeAt(x.length-1))?(I=x.slice(this.print_len),this.print_len+=I.length):(I=x.slice(this.print_len,x.lastIndexOf(" ")+1),this.print_len+=I.length),this.on_finalized_text(I,!1)}end(){let l;this.token_cache.length>0?(l=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):l="",this.next_tokens_are_prompt=!0,this.on_finalized_text(l,!0)}on_finalized_text(l,f){var x,I;l.length>0&&((x=this.callback_function)==null||x.call(this,l)),f&&this.callback_function===h&&n.apis.IS_PROCESS_AVAILABLE&&((I=this.callback_function)==null||I.call(this,`
`))}}class t extends p{constructor(l,{skip_prompt:f=!1,callback_function:x=null,token_callback_function:I=null,on_chunk_start:R=null,on_chunk_end:A=null,on_finalize:Z=null,time_precision:K=.02,skip_special_tokens:Q=!0,decode_kwargs:re={}}={}){super(l,{skip_prompt:f,callback_function:x,token_callback_function:I,decode_kwargs:{skip_special_tokens:Q,...re}}),this.timestamp_begin=l.timestamp_begin,this.on_chunk_start=R,this.on_chunk_end=A,this.on_finalize=Z,this.time_precision=K,this.waiting_for_timestamp=!1}put(l){var x,I;if(l.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const f=l[0];if(f.length===1){const R=Number(f[0])-this.timestamp_begin;if(R>=0){const A=R*this.time_precision;this.waiting_for_timestamp?(x=this.on_chunk_end)==null||x.call(this,A):(I=this.on_chunk_start)==null||I.call(this,A),this.waiting_for_timestamp=!this.waiting_for_timestamp,l=[[]]}}return super.put(l)}end(){var l;super.end(),(l=this.on_finalize)==null||l.call(this)}}},"./src/models.js":(e,r,i)=>{i.r(r),i.d(r,{ASTForAudioClassification:()=>C_,ASTModel:()=>ca,ASTPreTrainedModel:()=>Dd,AlbertForMaskedLM:()=>ya,AlbertForQuestionAnswering:()=>b_,AlbertForSequenceClassification:()=>l_,AlbertModel:()=>a_,AlbertPreTrainedModel:()=>Rd,AutoModel:()=>Pw,AutoModelForAudioClassification:()=>Z_,AutoModelForAudioFrameClassification:()=>Ow,AutoModelForCTC:()=>yT,AutoModelForCausalLM:()=>vv,AutoModelForDepthEstimation:()=>Cv,AutoModelForDocumentQuestionAnswering:()=>$w,AutoModelForImageClassification:()=>Mv,AutoModelForImageFeatureExtraction:()=>Iw,AutoModelForImageMatting:()=>Aw,AutoModelForImageSegmentation:()=>Pv,AutoModelForImageToImage:()=>Iv,AutoModelForMaskGeneration:()=>Sv,AutoModelForMaskedLM:()=>bT,AutoModelForNormalEstimation:()=>Sw,AutoModelForObjectDetection:()=>$v,AutoModelForQuestionAnswering:()=>Tv,AutoModelForSemanticSegmentation:()=>kv,AutoModelForSeq2SeqLM:()=>bv,AutoModelForSequenceClassification:()=>gv,AutoModelForSpeechSeq2Seq:()=>yv,AutoModelForTextToSpectrogram:()=>wv,AutoModelForTextToWaveform:()=>xv,AutoModelForTokenClassification:()=>gT,AutoModelForUniversalSegmentation:()=>Ov,AutoModelForVision2Seq:()=>Ev,AutoModelForXVector:()=>kw,AutoModelForZeroShotObjectDetection:()=>Av,BartForConditionalGeneration:()=>st,BartForSequenceClassification:()=>Mt,BartModel:()=>we,BartPretrainedModel:()=>L,BaseModelOutput:()=>vn,BeitForImageClassification:()=>R0,BeitModel:()=>L0,BeitPreTrainedModel:()=>Fy,BertForMaskedLM:()=>Ao,BertForQuestionAnswering:()=>er,BertForSequenceClassification:()=>Yr,BertForTokenClassification:()=>Ze,BertModel:()=>Eo,BertPreTrainedModel:()=>vr,BlenderbotForConditionalGeneration:()=>Wa,BlenderbotModel:()=>va,BlenderbotPreTrainedModel:()=>oa,BlenderbotSmallForConditionalGeneration:()=>Au,BlenderbotSmallModel:()=>hu,BlenderbotSmallPreTrainedModel:()=>$a,BloomForCausalLM:()=>W_,BloomModel:()=>f0,BloomPreTrainedModel:()=>Ey,CLIPModel:()=>md,CLIPPreTrainedModel:()=>Pu,CLIPSegForImageSegmentation:()=>Vw,CLIPSegModel:()=>Ww,CLIPSegPreTrainedModel:()=>sy,CLIPTextModel:()=>fh,CLIPTextModelWithProjection:()=>Td,CLIPVisionModel:()=>In,CLIPVisionModelWithProjection:()=>qa,CamembertForMaskedLM:()=>Tu,CamembertForQuestionAnswering:()=>So,CamembertForSequenceClassification:()=>Ua,CamembertForTokenClassification:()=>$u,CamembertModel:()=>Na,CamembertPreTrainedModel:()=>Sa,CausalLMOutput:()=>D_,CausalLMOutputWithPast:()=>xT,ChineseCLIPModel:()=>Uw,ChineseCLIPPreTrainedModel:()=>Nw,ClapAudioModelWithProjection:()=>jx,ClapModel:()=>Y_,ClapPreTrainedModel:()=>j_,ClapTextModelWithProjection:()=>cw,CodeGenForCausalLM:()=>Jw,CodeGenModel:()=>Zw,CodeGenPreTrainedModel:()=>zd,CohereForCausalLM:()=>Vd,CohereModel:()=>o0,CoherePreTrainedModel:()=>fy,ConvBertForMaskedLM:()=>le,ConvBertForQuestionAnswering:()=>ko,ConvBertForSequenceClassification:()=>at,ConvBertForTokenClassification:()=>Ft,ConvBertModel:()=>Ye,ConvBertPreTrainedModel:()=>oe,ConvNextForImageClassification:()=>Yy,ConvNextModel:()=>Ed,ConvNextPreTrainedModel:()=>c_,ConvNextV2ForImageClassification:()=>dx,ConvNextV2Model:()=>Qy,ConvNextV2PreTrainedModel:()=>K_,DPTForDepthEstimation:()=>ex,DPTModel:()=>J0,DPTPreTrainedModel:()=>qy,DebertaForMaskedLM:()=>Lr,DebertaForQuestionAnswering:()=>Po,DebertaForSequenceClassification:()=>Oo,DebertaForTokenClassification:()=>tr,DebertaModel:()=>Nt,DebertaPreTrainedModel:()=>Ie,DebertaV2ForMaskedLM:()=>ri,DebertaV2ForQuestionAnswering:()=>da,DebertaV2ForSequenceClassification:()=>Yo,DebertaV2ForTokenClassification:()=>la,DebertaV2Model:()=>jo,DebertaV2PreTrainedModel:()=>Ko,DecisionTransformerModel:()=>tv,DecisionTransformerPreTrainedModel:()=>ev,DeiTForImageClassification:()=>q0,DeiTModel:()=>K0,DeiTPreTrainedModel:()=>Ny,DepthAnythingForDepthEstimation:()=>rx,DepthAnythingPreTrainedModel:()=>tx,DepthProForDepthEstimation:()=>ix,DepthProPreTrainedModel:()=>sx,DetrForObjectDetection:()=>z0,DetrForSegmentation:()=>By,DetrModel:()=>j0,DetrObjectDetectionOutput:()=>Ly,DetrPreTrainedModel:()=>kh,DetrSegmentationOutput:()=>N0,Dinov2ForImageClassification:()=>dg,Dinov2Model:()=>cx,Dinov2PreTrainedModel:()=>Zy,DistilBertForMaskedLM:()=>ma,DistilBertForQuestionAnswering:()=>Io,DistilBertForSequenceClassification:()=>Wt,DistilBertForTokenClassification:()=>$o,DistilBertModel:()=>ha,DistilBertPreTrainedModel:()=>na,DonutSwinModel:()=>Xy,DonutSwinPreTrainedModel:()=>T_,EfficientNetForImageClassification:()=>Kx,EfficientNetModel:()=>Gx,EfficientNetPreTrainedModel:()=>Yg,ElectraForMaskedLM:()=>zo,ElectraForQuestionAnswering:()=>ii,ElectraForSequenceClassification:()=>Jo,ElectraForTokenClassification:()=>ia,ElectraModel:()=>ra,ElectraPreTrainedModel:()=>_n,EsmForMaskedLM:()=>wu,EsmForSequenceClassification:()=>Oa,EsmForTokenClassification:()=>bu,EsmModel:()=>eu,EsmPreTrainedModel:()=>Ba,FalconForCausalLM:()=>sT,FalconModel:()=>Rx,FalconPreTrainedModel:()=>dw,FastViTForImageClassification:()=>k0,FastViTModel:()=>P0,FastViTPreTrainedModel:()=>Sy,Florence2ForConditionalGeneration:()=>Bu,Florence2PreTrainedModel:()=>gu,GLPNForDepthEstimation:()=>v_,GLPNModel:()=>x_,GLPNPreTrainedModel:()=>ux,GPT2LMHeadModel:()=>Ud,GPT2Model:()=>Gw,GPT2PreTrainedModel:()=>iy,GPTBigCodeForCausalLM:()=>py,GPTBigCodeModel:()=>Eh,GPTBigCodePreTrainedModel:()=>cy,GPTJForCausalLM:()=>Wd,GPTJModel:()=>Gv,GPTJPreTrainedModel:()=>dy,GPTNeoForCausalLM:()=>Xw,GPTNeoModel:()=>Hw,GPTNeoPreTrainedModel:()=>ly,GPTNeoXForCausalLM:()=>Qw,GPTNeoXModel:()=>Yw,GPTNeoXPreTrainedModel:()=>uy,Gemma2ForCausalLM:()=>l0,Gemma2Model:()=>a0,Gemma2PreTrainedModel:()=>gy,GemmaForCausalLM:()=>i0,GemmaModel:()=>s0,GemmaPreTrainedModel:()=>my,GraniteForCausalLM:()=>n0,GraniteModel:()=>r0,GranitePreTrainedModel:()=>hy,GroupViTModel:()=>M0,GroupViTPreTrainedModel:()=>E0,HieraForImageClassification:()=>H0,HieraModel:()=>Wy,HieraPreTrainedModel:()=>Uy,HubertForCTC:()=>Px,HubertForSequenceClassification:()=>iw,HubertModel:()=>tT,HubertPreTrainedModel:()=>eT,ImageMattingOutput:()=>Dv,JAISLMHeadModel:()=>qw,JAISModel:()=>Kw,JAISPreTrainedModel:()=>ay,LlamaForCausalLM:()=>t0,LlamaModel:()=>e0,LlamaPreTrainedModel:()=>_y,LlavaForConditionalGeneration:()=>Lo,LlavaPreTrainedModel:()=>Ir,LongT5ForConditionalGeneration:()=>S_,LongT5Model:()=>w_,LongT5PreTrainedModel:()=>y_,M2M100ForConditionalGeneration:()=>mx,M2M100Model:()=>q_,M2M100PreTrainedModel:()=>zg,MBartForCausalLM:()=>Xs,MBartForConditionalGeneration:()=>Zo,MBartForSequenceClassification:()=>Js,MBartModel:()=>tn,MBartPreTrainedModel:()=>Lt,MPNetForMaskedLM:()=>s_,MPNetForQuestionAnswering:()=>O_,MPNetForSequenceClassification:()=>P_,MPNetForTokenClassification:()=>k_,MPNetModel:()=>M_,MPNetPreTrainedModel:()=>Id,MT5ForConditionalGeneration:()=>Pt,MT5Model:()=>I_,MT5PreTrainedModel:()=>d_,MarianMTModel:()=>fx,MarianModel:()=>Yv,MarianPreTrainedModel:()=>ew,MaskFormerForInstanceSegmentation:()=>lx,MaskFormerModel:()=>ax,MaskFormerPreTrainedModel:()=>Hy,MaskedLMOutput:()=>gd,MistralForCausalLM:()=>oT,MistralModel:()=>Fx,MistralPreTrainedModel:()=>lw,MobileBertForMaskedLM:()=>_u,MobileBertForQuestionAnswering:()=>o_,MobileBertForSequenceClassification:()=>m_,MobileBertModel:()=>Bd,MobileBertPreTrainedModel:()=>tu,MobileNetV1ForImageClassification:()=>Xx,MobileNetV1Model:()=>Hx,MobileNetV1PreTrainedModel:()=>qx,MobileNetV2ForImageClassification:()=>lT,MobileNetV2Model:()=>Yx,MobileNetV2PreTrainedModel:()=>mw,MobileNetV3ForImageClassification:()=>Zx,MobileNetV3Model:()=>Qx,MobileNetV3PreTrainedModel:()=>gw,MobileNetV4ForImageClassification:()=>Jx,MobileNetV4Model:()=>uT,MobileNetV4PreTrainedModel:()=>bw,MobileViTForImageClassification:()=>S0,MobileViTModel:()=>A0,MobileViTPreTrainedModel:()=>Iy,MobileViTV2ForImageClassification:()=>I0,MobileViTV2Model:()=>V_,MobileViTV2PreTrainedModel:()=>Cy,ModelOutput:()=>Dr,Moondream1ForConditionalGeneration:()=>Xo,MptForCausalLM:()=>Py,MptModel:()=>m0,MptPreTrainedModel:()=>My,MusicgenForCausalLM:()=>aT,MusicgenForConditionalGeneration:()=>fw,MusicgenModel:()=>KT,MusicgenPreTrainedModel:()=>hw,NomicBertModel:()=>_o,NomicBertPreTrainedModel:()=>Kr,OPTForCausalLM:()=>b0,OPTModel:()=>g0,OPTPreTrainedModel:()=>ky,OpenELMForCausalLM:()=>d0,OpenELMModel:()=>u0,OpenELMPreTrainedModel:()=>by,OwlViTForObjectDetection:()=>D0,OwlViTModel:()=>C0,OwlViTPreTrainedModel:()=>G_,Owlv2ForObjectDetection:()=>B0,Owlv2Model:()=>F0,Owlv2PreTrainedModel:()=>Dy,Phi3ForCausalLM:()=>h0,Phi3Model:()=>_0,Phi3PreTrainedModel:()=>p0,PhiForCausalLM:()=>Ty,PhiModel:()=>c0,PhiPreTrainedModel:()=>vy,PreTrainedModel:()=>Qe,PretrainedMixin:()=>nu,PvtForImageClassification:()=>qv,PvtModel:()=>w0,PvtPreTrainedModel:()=>$y,PyAnnoteForAudioFrameClassification:()=>Zv,PyAnnoteModel:()=>wx,PyAnnotePreTrainedModel:()=>tw,QuestionAnsweringModelOutput:()=>bd,Qwen2ForCausalLM:()=>xy,Qwen2Model:()=>wy,Qwen2PreTrainedModel:()=>yy,RTDetrForObjectDetection:()=>jy,RTDetrModel:()=>U0,RTDetrObjectDetectionOutput:()=>W0,RTDetrPreTrainedModel:()=>Ry,ResNetForImageClassification:()=>Hv,ResNetModel:()=>X0,ResNetPreTrainedModel:()=>Vy,RoFormerForMaskedLM:()=>Bo,RoFormerForQuestionAnswering:()=>ti,RoFormerForSequenceClassification:()=>Ks,RoFormerForTokenClassification:()=>ni,RoFormerModel:()=>en,RoFormerPreTrainedModel:()=>Jr,RobertaForMaskedLM:()=>Gu,RobertaForQuestionAnswering:()=>Su,RobertaForSequenceClassification:()=>xd,RobertaForTokenClassification:()=>wr,RobertaModel:()=>Va,RobertaPreTrainedModel:()=>ka,SamImageSegmentationOutput:()=>hx,SamModel:()=>jg,SamPreTrainedModel:()=>Jy,SapiensForDepthEstimation:()=>Xv,SapiensForNormalEstimation:()=>ox,SapiensForSemanticSegmentation:()=>nx,SapiensPreTrainedModel:()=>Om,SegformerForImageClassification:()=>Ux,SegformerForSemanticSegmentation:()=>Wx,SegformerModel:()=>Nx,SegformerPreTrainedModel:()=>Xg,Seq2SeqLMOutput:()=>wT,SequenceClassifierOutput:()=>Ca,SiglipModel:()=>r_,SiglipPreTrainedModel:()=>ru,SiglipTextModel:()=>U_,SiglipVisionModel:()=>zw,SpeechT5ForSpeechToText:()=>Sx,SpeechT5ForTextToSpeech:()=>Ix,SpeechT5HifiGan:()=>Cx,SpeechT5Model:()=>rT,SpeechT5PreTrainedModel:()=>Hg,SqueezeBertForMaskedLM:()=>Ad,SqueezeBertForQuestionAnswering:()=>g_,SqueezeBertForSequenceClassification:()=>Ld,SqueezeBertModel:()=>Pd,SqueezeBertPreTrainedModel:()=>i_,StableLmForCausalLM:()=>Vx,StableLmModel:()=>iT,StableLmPreTrainedModel:()=>_w,Starcoder2ForCausalLM:()=>Lx,Starcoder2Model:()=>Bx,Starcoder2PreTrainedModel:()=>uw,Swin2SRForImageSuperResolution:()=>Z0,Swin2SRModel:()=>Q0,Swin2SRPreTrainedModel:()=>Ky,SwinForImageClassification:()=>Gd,SwinModel:()=>Y0,SwinPreTrainedModel:()=>Gy,T5ForConditionalGeneration:()=>A_,T5Model:()=>$_,T5PreTrainedModel:()=>u_,TableTransformerForObjectDetection:()=>V0,TableTransformerModel:()=>zy,TableTransformerObjectDetectionOutput:()=>G0,TableTransformerPreTrainedModel:()=>Xh,TokenClassifierOutput:()=>_d,TrOCRForCausalLM:()=>Dx,TrOCRPreTrainedModel:()=>nT,UniSpeechForCTC:()=>Tx,UniSpeechForSequenceClassification:()=>Vg,UniSpeechModel:()=>vx,UniSpeechPreTrainedModel:()=>Wg,UniSpeechSatForAudioFrameClassification:()=>Ex,UniSpeechSatForCTC:()=>nw,UniSpeechSatForSequenceClassification:()=>ow,UniSpeechSatModel:()=>Kg,UniSpeechSatPreTrainedModel:()=>H_,ViTForImageClassification:()=>y0,ViTMAEModel:()=>Ha,ViTMAEPreTrainedModel:()=>x0,ViTMSNForImageClassification:()=>T0,ViTMSNModel:()=>v0,ViTMSNPreTrainedModel:()=>Ay,ViTModel:()=>Kv,ViTPreTrainedModel:()=>Oy,VisionEncoderDecoderModel:()=>Jt,VitMatteForImageMatting:()=>$0,VitMattePreTrainedModel:()=>O0,VitsModel:()=>pw,VitsModelOutput:()=>Fv,VitsPreTrainedModel:()=>zx,Wav2Vec2BertForCTC:()=>Jv,Wav2Vec2BertForSequenceClassification:()=>Mx,Wav2Vec2BertModel:()=>sw,Wav2Vec2BertPreTrainedModel:()=>qg,Wav2Vec2ForAudioFrameClassification:()=>Qv,Wav2Vec2ForCTC:()=>bx,Wav2Vec2ForSequenceClassification:()=>yx,Wav2Vec2Model:()=>gx,Wav2Vec2PreTrainedModel:()=>p_,WavLMForAudioFrameClassification:()=>Ax,WavLMForCTC:()=>Ox,WavLMForSequenceClassification:()=>$x,WavLMForXVector:()=>aw,WavLMModel:()=>kx,WavLMPreTrainedModel:()=>X_,WeSpeakerResNetModel:()=>xx,WeSpeakerResNetPreTrainedModel:()=>rw,WhisperForConditionalGeneration:()=>wt,WhisperModel:()=>be,WhisperPreTrainedModel:()=>S,XLMForQuestionAnswering:()=>xu,XLMForSequenceClassification:()=>fa,XLMForTokenClassification:()=>Du,XLMModel:()=>ba,XLMPreTrainedModel:()=>zu,XLMRobertaForMaskedLM:()=>qs,XLMRobertaForQuestionAnswering:()=>Cd,XLMRobertaForSequenceClassification:()=>La,XLMRobertaForTokenClassification:()=>t_,XLMRobertaModel:()=>Ga,XLMRobertaPreTrainedModel:()=>Fa,XLMWithLMHeadModel:()=>vd,XVectorOutput:()=>Cw,YolosForObjectDetection:()=>Rg,YolosModel:()=>px,YolosObjectDetectionOutput:()=>_x,YolosPreTrainedModel:()=>hg});var s=i("./src/configs.js"),c=i("./src/backends/onnx.js"),n=i("./src/utils/dtypes.js"),a=i("./src/utils/generic.js"),h=i("./src/utils/core.js"),p=i("./src/utils/hub.js"),t=i("./src/utils/constants.js"),u=i("./src/generation/logits_process.js"),l=i("./src/generation/configuration_utils.js"),f=i("./src/utils/tensor.js"),x=i("./src/utils/maths.js"),I=i("./src/generation/stopping_criteria.js"),R=i("./src/generation/logits_sampler.js"),A=i("./src/env.js"),Z=i("./src/models/whisper/generation_whisper.js"),K=i("./src/models/whisper/common_whisper.js");const Q={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7},re=new Map,se=new Map,ee=new Map;async function ce(C,te,$e){var yd;const ar=((yd=$e.config)==null?void 0:yd["transformers.js_config"])??{};let rn=$e.device??ar.device;rn&&typeof rn!="string"&&(rn.hasOwnProperty(te)?rn=rn[te]:(console.warn(`device not specified for "${te}". Using the default device.`),rn=null));const Qr=rn??(A.apis.IS_NODE_ENV?"cpu":"wasm"),Qo=(0,c.deviceToExecutionProviders)(Qr);let ea=$e.dtype??ar.dtype;typeof ea!="string"&&(ea&&ea.hasOwnProperty(te)?ea=ea[te]:(ea=n.DEFAULT_DEVICE_DTYPE_MAPPING[Qr]??n.DATA_TYPES.fp32,console.warn(`dtype not specified for "${te}". Using the default dtype (${ea}) for this device (${Qr}).`)));const _a=ea;if(n.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(_a)){if(_a===n.DATA_TYPES.fp16&&Qr==="webgpu"&&!await(0,n.isWebGpuFp16Supported)())throw new Error(`The device (${Qr}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${_a}. Should be one of: ${Object.keys(n.DATA_TYPES).join(", ")}`);const Pa=ar.kv_cache_dtype?typeof ar.kv_cache_dtype=="string"?ar.kv_cache_dtype:ar.kv_cache_dtype[_a]??"float32":void 0;if(Pa&&!["float32","float16"].includes(Pa))throw new Error(`Invalid kv_cache_dtype: ${Pa}. Should be one of: float32, float16`);const Ja={dtype:_a,kv_cache_dtype:Pa},ou=n.DEFAULT_DTYPE_SUFFIX_MAPPING[_a],ja=`${$e.subfolder??""}/${te}${ou}.onnx`,Aa={...$e.session_options};Aa.executionProviders??(Aa.executionProviders=Qo);const fl=ar.free_dimension_overrides;fl?Aa.freeDimensionOverrides??(Aa.freeDimensionOverrides=fl):Qr.startsWith("webnn")&&!Aa.freeDimensionOverrides&&console.warn('WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.');const Za=(0,p.getModelFile)(C,ja,!0,$e),za=$e.use_external_data_format??ar.use_external_data_format;let iu=[];if(za&&(za===!0||typeof za=="object"&&za.hasOwnProperty(te)&&za[te]===!0)){if(A.apis.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const Eu=`${te}${ou}.onnx_data`,Ou=`${$e.subfolder??""}/${Eu}`;iu.push(new Promise(async(Iu,Od)=>{const E_=await(0,p.getModelFile)(C,Ou,!0,$e);Iu({path:Eu,data:E_})}))}else Aa.externalData!==void 0&&(iu=Aa.externalData.map(async Eu=>{if(typeof Eu.data=="string"){const Ou=await(0,p.getModelFile)(C,Eu.data,!0,$e);return{...Eu,data:Ou}}return Eu}));if(iu.length>0&&(Aa.externalData=await Promise.all(iu)),Qr==="webgpu"){const Eu=(0,s.getKeyValueShapes)($e.config,{prefix:"present"});if(Object.keys(Eu).length>0&&!(0,c.isONNXProxy)()){const Ou={};for(const Iu in Eu)Ou[Iu]="gpu-buffer";Aa.preferredOutputLocation=Ou}}return{buffer:await Za,session_options:Aa,session_config:Ja}}async function X(C,te,$e){return Object.fromEntries(await Promise.all(Object.keys(te).map(async ar=>{const{buffer:rn,session_options:Qr,session_config:Qo}=await ce(C,te[ar],$e),ea=await(0,c.createInferenceSession)(rn,Qr,Qo);return[ar,ea]})))}async function Re(C,te,$e){return Object.fromEntries(await Promise.all(Object.keys(te).map(async ar=>{const rn=await(0,p.getModelJSON)(C,te[ar],!1,$e);return[ar,rn]})))}function De(C,te){const $e=Object.create(null),ar=[];for(const Qo of C.inputNames){const ea=te[Qo];if(!(ea instanceof f.Tensor)){ar.push(Qo);continue}$e[Qo]=(0,c.isONNXProxy)()?ea.clone():ea}if(ar.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ar.join(", ")}.`);const rn=Object.keys(te).length,Qr=C.inputNames.length;if(rn>Qr){let Qo=Object.keys(te).filter(ea=>!C.inputNames.includes(ea));console.warn(`WARNING: Too many inputs were provided (${rn} > ${Qr}). The following inputs will be ignored: "${Qo.join(", ")}".`)}return $e}async function et(C,te){const $e=De(C,te);try{const ar=Object.fromEntries(Object.entries($e).map(([Qr,Qo])=>[Qr,Qo.ort_tensor]));let rn=await C.run(ar);return rn=nt(rn),rn}catch(ar){throw console.error(`An error occurred during model execution: "${ar}".`),console.error("Inputs given to model:",$e),ar}}function nt(C){for(let te in C)(0,c.isONNXTensor)(C[te])?C[te]=new f.Tensor(C[te]):typeof C[te]=="object"&&nt(C[te]);return C}function it(C){if(C instanceof f.Tensor)return C;if(C.length===0)throw Error("items must be non-empty");if(Array.isArray(C[0])){if(C.some(te=>te.length!==C[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new f.Tensor("int64",BigInt64Array.from(C.flat().map(te=>BigInt(te))),[C.length,C[0].length])}else return new f.Tensor("int64",BigInt64Array.from(C.map(te=>BigInt(te))),[1,C.length])}function _t(C){return new f.Tensor("bool",[C],[1])}async function gt(C,te){let{encoder_outputs:$e,input_ids:ar,decoder_input_ids:rn,...Qr}=te;if(!$e){const ea=(0,h.pick)(te,C.sessions.model.inputNames);$e=(await Dt(C,ea)).last_hidden_state}return Qr.input_ids=rn,Qr.encoder_hidden_states=$e,C.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Qr.encoder_attention_mask=te.attention_mask),await Ge(C,Qr,!0)}async function Dt(C,te){const $e=C.sessions.model,ar=(0,h.pick)(te,$e.inputNames);if($e.inputNames.includes("inputs_embeds")&&!ar.inputs_embeds){if(!te.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ar.inputs_embeds=await C.encode_text({input_ids:te.input_ids})}return $e.inputNames.includes("token_type_ids")&&!ar.token_type_ids&&(ar.token_type_ids=new f.Tensor("int64",new BigInt64Array(ar.input_ids.data.length),ar.input_ids.dims)),await et($e,ar)}async function Ge(C,te,$e=!1){const ar=C.sessions[$e?"decoder_model_merged":"model"],{past_key_values:rn,...Qr}=te;ar.inputNames.includes("use_cache_branch")&&(Qr.use_cache_branch=_t(!!rn)),ar.inputNames.includes("position_ids")&&Qr.attention_mask&&!Qr.position_ids&&(Qr.position_ids=ct(Qr,rn)),C.addPastKeyValues(Qr,rn);const Qo=(0,h.pick)(Qr,ar.inputNames);return await et(ar,Qo)}async function ge(C,{input_ids:te=null,attention_mask:$e=null,pixel_values:ar=null,position_ids:rn=null,inputs_embeds:Qr=null,past_key_values:Qo=null,generation_config:ea=null,logits_processor:_a=null,...Pa}){if(!Qr){if(Qr=await C.encode_text({input_ids:te}),ar&&te.dims[1]!==1){const ou=await C.encode_image({pixel_values:ar});({inputs_embeds:Qr,attention_mask:$e}=C._merge_input_ids_with_image_features({image_features:ou,inputs_embeds:Qr,input_ids:te,attention_mask:$e}))}else if(Qo&&ar&&te.dims[1]===1){const ou=te.dims[1],ja=Object.values(Qo)[0].dims.at(-2);$e=(0,f.cat)([(0,f.ones)([te.dims[0],ja]),$e.slice(null,[$e.dims[1]-ou,$e.dims[1]])],1)}}return await Ge(C,{inputs_embeds:Qr,past_key_values:Qo,attention_mask:$e,position_ids:rn,generation_config:ea,logits_processor:_a},!0)}function ct(C,te=null){const{input_ids:$e,inputs_embeds:ar,attention_mask:rn}=C,[Qr,Qo]=rn.dims,ea=new BigInt64Array(rn.data.length);for(let Pa=0;Pa<Qr;++Pa){const Ja=Pa*Qo;let ou=BigInt(0);for(let ja=0;ja<Qo;++ja){const Aa=Ja+ja;rn.data[Aa]===0n?ea[Aa]=BigInt(1):(ea[Aa]=ou,ou+=rn.data[Aa])}}let _a=new f.Tensor("int64",ea,rn.dims);if(te){const Pa=-($e??ar).dims.at(1);_a=_a.slice(null,[Pa,null])}return _a}function Ot(C,te,$e,ar){if($e.past_key_values){const rn=Object.values($e.past_key_values)[0].dims.at(-2),{input_ids:Qr,attention_mask:Qo}=$e;if(!(Qo&&Qo.dims[1]>Qr.dims[1])){if(rn<Qr.dims[1])$e.input_ids=Qr.slice(null,[rn,null]);else if(C.config.image_token_index!=null&&Qr.data.some(ea=>ea==C.config.image_token_index)){const ea=C.config.num_image_tokens;if(!ea)throw new Error("`num_image_tokens` is missing in the model configuration.");const _a=Qr.dims[1]-(rn-ea);$e.input_ids=Qr.slice(null,[-_a,null]),$e.attention_mask=(0,f.ones)([1,rn+_a])}}}return $e}function $t(C,te,$e,ar){return $e.past_key_values&&(te=te.map(rn=>[rn.at(-1)])),{...$e,decoder_input_ids:it(te)}}function gr(C,...te){return C.config.is_encoder_decoder?$t(C,...te):Ot(C,...te)}class Qe extends a.Callable{constructor($e,ar,rn){super();_r(this,"main_input_name","input_ids");_r(this,"forward_params",["input_ids","attention_mask"]);this.config=$e,this.sessions=ar,this.configs=rn;const Qr=ee.get(this.constructor),Qo=re.get(Qr);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,Qo){case Q.DecoderOnly:this.can_generate=!0,this._forward=Ge,this._prepare_inputs_for_generation=Ot;break;case Q.Seq2Seq:case Q.Vision2Seq:case Q.Musicgen:this.can_generate=!0,this._forward=gt,this._prepare_inputs_for_generation=$t;break;case Q.EncoderDecoder:this._forward=gt;break;case Q.ImageTextToText:this.can_generate=!0,this._forward=ge,this._prepare_inputs_for_generation=gr;break;default:this._forward=Dt;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var ar;const $e=[];for(const rn of Object.values(this.sessions))(ar=rn==null?void 0:rn.handler)!=null&&ar.dispose&&$e.push(rn.handler.dispose());return await Promise.all($e)}static async from_pretrained($e,{progress_callback:ar=null,config:rn=null,cache_dir:Qr=null,local_files_only:Qo=!1,revision:ea="main",model_file_name:_a=null,subfolder:Pa="onnx",device:Ja=null,dtype:ou=null,use_external_data_format:ja=null,session_options:Aa={}}={}){let fl={progress_callback:ar,config:rn,cache_dir:Qr,local_files_only:Qo,revision:ea,model_file_name:_a,subfolder:Pa,device:Ja,dtype:ou,use_external_data_format:ja,session_options:Aa};const Za=ee.get(this),za=re.get(Za);rn=fl.config=await s.AutoConfig.from_pretrained($e,fl);let iu;if(za===Q.DecoderOnly)iu=await Promise.all([X($e,{model:fl.model_file_name??"model"},fl),Re($e,{generation_config:"generation_config.json"},fl)]);else if(za===Q.Seq2Seq||za===Q.Vision2Seq)iu=await Promise.all([X($e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},fl),Re($e,{generation_config:"generation_config.json"},fl)]);else if(za===Q.MaskGeneration)iu=await Promise.all([X($e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},fl)]);else if(za===Q.EncoderDecoder)iu=await Promise.all([X($e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},fl)]);else if(za===Q.ImageTextToText){const Fd={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};rn.is_encoder_decoder&&(Fd.model="encoder_model"),iu=await Promise.all([X($e,Fd,fl),Re($e,{generation_config:"generation_config.json"},fl)])}else za===Q.Musicgen?iu=await Promise.all([X($e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},fl),Re($e,{generation_config:"generation_config.json"},fl)]):(za!==Q.EncoderOnly&&console.warn(`Model type for '${Za??(rn==null?void 0:rn.model_type)}' not found, assuming encoder-only architecture. Please report this at ${t.GITHUB_ISSUE_URL}.`),iu=await Promise.all([X($e,{model:fl.model_file_name??"model"},fl)]));return new this(rn,...iu)}async _call($e){return await this.forward($e)}async forward($e){return await this._forward(this,$e)}get generation_config(){var $e;return(($e=this.configs)==null?void 0:$e.generation_config)??null}_get_logits_warper($e){const ar=new u.LogitsProcessorList;return $e.temperature!==null&&$e.temperature!==1&&ar.push(new u.TemperatureLogitsWarper($e.temperature)),$e.top_k!==null&&$e.top_k!==0&&ar.push(new u.TopKLogitsWarper($e.top_k)),$e.top_p!==null&&$e.top_p<1&&ar.push(new u.TopPLogitsWarper($e.top_p)),ar}_get_logits_processor($e,ar,rn=null){const Qr=new u.LogitsProcessorList;if($e.repetition_penalty!==null&&$e.repetition_penalty!==1&&Qr.push(new u.RepetitionPenaltyLogitsProcessor($e.repetition_penalty)),$e.no_repeat_ngram_size!==null&&$e.no_repeat_ngram_size>0&&Qr.push(new u.NoRepeatNGramLogitsProcessor($e.no_repeat_ngram_size)),$e.bad_words_ids!==null&&Qr.push(new u.NoBadWordsLogitsProcessor($e.bad_words_ids,$e.eos_token_id)),$e.min_length!==null&&$e.eos_token_id!==null&&$e.min_length>0&&Qr.push(new u.MinLengthLogitsProcessor($e.min_length,$e.eos_token_id)),$e.min_new_tokens!==null&&$e.eos_token_id!==null&&$e.min_new_tokens>0&&Qr.push(new u.MinNewTokensLengthLogitsProcessor(ar,$e.min_new_tokens,$e.eos_token_id)),$e.forced_bos_token_id!==null&&Qr.push(new u.ForcedBOSTokenLogitsProcessor($e.forced_bos_token_id)),$e.forced_eos_token_id!==null&&Qr.push(new u.ForcedEOSTokenLogitsProcessor($e.max_length,$e.forced_eos_token_id)),$e.begin_suppress_tokens!==null){const Qo=ar>1||$e.forced_bos_token_id===null?ar:ar+1;Qr.push(new u.SuppressTokensAtBeginLogitsProcessor($e.begin_suppress_tokens,Qo))}return $e.guidance_scale!==null&&$e.guidance_scale>1&&Qr.push(new u.ClassifierFreeGuidanceLogitsProcessor($e.guidance_scale)),rn!==null&&Qr.extend(rn),Qr}_prepare_generation_config($e,ar,rn=l.GenerationConfig){const Qr={...this.config};for(const ea of["decoder","generator","text_config"])ea in Qr&&Object.assign(Qr,Qr[ea]);const Qo=new rn(Qr);return Object.assign(Qo,this.generation_config??{}),$e&&Object.assign(Qo,$e),ar&&Object.assign(Qo,(0,h.pick)(ar,Object.getOwnPropertyNames(Qo))),Qo}_get_stopping_criteria($e,ar=null){const rn=new I.StoppingCriteriaList;return $e.max_length!==null&&rn.push(new I.MaxLengthCriteria($e.max_length,this.config.max_position_embeddings??null)),$e.eos_token_id!==null&&rn.push(new I.EosTokenCriteria($e.eos_token_id)),ar&&rn.extend(ar),rn}_validate_model_class(){if(!this.can_generate){const $e=[Qg,xw,ww,yw],ar=ee.get(this.constructor),rn=new Set,Qr=this.config.model_type;for(const ea of $e){const _a=ea.get(Qr);_a&&rn.add(_a[0])}let Qo=`The current model class (${ar}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw rn.size>0&&(Qo+=` Please use the following class instead: ${[...rn].join(", ")}`),Error(Qo)}}prepare_inputs_for_generation(...$e){return this._prepare_inputs_for_generation(this,...$e)}_update_model_kwargs_for_generation({generated_input_ids:$e,outputs:ar,model_inputs:rn,is_encoder_decoder:Qr}){return rn.past_key_values=this.getPastKeyValues(ar,rn.past_key_values),rn.input_ids=new f.Tensor("int64",$e.flat(),[$e.length,1]),Qr||(rn.attention_mask=(0,f.cat)([rn.attention_mask,(0,f.ones)([rn.attention_mask.dims[0],1])],1)),rn.position_ids=null,rn}_prepare_model_inputs({inputs:$e,bos_token_id:ar,model_kwargs:rn}){const Qr=(0,h.pick)(rn,this.forward_params),Qo=this.main_input_name;if(Qo in Qr){if($e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Qr[Qo]=$e;return{inputs_tensor:Qr[Qo],model_inputs:Qr,model_input_name:Qo}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:$e,model_inputs:ar,model_input_name:rn,generation_config:Qr}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ar.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:ea,pixel_values:_a,attention_mask:Pa,...Ja}=ar,ou=await this._prepare_inputs_embeds(ar);ar={...Ja,...(0,h.pick)(ou,["inputs_embeds","attention_mask"])}}let{last_hidden_state:Qo}=await Dt(this,ar);if(Qr.guidance_scale!==null&&Qr.guidance_scale>1)Qo=(0,f.cat)([Qo,(0,f.full_like)(Qo,0)],0),"attention_mask"in ar&&(ar.attention_mask=(0,f.cat)([ar.attention_mask,(0,f.zeros_like)(ar.attention_mask)],0));else if(ar.decoder_input_ids){const ea=it(ar.decoder_input_ids).dims[0];if(ea!==Qo.dims[0]){if(Qo.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${Qo.dims[0]}) than the decoder inputs (${ea}).`);Qo=(0,f.cat)(Array.from({length:ea},()=>Qo),0)}}return ar.encoder_outputs=Qo,ar}_prepare_decoder_input_ids_for_generation({batch_size:$e,model_input_name:ar,model_kwargs:rn,decoder_start_token_id:Qr,bos_token_id:Qo,generation_config:ea}){let{decoder_input_ids:_a,...Pa}=rn;if(_a)Array.isArray(_a[0])||(_a=Array.from({length:$e},()=>_a));else if(Qr??(Qr=Qo),this.config.model_type==="musicgen")_a=Array.from({length:$e*this.config.decoder.num_codebooks},()=>[Qr]);else if(Array.isArray(Qr)){if(Qr.length!==$e)throw new Error(`\`decoder_start_token_id\` expcted to have length ${$e} but got ${Qr.length}`);_a=Qr}else _a=Array.from({length:$e},()=>[Qr]);return _a=it(_a),rn.decoder_attention_mask=(0,f.ones_like)(_a),{input_ids:_a,model_inputs:Pa}}async generate({inputs:$e=null,generation_config:ar=null,logits_processor:rn=null,stopping_criteria:Qr=null,streamer:Qo=null,...ea}){this._validate_model_class(),ar=this._prepare_generation_config(ar,ea);let{inputs_tensor:_a,model_inputs:Pa,model_input_name:Ja}=this._prepare_model_inputs({inputs:$e,model_kwargs:ea});const ou=this.config.is_encoder_decoder;ou&&("encoder_outputs"in Pa||(Pa=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:_a,model_inputs:Pa,model_input_name:Ja,generation_config:ar})));let ja;ou?{input_ids:ja,model_inputs:Pa}=this._prepare_decoder_input_ids_for_generation({batch_size:Pa[Ja].dims.at(0),model_input_name:Ja,model_kwargs:Pa,decoder_start_token_id:ar.decoder_start_token_id,bos_token_id:ar.bos_token_id,generation_config:ar}):ja=Pa[Ja];let Aa=ja.dims.at(-1);ar.max_new_tokens!==null&&(ar.max_length=Aa+ar.max_new_tokens);const fl=this._get_logits_processor(ar,Aa,rn),Za=this._get_stopping_criteria(ar,Qr),za=Pa[Ja].dims.at(0),iu=R.LogitsSampler.getSampler(ar),Fd=new Array(za).fill(0),yd=ja.tolist();Qo&&Qo.put(yd);let Eu,Ou={};for(;;){if(Pa=this.prepare_inputs_for_generation(yd,Pa,ar),Eu=await this.forward(Pa),ar.output_attentions&&ar.return_dict_in_generate){const n_=this.getAttentions(Eu);for(const J_ in n_)J_ in Ou||(Ou[J_]=[]),Ou[J_].push(n_[J_])}const E_=Eu.logits.slice(null,-1,null),Zg=fl(yd,E_),Dw=[];for(let n_=0;n_<Zg.dims.at(0);++n_){const J_=Zg[n_],vT=await iu(J_);for(const[TT,ET]of vT){const MT=BigInt(TT);Fd[n_]+=ET,yd[n_].push(MT),Dw.push([MT]);break}}if(Qo&&Qo.put(Dw),Za(yd).every(n_=>n_))break;Pa=this._update_model_kwargs_for_generation({generated_input_ids:Dw,outputs:Eu,model_inputs:Pa,is_encoder_decoder:ou})}Qo&&Qo.end();const Iu=this.getPastKeyValues(Eu,Pa.past_key_values,!0),Od=new f.Tensor("int64",yd.flat(),[yd.length,yd[0].length]);if(ar.return_dict_in_generate)return{sequences:Od,past_key_values:Iu,...Ou};for(const E_ of Object.values(Eu))E_.location==="gpu-buffer"&&E_.dispose();return Od}getPastKeyValues($e,ar,rn=!1){const Qr=Object.create(null);for(const Qo in $e)if(Qo.startsWith("present")){const ea=Qo.replace("present","past_key_values"),_a=Qo.includes("encoder");if(_a&&ar?Qr[ea]=ar[ea]:Qr[ea]=$e[Qo],ar&&(!_a||rn)){const Pa=ar[ea];Pa.location==="gpu-buffer"&&Pa.dispose()}}return Qr}getAttentions($e){const ar={};for(const rn of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Qr in $e)Qr.startsWith(rn)&&(rn in ar||(ar[rn]=[]),ar[rn].push($e[Qr]));return ar}addPastKeyValues($e,ar){var rn;if(ar)Object.assign($e,ar);else{const Qr=this.sessions.decoder_model_merged??this.sessions.model,Qo=((rn=Qr==null?void 0:Qr.config)==null?void 0:rn.kv_cache_dtype)??"float32",ea=Qo==="float16"?new Uint16Array:[],_a=(0,s.getKeyValueShapes)(this.config);for(const Pa in _a)$e[Pa]=new f.Tensor(Qo,ea,_a[Pa])}}async encode_image({pixel_values:$e}){const ar=(await et(this.sessions.vision_encoder,{pixel_values:$e})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${ar.dims[1]}).`),this.config.num_image_tokens=ar.dims[1]),ar}async encode_text({input_ids:$e}){return(await et(this.sessions.embed_tokens,{input_ids:$e})).inputs_embeds}}class Dr{}class vn extends Dr{constructor({last_hidden_state:te,hidden_states:$e=null,attentions:ar=null}){super(),this.last_hidden_state=te,this.hidden_states=$e,this.attentions=ar}}class vr extends Qe{}class Eo extends vr{}class Ao extends vr{async _call(te){return new gd(await super._call(te))}}class Yr extends vr{async _call(te){return new Ca(await super._call(te))}}class Ze extends vr{async _call(te){return new _d(await super._call(te))}}class er extends vr{async _call(te){return new bd(await super._call(te))}}class Kr extends Qe{}class _o extends Kr{}class Jr extends Qe{}class en extends Jr{}class Bo extends Jr{async _call(te){return new gd(await super._call(te))}}class Ks extends Jr{async _call(te){return new Ca(await super._call(te))}}class ni extends Jr{async _call(te){return new _d(await super._call(te))}}class ti extends Jr{async _call(te){return new bd(await super._call(te))}}class oe extends Qe{}class Ye extends oe{}class le extends oe{async _call(te){return new gd(await super._call(te))}}class at extends oe{async _call(te){return new Ca(await super._call(te))}}class Ft extends oe{async _call(te){return new _d(await super._call(te))}}class ko extends oe{async _call(te){return new bd(await super._call(te))}}class _n extends Qe{}class ra extends _n{}class zo extends _n{async _call(te){return new gd(await super._call(te))}}class Jo extends _n{async _call(te){return new Ca(await super._call(te))}}class ia extends _n{async _call(te){return new _d(await super._call(te))}}class ii extends _n{async _call(te){return new bd(await super._call(te))}}class Sa extends Qe{}class Na extends Sa{}class Tu extends Sa{async _call(te){return new gd(await super._call(te))}}class Ua extends Sa{async _call(te){return new Ca(await super._call(te))}}class $u extends Sa{async _call(te){return new _d(await super._call(te))}}class So extends Sa{async _call(te){return new bd(await super._call(te))}}class Ie extends Qe{}class Nt extends Ie{}class Lr extends Ie{async _call(te){return new gd(await super._call(te))}}class Oo extends Ie{async _call(te){return new Ca(await super._call(te))}}class tr extends Ie{async _call(te){return new _d(await super._call(te))}}class Po extends Ie{async _call(te){return new bd(await super._call(te))}}class Ko extends Qe{}class jo extends Ko{}class ri extends Ko{async _call(te){return new gd(await super._call(te))}}class Yo extends Ko{async _call(te){return new Ca(await super._call(te))}}class la extends Ko{async _call(te){return new _d(await super._call(te))}}class da extends Ko{async _call(te){return new bd(await super._call(te))}}class na extends Qe{}class ha extends na{}class Wt extends na{async _call(te){return new Ca(await super._call(te))}}class $o extends na{async _call(te){return new _d(await super._call(te))}}class Io extends na{async _call(te){return new bd(await super._call(te))}}class ma extends na{async _call(te){return new gd(await super._call(te))}}class Ba extends Qe{}class eu extends Ba{}class wu extends Ba{async _call(te){return new gd(await super._call(te))}}class Oa extends Ba{async _call(te){return new Ca(await super._call(te))}}class bu extends Ba{async _call(te){return new _d(await super._call(te))}}class tu extends Qe{}class Bd extends tu{}class _u extends tu{async _call(te){return new gd(await super._call(te))}}class m_ extends tu{async _call(te){return new Ca(await super._call(te))}}class o_ extends tu{async _call(te){return new bd(await super._call(te))}}class Id extends Qe{}class M_ extends Id{}class s_ extends Id{async _call(te){return new gd(await super._call(te))}}class P_ extends Id{async _call(te){return new Ca(await super._call(te))}}class k_ extends Id{async _call(te){return new _d(await super._call(te))}}class O_ extends Id{async _call(te){return new bd(await super._call(te))}}class i_ extends Qe{}class Pd extends i_{}class Ad extends i_{async _call(te){return new gd(await super._call(te))}}class Ld extends i_{async _call(te){return new Ca(await super._call(te))}}class g_ extends i_{async _call(te){return new bd(await super._call(te))}}class Rd extends Qe{}class a_ extends Rd{}class l_ extends Rd{async _call(te){return new Ca(await super._call(te))}}class b_ extends Rd{async _call(te){return new bd(await super._call(te))}}class ya extends Rd{async _call(te){return new gd(await super._call(te))}}class u_ extends Qe{constructor(){super(...arguments);_r(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class $_ extends u_{}class A_ extends u_{}class y_ extends Qe{}class w_ extends y_{}class S_ extends y_{}class d_ extends Qe{}class I_ extends d_{}class Pt extends d_{}class L extends Qe{}class we extends L{}class st extends L{}class Mt extends L{async _call(te){return new Ca(await super._call(te))}}class Lt extends Qe{}class tn extends Lt{}class Zo extends Lt{}class Js extends Lt{async _call(te){return new Ca(await super._call(te))}}class Xs extends Lt{}class oa extends Qe{}class va extends oa{}class Wa extends oa{}class $a extends Qe{}class hu extends $a{}class Au extends $a{}class ka extends Qe{}class Va extends ka{}class Gu extends ka{async _call(te){return new gd(await super._call(te))}}class xd extends ka{async _call(te){return new Ca(await super._call(te))}}class wr extends ka{async _call(te){return new _d(await super._call(te))}}class Su extends ka{async _call(te){return new bd(await super._call(te))}}class zu extends Qe{}class ba extends zu{}class vd extends zu{async _call(te){return new gd(await super._call(te))}}class fa extends zu{async _call(te){return new Ca(await super._call(te))}}class Du extends zu{async _call(te){return new _d(await super._call(te))}}class xu extends zu{async _call(te){return new bd(await super._call(te))}}class Fa extends Qe{}class Ga extends Fa{}class qs extends Fa{async _call(te){return new gd(await super._call(te))}}class La extends Fa{async _call(te){return new Ca(await super._call(te))}}class t_ extends Fa{async _call(te){return new _d(await super._call(te))}}class Cd extends Fa{async _call(te){return new bd(await super._call(te))}}class Dd extends Qe{}class ca extends Dd{}class C_ extends Dd{}class S extends Qe{constructor(){super(...arguments);_r(this,"requires_attention_mask",!1);_r(this,"main_input_name","input_features");_r(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class be extends S{}class wt extends S{_prepare_generation_config(te,$e){return super._prepare_generation_config(te,$e,Z.WhisperGenerationConfig)}_retrieve_init_tokens(te){const $e=[te.decoder_start_token_id];let ar=te.language;const rn=te.task;if(te.is_multilingual){ar||(console.warn("No language specified - defaulting to English (en)."),ar="en");const Qo=`<|${(0,K.whisper_language_to_code)(ar)}|>`;$e.push(te.lang_to_id[Qo]),$e.push(te.task_to_id[rn??"transcribe"])}else if(ar||rn)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!te.return_timestamps&&te.no_timestamps_token_id&&$e.at(-1)!==te.no_timestamps_token_id?$e.push(te.no_timestamps_token_id):te.return_timestamps&&$e.at(-1)===te.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),$e.pop()),$e.filter(Qr=>Qr!=null)}async generate({inputs:te=null,generation_config:$e=null,logits_processor:ar=null,stopping_criteria:rn=null,...Qr}){$e=this._prepare_generation_config($e,Qr);const Qo=Qr.decoder_input_ids??this._retrieve_init_tokens($e);if($e.return_timestamps&&(ar??(ar=new u.LogitsProcessorList),ar.push(new u.WhisperTimeStampLogitsProcessor($e,Qo))),$e.begin_suppress_tokens&&(ar??(ar=new u.LogitsProcessorList),ar.push(new u.SuppressTokensAtBeginLogitsProcessor($e.begin_suppress_tokens,Qo.length))),$e.return_token_timestamps){if(!$e.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");$e.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),$e.output_attentions=!0,$e.return_dict_in_generate=!0}const ea=await super.generate({inputs:te,generation_config:$e,logits_processor:ar,decoder_input_ids:Qo,...Qr});return $e.return_token_timestamps&&(ea.token_timestamps=this._extract_token_timestamps(ea,$e.alignment_heads,$e.num_frames)),ea}_extract_token_timestamps(te,$e,ar=null,rn=.02){if(!te.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ar==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Qr=this.config.median_filter_width;Qr===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Qr=7);const Qo=te.cross_attentions,ea=Array.from({length:this.config.decoder_layers},(Za,za)=>(0,f.cat)(Qo.map(iu=>iu[za]),2)),_a=(0,f.stack)($e.map(([Za,za])=>{if(Za>=ea.length)throw new Error(`Layer index ${Za} is out of bounds for cross attentions (length ${ea.length}).`);return ar?ea[Za].slice(null,za,null,[0,ar]):ea[Za].slice(null,za)})).transpose(1,0,2,3),[Pa,Ja]=(0,f.std_mean)(_a,-2,0,!0),ou=_a.clone();for(let Za=0;Za<ou.dims[0];++Za){const za=ou[Za];for(let iu=0;iu<za.dims[0];++iu){const Fd=za[iu],yd=Pa[Za][iu][0].data,Eu=Ja[Za][iu][0].data;for(let Ou=0;Ou<Fd.dims[0];++Ou){let Iu=Fd[Ou].data;for(let Od=0;Od<Iu.length;++Od)Iu[Od]=(Iu[Od]-Eu[Od])/yd[Od];Iu.set((0,x.medianFilter)(Iu,Qr))}}}const ja=[(0,f.mean)(ou,1)],Aa=te.sequences.dims,fl=new f.Tensor("float32",new Float32Array(Aa[0]*Aa[1]),Aa);for(let Za=0;Za<Aa[0];++Za){const za=ja[Za].neg().squeeze_(0),[iu,Fd]=(0,x.dynamic_time_warping)(za.tolist()),yd=Array.from({length:iu.length-1},(Iu,Od)=>iu[Od+1]-iu[Od]),Eu=(0,h.mergeArrays)([1],yd).map(Iu=>!!Iu),Ou=[];for(let Iu=0;Iu<Eu.length;++Iu)Eu[Iu]&&Ou.push(Fd[Iu]*rn);fl[Za].data.set(Ou,1)}return fl}}class Jt extends Qe{constructor(){super(...arguments);_r(this,"main_input_name","pixel_values");_r(this,"forward_params",["pixel_values","input_ids","encoder_hidden_states","past_key_values"])}}class Ir extends Qe{constructor(){super(...arguments);_r(this,"forward_params",["input_ids","pixel_values","attention_mask","position_ids","past_key_values"])}}class Lo extends Ir{_merge_input_ids_with_image_features({inputs_embeds:te,image_features:$e,input_ids:ar,attention_mask:rn}){const Qr=this.config.image_token_index,ea=ar.tolist().map(ja=>ja.findIndex(Aa=>Aa==Qr)),_a=ea.every(ja=>ja===-1),Pa=ea.every(ja=>ja!==-1);if(!_a&&!Pa)throw new Error("Every input should contain either 0 or 1 image token.");if(_a)return{inputs_embeds:te,attention_mask:rn};const Ja=[],ou=[];for(let ja=0;ja<ea.length;++ja){const Aa=ea[ja],fl=te[ja],Za=$e[ja],za=rn[ja];Ja.push((0,f.cat)([fl.slice([0,Aa]),Za,fl.slice([Aa+1,fl.dims[0]])],0)),ou.push((0,f.cat)([za.slice([0,Aa]),(0,f.ones)([Za.dims[0]]),za.slice([Aa+1,za.dims[0]])],0))}return{inputs_embeds:(0,f.stack)(Ja,0),attention_mask:(0,f.stack)(ou,0)}}}class Xo extends Lo{}class gu extends Qe{constructor(){super(...arguments);_r(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);_r(this,"main_input_name","inputs_embeds")}}class Bu extends gu{_merge_input_ids_with_image_features({inputs_embeds:te,image_features:$e,input_ids:ar,attention_mask:rn}){return{inputs_embeds:(0,f.cat)([$e,te],1),attention_mask:(0,f.cat)([(0,f.ones)($e.dims.slice(0,2)),rn],1)}}async _prepare_inputs_embeds({input_ids:te,pixel_values:$e,inputs_embeds:ar,attention_mask:rn}){if(!te&&!$e)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Qr,Qo;return te&&(Qr=await this.encode_text({input_ids:te})),$e&&(Qo=await this.encode_image({pixel_values:$e})),Qr&&Qo?{inputs_embeds:ar,attention_mask:rn}=this._merge_input_ids_with_image_features({inputs_embeds:Qr,image_features:Qo,input_ids:te,attention_mask:rn}):ar=Qr||Qo,{inputs_embeds:ar,attention_mask:rn}}async forward({input_ids:te,pixel_values:$e,attention_mask:ar,decoder_input_ids:rn,decoder_attention_mask:Qr,encoder_outputs:Qo,past_key_values:ea,inputs_embeds:_a,decoder_inputs_embeds:Pa}){if(_a||({inputs_embeds:_a,attention_mask:ar}=await this._prepare_inputs_embeds({input_ids:te,pixel_values:$e,inputs_embeds:_a,attention_mask:ar})),!Qo){let{last_hidden_state:ja}=await Dt(this,{inputs_embeds:_a,attention_mask:ar});Qo=ja}if(!Pa){if(!rn)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");Pa=await this.encode_text({input_ids:rn})}return await Ge(this,{inputs_embeds:Pa,attention_mask:Qr,encoder_attention_mask:ar,encoder_hidden_states:Qo,past_key_values:ea},!0)}}class Pu extends Qe{}class md extends Pu{}class fh extends Pu{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="text_model"),super.from_pretrained(te,$e)}}class Td extends Pu{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="text_model"),super.from_pretrained(te,$e)}}class In extends Pu{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="vision_model"),super.from_pretrained(te,$e)}}class qa extends Pu{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="vision_model"),super.from_pretrained(te,$e)}}class ru extends Qe{}class r_ extends ru{}class U_ extends ru{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="text_model"),super.from_pretrained(te,$e)}}class zw extends Pu{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="vision_model"),super.from_pretrained(te,$e)}}class Nw extends Qe{}class Uw extends Nw{}class sy extends Qe{}class Ww extends sy{}class Vw extends sy{}class iy extends Qe{}class Gw extends iy{}class Ud extends iy{}class ay extends Qe{}class Kw extends ay{}class qw extends ay{}class ly extends Qe{}class Hw extends ly{}class Xw extends ly{}class uy extends Qe{}class Yw extends uy{}class Qw extends uy{}class dy extends Qe{}class Gv extends dy{}class Wd extends dy{}class cy extends Qe{}class Eh extends cy{}class py extends cy{}class zd extends Qe{}class Zw extends zd{}class Jw extends zd{}class _y extends Qe{}class e0 extends _y{}class t0 extends _y{}class hy extends Qe{}class r0 extends hy{}class n0 extends hy{}class fy extends Qe{}class o0 extends fy{}class Vd extends fy{}class my extends Qe{}class s0 extends my{}class i0 extends my{}class gy extends Qe{}class a0 extends gy{}class l0 extends gy{}class by extends Qe{}class u0 extends by{}class d0 extends by{}class yy extends Qe{}class wy extends yy{}class xy extends yy{}class vy extends Qe{}class c0 extends vy{}class Ty extends vy{}class p0 extends Qe{}class _0 extends p0{}class h0 extends p0{}class Ey extends Qe{}class f0 extends Ey{}class W_ extends Ey{}class My extends Qe{}class m0 extends My{}class Py extends My{}class ky extends Qe{}class g0 extends ky{}class b0 extends ky{}class Oy extends Qe{}class Kv extends Oy{}class y0 extends Oy{async _call(te){return new Ca(await super._call(te))}}class $y extends Qe{}class w0 extends $y{}class qv extends $y{async _call(te){return new Ca(await super._call(te))}}class x0 extends Qe{}class Ha extends x0{}class Ay extends Qe{}class v0 extends Ay{}class T0 extends Ay{async _call(te){return new Ca(await super._call(te))}}class E0 extends Qe{}class M0 extends E0{}class Sy extends Qe{}class P0 extends Sy{}class k0 extends Sy{async _call(te){return new Ca(await super._call(te))}}class O0 extends Qe{}class $0 extends O0{async _call(te){return new Dv(await super._call(te))}}class Iy extends Qe{}class A0 extends Iy{}class S0 extends Iy{async _call(te){return new Ca(await super._call(te))}}class Cy extends Qe{}class V_ extends Cy{}class I0 extends Cy{async _call(te){return new Ca(await super._call(te))}}class G_ extends Qe{}class C0 extends G_{}class D0 extends G_{}class Dy extends Qe{}class F0 extends Dy{}class B0 extends Dy{}class Fy extends Qe{}class L0 extends Fy{}class R0 extends Fy{async _call(te){return new Ca(await super._call(te))}}class kh extends Qe{}class j0 extends kh{}class z0 extends kh{async _call(te){return new Ly(await super._call(te))}}class By extends kh{async _call(te){return new N0(await super._call(te))}}class Ly extends Dr{constructor({logits:te,pred_boxes:$e}){super(),this.logits=te,this.pred_boxes=$e}}class N0 extends Dr{constructor({logits:te,pred_boxes:$e,pred_masks:ar}){super(),this.logits=te,this.pred_boxes=$e,this.pred_masks=ar}}class Ry extends Qe{}class U0 extends Ry{}class jy extends Ry{async _call(te){return new W0(await super._call(te))}}class W0 extends Dr{constructor({logits:te,pred_boxes:$e}){super(),this.logits=te,this.pred_boxes=$e}}class Xh extends Qe{}class zy extends Xh{}class V0 extends Xh{async _call(te){return new G0(await super._call(te))}}class G0 extends Ly{}class Ny extends Qe{}class K0 extends Ny{}class q0 extends Ny{async _call(te){return new Ca(await super._call(te))}}class Uy extends Qe{}class Wy extends Uy{}class H0 extends Uy{async _call(te){return new Ca(await super._call(te))}}class Vy extends Qe{}class X0 extends Vy{}class Hv extends Vy{async _call(te){return new Ca(await super._call(te))}}class Gy extends Qe{}class Y0 extends Gy{}class Gd extends Gy{async _call(te){return new Ca(await super._call(te))}}class Ky extends Qe{}class Q0 extends Ky{}class Z0 extends Ky{}class qy extends Qe{}class J0 extends qy{}class ex extends qy{}class tx extends Qe{}class rx extends tx{}class Om extends Qe{}class nx extends Om{}class Xv extends Om{}class ox extends Om{}class sx extends Qe{}class ix extends sx{}class Hy extends Qe{}class ax extends Hy{}class lx extends Hy{}class ux extends Qe{}class x_ extends ux{}class v_ extends ux{}class T_ extends Qe{}class Xy extends T_{}class c_ extends Qe{}class Ed extends c_{}class Yy extends c_{async _call(te){return new Ca(await super._call(te))}}class K_ extends Qe{}class Qy extends K_{}class dx extends K_{async _call(te){return new Ca(await super._call(te))}}class Zy extends Qe{}class cx extends Zy{}class dg extends Zy{async _call(te){return new Ca(await super._call(te))}}class hg extends Qe{}class px extends hg{}class Rg extends hg{async _call(te){return new _x(await super._call(te))}}class _x extends Dr{constructor({logits:te,pred_boxes:$e}){super(),this.logits=te,this.pred_boxes=$e}}class Jy extends Qe{}class jg extends Jy{async get_image_embeddings({pixel_values:te}){return await Dt(this,{pixel_values:te})}async forward(te){if((!te.image_embeddings||!te.image_positional_embeddings)&&(te={...te,...await this.get_image_embeddings(te)}),!te.input_labels&&te.input_points){const ar=te.input_points.dims.slice(0,-1),rn=ar.reduce((Qr,Qo)=>Qr*Qo,1);te.input_labels=new f.Tensor("int64",new BigInt64Array(rn).fill(1n),ar)}const $e={image_embeddings:te.image_embeddings,image_positional_embeddings:te.image_positional_embeddings};return te.input_points&&($e.input_points=te.input_points),te.input_labels&&($e.input_labels=te.input_labels),te.input_boxes&&($e.input_boxes=te.input_boxes),await et(this.sessions.prompt_encoder_mask_decoder,$e)}async _call(te){return new hx(await super._call(te))}}class hx extends Dr{constructor({iou_scores:te,pred_masks:$e}){super(),this.iou_scores=te,this.pred_masks=$e}}class ew extends Qe{}class Yv extends ew{}class fx extends ew{}class zg extends Qe{}class q_ extends zg{}class mx extends zg{}class p_ extends Qe{}class gx extends p_{}class bx extends p_{async _call(te){return new D_(await super._call(te))}}class yx extends p_{async _call(te){return new Ca(await super._call(te))}}class Qv extends p_{async _call(te){return new _d(await super._call(te))}}class tw extends Qe{}class wx extends tw{}class Zv extends tw{async _call(te){return new _d(await super._call(te))}}class rw extends Qe{}class xx extends rw{}class Wg extends Qe{}class vx extends Wg{}class Tx extends Wg{async _call(te){return new D_(await super._call(te))}}class Vg extends Wg{async _call(te){return new Ca(await super._call(te))}}class H_ extends Qe{}class Kg extends H_{}class nw extends H_{async _call(te){return new D_(await super._call(te))}}class ow extends H_{async _call(te){return new Ca(await super._call(te))}}class Ex extends H_{async _call(te){return new _d(await super._call(te))}}class qg extends Qe{}class sw extends qg{}class Jv extends qg{async _call(te){return new D_(await super._call(te))}}class Mx extends qg{async _call(te){return new Ca(await super._call(te))}}class eT extends Qe{}class tT extends p_{}class Px extends p_{async _call(te){return new D_(await super._call(te))}}class iw extends p_{async _call(te){return new Ca(await super._call(te))}}class X_ extends Qe{}class kx extends X_{}class Ox extends X_{async _call(te){return new D_(await super._call(te))}}class $x extends X_{async _call(te){return new Ca(await super._call(te))}}class aw extends X_{async _call(te){return new Cw(await super._call(te))}}class Ax extends X_{async _call(te){return new _d(await super._call(te))}}class Hg extends Qe{}class rT extends Hg{}class Sx extends Hg{}class Ix extends Hg{async generate_speech(te,$e,{threshold:ar=.5,minlenratio:rn=0,maxlenratio:Qr=20,vocoder:Qo=null}={}){const ea={input_ids:te},{encoder_outputs:_a,encoder_attention_mask:Pa}=await Dt(this,ea),Ja=_a.dims[1]/this.config.reduction_factor,ou=Math.floor(Ja*Qr),ja=Math.floor(Ja*rn),Aa=this.config.num_mel_bins;let fl=[],Za=null,za=null,iu=0;for(;;){++iu;const Eu=_t(!!za);let Ou;za?Ou=za.output_sequence_out:Ou=new f.Tensor("float32",new Float32Array(Aa),[1,1,Aa]);let Iu={use_cache_branch:Eu,output_sequence:Ou,encoder_attention_mask:Pa,speaker_embeddings:$e,encoder_hidden_states:_a};this.addPastKeyValues(Iu,Za),za=await et(this.sessions.decoder_model_merged,Iu),Za=this.getPastKeyValues(za,Za);const{prob:Od,spectrum:E_}=za;if(fl.push(E_),iu>=ja&&(Array.from(Od.data).filter(Zg=>Zg>=ar).length>0||iu>=ou))break}const Fd=(0,f.cat)(fl),{waveform:yd}=await et(Qo.sessions.model,{spectrogram:Fd});return{spectrogram:Fd,waveform:yd}}}class Cx extends Qe{constructor(){super(...arguments);_r(this,"main_input_name","spectrogram")}}class nT extends Qe{}class Dx extends nT{}class lw extends Qe{}class Fx extends lw{}class oT extends lw{}class uw extends Qe{}class Bx extends uw{}class Lx extends uw{}class dw extends Qe{}class Rx extends dw{}class sT extends dw{}class j_ extends Qe{}class Y_ extends j_{}class cw extends j_{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="text_model"),super.from_pretrained(te,$e)}}class jx extends j_{static async from_pretrained(te,$e={}){return $e.model_file_name??($e.model_file_name="audio_model"),super.from_pretrained(te,$e)}}class zx extends Qe{}class pw extends zx{async _call(te){return new Fv(await super._call(te))}}class Xg extends Qe{}class Nx extends Xg{}class Ux extends Xg{}class Wx extends Xg{}class _w extends Qe{}class iT extends _w{}class Vx extends _w{}class Yg extends Qe{}class Gx extends Yg{}class Kx extends Yg{async _call(te){return new Ca(await super._call(te))}}class hw extends Qe{}class KT extends hw{}class aT extends hw{}class fw extends Qe{constructor(){super(...arguments);_r(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask($e){const[ar,rn]=$e.dims,Qr=this.config.decoder.num_codebooks,Qo=rn-Qr;let ea=0;for(let Ja=0;Ja<$e.size;++Ja){if($e.data[Ja]===this.config.decoder.pad_token_id)continue;const ou=Ja%rn,ja=Math.floor(Ja/rn)%Qr,Aa=ou-ja;Aa>0&&Aa<=Qo&&($e.data[ea++]=$e.data[Ja])}const _a=Math.floor(ar/Qr),Pa=ea/(_a*Qr);return new f.Tensor($e.type,$e.data.slice(0,ea),[_a,Qr,Pa])}prepare_inputs_for_generation($e,ar,rn){let Qr=structuredClone($e);for(let ea=0;ea<Qr.length;++ea)for(let _a=0;_a<Qr[ea].length;++_a)ea%this.config.decoder.num_codebooks>=_a&&(Qr[ea][_a]=BigInt(this.config.decoder.pad_token_id));return rn.guidance_scale!==null&&rn.guidance_scale>1&&(Qr=Qr.concat(Qr)),super.prepare_inputs_for_generation(Qr,ar,rn)}async generate($e){const ar=await super.generate($e),rn=this._apply_and_filter_by_delay_pattern_mask(ar).unsqueeze_(0),{audio_values:Qr}=await et(this.sessions.encodec_decode,{audio_codes:rn});return Qr}}class qx extends Qe{}class Hx extends qx{}class Xx extends qx{async _call(te){return new Ca(await super._call(te))}}class mw extends Qe{}class Yx extends mw{}class lT extends mw{async _call(te){return new Ca(await super._call(te))}}class gw extends Qe{}class Qx extends gw{}class Zx extends gw{async _call(te){return new Ca(await super._call(te))}}class bw extends Qe{}class uT extends bw{}class Jx extends bw{async _call(te){return new Ca(await super._call(te))}}class ev extends Qe{}class tv extends ev{}class nu{static async from_pretrained(te,{progress_callback:$e=null,config:ar=null,cache_dir:rn=null,local_files_only:Qr=!1,revision:Qo="main",model_file_name:ea=null,subfolder:_a="onnx",device:Pa=null,dtype:Ja=null,use_external_data_format:ou=null,session_options:ja={}}={}){const Aa={progress_callback:$e,config:ar,cache_dir:rn,local_files_only:Qr,revision:Qo,model_file_name:ea,subfolder:_a,device:Pa,dtype:Ja,use_external_data_format:ou,session_options:ja};if(Aa.config=await s.AutoConfig.from_pretrained(te,Aa),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const fl of this.MODEL_CLASS_MAPPINGS){const Za=fl.get(Aa.config.model_type);if(Za)return await Za[1].from_pretrained(te,Aa)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${Aa.config.model_type}", attempting to construct from base class.`),await Qe.from_pretrained(te,Aa);throw Error(`Unsupported model type: ${Aa.config.model_type}`)}}_r(nu,"MODEL_CLASS_MAPPINGS",null),_r(nu,"BASE_IF_FAIL",!1);const qT=new Map([["bert",["BertModel",Eo]],["nomic_bert",["NomicBertModel",_o]],["roformer",["RoFormerModel",en]],["electra",["ElectraModel",ra]],["esm",["EsmModel",eu]],["convbert",["ConvBertModel",Ye]],["camembert",["CamembertModel",Na]],["deberta",["DebertaModel",Nt]],["deberta-v2",["DebertaV2Model",jo]],["mpnet",["MPNetModel",M_]],["albert",["AlbertModel",a_]],["distilbert",["DistilBertModel",ha]],["roberta",["RobertaModel",Va]],["xlm",["XLMModel",ba]],["xlm-roberta",["XLMRobertaModel",Ga]],["clap",["ClapModel",Y_]],["clip",["CLIPModel",md]],["clipseg",["CLIPSegModel",Ww]],["chinese_clip",["ChineseCLIPModel",Uw]],["siglip",["SiglipModel",r_]],["mobilebert",["MobileBertModel",Bd]],["squeezebert",["SqueezeBertModel",Pd]],["wav2vec2",["Wav2Vec2Model",gx]],["wav2vec2-bert",["Wav2Vec2BertModel",sw]],["unispeech",["UniSpeechModel",vx]],["unispeech-sat",["UniSpeechSatModel",Kg]],["hubert",["HubertModel",tT]],["wavlm",["WavLMModel",kx]],["audio-spectrogram-transformer",["ASTModel",ca]],["vits",["VitsModel",pw]],["pyannote",["PyAnnoteModel",wx]],["wespeaker-resnet",["WeSpeakerResNetModel",xx]],["detr",["DetrModel",j0]],["rt_detr",["RTDetrModel",U0]],["table-transformer",["TableTransformerModel",zy]],["vit",["ViTModel",Kv]],["pvt",["PvtModel",w0]],["vit_msn",["ViTMSNModel",v0]],["vit_mae",["ViTMAEModel",Ha]],["groupvit",["GroupViTModel",M0]],["fastvit",["FastViTModel",P0]],["mobilevit",["MobileViTModel",A0]],["mobilevitv2",["MobileViTV2Model",V_]],["owlvit",["OwlViTModel",C0]],["owlv2",["Owlv2Model",F0]],["beit",["BeitModel",L0]],["deit",["DeiTModel",K0]],["hiera",["HieraModel",Wy]],["convnext",["ConvNextModel",Ed]],["convnextv2",["ConvNextV2Model",Qy]],["dinov2",["Dinov2Model",cx]],["resnet",["ResNetModel",X0]],["swin",["SwinModel",Y0]],["swin2sr",["Swin2SRModel",Q0]],["donut-swin",["DonutSwinModel",Xy]],["yolos",["YolosModel",px]],["dpt",["DPTModel",J0]],["glpn",["GLPNModel",x_]],["hifigan",["SpeechT5HifiGan",Cx]],["efficientnet",["EfficientNetModel",Gx]],["decision_transformer",["DecisionTransformerModel",tv]],["mobilenet_v1",["MobileNetV1Model",Hx]],["mobilenet_v2",["MobileNetV2Model",Yx]],["mobilenet_v3",["MobileNetV3Model",Qx]],["mobilenet_v4",["MobileNetV4Model",uT]],["maskformer",["MaskFormerModel",ax]]]),dT=new Map([["t5",["T5Model",$_]],["longt5",["LongT5Model",w_]],["mt5",["MT5Model",I_]],["bart",["BartModel",we]],["mbart",["MBartModel",tn]],["marian",["MarianModel",Yv]],["whisper",["WhisperModel",be]],["m2m_100",["M2M100Model",q_]],["blenderbot",["BlenderbotModel",va]],["blenderbot-small",["BlenderbotSmallModel",hu]]]),cT=new Map([["bloom",["BloomModel",f0]],["jais",["JAISModel",Kw]],["gpt2",["GPT2Model",Gw]],["gptj",["GPTJModel",Gv]],["gpt_bigcode",["GPTBigCodeModel",Eh]],["gpt_neo",["GPTNeoModel",Hw]],["gpt_neox",["GPTNeoXModel",Yw]],["codegen",["CodeGenModel",Zw]],["llama",["LlamaModel",e0]],["granite",["GraniteModel",r0]],["cohere",["CohereModel",o0]],["gemma",["GemmaModel",s0]],["gemma2",["Gemma2Model",a0]],["openelm",["OpenELMModel",u0]],["qwen2",["Qwen2Model",wy]],["phi",["PhiModel",c0]],["phi3",["Phi3Model",_0]],["mpt",["MptModel",m0]],["opt",["OPTModel",g0]],["mistral",["MistralModel",Fx]],["starcoder2",["Starcoder2Model",Bx]],["falcon",["FalconModel",Rx]],["stablelm",["StableLmModel",iT]]]),yw=new Map([["speecht5",["SpeechT5ForSpeechToText",Sx]],["whisper",["WhisperForConditionalGeneration",wt]]]),rv=new Map([["speecht5",["SpeechT5ForTextToSpeech",Ix]]]),pT=new Map([["vits",["VitsModel",pw]],["musicgen",["MusicgenForConditionalGeneration",fw]]]),kd=new Map([["bert",["BertForSequenceClassification",Yr]],["roformer",["RoFormerForSequenceClassification",Ks]],["electra",["ElectraForSequenceClassification",Jo]],["esm",["EsmForSequenceClassification",Oa]],["convbert",["ConvBertForSequenceClassification",at]],["camembert",["CamembertForSequenceClassification",Ua]],["deberta",["DebertaForSequenceClassification",Oo]],["deberta-v2",["DebertaV2ForSequenceClassification",Yo]],["mpnet",["MPNetForSequenceClassification",P_]],["albert",["AlbertForSequenceClassification",l_]],["distilbert",["DistilBertForSequenceClassification",Wt]],["roberta",["RobertaForSequenceClassification",xd]],["xlm",["XLMForSequenceClassification",fa]],["xlm-roberta",["XLMRobertaForSequenceClassification",La]],["bart",["BartForSequenceClassification",Mt]],["mbart",["MBartForSequenceClassification",Js]],["mobilebert",["MobileBertForSequenceClassification",m_]],["squeezebert",["SqueezeBertForSequenceClassification",Ld]]]),nv=new Map([["bert",["BertForTokenClassification",Ze]],["roformer",["RoFormerForTokenClassification",ni]],["electra",["ElectraForTokenClassification",ia]],["esm",["EsmForTokenClassification",bu]],["convbert",["ConvBertForTokenClassification",Ft]],["camembert",["CamembertForTokenClassification",$u]],["deberta",["DebertaForTokenClassification",tr]],["deberta-v2",["DebertaV2ForTokenClassification",la]],["mpnet",["MPNetForTokenClassification",k_]],["distilbert",["DistilBertForTokenClassification",$o]],["roberta",["RobertaForTokenClassification",wr]],["xlm",["XLMForTokenClassification",Du]],["xlm-roberta",["XLMRobertaForTokenClassification",t_]]]),ww=new Map([["t5",["T5ForConditionalGeneration",A_]],["longt5",["LongT5ForConditionalGeneration",S_]],["mt5",["MT5ForConditionalGeneration",Pt]],["bart",["BartForConditionalGeneration",st]],["mbart",["MBartForConditionalGeneration",Zo]],["marian",["MarianMTModel",fx]],["m2m_100",["M2M100ForConditionalGeneration",mx]],["blenderbot",["BlenderbotForConditionalGeneration",Wa]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",Au]]]),Qg=new Map([["bloom",["BloomForCausalLM",W_]],["gpt2",["GPT2LMHeadModel",Ud]],["jais",["JAISLMHeadModel",qw]],["gptj",["GPTJForCausalLM",Wd]],["gpt_bigcode",["GPTBigCodeForCausalLM",py]],["gpt_neo",["GPTNeoForCausalLM",Xw]],["gpt_neox",["GPTNeoXForCausalLM",Qw]],["codegen",["CodeGenForCausalLM",Jw]],["llama",["LlamaForCausalLM",t0]],["granite",["GraniteForCausalLM",n0]],["cohere",["CohereForCausalLM",Vd]],["gemma",["GemmaForCausalLM",i0]],["gemma2",["Gemma2ForCausalLM",l0]],["openelm",["OpenELMForCausalLM",d0]],["qwen2",["Qwen2ForCausalLM",xy]],["phi",["PhiForCausalLM",Ty]],["phi3",["Phi3ForCausalLM",h0]],["mpt",["MptForCausalLM",Py]],["opt",["OPTForCausalLM",b0]],["mbart",["MBartForCausalLM",Xs]],["mistral",["MistralForCausalLM",oT]],["starcoder2",["Starcoder2ForCausalLM",Lx]],["falcon",["FalconForCausalLM",sT]],["trocr",["TrOCRForCausalLM",Dx]],["stablelm",["StableLmForCausalLM",Vx]]]),ov=new Map([["bert",["BertForMaskedLM",Ao]],["roformer",["RoFormerForMaskedLM",Bo]],["electra",["ElectraForMaskedLM",zo]],["esm",["EsmForMaskedLM",wu]],["convbert",["ConvBertForMaskedLM",le]],["camembert",["CamembertForMaskedLM",Tu]],["deberta",["DebertaForMaskedLM",Lr]],["deberta-v2",["DebertaV2ForMaskedLM",ri]],["mpnet",["MPNetForMaskedLM",s_]],["albert",["AlbertForMaskedLM",ya]],["distilbert",["DistilBertForMaskedLM",ma]],["roberta",["RobertaForMaskedLM",Gu]],["xlm",["XLMWithLMHeadModel",vd]],["xlm-roberta",["XLMRobertaForMaskedLM",qs]],["mobilebert",["MobileBertForMaskedLM",_u]],["squeezebert",["SqueezeBertForMaskedLM",Ad]]]),Q_=new Map([["bert",["BertForQuestionAnswering",er]],["roformer",["RoFormerForQuestionAnswering",ti]],["electra",["ElectraForQuestionAnswering",ii]],["convbert",["ConvBertForQuestionAnswering",ko]],["camembert",["CamembertForQuestionAnswering",So]],["deberta",["DebertaForQuestionAnswering",Po]],["deberta-v2",["DebertaV2ForQuestionAnswering",da]],["mpnet",["MPNetForQuestionAnswering",O_]],["albert",["AlbertForQuestionAnswering",b_]],["distilbert",["DistilBertForQuestionAnswering",Io]],["roberta",["RobertaForQuestionAnswering",Su]],["xlm",["XLMForQuestionAnswering",xu]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Cd]],["mobilebert",["MobileBertForQuestionAnswering",o_]],["squeezebert",["SqueezeBertForQuestionAnswering",g_]]]),xw=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Jt]]]),_T=new Map([["llava",["LlavaForConditionalGeneration",Lo]],["moondream1",["Moondream1ForConditionalGeneration",Xo]],["florence2",["Florence2ForConditionalGeneration",Bu]]]),sv=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Jt]]]),iv=new Map([["vit",["ViTForImageClassification",y0]],["pvt",["PvtForImageClassification",qv]],["vit_msn",["ViTMSNForImageClassification",T0]],["fastvit",["FastViTForImageClassification",k0]],["mobilevit",["MobileViTForImageClassification",S0]],["mobilevitv2",["MobileViTV2ForImageClassification",I0]],["beit",["BeitForImageClassification",R0]],["deit",["DeiTForImageClassification",q0]],["hiera",["HieraForImageClassification",H0]],["convnext",["ConvNextForImageClassification",Yy]],["convnextv2",["ConvNextV2ForImageClassification",dx]],["dinov2",["Dinov2ForImageClassification",dg]],["resnet",["ResNetForImageClassification",Hv]],["swin",["SwinForImageClassification",Gd]],["segformer",["SegformerForImageClassification",Ux]],["efficientnet",["EfficientNetForImageClassification",Kx]],["mobilenet_v1",["MobileNetV1ForImageClassification",Xx]],["mobilenet_v2",["MobileNetV2ForImageClassification",lT]],["mobilenet_v3",["MobileNetV3ForImageClassification",Zx]],["mobilenet_v4",["MobileNetV4ForImageClassification",Jx]]]),av=new Map([["detr",["DetrForObjectDetection",z0]],["rt_detr",["RTDetrForObjectDetection",jy]],["table-transformer",["TableTransformerForObjectDetection",V0]],["yolos",["YolosForObjectDetection",Rg]]]),vw=new Map([["owlvit",["OwlViTForObjectDetection",D0]],["owlv2",["Owlv2ForObjectDetection",B0]]]),lv=new Map([["detr",["DetrForSegmentation",By]],["clipseg",["CLIPSegForImageSegmentation",Vw]]]),uv=new Map([["segformer",["SegformerForSemanticSegmentation",Wx]],["sapiens",["SapiensForSemanticSegmentation",nx]]]),dv=new Map([["detr",["DetrForSegmentation",By]],["maskformer",["MaskFormerForInstanceSegmentation",lx]]]),Tw=new Map([["sam",["SamModel",jg]]]),cv=new Map([["wav2vec2",["Wav2Vec2ForCTC",bx]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Jv]],["unispeech",["UniSpeechForCTC",Tx]],["unispeech-sat",["UniSpeechSatForCTC",nw]],["wavlm",["WavLMForCTC",Ox]],["hubert",["HubertForCTC",Px]]]),pv=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",yx]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Mx]],["unispeech",["UniSpeechForSequenceClassification",Vg]],["unispeech-sat",["UniSpeechSatForSequenceClassification",ow]],["wavlm",["WavLMForSequenceClassification",$x]],["hubert",["HubertForSequenceClassification",iw]],["audio-spectrogram-transformer",["ASTForAudioClassification",C_]]]),Ew=new Map([["wavlm",["WavLMForXVector",aw]]]),_v=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",Ex]],["wavlm",["WavLMForAudioFrameClassification",Ax]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Qv]],["pyannote",["PyAnnoteForAudioFrameClassification",Zv]]]),hT=new Map([["vitmatte",["VitMatteForImageMatting",$0]]]),Mw=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Z0]]]),hv=new Map([["dpt",["DPTForDepthEstimation",ex]],["depth_anything",["DepthAnythingForDepthEstimation",rx]],["glpn",["GLPNForDepthEstimation",v_]],["sapiens",["SapiensForDepthEstimation",Xv]],["depth_pro",["DepthProForDepthEstimation",ix]]]),fv=new Map([["sapiens",["SapiensForNormalEstimation",ox]]]),mv=new Map([["clip",["CLIPVisionModelWithProjection",qa]],["siglip",["SiglipVisionModel",zw]]]),fT=[[qT,Q.EncoderOnly],[dT,Q.EncoderDecoder],[cT,Q.DecoderOnly],[kd,Q.EncoderOnly],[nv,Q.EncoderOnly],[ww,Q.Seq2Seq],[yw,Q.Seq2Seq],[Qg,Q.DecoderOnly],[ov,Q.EncoderOnly],[Q_,Q.EncoderOnly],[xw,Q.Vision2Seq],[_T,Q.ImageTextToText],[iv,Q.EncoderOnly],[lv,Q.EncoderOnly],[dv,Q.EncoderOnly],[uv,Q.EncoderOnly],[hT,Q.EncoderOnly],[Mw,Q.EncoderOnly],[hv,Q.EncoderOnly],[fv,Q.EncoderOnly],[av,Q.EncoderOnly],[vw,Q.EncoderOnly],[Tw,Q.MaskGeneration],[cv,Q.EncoderOnly],[pv,Q.EncoderOnly],[rv,Q.Seq2Seq],[pT,Q.EncoderOnly],[Ew,Q.EncoderOnly],[_v,Q.EncoderOnly],[mv,Q.EncoderOnly]];for(const[C,te]of fT)for(const[$e,ar]of C.values())re.set($e,te),ee.set(ar,$e),se.set($e,ar);const mT=[["MusicgenForConditionalGeneration",fw,Q.Musicgen],["CLIPTextModelWithProjection",Td,Q.EncoderOnly],["SiglipTextModel",U_,Q.EncoderOnly],["ClapTextModelWithProjection",cw,Q.EncoderOnly],["ClapAudioModelWithProjection",jx,Q.EncoderOnly]];for(const[C,te,$e]of mT)re.set(C,$e),ee.set(te,C),se.set(C,te);class Pw extends nu{}_r(Pw,"MODEL_CLASS_MAPPINGS",fT.map(te=>te[0])),_r(Pw,"BASE_IF_FAIL",!0);class gv extends nu{}_r(gv,"MODEL_CLASS_MAPPINGS",[kd]);class gT extends nu{}_r(gT,"MODEL_CLASS_MAPPINGS",[nv]);class bv extends nu{}_r(bv,"MODEL_CLASS_MAPPINGS",[ww]);class yv extends nu{}_r(yv,"MODEL_CLASS_MAPPINGS",[yw]);class wv extends nu{}_r(wv,"MODEL_CLASS_MAPPINGS",[rv]);class xv extends nu{}_r(xv,"MODEL_CLASS_MAPPINGS",[pT]);class vv extends nu{}_r(vv,"MODEL_CLASS_MAPPINGS",[Qg]);class bT extends nu{}_r(bT,"MODEL_CLASS_MAPPINGS",[ov]);class Tv extends nu{}_r(Tv,"MODEL_CLASS_MAPPINGS",[Q_]);class Ev extends nu{}_r(Ev,"MODEL_CLASS_MAPPINGS",[xw]);class Mv extends nu{}_r(Mv,"MODEL_CLASS_MAPPINGS",[iv]);class Pv extends nu{}_r(Pv,"MODEL_CLASS_MAPPINGS",[lv]);class kv extends nu{}_r(kv,"MODEL_CLASS_MAPPINGS",[uv]);class Ov extends nu{}_r(Ov,"MODEL_CLASS_MAPPINGS",[dv]);class $v extends nu{}_r($v,"MODEL_CLASS_MAPPINGS",[av]);class Av extends nu{}_r(Av,"MODEL_CLASS_MAPPINGS",[vw]);class Sv extends nu{}_r(Sv,"MODEL_CLASS_MAPPINGS",[Tw]);class yT extends nu{}_r(yT,"MODEL_CLASS_MAPPINGS",[cv]);class Z_ extends nu{}_r(Z_,"MODEL_CLASS_MAPPINGS",[pv]);class kw extends nu{}_r(kw,"MODEL_CLASS_MAPPINGS",[Ew]);class Ow extends nu{}_r(Ow,"MODEL_CLASS_MAPPINGS",[_v]);class $w extends nu{}_r($w,"MODEL_CLASS_MAPPINGS",[sv]);class Aw extends nu{}_r(Aw,"MODEL_CLASS_MAPPINGS",[hT]);class Iv extends nu{}_r(Iv,"MODEL_CLASS_MAPPINGS",[Mw]);class Cv extends nu{}_r(Cv,"MODEL_CLASS_MAPPINGS",[hv]);class Sw extends nu{}_r(Sw,"MODEL_CLASS_MAPPINGS",[fv]);class Iw extends nu{}_r(Iw,"MODEL_CLASS_MAPPINGS",[mv]);class wT extends Dr{constructor({logits:te,past_key_values:$e,encoder_outputs:ar,decoder_attentions:rn=null,cross_attentions:Qr=null}){super(),this.logits=te,this.past_key_values=$e,this.encoder_outputs=ar,this.decoder_attentions=rn,this.cross_attentions=Qr}}class Ca extends Dr{constructor({logits:te}){super(),this.logits=te}}class Cw extends Dr{constructor({logits:te,embeddings:$e}){super(),this.logits=te,this.embeddings=$e}}class _d extends Dr{constructor({logits:te}){super(),this.logits=te}}class gd extends Dr{constructor({logits:te}){super(),this.logits=te}}class bd extends Dr{constructor({start_logits:te,end_logits:$e}){super(),this.start_logits=te,this.end_logits=$e}}class D_ extends Dr{constructor({logits:te}){super(),this.logits=te}}class xT extends Dr{constructor({logits:te,past_key_values:$e}){super(),this.logits=te,this.past_key_values=$e}}class Dv extends Dr{constructor({alphas:te}){super(),this.alphas=te}}class Fv extends Dr{constructor({waveform:te,spectrogram:$e}){super(),this.waveform=te,this.spectrogram=$e}}},"./src/models/whisper/common_whisper.js":(e,r,i)=>{i.r(r),i.d(r,{WHISPER_LANGUAGE_MAPPING:()=>c,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>n,whisper_language_to_code:()=>a});const s=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],c=new Map(s),n=new Map([...s.map(([h,p])=>[p,h]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function a(h){h=h.toLowerCase();let p=n.get(h);if(p===void 0)if(c.has(h))p=h;else{const u=h.length===2?c.keys():c.values();throw new Error(`Language "${h}" is not supported. Must be one of: ${JSON.stringify(u)}`)}return p}},"./src/models/whisper/generation_whisper.js":(e,r,i)=>{i.r(r),i.d(r,{WhisperGenerationConfig:()=>c});var s=i("./src/generation/configuration_utils.js");class c extends s.GenerationConfig{constructor(){super(...arguments);_r(this,"return_timestamps",null);_r(this,"return_token_timestamps",null);_r(this,"num_frames",null);_r(this,"alignment_heads",null);_r(this,"task",null);_r(this,"language",null);_r(this,"no_timestamps_token_id",null);_r(this,"prompt_ids",null);_r(this,"is_multilingual",null);_r(this,"lang_to_id",null);_r(this,"task_to_id",null);_r(this,"max_initial_timestamp_index",1)}}},"./src/ops/registry.js":(e,r,i)=>{i.r(r),i.d(r,{TensorOpRegistry:()=>a});var s=i("./src/backends/onnx.js"),c=i("./src/utils/tensor.js");const n=async(h,p,t)=>{const u=await(0,s.createInferenceSession)(new Uint8Array(h),p);return async l=>{const f=Object.fromEntries(Object.entries(l).map(([I,R])=>[I,R.ort_tensor])),x=await u.run(f);return Array.isArray(t)?t.map(I=>new c.Tensor(x[I])):new c.Tensor(x[t])}};class a{static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=n([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=n([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=n([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=n([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=n([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=n([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}}_r(a,"session_options",{})},"./src/pipelines.js":(e,r,i)=>{i.r(r),i.d(r,{AudioClassificationPipeline:()=>nt,AutomaticSpeechRecognitionPipeline:()=>_t,DepthEstimationPipeline:()=>Dr,DocumentQuestionAnsweringPipeline:()=>$t,FeatureExtractionPipeline:()=>De,FillMaskPipeline:()=>Q,ImageClassificationPipeline:()=>Dt,ImageFeatureExtractionPipeline:()=>et,ImageSegmentationPipeline:()=>Ge,ImageToImagePipeline:()=>Qe,ImageToTextPipeline:()=>gt,ObjectDetectionPipeline:()=>ct,Pipeline:()=>R,QuestionAnsweringPipeline:()=>K,SummarizationPipeline:()=>se,Text2TextGenerationPipeline:()=>re,TextClassificationPipeline:()=>A,TextGenerationPipeline:()=>X,TextToAudioPipeline:()=>gr,TokenClassificationPipeline:()=>Z,TranslationPipeline:()=>ee,ZeroShotAudioClassificationPipeline:()=>it,ZeroShotClassificationPipeline:()=>Re,ZeroShotImageClassificationPipeline:()=>ge,ZeroShotObjectDetectionPipeline:()=>Ot,pipeline:()=>Eo});var s=i("./src/tokenizers.js"),c=i("./src/models.js"),n=i("./src/processors.js"),a=i("./src/utils/generic.js"),h=i("./src/utils/core.js"),p=i("./src/utils/maths.js"),t=i("./src/utils/audio.js"),u=i("./src/utils/tensor.js"),l=i("./src/utils/image.js");async function f(Yr){return Array.isArray(Yr)||(Yr=[Yr]),await Promise.all(Yr.map(Ze=>l.RawImage.read(Ze)))}async function x(Yr,Ze){return Array.isArray(Yr)||(Yr=[Yr]),await Promise.all(Yr.map(er=>typeof er=="string"||er instanceof URL?(0,t.read_audio)(er,Ze):er instanceof Float64Array?new Float32Array(er):er))}function I(Yr,Ze){Ze&&(Yr=Yr.map(en=>en|0));const[er,Kr,_o,Jr]=Yr;return{xmin:er,ymin:Kr,xmax:_o,ymax:Jr}}class R extends a.Callable{constructor({task:Ze,model:er,tokenizer:Kr=null,processor:_o=null}){super(),this.task=Ze,this.model=er,this.tokenizer=Kr,this.processor=_o}async dispose(){await this.model.dispose()}}class A extends R{constructor(Ze){super(Ze)}async _call(Ze,{top_k:er=1}={}){const Kr=this.tokenizer(Ze,{padding:!0,truncation:!0}),_o=await this.model(Kr),Jr=this.model.config.problem_type==="multi_label_classification"?Ks=>Ks.sigmoid():Ks=>new u.Tensor("float32",(0,p.softmax)(Ks.data),Ks.dims),en=this.model.config.id2label,Bo=[];for(const Ks of _o.logits){const ni=Jr(Ks),ti=await(0,u.topk)(ni,er),oe=ti[0].tolist(),le=ti[1].tolist().map((at,Ft)=>({label:en?en[at]:`LABEL_${at}`,score:oe[Ft]}));er===1?Bo.push(...le):Bo.push(le)}return Array.isArray(Ze)||er===1?Bo:Bo[0]}}class Z extends R{constructor(Ze){super(Ze)}async _call(Ze,{ignore_labels:er=["O"]}={}){const Kr=Array.isArray(Ze),_o=this.tokenizer(Kr?Ze:[Ze],{padding:!0,truncation:!0}),en=(await this.model(_o)).logits,Bo=this.model.config.id2label,Ks=[];for(let ni=0;ni<en.dims[0];++ni){const ti=_o.input_ids[ni],oe=en[ni],Ye=[];for(let le=0;le<oe.dims[0];++le){const at=oe[le],Ft=(0,p.max)(at.data)[1],ko=Bo?Bo[Ft]:`LABEL_${Ft}`;if(er.includes(ko))continue;const _n=this.tokenizer.decode([ti[le].item()],{skip_special_tokens:!0});if(_n==="")continue;const ra=(0,p.softmax)(at.data);Ye.push({entity:ko,score:ra[Ft],index:le,word:_n})}Ks.push(Ye)}return Kr?Ks:Ks[0]}}class K extends R{constructor(Ze){super(Ze)}async _call(Ze,er,{top_k:Kr=1}={}){const _o=this.tokenizer(Ze,{text_pair:er,padding:!0,truncation:!0}),{start_logits:Jr,end_logits:en}=await this.model(_o),Bo=_o.input_ids.tolist(),Ks=_o.attention_mask.tolist(),ni=this.tokenizer.all_special_ids,ti=[];for(let oe=0;oe<Jr.dims[0];++oe){const Ye=Bo[oe],le=Ye.findIndex(zo=>zo==this.tokenizer.sep_token_id);Ks[oe].map((zo,Jo)=>zo==1&&(Jo===0||Jo>le&&ni.findIndex(ia=>ia==Ye[Jo])===-1));const at=Jr[oe].tolist(),Ft=en[oe].tolist();for(let zo=1;zo<at.length;++zo)(Ks[oe]==0||zo<=le||ni.findIndex(Jo=>Jo==Ye[zo])!==-1)&&(at[zo]=-1/0,Ft[zo]=-1/0);const ko=(0,p.softmax)(at).map((zo,Jo)=>[zo,Jo]),_n=(0,p.softmax)(Ft).map((zo,Jo)=>[zo,Jo]);ko[0][0]=0,_n[0][0]=0;const ra=(0,h.product)(ko,_n).filter(zo=>zo[0][1]<=zo[1][1]).map(zo=>[zo[0][1],zo[1][1],zo[0][0]*zo[1][0]]).sort((zo,Jo)=>Jo[2]-zo[2]);for(let zo=0;zo<Math.min(ra.length,Kr);++zo){const[Jo,ia,ii]=ra[zo],Sa=Ye.slice(Jo,ia+1),Na=this.tokenizer.decode(Sa,{skip_special_tokens:!0});ti.push({answer:Na,score:ii})}}return Kr===1?ti[0]:ti}}class Q extends R{constructor(Ze){super(Ze)}async _call(Ze,{top_k:er=5}={}){const Kr=this.tokenizer(Ze,{padding:!0,truncation:!0}),{logits:_o}=await this.model(Kr),Jr=[],en=Kr.input_ids.tolist();for(let Bo=0;Bo<en.length;++Bo){const Ks=en[Bo],ni=Ks.findIndex(at=>at==this.tokenizer.mask_token_id);if(ni===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const ti=_o[Bo][ni],oe=await(0,u.topk)(new u.Tensor("float32",(0,p.softmax)(ti.data),ti.dims),er),Ye=oe[0].tolist(),le=oe[1].tolist();Jr.push(le.map((at,Ft)=>{const ko=Ks.slice();return ko[ni]=at,{score:Ye[Ft],token:Number(at),token_str:this.tokenizer.model.vocab[at],sequence:this.tokenizer.decode(ko,{skip_special_tokens:!0})}}))}return Array.isArray(Ze)?Jr:Jr[0]}}class re extends R{constructor(er){super(er);_r(this,"_key","generated_text")}async _call(er,Kr={}){Array.isArray(er)||(er=[er]),this.model.config.prefix&&(er=er.map(ni=>this.model.config.prefix+ni));const _o=this.model.config.task_specific_params;_o&&_o[this.task]&&_o[this.task].prefix&&(er=er.map(ni=>_o[this.task].prefix+ni));const Jr=this.tokenizer,en={padding:!0,truncation:!0};let Bo;this instanceof ee&&"_build_translation_inputs"in Jr?Bo=Jr._build_translation_inputs(er,en,Kr):Bo=Jr(er,en);const Ks=await this.model.generate({...Bo,...Kr});return Jr.batch_decode(Ks,{skip_special_tokens:!0}).map(ni=>({[this._key]:ni}))}}class se extends re{constructor(er){super(er);_r(this,"_key","summary_text")}}class ee extends re{constructor(er){super(er);_r(this,"_key","translation_text")}}function ce(Yr){return Array.isArray(Yr)&&Yr.every(Ze=>"role"in Ze&&"content"in Ze)}class X extends R{constructor(Ze){super(Ze)}async _call(Ze,er={}){let Kr=!1,_o=!1,Jr;if(typeof Ze=="string")Jr=Ze=[Ze];else if(Array.isArray(Ze)&&Ze.every(le=>typeof le=="string"))Kr=!0,Jr=Ze;else{if(ce(Ze))Ze=[Ze];else if(Array.isArray(Ze)&&Ze.every(ce))Kr=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");_o=!0,Jr=Ze.map(le=>this.tokenizer.apply_chat_template(le,{tokenize:!1,add_generation_prompt:!0}))}const en=er.add_special_tokens??!1,Bo=_o?!1:er.return_full_text??!0;this.tokenizer.padding_side="left";const Ks=this.tokenizer(Jr,{add_special_tokens:en,padding:!0,truncation:!0}),ni=await this.model.generate({...Ks,...er}),ti=this.tokenizer.batch_decode(ni,{skip_special_tokens:!0});let oe;!Bo&&Ks.input_ids.dims.at(-1)>0&&(oe=this.tokenizer.batch_decode(Ks.input_ids,{skip_special_tokens:!0}).map(le=>le.length));const Ye=Array.from({length:Ze.length},le=>[]);for(let le=0;le<ti.length;++le){const at=Math.floor(le/ni.dims[0]*Ze.length);oe&&(ti[le]=ti[le].slice(oe[at])),Ye[at].push({generated_text:_o?[...Ze[at],{role:"assistant",content:ti[le]}]:ti[le]})}return!Kr&&Ye.length===1?Ye[0]:Ye}}class Re extends R{constructor(Ze){super(Ze),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([er,Kr])=>[er.toLowerCase(),Kr])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(Ze,er,{hypothesis_template:Kr="This example is {}.",multi_label:_o=!1}={}){const Jr=Array.isArray(Ze);Jr||(Ze=[Ze]),Array.isArray(er)||(er=[er]);const en=er.map(ni=>Kr.replace("{}",ni)),Bo=_o||er.length===1,Ks=[];for(const ni of Ze){const ti=[];for(const le of en){const at=this.tokenizer(ni,{text_pair:le,padding:!0,truncation:!0}),Ft=await this.model(at);Bo?ti.push([Ft.logits.data[this.contradiction_id],Ft.logits.data[this.entailment_id]]):ti.push(Ft.logits.data[this.entailment_id])}const Ye=(Bo?ti.map(le=>(0,p.softmax)(le)[1]):(0,p.softmax)(ti)).map((le,at)=>[le,at]).sort((le,at)=>at[0]-le[0]);Ks.push({sequence:ni,labels:Ye.map(le=>er[le[1]]),scores:Ye.map(le=>le[0])})}return Jr?Ks:Ks[0]}}class De extends R{constructor(Ze){super(Ze)}async _call(Ze,{pooling:er="none",normalize:Kr=!1,quantize:_o=!1,precision:Jr="binary"}={}){const en=this.tokenizer(Ze,{padding:!0,truncation:!0}),Bo=await this.model(en);let Ks=Bo.last_hidden_state??Bo.logits??Bo.token_embeddings;if(er!=="none")if(er==="mean")Ks=(0,u.mean_pooling)(Ks,en.attention_mask);else if(er==="cls")Ks=Ks.slice(null,0);else throw Error(`Pooling method '${er}' not supported.`);return Kr&&(Ks=Ks.normalize(2,-1)),_o&&(Ks=(0,u.quantize_embeddings)(Ks,Jr)),Ks}}class et extends R{constructor(Ze){super(Ze)}async _call(Ze,{pool:er=null}={}){const Kr=await f(Ze),{pixel_values:_o}=await this.processor(Kr),Jr=await this.model({pixel_values:_o});let en;if(er){if(!("pooler_output"in Jr))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");en=Jr.pooler_output}else en=Jr.last_hidden_state??Jr.logits??Jr.image_embeds;return en}}class nt extends R{constructor(Ze){super(Ze)}async _call(Ze,{top_k:er=5}={}){const Kr=this.processor.feature_extractor.config.sampling_rate,_o=await x(Ze,Kr),Jr=this.model.config.id2label,en=[];for(const Bo of _o){const Ks=await this.processor(Bo),ti=(await this.model(Ks)).logits[0],oe=await(0,u.topk)(new u.Tensor("float32",(0,p.softmax)(ti.data),ti.dims),er),Ye=oe[0].tolist(),at=oe[1].tolist().map((Ft,ko)=>({label:Jr?Jr[Ft]:`LABEL_${Ft}`,score:Ye[ko]}));en.push(at)}return Array.isArray(Ze)?en:en[0]}}class it extends R{constructor(Ze){super(Ze)}async _call(Ze,er,{hypothesis_template:Kr="This is a sound of {}."}={}){const _o=!Array.isArray(Ze);_o&&(Ze=[Ze]);const Jr=er.map(ti=>Kr.replace("{}",ti)),en=this.tokenizer(Jr,{padding:!0,truncation:!0}),Bo=this.processor.feature_extractor.config.sampling_rate,Ks=await x(Ze,Bo),ni=[];for(const ti of Ks){const oe=await this.processor(ti),Ye=await this.model({...en,...oe}),le=(0,p.softmax)(Ye.logits_per_audio.data);ni.push([...le].map((at,Ft)=>({score:at,label:er[Ft]})))}return _o?ni[0]:ni}}class _t extends R{constructor(Ze){super(Ze)}async _call(Ze,er={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(Ze,er);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(Ze,er);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(Ze,er){er.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),er.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const Kr=!Array.isArray(Ze);Kr&&(Ze=[Ze]);const _o=this.processor.feature_extractor.config.sampling_rate,Jr=await x(Ze,_o),en=[];for(const Bo of Jr){const Ks=await this.processor(Bo),ti=(await this.model(Ks)).logits[0],oe=[];for(const le of ti)oe.push((0,p.max)(le.data)[1]);const Ye=this.tokenizer.decode(oe);en.push({text:Ye})}return Kr?en[0]:en}async _call_whisper(Ze,er){const Kr=er.return_timestamps??!1,_o=er.chunk_length_s??0,Jr=er.force_full_sequences??!1;let en=er.stride_length_s??null;const Bo={...er};Kr==="word"&&(Bo.return_token_timestamps=!0,Bo.return_timestamps=!1);const Ks=!Array.isArray(Ze);Ks&&(Ze=[Ze]);const ni=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,ti=this.processor.feature_extractor.config.hop_length,oe=this.processor.feature_extractor.config.sampling_rate,Ye=await x(Ze,oe),le=[];for(const at of Ye){let Ft=[];if(_o>0){if(en===null)en=_o/6;else if(_o<=en)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const ra=oe*_o,zo=oe*en,Jo=ra-2*zo;let ia=0;for(;;){const ii=ia+ra,Sa=at.subarray(ia,ii),Na=await this.processor(Sa),Tu=ia===0,Ua=ii>=at.length;if(Ft.push({stride:[Sa.length,Tu?0:zo,Ua?0:zo],input_features:Na.input_features,is_last:Ua}),Ua)break;ia+=Jo}}else Ft=[{stride:[at.length,0,0],input_features:(await this.processor(at)).input_features,is_last:!0}];for(const ra of Ft){Bo.num_frames=Math.floor(ra.stride[0]/ti);const zo=await this.model.generate({inputs:ra.input_features,...Bo});Kr==="word"?(ra.tokens=zo.sequences.tolist()[0],ra.token_timestamps=zo.token_timestamps.tolist()[0].map(Jo=>(0,p.round)(Jo,2))):ra.tokens=zo[0].tolist(),ra.stride=ra.stride.map(Jo=>Jo/oe)}const[ko,_n]=this.tokenizer._decode_asr(Ft,{time_precision:ni,return_timestamps:Kr,force_full_sequences:Jr});le.push({text:ko,..._n})}return Ks?le[0]:le}}class gt extends R{constructor(Ze){super(Ze)}async _call(Ze,er={}){const Kr=Array.isArray(Ze),_o=await f(Ze),{pixel_values:Jr}=await this.processor(_o),en=[];for(const Bo of Jr){Bo.dims=[1,...Bo.dims];const Ks=await this.model.generate({inputs:Bo,...er}),ni=this.tokenizer.batch_decode(Ks,{skip_special_tokens:!0}).map(ti=>({generated_text:ti.trim()}));en.push(ni)}return Kr?en:en[0]}}class Dt extends R{constructor(Ze){super(Ze)}async _call(Ze,{top_k:er=5}={}){const Kr=await f(Ze),{pixel_values:_o}=await this.processor(Kr),Jr=await this.model({pixel_values:_o}),en=this.model.config.id2label,Bo=[];for(const Ks of Jr.logits){const ni=await(0,u.topk)(new u.Tensor("float32",(0,p.softmax)(Ks.data),Ks.dims),er),ti=ni[0].tolist(),Ye=ni[1].tolist().map((le,at)=>({label:en?en[le]:`LABEL_${le}`,score:ti[at]}));Bo.push(Ye)}return Array.isArray(Ze)?Bo:Bo[0]}}class Ge extends R{constructor(Ze){super(Ze),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(Ze,{threshold:er=.5,mask_threshold:Kr=.5,overlap_mask_area_threshold:_o=.8,label_ids_to_fuse:Jr=null,target_sizes:en=null,subtask:Bo=null}={}){if(Array.isArray(Ze)&&Ze.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const ni=await f(Ze),ti=ni.map(_n=>[_n.height,_n.width]),{pixel_values:oe,pixel_mask:Ye}=await this.processor(ni),le=await this.model({pixel_values:oe,pixel_mask:Ye});let at=null;if(Bo!==null)at=this.subtasks_mapping[Bo];else for(let[_n,ra]of Object.entries(this.subtasks_mapping))if(ra in this.processor.feature_extractor){at=this.processor.feature_extractor[ra].bind(this.processor.feature_extractor),Bo=_n;break}const Ft=this.model.config.id2label,ko=[];if(Bo==="panoptic"||Bo==="instance"){const _n=at(le,er,Kr,_o,Jr,en??ti)[0],ra=_n.segmentation;for(const zo of _n.segments_info){const Jo=new Uint8ClampedArray(ra.data.length);for(let ii=0;ii<ra.data.length;++ii)ra.data[ii]===zo.id&&(Jo[ii]=255);const ia=new l.RawImage(Jo,ra.dims[1],ra.dims[0],1);ko.push({score:zo.score,label:Ft[zo.label_id],mask:ia})}}else if(Bo==="semantic"){const{segmentation:_n,labels:ra}=at(le,en??ti)[0];for(const zo of ra){const Jo=new Uint8ClampedArray(_n.data.length);for(let ii=0;ii<_n.data.length;++ii)_n.data[ii]===zo&&(Jo[ii]=255);const ia=new l.RawImage(Jo,_n.dims[1],_n.dims[0],1);ko.push({score:null,label:Ft[zo],mask:ia})}}else throw Error(`Subtask ${Bo} not supported.`);return ko}}class ge extends R{constructor(Ze){super(Ze)}async _call(Ze,er,{hypothesis_template:Kr="This is a photo of {}"}={}){const _o=Array.isArray(Ze),Jr=await f(Ze),en=er.map(Ye=>Kr.replace("{}",Ye)),Bo=this.tokenizer(en,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:Ks}=await this.processor(Jr),ni=await this.model({...Bo,pixel_values:Ks}),ti=this.model.config.model_type==="siglip"?Ye=>Ye.sigmoid().data:Ye=>(0,p.softmax)(Ye.data),oe=[];for(const Ye of ni.logits_per_image){const at=[...ti(Ye)].map((Ft,ko)=>({score:Ft,label:er[ko]}));at.sort((Ft,ko)=>ko.score-Ft.score),oe.push(at)}return _o?oe:oe[0]}}class ct extends R{constructor(Ze){super(Ze)}async _call(Ze,{threshold:er=.9,percentage:Kr=!1}={}){const _o=Array.isArray(Ze);if(_o&&Ze.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const Jr=await f(Ze),en=Kr?null:Jr.map(le=>[le.height,le.width]),{pixel_values:Bo,pixel_mask:Ks}=await this.processor(Jr),ni=await this.model({pixel_values:Bo,pixel_mask:Ks}),ti=this.processor.feature_extractor.post_process_object_detection(ni,er,en),oe=this.model.config.id2label,Ye=ti.map(le=>le.boxes.map((at,Ft)=>({score:le.scores[Ft],label:oe[le.classes[Ft]],box:I(at,!Kr)})));return _o?Ye:Ye[0]}}class Ot extends R{constructor(Ze){super(Ze)}async _call(Ze,er,{threshold:Kr=.1,top_k:_o=null,percentage:Jr=!1}={}){const en=Array.isArray(Ze),Bo=await f(Ze),Ks=this.tokenizer(er,{padding:!0,truncation:!0}),ni=await this.processor(Bo),ti=[];for(let oe=0;oe<Bo.length;++oe){const Ye=Bo[oe],le=Jr?null:[[Ye.height,Ye.width]],at=ni.pixel_values[oe].unsqueeze_(0),Ft=await this.model({...Ks,pixel_values:at}),ko=this.processor.feature_extractor.post_process_object_detection(Ft,Kr,le,!0)[0];let _n=ko.boxes.map((ra,zo)=>({score:ko.scores[zo],label:er[ko.classes[zo]],box:I(ra,!Jr)})).sort((ra,zo)=>zo.score-ra.score);_o!==null&&(_n=_n.slice(0,_o)),ti.push(_n)}return en?ti:ti[0]}}class $t extends R{constructor(Ze){super(Ze)}async _call(Ze,er,Kr={}){throw new Error("This pipeline is not yet supported in Transformers.js v3.")}}class gr extends R{constructor(er){super(er);_r(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=er.vocoder??null}async _call(er,{speaker_embeddings:Kr=null}={}){return this.processor?this._call_text_to_spectrogram(er,{speaker_embeddings:Kr}):this._call_text_to_waveform(er)}async _call_text_to_waveform(er){const Kr=this.tokenizer(er,{padding:!0,truncation:!0}),{waveform:_o}=await this.model(Kr),Jr=this.model.config.sampling_rate;return{audio:_o.data,sampling_rate:Jr}}async _call_text_to_spectrogram(er,{speaker_embeddings:Kr}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await c.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof Kr=="string"||Kr instanceof URL)&&(Kr=new Float32Array(await(await fetch(Kr)).arrayBuffer())),Kr instanceof Float32Array)Kr=new u.Tensor("float32",Kr,[1,Kr.length]);else if(!(Kr instanceof u.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:_o}=this.tokenizer(er,{padding:!0,truncation:!0}),{waveform:Jr}=await this.model.generate_speech(_o,Kr,{vocoder:this.vocoder}),en=this.processor.feature_extractor.config.sampling_rate;return{audio:Jr.data,sampling_rate:en}}}class Qe extends R{constructor(Ze){super(Ze)}async _call(Ze){const er=await f(Ze),Kr=await this.processor(er),_o=await this.model(Kr),Jr=[];for(const en of _o.reconstruction){const Bo=en.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");Jr.push(l.RawImage.fromTensor(Bo))}return Jr.length>1?Jr:Jr[0]}}class Dr extends R{constructor(Ze){super(Ze)}async _call(Ze){const er=await f(Ze),Kr=await this.processor(er),{predicted_depth:_o}=await this.model(Kr),Jr=[];for(let en=0;en<er.length;++en){const Bo=(0,u.interpolate)(_o[en],er[en].size.reverse(),"bilinear",!1),Ks=Bo.mul_(255/(0,p.max)(Bo.data)[0]).to("uint8");Jr.push({predicted_depth:_o[en],depth:l.RawImage.fromTensor(Ks)})}return Jr.length>1?Jr:Jr[0]}}const vn=Object.freeze({"text-classification":{tokenizer:s.AutoTokenizer,pipeline:A,model:c.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:s.AutoTokenizer,pipeline:Z,model:c.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:s.AutoTokenizer,pipeline:K,model:c.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:s.AutoTokenizer,pipeline:Q,model:c.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:s.AutoTokenizer,pipeline:se,model:c.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:s.AutoTokenizer,pipeline:ee,model:c.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:s.AutoTokenizer,pipeline:re,model:c.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:s.AutoTokenizer,pipeline:X,model:c.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:s.AutoTokenizer,pipeline:Re,model:c.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:nt,model:c.AutoModelForAudioClassification,processor:n.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:s.AutoTokenizer,pipeline:it,model:c.AutoModel,processor:n.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:s.AutoTokenizer,pipeline:_t,model:[c.AutoModelForSpeechSeq2Seq,c.AutoModelForCTC],processor:n.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:s.AutoTokenizer,pipeline:gr,model:[c.AutoModelForTextToWaveform,c.AutoModelForTextToSpectrogram],processor:[n.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:s.AutoTokenizer,pipeline:gt,model:c.AutoModelForVision2Seq,processor:n.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:Dt,model:c.AutoModelForImageClassification,processor:n.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:Ge,model:[c.AutoModelForImageSegmentation,c.AutoModelForSemanticSegmentation,c.AutoModelForUniversalSegmentation],processor:n.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:s.AutoTokenizer,pipeline:ge,model:c.AutoModel,processor:n.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:ct,model:c.AutoModelForObjectDetection,processor:n.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:s.AutoTokenizer,pipeline:Ot,model:c.AutoModelForZeroShotObjectDetection,processor:n.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:s.AutoTokenizer,pipeline:$t,model:c.AutoModelForDocumentQuestionAnswering,processor:n.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:Qe,model:c.AutoModelForImageToImage,processor:n.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Dr,model:c.AutoModelForDepthEstimation,processor:n.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:s.AutoTokenizer,pipeline:De,model:c.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:n.AutoProcessor,pipeline:et,model:[c.AutoModelForImageFeatureExtraction,c.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),vr=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Eo(Yr,Ze=null,{progress_callback:er=null,config:Kr=null,cache_dir:_o=null,local_files_only:Jr=!1,revision:en="main",device:Bo=null,dtype:Ks=null,model_file_name:ni=null,session_options:ti={}}={}){Yr=vr[Yr]??Yr;const oe=vn[Yr.split("_",1)[0]];if(!oe)throw Error(`Unsupported pipeline: ${Yr}. Must be one of [${Object.keys(vn)}]`);Ze||(Ze=oe.default.model,console.log(`No model specified. Using default model: "${Ze}".`));const Ye={progress_callback:er,config:Kr,cache_dir:_o,local_files_only:Jr,revision:en,device:Bo,dtype:Ks,model_file_name:ni,session_options:ti},le=new Map([["tokenizer",oe.tokenizer],["model",oe.model],["processor",oe.processor]]),at=await Ao(le,Ze,Ye);at.task=Yr,(0,h.dispatchCallback)(er,{status:"ready",task:Yr,model:Ze});const Ft=oe.pipeline;return new Ft(at)}async function Ao(Yr,Ze,er){const Kr=Object.create(null),_o=[];for(const[Jr,en]of Yr.entries()){if(!en)continue;let Bo;Array.isArray(en)?Bo=new Promise(async(Ks,ni)=>{var oe,Ye;let ti;for(const le of en){if(le===null){Ks(null);return}try{Ks(await le.from_pretrained(Ze,er));return}catch(at){if((oe=at.message)!=null&&oe.includes("Unsupported model type"))ti=at;else if((Ye=at.message)!=null&&Ye.includes("Could not locate file"))ti=at;else{ni(at);return}}}ni(ti)}):Bo=en.from_pretrained(Ze,er),Kr[Jr]=Bo,_o.push(Bo)}await Promise.all(_o);for(const[Jr,en]of Object.entries(Kr))Kr[Jr]=await en;return Kr}},"./src/processors.js":(e,r,i)=>{i.r(r),i.d(r,{ASTFeatureExtractor:()=>at,AutoProcessor:()=>$u,BeitFeatureExtractor:()=>er,BitImageProcessor:()=>De,CLIPFeatureExtractor:()=>nt,CLIPImageProcessor:()=>it,ChineseCLIPFeatureExtractor:()=>_t,ClapFeatureExtractor:()=>Ft,ConvNextFeatureExtractor:()=>Dt,ConvNextImageProcessor:()=>Ge,DPTFeatureExtractor:()=>X,DPTImageProcessor:()=>Re,DeiTFeatureExtractor:()=>Ze,DetrFeatureExtractor:()=>Jr,DonutFeatureExtractor:()=>Kr,EfficientNetImageProcessor:()=>Ot,FeatureExtractor:()=>Q,Florence2Processor:()=>Ua,GLPNFeatureExtractor:()=>et,ImageFeatureExtractor:()=>re,MaskFormerFeatureExtractor:()=>en,MobileNetV1FeatureExtractor:()=>$t,MobileNetV2FeatureExtractor:()=>gr,MobileNetV3FeatureExtractor:()=>Qe,MobileNetV4FeatureExtractor:()=>Dr,MobileViTFeatureExtractor:()=>vn,MobileViTImageProcessor:()=>vr,NougatImageProcessor:()=>_o,OwlViTFeatureExtractor:()=>Eo,OwlViTProcessor:()=>Tu,Owlv2ImageProcessor:()=>Ao,Processor:()=>zo,PvtImageProcessor:()=>ce,PyAnnoteFeatureExtractor:()=>ko,PyAnnoteProcessor:()=>Sa,RTDetrImageProcessor:()=>Yr,SamImageProcessor:()=>Ks,SamProcessor:()=>Jo,SapiensFeatureExtractor:()=>se,SeamlessM4TFeatureExtractor:()=>le,SegformerFeatureExtractor:()=>ee,SiglipImageProcessor:()=>gt,SpeechT5FeatureExtractor:()=>ra,SpeechT5Processor:()=>Na,Swin2SRImageProcessor:()=>ni,ViTFeatureExtractor:()=>ge,ViTImageProcessor:()=>ct,VitMatteImageProcessor:()=>ti,Wav2Vec2FeatureExtractor:()=>Ye,Wav2Vec2ProcessorWithLM:()=>ii,WeSpeakerFeatureExtractor:()=>_n,WhisperFeatureExtractor:()=>oe,WhisperProcessor:()=>ia,YolosFeatureExtractor:()=>Bo});var s=i("./src/utils/generic.js"),c=i("./src/utils/core.js"),n=i("./src/utils/hub.js"),a=i("./src/utils/maths.js"),h=i("./src/utils/tensor.js");i("./src/utils/image.js");var p=i("./src/utils/audio.js");function t([So,Ie,Nt,Lr]){return[So-Nt/2,Ie-Lr/2,So+Nt/2,Ie+Lr/2]}function u(So,Ie=.5,Nt=null,Lr=!1){const Oo=So.logits,tr=So.pred_boxes,[Po,Ko,jo]=Oo.dims;if(Nt!==null&&Nt.length!==Po)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let ri=[];for(let Yo=0;Yo<Po;++Yo){let la=Nt!==null?Nt[Yo]:null,da={boxes:[],classes:[],scores:[]},na=Oo[Yo],ha=tr[Yo];for(let Wt=0;Wt<Ko;++Wt){let $o=na[Wt],Io=[],ma;if(Lr){ma=$o.sigmoid().data;for(let Ba=0;Ba<ma.length;++Ba)ma[Ba]>Ie&&Io.push(Ba)}else{let Ba=(0,a.max)($o.data)[1];if(Ba===jo-1||(ma=(0,a.softmax)($o.data),ma[Ba]<Ie))continue;Io.push(Ba)}for(const Ba of Io){let eu=ha[Wt].data;eu=t(eu),la!==null&&(eu=eu.map((wu,Oa)=>wu*la[(Oa+1)%2])),da.boxes.push(eu),da.classes.push(Ba),da.scores.push(ma[Ba])}}ri.push(da)}return ri}function l(So,Ie=null){const Nt=So.logits,Lr=Nt.dims[0];if(Ie!==null&&Ie.length!==Lr)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const Oo=[];for(let tr=0;tr<Lr;++tr){const Po=Ie!==null?Ie[tr]:null;let Ko=Nt[tr];Po!==null&&(Ko=(0,h.interpolate)(Ko,Po,"bilinear",!1));const[jo,ri]=Po??Ko.dims.slice(-2),Yo=new h.Tensor("int32",new Int32Array(jo*ri),[jo,ri]),la=Ko[0].data,da=Yo.data;for(let Wt=1;Wt<Ko.dims[0];++Wt){const $o=Ko[Wt].data;for(let Io=0;Io<$o.length;++Io)$o[Io]>la[Io]&&(la[Io]=$o[Io],da[Io]=Wt)}const na=new Array(Ko.dims[0]);for(let Wt=0;Wt<da.length;++Wt){const $o=da[Wt];na[$o]=$o}const ha=na.filter(Wt=>Wt!==void 0);Oo.push({segmentation:Yo,labels:ha})}return Oo}function f(So,Ie,Nt,Lr){const Oo=[],tr=[],Po=[];for(let Ko=0;Ko<So.dims[0];++Ko){const jo=So[Ko],ri=Ie[Ko],Yo=(0,a.max)(jo.data)[1];if(Yo===Lr)continue;const da=(0,a.softmax)(jo.data)[Yo];da>Nt&&(Oo.push(ri),tr.push(da),Po.push(Yo))}return[Oo,tr,Po]}function x(So,Ie,Nt,Lr=.5,Oo=.8){const tr=[];let Po=0,Ko=0;const jo=Ie[Nt].data;for(let Yo=0;Yo<So.length;++Yo)So[Yo]===Nt&&(tr.push(Yo),++Po),jo[Yo]>=Lr&&++Ko;let ri=Po>0&&Ko>0;return ri&&(ri=Po/Ko>Oo),[ri,tr]}function I(So,Ie,Nt,Lr,Oo,tr=null,Po=null){const[Ko,jo]=Po??So[0].dims,ri=new h.Tensor("int32",new Int32Array(Ko*jo),[Ko,jo]),Yo=[];if(Po!==null)for(let Wt=0;Wt<So.length;++Wt)So[Wt]=(0,h.interpolate)(So[Wt],Po,"bilinear",!1);const la=new Int32Array(So[0].data.length),da=new Float32Array(So[0].data.length);for(let Wt=0;Wt<So.length;++Wt){let $o=Ie[Wt];const Io=So[Wt].data;for(let ma=0;ma<Io.length;++ma)Io[ma]*=$o,Io[ma]>da[ma]&&(la[ma]=Wt,da[ma]=Io[ma])}let na=0;const ha=ri.data;for(let Wt=0;Wt<Nt.length;++Wt){const $o=Nt[Wt],[Io,ma]=x(la,So,Wt,Lr,Oo);if(Io){++na;for(const Ba of ma)ha[Ba]=na;Yo.push({id:na,label_id:$o,score:Ie[Wt]})}}return[ri,Yo]}function R(So,Ie=.5,Nt=.5,Lr=.8,Oo=null,tr=null){Oo===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),Oo=new Set);const Po=So.class_queries_logits??So.logits,jo=(So.masks_queries_logits??So.pred_masks).sigmoid();let[ri,Yo,la]=Po.dims;if(la-=1,tr!==null&&tr.length!==ri)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let da=[];for(let na=0;na<ri;++na){let ha=tr!==null?tr[na]:null,Wt=Po[na],$o=jo[na],[Io,ma,Ba]=f(Wt,$o,Ie,la);if(Ba.length===0){let[Oa,bu]=ha??$o.dims.slice(-2),tu=new h.Tensor("int32",new Int32Array(Oa*bu).fill(-1),[Oa,bu]);da.push({segmentation:tu,segments_info:[]});continue}let[eu,wu]=I(Io,ma,Ba,Nt,Lr,Oo,ha);da.push({segmentation:eu,segments_info:wu})}return da}function A(So,Ie){var Nt;if(!(So instanceof Float32Array||So instanceof Float64Array))throw new Error(`${Ie} expects input to be a Float32Array or a Float64Array, but got ${((Nt=So==null?void 0:So.constructor)==null?void 0:Nt.name)??typeof So} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function Z(So,Ie,Nt=0,Lr=null){const Oo=So/Ie;let tr=(0,a.bankers_round)(Oo)*Ie;return Lr!==null&&tr>Lr&&(tr=Math.floor(Oo)*Ie),tr<Nt&&(tr=Math.ceil(Oo)*Ie),tr}function K([So,Ie],Nt){return[Math.max(Math.floor(So/Nt),1)*Nt,Math.max(Math.floor(Ie/Nt),1)*Nt]}class Q extends s.Callable{constructor(Ie){super(),this.config=Ie}}class re extends Q{constructor(Ie){super(Ie),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(Ie,Nt,Lr=2){const Oo=Ie.height,tr=Ie.width,Po=Nt.height,Ko=Nt.width;let jo=Math.min(Oo,Po),ri=Math.min(tr,Ko);return jo===Oo&&ri===tr?Ie:(Oo>tr?ri=Math.floor(tr*jo/Oo):tr>Oo&&(jo=Math.floor(Oo*ri/tr)),await Ie.resize(ri,jo,{resample:Lr}))}async crop_margin(Ie,Nt=200){const Lr=Ie.clone().grayscale(),Oo=(0,a.min)(Lr.data)[0],Po=(0,a.max)(Lr.data)[0]-Oo;if(Po===0)return Ie;const Ko=Nt/255;let jo=Lr.width,ri=Lr.height,Yo=0,la=0;const da=Lr.data;for(let na=0;na<Lr.height;++na){const ha=na*Lr.width;for(let Wt=0;Wt<Lr.width;++Wt)(da[ha+Wt]-Oo)/Po<Ko&&(jo=Math.min(jo,Wt),ri=Math.min(ri,na),Yo=Math.max(Yo,Wt),la=Math.max(la,na))}return Ie=await Ie.crop([jo,ri,Yo,la]),Ie}pad_image(Ie,Nt,Lr,{mode:Oo="constant",center:tr=!1,constant_values:Po=0}={}){const[Ko,jo,ri]=Nt;let Yo,la;if(typeof Lr=="number"?(Yo=Lr,la=Lr):(Yo=Lr.width,la=Lr.height),Yo!==jo||la!==Ko){const da=new Float32Array(Yo*la*ri);if(Array.isArray(Po))for(let Wt=0;Wt<da.length;++Wt)da[Wt]=Po[Wt%ri];else Po!==0&&da.fill(Po);const[na,ha]=tr?[Math.floor((Yo-jo)/2),Math.floor((la-Ko)/2)]:[0,0];for(let Wt=0;Wt<Ko;++Wt){const $o=(Wt+ha)*Yo,Io=Wt*jo;for(let ma=0;ma<jo;++ma){const Ba=($o+ma+na)*ri,eu=(Io+ma)*ri;for(let wu=0;wu<ri;++wu)da[Ba+wu]=Ie[eu+wu]}}if(Oo==="symmetric"){if(tr)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const Wt=Ko-1,$o=jo-1;for(let Io=0;Io<la;++Io){const ma=Io*Yo,Ba=(0,c.calculateReflectOffset)(Io,Wt)*jo;for(let eu=0;eu<Yo;++eu){if(Io<Ko&&eu<jo)continue;const wu=(ma+eu)*ri,Oa=(Ba+(0,c.calculateReflectOffset)(eu,$o))*ri;for(let bu=0;bu<ri;++bu)da[wu+bu]=Ie[Oa+bu]}}}Ie=da,Nt=[la,Yo,ri]}return[Ie,Nt]}rescale(Ie){for(let Nt=0;Nt<Ie.length;++Nt)Ie[Nt]=this.rescale_factor*Ie[Nt]}get_resize_output_image_size(Ie,Nt){const[Lr,Oo]=Ie.size;let tr,Po;if(this.do_thumbnail){const{height:Ko,width:jo}=Nt;tr=Math.min(Ko,jo)}else Number.isInteger(Nt)?(tr=Nt,Po=this.config.max_size??tr):Nt!==void 0&&(tr=Nt.shortest_edge,Po=Nt.longest_edge);if(tr!==void 0||Po!==void 0){const Ko=tr===void 0?1:Math.max(tr/Lr,tr/Oo),jo=Lr*Ko,ri=Oo*Ko,Yo=Po===void 0?1:Math.min(Po/jo,Po/ri);let la=Math.floor(Number((jo*Yo).toFixed(2))),da=Math.floor(Number((ri*Yo).toFixed(2)));return this.size_divisibility!==void 0&&([la,da]=K([la,da],this.size_divisibility)),[la,da]}else if(Nt!==void 0&&Nt.width!==void 0&&Nt.height!==void 0){let Ko=Nt.width,jo=Nt.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let ri=jo/Oo,Yo=Ko/Lr;Math.abs(1-Yo)<Math.abs(1-ri)?ri=Yo:Yo=ri,jo=Z(ri*Oo,this.config.ensure_multiple_of),Ko=Z(Yo*Lr,this.config.ensure_multiple_of)}return[Ko,jo]}else{if(this.size_divisibility!==void 0)return K([Lr,Oo],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(Nt)}`)}}async resize(Ie){const[Nt,Lr]=this.get_resize_output_image_size(Ie,this.size);return await Ie.resize(Nt,Lr,{resample:this.resample})}async preprocess(Ie,{do_normalize:Nt=null,do_pad:Lr=null,do_convert_rgb:Oo=null,do_convert_grayscale:tr=null,do_flip_channel_order:Po=null}={}){this.do_crop_margin&&(Ie=await this.crop_margin(Ie));const[Ko,jo]=Ie.size;if(Oo??this.do_convert_rgb?Ie=Ie.rgb():tr&&(Ie=Ie.grayscale()),this.do_resize&&(Ie=await this.resize(Ie)),this.do_thumbnail&&(Ie=await this.thumbnail(Ie,this.size,this.resample)),this.do_center_crop){let na,ha;Number.isInteger(this.crop_size)?(na=this.crop_size,ha=this.crop_size):(na=this.crop_size.width,ha=this.crop_size.height),Ie=await Ie.center_crop(na,ha)}const ri=[Ie.height,Ie.width];let Yo=Float32Array.from(Ie.data),la=[Ie.height,Ie.width,Ie.channels];if(this.do_rescale&&this.rescale(Yo),Nt??this.do_normalize){let na=this.image_mean;Array.isArray(this.image_mean)||(na=new Array(Ie.channels).fill(na));let ha=this.image_std;if(Array.isArray(this.image_std)||(ha=new Array(Ie.channels).fill(na)),na.length!==Ie.channels||ha.length!==Ie.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${na.length}) and \`image_std\` (${ha.length}) must match the number of channels in the image (${Ie.channels}).`);for(let Wt=0;Wt<Yo.length;Wt+=Ie.channels)for(let $o=0;$o<Ie.channels;++$o)Yo[Wt+$o]=(Yo[Wt+$o]-na[$o])/ha[$o]}if(Lr??this.do_pad){if(this.pad_size)[Yo,la]=this.pad_image(Yo,[Ie.height,Ie.width,Ie.channels],this.pad_size);else if(this.size_divisibility){const[na,ha]=K([la[1],la[0]],this.size_divisibility);[Yo,la]=this.pad_image(Yo,la,{width:na,height:ha})}}if(Po??this.do_flip_channel_order){if(la[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let na=0;na<Yo.length;na+=3){const ha=Yo[na];Yo[na]=Yo[na+2],Yo[na+2]=ha}}const da=new h.Tensor("float32",Yo,la).permute(2,0,1);return{original_size:[jo,Ko],reshaped_input_size:ri,pixel_values:da}}async _call(Ie,...Nt){Array.isArray(Ie)||(Ie=[Ie]);const Lr=await Promise.all(Ie.map(tr=>this.preprocess(tr)));return{pixel_values:(0,h.stack)(Lr.map(tr=>tr.pixel_values),0),original_sizes:Lr.map(tr=>tr.original_size),reshaped_input_sizes:Lr.map(tr=>tr.reshaped_input_size)}}}class se extends re{post_process_semantic_segmentation(...Ie){return l(...Ie)}}class ee extends re{post_process_semantic_segmentation(...Ie){return l(...Ie)}}class ce extends re{}class X extends re{}class Re extends X{}class De extends re{}class et extends re{}class nt extends re{}class it extends nt{}class _t extends re{}class gt extends re{}class Dt extends re{constructor(Ie){super(Ie),this.crop_pct=this.config.crop_pct??224/256}async resize(Ie){var Lr;const Nt=(Lr=this.size)==null?void 0:Lr.shortest_edge;if(Nt===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(Nt<384){const Oo=Math.floor(Nt/this.crop_pct),[tr,Po]=this.get_resize_output_image_size(Ie,{shortest_edge:Oo});Ie=await Ie.resize(tr,Po,{resample:this.resample}),Ie=await Ie.center_crop(Nt,Nt)}else Ie=await Ie.resize(Nt,Nt,{resample:this.resample});return Ie}}class Ge extends Dt{}class ge extends re{}class ct extends re{}class Ot extends re{constructor(Ie){super(Ie),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(Nt=>Nt*Nt))}}class $t extends re{}class gr extends re{}class Qe extends re{}class Dr extends re{}class vn extends re{}class vr extends vn{}class Eo extends re{post_process_object_detection(...Ie){return u(...Ie)}}class Ao extends Eo{}class Yr extends re{post_process_object_detection(...Ie){return u(...Ie)}}class Ze extends re{}class er extends re{}class Kr extends re{pad_image(Ie,Nt,Lr,Oo={}){const[tr,Po,Ko]=Nt;let jo=this.image_mean;Array.isArray(this.image_mean)||(jo=new Array(Ko).fill(jo));let ri=this.image_std;Array.isArray(ri)||(ri=new Array(Ko).fill(jo));const Yo=jo.map((la,da)=>-la/ri[da]);return super.pad_image(Ie,Nt,Lr,{center:!0,constant_values:Yo,...Oo})}}class _o extends Kr{}class Jr extends re{async _call(Ie){const Nt=await super._call(Ie),Lr=[Nt.pixel_values.dims[0],64,64],Oo=(0,h.full)(Lr,1n);return{...Nt,pixel_mask:Oo}}post_process_object_detection(...Ie){return u(...Ie)}post_process_panoptic_segmentation(...Ie){return R(...Ie)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class en extends re{post_process_panoptic_segmentation(...Ie){return R(...Ie)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class Bo extends re{post_process_object_detection(...Ie){return u(...Ie)}}class Ks extends re{reshape_input_points(Ie,Nt,Lr,Oo=!1){Ie=structuredClone(Ie);let tr=(0,c.calculateDimensions)(Ie);if(tr.length===3)Oo||(tr=[1,...tr]),Ie=[Ie];else if(tr.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let Po=0;Po<Ie.length;++Po){let Ko=Nt[Po],jo=Lr[Po],ri=[jo[0]/Ko[0],jo[1]/Ko[1]];for(let Yo=0;Yo<Ie[Po].length;++Yo)for(let la=0;la<Ie[Po][Yo].length;++la)for(let da=0;da<Ie[Po][Yo][la].length;++da)Ie[Po][Yo][la][da]*=ri[da%2]}return new h.Tensor("float32",Float32Array.from(Ie.flat(1/0)),tr)}add_input_labels(Ie,Nt){let Lr=(0,c.calculateDimensions)(Ie);if(Lr.length===2)Lr=[1,...Lr],Ie=[Ie];else if(Lr.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(Lr.some((Oo,tr)=>Oo!==Nt.dims[tr]))throw Error(`The first ${Lr.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new h.Tensor("int64",Ie.flat(1/0).map(BigInt),Lr)}async _call(Ie,{input_points:Nt=null,input_labels:Lr=null,input_boxes:Oo=null}={}){const tr=await super._call(Ie);if(Nt&&(tr.input_points=this.reshape_input_points(Nt,tr.original_sizes,tr.reshaped_input_sizes)),Lr){if(!tr.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");tr.input_labels=this.add_input_labels(Lr,tr.input_points)}return Oo&&(tr.input_boxes=this.reshape_input_points(Oo,tr.original_sizes,tr.reshaped_input_sizes,!0)),tr}async post_process_masks(Ie,Nt,Lr,{mask_threshold:Oo=0,binarize:tr=!0,pad_size:Po=null}={}){const Ko=[];Po=Po??this.pad_size;const jo=[Po.height,Po.width];for(let ri=0;ri<Nt.length;++ri){const Yo=Nt[ri],la=Lr[ri];let da=await(0,h.interpolate_4d)(Ie[ri],{mode:"bilinear",size:jo});if(da=da.slice(null,null,[0,la[0]],[0,la[1]]),da=await(0,h.interpolate_4d)(da,{mode:"bilinear",size:Yo}),tr){const na=da.data,ha=new Uint8Array(na.length);for(let Wt=0;Wt<na.length;++Wt)na[Wt]>Oo&&(ha[Wt]=1);da=new h.Tensor("bool",ha,da.dims)}Ko.push(da)}return Ko}generate_crop_boxes(Ie,Nt,{crop_n_layers:Lr=0,overlap_ratio:Oo=512/1500,points_per_crop:tr=32,crop_n_points_downscale_factor:Po=1}={}){}}class ni extends re{pad_image(Ie,Nt,Lr,Oo={}){const[tr,Po,Ko]=Nt;return super.pad_image(Ie,Nt,{width:Po+(Lr-Po%Lr)%Lr,height:tr+(Lr-tr%Lr)%Lr},{mode:"symmetric",center:!1,constant_values:-1,...Oo})}}class ti extends re{async _call(Ie,Nt){Array.isArray(Ie)||(Ie=[Ie]),Array.isArray(Nt)||(Nt=[Nt]);const Lr=await Promise.all(Ie.map(Po=>this.preprocess(Po))),Oo=await Promise.all(Nt.map(Po=>this.preprocess(Po,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,h.stack)(Lr.map((Po,Ko)=>(0,h.cat)([Po.pixel_values,Oo[Ko].pixel_values],0)),0),original_sizes:Lr.map(Po=>Po.original_size),reshaped_input_sizes:Lr.map(Po=>Po.reshaped_input_size)}}}class oe extends Q{constructor(Ie){var Nt;super(Ie),(Nt=this.config).mel_filters??(Nt.mel_filters=(0,p.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,p.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(Ie){const Nt=await(0,p.spectrogram)(Ie,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),Lr=Nt.data,Oo=(0,a.max)(Lr)[0];for(let tr=0;tr<Lr.length;++tr)Lr[tr]=(Math.max(Lr[tr],Oo-8)+4)/4;return Nt}async _call(Ie){A(Ie,"WhisperFeatureExtractor");let Nt;return Ie.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),Nt=Ie.slice(0,this.config.n_samples)):(Nt=new Float32Array(this.config.n_samples),Nt.set(Ie)),{input_features:(await this._extract_fbank_features(Nt)).unsqueeze_(0)}}}class Ye extends Q{_zero_mean_unit_var_norm(Ie){const Lr=Ie.reduce((tr,Po)=>tr+Po,0)/Ie.length,Oo=Ie.reduce((tr,Po)=>tr+(Po-Lr)**2,0)/Ie.length;return Ie.map(tr=>(tr-Lr)/Math.sqrt(Oo+1e-7))}async _call(Ie){A(Ie,"Wav2Vec2FeatureExtractor"),Ie instanceof Float64Array&&(Ie=new Float32Array(Ie));let Nt=Ie;this.config.do_normalize&&(Nt=this._zero_mean_unit_var_norm(Nt));const Lr=[1,Nt.length];return{input_values:new h.Tensor("float32",Nt,Lr),attention_mask:new h.Tensor("int64",new BigInt64Array(Nt.length).fill(1n),Lr)}}}class le extends Q{constructor(Ie){super(Ie);const Nt=this.config.sampling_rate,Lr=(0,p.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Nt/2),Nt,null,"kaldi",!0);for(let Oo=0;Oo<Lr.length;++Oo)Lr[Oo].push(0);this.mel_filters=Lr,this.window=(0,p.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(Ie,Nt){return Ie=Ie.map(Lr=>Lr*32768),(0,p.spectrogram)(Ie,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Nt,transpose:!0})}async _call(Ie,{padding:Nt=!0,pad_to_multiple_of:Lr=2,do_normalize_per_mel_bins:Oo=!0,return_attention_mask:tr=!0}={}){A(Ie,"SeamlessM4TFeatureExtractor");let Po=await this._extract_fbank_features(Ie,this.config.max_length);if(Oo){const[ha,Wt]=Po.dims,$o=Po.data;for(let Io=0;Io<Wt;++Io){let ma=0;for(let Oa=0;Oa<ha;++Oa)ma+=$o[Oa*Wt+Io];const Ba=ma/ha;let eu=0;for(let Oa=0;Oa<ha;++Oa)eu+=($o[Oa*Wt+Io]-Ba)**2;eu/=ha-1;const wu=Math.sqrt(eu+1e-7);for(let Oa=0;Oa<ha;++Oa){const bu=Oa*Wt+Io;$o[bu]=($o[bu]-Ba)/wu}}}let Ko;if(Nt){const[ha,Wt]=Po.dims,$o=Po.data,Io=ha%Lr;if(Io>0){const ma=new Float32Array(Wt*(ha+Io));ma.set($o),ma.fill(this.config.padding_value,$o.length);const Ba=ha+Io;Po=new h.Tensor(Po.type,ma,[Ba,Wt]),tr&&(Ko=new h.Tensor("int64",new BigInt64Array(Ba),[1,Ba]),Ko.data.fill(1n,0,ha))}}const[jo,ri]=Po.dims,Yo=this.config.stride;if(jo%Yo!==0)throw new Error(`The number of frames (${jo}) must be a multiple of the stride (${Yo}).`);const da=Po.view(1,Math.floor(jo/Yo),ri*Yo),na={input_features:da};if(tr){const ha=da.dims[1],Wt=new BigInt64Array(ha);if(Ko){const $o=Ko.data;for(let Io=1,ma=0;Io<jo;Io+=Yo,++ma)Wt[ma]=$o[Io]}else Wt.fill(1n);na.attention_mask=new h.Tensor("int64",Wt,[1,ha])}return na}}class at extends Q{constructor(Ie){super(Ie);const Nt=this.config.sampling_rate,Lr=(0,p.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Nt/2),Nt,null,"kaldi",!0);for(let Oo=0;Oo<Lr.length;++Oo)Lr[Oo].push(0);this.mel_filters=Lr,this.window=(0,p.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(Ie,Nt){return(0,p.spectrogram)(Ie,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Nt,transpose:!0})}async _call(Ie){A(Ie,"ASTFeatureExtractor");const Nt=await this._extract_fbank_features(Ie,this.config.max_length);if(this.config.do_normalize){const Lr=this.std*2,Oo=Nt.data;for(let tr=0;tr<Oo.length;++tr)Oo[tr]=(Oo[tr]-this.mean)/Lr}return{input_values:Nt.unsqueeze_(0)}}}class Ft extends Q{constructor(Ie){super(Ie),this.mel_filters=(0,p.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,p.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,p.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(Ie,Nt,Lr,Oo){let tr;const Po=Ie.length-Nt;if(Po>0)if(Lr==="rand_trunc"){const Ko=Math.floor(Math.random()*(Po+1));Ie=Ie.subarray(Ko,Ko+Nt),tr=await this._extract_fbank_features(Ie,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${Lr}" not implemented`);else{if(Po<0){let Ko=new Float64Array(Nt);if(Ko.set(Ie),Oo==="repeat")for(let jo=Ie.length;jo<Nt;jo+=Ie.length)Ko.set(Ie.subarray(0,Math.min(Ie.length,Nt-jo)),jo);else if(Oo==="repeatpad")for(let jo=Ie.length;jo<-Po;jo+=Ie.length)Ko.set(Ie,jo);Ie=Ko}if(Lr==="fusion")throw new Error(`Truncation strategy "${Lr}" not implemented`);tr=await this._extract_fbank_features(Ie,this.mel_filters_slaney,this.config.nb_max_samples)}return tr.unsqueeze_(0)}async _extract_fbank_features(Ie,Nt,Lr=null){return(0,p.spectrogram)(Ie,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:Nt,log_mel:"dB",max_num_frames:Lr,do_pad:!1,transpose:!0})}async _call(Ie,{max_length:Nt=null}={}){return A(Ie,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(Ie,Nt??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class ko extends Q{async _call(Ie){A(Ie,"PyAnnoteFeatureExtractor"),Ie instanceof Float64Array&&(Ie=new Float32Array(Ie));const Nt=[1,1,Ie.length];return{input_values:new h.Tensor("float32",Ie,Nt)}}samples_to_frames(Ie){return(Ie-this.config.offset)/this.config.step}post_process_speaker_diarization(Ie,Nt){const Lr=Nt/this.samples_to_frames(Nt)/this.config.sampling_rate,Oo=[];for(const tr of Ie.tolist()){const Po=[];let Ko=-1;for(let jo=0;jo<tr.length;++jo){const ri=(0,a.softmax)(tr[jo]),[Yo,la]=(0,a.max)(ri),[da,na]=[jo,jo+1];la!==Ko?(Ko=la,Po.push({id:la,start:da,end:na,score:Yo})):(Po.at(-1).end=na,Po.at(-1).score+=Yo)}Oo.push(Po.map(({id:jo,start:ri,end:Yo,score:la})=>({id:jo,start:ri*Lr,end:Yo*Lr,confidence:la/(Yo-ri)})))}return Oo}}class _n extends Q{constructor(Ie){super(Ie);const Nt=this.config.sampling_rate,Lr=(0,p.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Nt/2),Nt,null,"kaldi",!0);for(let Oo=0;Oo<Lr.length;++Oo)Lr[Oo].push(0);this.mel_filters=Lr,this.window=(0,p.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(Ie){return Ie=Ie.map(Nt=>Nt*32768),(0,p.spectrogram)(Ie,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(Ie){A(Ie,"WeSpeakerFeatureExtractor");const Nt=(await this._extract_fbank_features(Ie)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const Lr=Nt.mean(1).data,Oo=Nt.data,[tr,Po,Ko]=Nt.dims;for(let jo=0;jo<tr;++jo){const ri=jo*Po*Ko,Yo=jo*Ko;for(let la=0;la<Po;++la){const da=ri+la*Ko;for(let na=0;na<Ko;++na)Oo[da+na]-=Lr[Yo+na]}}}return{input_features:Nt}}}class ra extends Q{}class zo extends s.Callable{constructor(Ie){super(),this.feature_extractor=Ie}async _call(Ie,...Nt){return await this.feature_extractor(Ie,...Nt)}}class Jo extends zo{async _call(...Ie){return await this.feature_extractor(...Ie)}post_process_masks(...Ie){return this.feature_extractor.post_process_masks(...Ie)}reshape_input_points(...Ie){return this.feature_extractor.reshape_input_points(...Ie)}}class ia extends zo{async _call(Ie){return await this.feature_extractor(Ie)}}class ii extends zo{async _call(Ie){return await this.feature_extractor(Ie)}}class Sa extends zo{async _call(Ie){return await this.feature_extractor(Ie)}post_process_speaker_diarization(...Ie){return this.feature_extractor.post_process_speaker_diarization(...Ie)}}class Na extends zo{async _call(Ie){return await this.feature_extractor(Ie)}}class Tu extends zo{}class Ua extends zo{constructor(Ie){super(Ie);const{tasks_answer_post_processing_type:Nt,task_prompts_without_inputs:Lr,task_prompts_with_input:Oo}=Ie.config;this.tasks_answer_post_processing_type=new Map(Object.entries(Nt??{})),this.task_prompts_without_inputs=new Map(Object.entries(Lr??{})),this.task_prompts_with_input=new Map(Object.entries(Oo??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(Ie){typeof Ie=="string"&&(Ie=[Ie]);const Nt=[];for(const Lr of Ie)if(this.task_prompts_without_inputs.has(Lr))Nt.push(this.task_prompts_without_inputs.get(Lr));else{for(const[Oo,tr]of this.task_prompts_with_input)if(Lr.includes(Oo)){Nt.push(tr.replaceAll("{input}",Lr).replaceAll(Oo,""));break}Nt.length!==Ie.length&&Nt.push(Lr)}return Nt}post_process_generation(Ie,Nt,Lr){const Oo=this.tasks_answer_post_processing_type.get(Nt)??"pure_text";Ie=Ie.replaceAll("<s>","").replaceAll("</s>","");let tr;switch(Oo){case"pure_text":tr=Ie;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const Po=Oo==="ocr"?"quad_boxes":"bboxes",Ko=Ie.matchAll(this.regexes[Po]),jo=[],ri=[];for(const[Yo,la,...da]of Ko)jo.push(la?la.trim():jo.at(-1)??""),ri.push(da.map((na,ha)=>(Number(na)+.5)/this.size_per_bin*Lr[ha%2]));tr={labels:jo,[Po]:ri};break;default:throw new Error(`Task "${Nt}" (of type "${Oo}") not yet implemented.`)}return{[Nt]:tr}}}class $u{static async from_pretrained(Ie,{progress_callback:Nt=null,config:Lr=null,cache_dir:Oo=null,local_files_only:tr=!1,revision:Po="main"}={}){let Ko=Lr??await(0,n.getModelJSON)(Ie,"preprocessor_config.json",!0,{progress_callback:Nt,config:Lr,cache_dir:Oo,local_files_only:tr,revision:Po}),jo=Ko.feature_extractor_type??Ko.image_processor_type,ri=this.FEATURE_EXTRACTOR_CLASS_MAPPING[jo];if(!ri)if(Ko.size!==void 0)console.warn(`Feature extractor type "${jo}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),ri=re;else throw new Error(`Unknown Feature Extractor type: ${jo}`);let Yo=this.PROCESSOR_CLASS_MAPPING[Ko.processor_class]??zo,la=new ri(Ko);return new Yo(la)}}_r($u,"FEATURE_EXTRACTOR_CLASS_MAPPING",{ImageFeatureExtractor:re,WhisperFeatureExtractor:oe,ViTFeatureExtractor:ge,MobileViTFeatureExtractor:vn,MobileViTImageProcessor:vr,MobileNetV1FeatureExtractor:$t,MobileNetV2FeatureExtractor:gr,MobileNetV3FeatureExtractor:Qe,MobileNetV4FeatureExtractor:Dr,OwlViTFeatureExtractor:Eo,Owlv2ImageProcessor:Ao,CLIPFeatureExtractor:nt,CLIPImageProcessor:it,Florence2Processor:Ua,ChineseCLIPFeatureExtractor:_t,SiglipImageProcessor:gt,ConvNextFeatureExtractor:Dt,ConvNextImageProcessor:Ge,SegformerFeatureExtractor:ee,SapiensFeatureExtractor:se,BitImageProcessor:De,DPTImageProcessor:Re,DPTFeatureExtractor:X,PvtImageProcessor:ce,GLPNFeatureExtractor:et,BeitFeatureExtractor:er,DeiTFeatureExtractor:Ze,DetrFeatureExtractor:Jr,RTDetrImageProcessor:Yr,MaskFormerFeatureExtractor:en,YolosFeatureExtractor:Bo,DonutFeatureExtractor:Kr,NougatImageProcessor:_o,EfficientNetImageProcessor:Ot,ViTImageProcessor:ct,VitMatteImageProcessor:ti,SamImageProcessor:Ks,Swin2SRImageProcessor:ni,Wav2Vec2FeatureExtractor:Ye,SeamlessM4TFeatureExtractor:le,SpeechT5FeatureExtractor:ra,ASTFeatureExtractor:at,ClapFeatureExtractor:Ft,PyAnnoteFeatureExtractor:ko,WeSpeakerFeatureExtractor:_n}),_r($u,"PROCESSOR_CLASS_MAPPING",{WhisperProcessor:ia,Wav2Vec2ProcessorWithLM:ii,PyAnnoteProcessor:Sa,SamProcessor:Jo,SpeechT5Processor:Na,OwlViTProcessor:Tu,Florence2Processor:Ua})},"./src/tokenizers.js":(e,r,i)=>{i.r(r),i.d(r,{AlbertTokenizer:()=>Ko,AutoTokenizer:()=>I_,BartTokenizer:()=>wu,BertTokenizer:()=>Po,BlenderbotSmallTokenizer:()=>A_,BlenderbotTokenizer:()=>$_,BloomTokenizer:()=>Bd,CLIPTokenizer:()=>l_,CamembertTokenizer:()=>$o,CodeGenTokenizer:()=>a_,CodeLlamaTokenizer:()=>o_,CohereTokenizer:()=>d_,ConvBertTokenizer:()=>na,DebertaTokenizer:()=>Yo,DebertaV2Tokenizer:()=>la,DistilBertTokenizer:()=>Wt,ElectraTokenizer:()=>ma,EsmTokenizer:()=>k_,FalconTokenizer:()=>s_,GPT2Tokenizer:()=>eu,GPTNeoXTokenizer:()=>P_,GemmaTokenizer:()=>i_,Grok1Tokenizer:()=>Pd,HerbertTokenizer:()=>da,LlamaTokenizer:()=>m_,M2M100Tokenizer:()=>g_,MBart50Tokenizer:()=>bu,MBartTokenizer:()=>Oa,MPNetTokenizer:()=>M_,MarianTokenizer:()=>ya,MobileBertTokenizer:()=>jo,NllbTokenizer:()=>Ld,NougatTokenizer:()=>w_,PreTrainedTokenizer:()=>tr,Qwen2Tokenizer:()=>O_,RoFormerTokenizer:()=>ha,RobertaTokenizer:()=>tu,SiglipTokenizer:()=>b_,SpeechT5Tokenizer:()=>y_,SqueezeBertTokenizer:()=>ri,T5Tokenizer:()=>Ba,TokenizerModel:()=>et,VitsTokenizer:()=>S_,Wav2Vec2CTCTokenizer:()=>u_,WhisperTokenizer:()=>Rd,XLMRobertaTokenizer:()=>Id,XLMTokenizer:()=>Io,is_chinese_char:()=>Q});var s=i("./src/utils/generic.js"),c=i("./src/utils/core.js"),n=i("./src/utils/hub.js"),a=i("./src/utils/maths.js"),h=i("./src/utils/tensor.js"),p=i("./src/utils/data-structures.js"),t=i("./node_modules/@huggingface/jinja/dist/index.js"),u=i("./src/models/whisper/common_whisper.js");i("./src/utils/constants.js");async function l(Pt,L){const we=await Promise.all([(0,n.getModelJSON)(Pt,"tokenizer.json",!0,L),(0,n.getModelJSON)(Pt,"tokenizer_config.json",!0,L)]);return L.legacy!==null&&(we[1].legacy=L.legacy),we}function f(Pt,L){const we=[];let st=0;for(const Mt of Pt.matchAll(L)){const Lt=Mt[0];st<Mt.index&&we.push(Pt.slice(st,Mt.index)),Lt.length>0&&we.push(Lt),st=Mt.index+Lt.length}return st<Pt.length&&we.push(Pt.slice(st)),we}function x(Pt,L=!0){if(Pt.Regex!==void 0){let we=Pt.Regex.replace(/\\([#&~])/g,"$1");for(const[st,Mt]of Re)we=we.replaceAll(st,Mt);return new RegExp(we,"gu")}else if(Pt.String!==void 0){const we=(0,c.escapeRegExp)(Pt.String);return new RegExp(L?we:`(${we})`,"gu")}else return console.warn("Unknown pattern type:",Pt),null}function I(Pt){return new Map(Object.entries(Pt))}function R(Pt){const L=Pt.dims;switch(L.length){case 1:return Pt.tolist();case 2:if(L[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Pt.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${L.length}.`)}}function A(Pt){return Pt.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function Z(Pt){return Pt.replace(new RegExp("\\p{M}","gu"),"")}function K(Pt){return Z(Pt.toLowerCase())}function Q(Pt){return Pt>=19968&&Pt<=40959||Pt>=13312&&Pt<=19903||Pt>=131072&&Pt<=173791||Pt>=173824&&Pt<=177983||Pt>=177984&&Pt<=178207||Pt>=178208&&Pt<=183983||Pt>=63744&&Pt<=64255||Pt>=194560&&Pt<=195103}function re(Pt,L,we){const st=[];let Mt=0;for(;Mt<Pt.length;){if(st.push(Pt[Mt]),(L.get(Pt[Mt])??we)!==we){++Mt;continue}for(;++Mt<Pt.length&&(L.get(Pt[Mt])??we)===we;)L.get(st.at(-1))!==we&&(st[st.length-1]+=Pt[Mt])}return st}function se(Pt){return Pt.match(/\S+/g)||[]}const ee="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",ce=new RegExp(`^[${ee}]+$`,"gu"),X=".,!?",Re=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${X}])]+`,` ?[^\\s${X}]+`]]);class De{constructor(L){this.content=L.content,this.id=L.id,this.single_word=L.single_word??!1,this.lstrip=L.lstrip??!1,this.rstrip=L.rstrip??!1,this.special=L.special??!1,this.normalized=L.normalized??null}}class et extends s.Callable{constructor(L){super(),this.config=L,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(L,...we){switch(L.type){case"WordPiece":return new nt(L);case"Unigram":return new it(L,...we);case"BPE":return new Dt(L);default:if(L.vocab)return Array.isArray(L.vocab)?new it(L,...we):new Ge(L,...we);throw new Error(`Unknown TokenizerModel type: ${L.type}`)}}_call(L){return L=this.encode(L),this.fuse_unk&&(L=re(L,this.tokens_to_ids,this.unk_token_id)),L}encode(L){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(L){return L.map(we=>this.tokens_to_ids.get(we)??this.unk_token_id)}convert_ids_to_tokens(L){return L.map(we=>this.vocab[we]??this.unk_token)}}class nt extends et{constructor(L){super(L),this.tokens_to_ids=I(L.vocab),this.unk_token_id=this.tokens_to_ids.get(L.unk_token),this.unk_token=L.unk_token,this.max_input_chars_per_word=L.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[we,st]of this.tokens_to_ids)this.vocab[st]=we}encode(L){const we=[];for(const st of L){const Mt=[...st];if(Mt.length>this.max_input_chars_per_word){we.push(this.unk_token);continue}let Lt=!1,tn=0;const Zo=[];for(;tn<Mt.length;){let Js=Mt.length,Xs=null;for(;tn<Js;){let oa=Mt.slice(tn,Js).join("");if(tn>0&&(oa=this.config.continuing_subword_prefix+oa),this.tokens_to_ids.has(oa)){Xs=oa;break}--Js}if(Xs===null){Lt=!0;break}Zo.push(Xs),tn=Js}Lt?we.push(this.unk_token):we.push(...Zo)}return we}}class it extends et{constructor(L,we){super(L);const st=L.vocab.length;this.vocab=new Array(st),this.scores=new Array(st);for(let Mt=0;Mt<st;++Mt){const Lt=L.vocab[Mt];this.vocab[Mt]=Lt[0],this.scores[Mt]=Lt[1]}this.unk_token_id=L.unk_id,this.unk_token=this.vocab[L.unk_id],this.tokens_to_ids=new Map(this.vocab.map((Mt,Lt)=>[Mt,Lt])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=we.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,a.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new p.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(L){const we=L.chars,st=1;let Mt=0;for(;Mt<we.length;){let Lt=!1;const tn=we.slice(Mt).join(""),Zo=this.trie.commonPrefixSearch(tn);for(const Js of Zo){const Xs=this.tokens_to_ids.get(Js),oa=this.scores[Xs],va=(0,c.len)(Js);L.insert(Mt,va,oa,Xs),!Lt&&va===st&&(Lt=!0)}Lt||L.insert(Mt,st,this.unk_score,this.unk_token_id),Mt+=st}}tokenize(L){const we=new p.TokenLattice(L,this.bos_token_id,this.eos_token_id);return this.populateNodes(we),we.tokens()}encode(L){const we=[];for(const st of L){const Mt=this.tokenize(st);we.push(...Mt)}return we}}const _t=(()=>{const Pt=[...Array.from({length:94},(Mt,Lt)=>Lt+33),...Array.from({length:12},(Mt,Lt)=>Lt+161),...Array.from({length:82},(Mt,Lt)=>Lt+174)],L=Pt.slice();let we=0;for(let Mt=0;Mt<256;++Mt)Pt.includes(Mt)||(Pt.push(Mt),L.push(256+we),we+=1);const st=L.map(Mt=>String.fromCharCode(Mt));return Object.fromEntries(Pt.map((Mt,Lt)=>[Mt,st[Lt]]))})(),gt=(0,c.reverseDictionary)(_t);class Dt extends et{constructor(L){super(L),this.tokens_to_ids=I(L.vocab),this.unk_token_id=this.tokens_to_ids.get(L.unk_token),this.unk_token=L.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[st,Mt]of this.tokens_to_ids)this.vocab[Mt]=st;const we=Array.isArray(L.merges[0]);this.merges=we?L.merges:L.merges.map(st=>st.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((st,Mt)=>[JSON.stringify(st),Mt])),this.end_of_word_suffix=L.end_of_word_suffix,this.continuing_subword_suffix=L.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(L){if(L.length===0)return[];const we=this.cache.get(L);if(we!==void 0)return we;const st=Array.from(L);this.end_of_word_suffix&&(st[st.length-1]+=this.end_of_word_suffix);let Mt=[];if(st.length>1){const Lt=new p.PriorityQueue((Js,Xs)=>Js.score<Xs.score);let tn={token:st[0],bias:0,prev:null,next:null},Zo=tn;for(let Js=1;Js<st.length;++Js){const Xs={bias:Js/st.length,token:st[Js],prev:Zo,next:null};Zo.next=Xs,this._add_node(Lt,Zo),Zo=Xs}for(;!Lt.isEmpty();){const Js=Lt.pop();if(Js.deleted||!Js.next||Js.next.deleted)continue;if(Js.deleted=!0,Js.next.deleted=!0,Js.prev){const oa={...Js.prev};Js.prev.deleted=!0,Js.prev=oa,oa.prev?oa.prev.next=oa:tn=oa}const Xs={token:Js.token+Js.next.token,bias:Js.bias,prev:Js.prev,next:Js.next.next};Xs.prev?(Xs.prev.next=Xs,this._add_node(Lt,Xs.prev)):tn=Xs,Xs.next&&(Xs.next.prev=Xs,this._add_node(Lt,Xs))}for(let Js=tn;Js!==null;Js=Js.next)Mt.push(Js.token)}else Mt=st;if(this.continuing_subword_suffix)for(let Lt=0;Lt<Mt.length-1;++Lt)Mt[Lt]+=this.continuing_subword_suffix;return this.cache.set(L,Mt),Mt}_add_node(L,we){const st=this.bpe_ranks.get(JSON.stringify([we.token,we.next.token]));st!==void 0&&(we.score=st+we.bias,L.push(we))}encode(L){const we=[];for(const st of L){if(this.ignore_merges&&this.tokens_to_ids.has(st)){we.push(st);continue}const Mt=this.bpe(st);for(const Lt of Mt)if(this.tokens_to_ids.has(Lt))we.push(Lt);else if(this.byte_fallback){const tn=Array.from(this.text_encoder.encode(Lt)).map(Zo=>`<0x${Zo.toString(16).toUpperCase().padStart(2,"0")}>`);tn.every(Zo=>this.tokens_to_ids.has(Zo))?we.push(...tn):we.push(this.unk_token)}else we.push(this.unk_token)}return we}}class Ge extends et{constructor(L,we){super(L),this.tokens_to_ids=I(we.target_lang?L.vocab[we.target_lang]:L.vocab),this.bos_token=we.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=we.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=we.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=we.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[st,Mt]of this.tokens_to_ids)this.vocab[Mt]=st}encode(L){return L}}class ge extends s.Callable{constructor(L){super(),this.config=L}static fromConfig(L){if(L===null)return null;switch(L.type){case"BertNormalizer":return new Ao(L);case"Precompiled":return new Tu(L);case"Sequence":return new Eo(L);case"Replace":return new ct(L);case"NFC":return new Ot(L);case"NFKC":return new $t(L);case"NFKD":return new gr(L);case"Strip":return new Qe(L);case"StripAccents":return new Dr(L);case"Lowercase":return new vn(L);case"Prepend":return new vr(L);default:throw new Error(`Unknown Normalizer type: ${L.type}`)}}normalize(L){throw Error("normalize should be implemented in subclass.")}_call(L){return this.normalize(L)}}class ct extends ge{normalize(L){const we=x(this.config.pattern);return we===null?L:L.replaceAll(we,this.config.content)}}class Ot extends ge{normalize(L){return L=L.normalize("NFC"),L}}class $t extends ge{normalize(L){return L=L.normalize("NFKC"),L}}class gr extends ge{normalize(L){return L=L.normalize("NFKD"),L}}class Qe extends ge{normalize(L){return this.config.strip_left&&this.config.strip_right?L=L.trim():(this.config.strip_left&&(L=L.trimStart()),this.config.strip_right&&(L=L.trimEnd())),L}}class Dr extends ge{normalize(L){return L=Z(L),L}}class vn extends ge{normalize(L){return L=L.toLowerCase(),L}}class vr extends ge{normalize(L){return L=this.config.prepend+L,L}}class Eo extends ge{constructor(L){super(L),this.normalizers=L.normalizers.map(we=>ge.fromConfig(we))}normalize(L){return this.normalizers.reduce((we,st)=>st.normalize(we),L)}}class Ao extends ge{_tokenize_chinese_chars(L){const we=[];for(let st=0;st<L.length;++st){const Mt=L[st],Lt=Mt.charCodeAt(0);Q(Lt)?(we.push(" "),we.push(Mt),we.push(" ")):we.push(Mt)}return we.join("")}stripAccents(L){return L.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(L){switch(L){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(L)}}_clean_text(L){const we=[];for(const st of L){const Mt=st.charCodeAt(0);Mt===0||Mt===65533||this._is_control(st)||(/^\s$/.test(st)?we.push(" "):we.push(st))}return we.join("")}normalize(L){return this.config.clean_text&&(L=this._clean_text(L)),this.config.handle_chinese_chars&&(L=this._tokenize_chinese_chars(L)),this.config.lowercase?(L=L.toLowerCase(),this.config.strip_accents!==!1&&(L=this.stripAccents(L))):this.config.strip_accents&&(L=this.stripAccents(L)),L}}class Yr extends s.Callable{static fromConfig(L){if(L===null)return null;switch(L.type){case"BertPreTokenizer":return new Ze(L);case"Sequence":return new Ua(L);case"Whitespace":return new $u(L);case"WhitespaceSplit":return new So(L);case"Metaspace":return new Sa(L);case"ByteLevel":return new er(L);case"Split":return new Kr(L);case"Punctuation":return new _o(L);case"Digits":return new Jr(L);case"Replace":return new Ie(L);default:throw new Error(`Unknown PreTokenizer type: ${L.type}`)}}pre_tokenize_text(L,we){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(L,we){return(Array.isArray(L)?L.map(st=>this.pre_tokenize_text(st,we)):this.pre_tokenize_text(L,we)).flat()}_call(L,we){return this.pre_tokenize(L,we)}}class Ze extends Yr{constructor(L){super(),this.pattern=new RegExp(`[^\\s${ee}]+|[${ee}]`,"gu")}pre_tokenize_text(L,we){return L.trim().match(this.pattern)||[]}}class er extends Yr{constructor(L){super(),this.config=L,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=_t,this.text_encoder=new TextEncoder}pre_tokenize_text(L,we){return this.add_prefix_space&&!L.startsWith(" ")&&(L=" "+L),(this.use_regex?L.match(this.pattern)||[]:[L]).map(Mt=>Array.from(this.text_encoder.encode(Mt),Lt=>this.byte_encoder[Lt]).join(""))}}class Kr extends Yr{constructor(L){super(),this.config=L,this.pattern=x(this.config.pattern,this.config.invert)}pre_tokenize_text(L,we){return this.pattern===null?[]:this.config.invert?L.match(this.pattern)||[]:f(L,this.pattern)}}class _o extends Yr{constructor(L){super(),this.config=L,this.pattern=new RegExp(`[^${ee}]+|[${ee}]+`,"gu")}pre_tokenize_text(L,we){return L.match(this.pattern)||[]}}class Jr extends Yr{constructor(L){super(),this.config=L;const we=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(we,"gu")}pre_tokenize_text(L,we){return L.match(this.pattern)||[]}}class en extends s.Callable{constructor(L){super(),this.config=L}static fromConfig(L){if(L===null)return null;switch(L.type){case"TemplateProcessing":return new ni(L);case"ByteLevel":return new ti(L);case"RobertaProcessing":return new Ks(L);case"BertProcessing":return new Bo(L);case"Sequence":return new oe(L);default:throw new Error(`Unknown PostProcessor type: ${L.type}`)}}post_process(L,...we){throw Error("post_process should be implemented in subclass.")}_call(L,...we){return this.post_process(L,...we)}}class Bo extends en{constructor(L){super(L),this.cls=L.cls[0],this.sep=L.sep[0]}post_process(L,we=null,{add_special_tokens:st=!0}={}){st&&(L=(0,c.mergeArrays)([this.cls],L,[this.sep]));let Mt=new Array(L.length).fill(0);if(we!==null){const Lt=st&&this instanceof Ks?[this.sep]:[],tn=st?[this.sep]:[];L=(0,c.mergeArrays)(L,Lt,we,tn),Mt=(0,c.mergeArrays)(Mt,new Array(we.length+Lt.length+tn.length).fill(1))}return{tokens:L,token_type_ids:Mt}}}class Ks extends Bo{}class ni extends en{constructor(L){super(L),this.single=L.single,this.pair=L.pair}post_process(L,we=null,{add_special_tokens:st=!0}={}){const Mt=we===null?this.single:this.pair;let Lt=[],tn=[];for(const Zo of Mt)"SpecialToken"in Zo?st&&(Lt.push(Zo.SpecialToken.id),tn.push(Zo.SpecialToken.type_id)):"Sequence"in Zo&&(Zo.Sequence.id==="A"?(Lt=(0,c.mergeArrays)(Lt,L),tn=(0,c.mergeArrays)(tn,new Array(L.length).fill(Zo.Sequence.type_id))):Zo.Sequence.id==="B"&&(Lt=(0,c.mergeArrays)(Lt,we),tn=(0,c.mergeArrays)(tn,new Array(we.length).fill(Zo.Sequence.type_id))));return{tokens:Lt,token_type_ids:tn}}}class ti extends en{post_process(L,we=null){return we&&(L=(0,c.mergeArrays)(L,we)),{tokens:L}}}class oe extends en{constructor(L){super(L),this.processors=L.processors.map(we=>en.fromConfig(we))}post_process(L,we=null,st={}){let Mt;for(const Lt of this.processors)if(Lt instanceof ti)L=Lt.post_process(L).tokens,we&&(we=Lt.post_process(we).tokens);else{const tn=Lt.post_process(L,we,st);L=tn.tokens,Mt=tn.token_type_ids}return{tokens:L,token_type_ids:Mt}}}class Ye extends s.Callable{constructor(L){super(),this.config=L,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=L.trim_offsets}static fromConfig(L){if(L===null)return null;switch(L.type){case"WordPiece":return new _n(L);case"Metaspace":return new Na(L);case"ByteLevel":return new ra(L);case"Replace":return new le(L);case"ByteFallback":return new at(L);case"Fuse":return new Ft(L);case"Strip":return new ko(L);case"Sequence":return new Jo(L);case"CTC":return new zo(L);case"BPEDecoder":return new ia(L);default:throw new Error(`Unknown Decoder type: ${L.type}`)}}_call(L){return this.decode(L)}decode(L){return this.decode_chain(L).join("")}decode_chain(L){throw Error("`decode_chain` should be implemented in subclass.")}}class le extends Ye{decode_chain(L){const we=x(this.config.pattern);return we===null?L:L.map(st=>st.replaceAll(we,this.config.content))}}class at extends Ye{constructor(L){super(L),this.text_decoder=new TextDecoder}decode_chain(L){const we=[];let st=[];for(const Mt of L){let Lt=null;if(Mt.length===6&&Mt.startsWith("<0x")&&Mt.endsWith(">")){const tn=parseInt(Mt.slice(3,5),16);isNaN(tn)||(Lt=tn)}if(Lt!==null)st.push(Lt);else{if(st.length>0){const tn=this.text_decoder.decode(Uint8Array.from(st));we.push(tn),st=[]}we.push(Mt)}}if(st.length>0){const Mt=this.text_decoder.decode(Uint8Array.from(st));we.push(Mt),st=[]}return we}}class Ft extends Ye{decode_chain(L){return[L.join("")]}}class ko extends Ye{constructor(L){super(L),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(L){return L.map(we=>{let st=0;for(let Lt=0;Lt<this.start&&we[Lt]===this.content;++Lt){st=Lt+1;continue}let Mt=we.length;for(let Lt=0;Lt<this.stop;++Lt){const tn=we.length-Lt-1;if(we[tn]===this.content){Mt=tn;continue}else break}return we.slice(st,Mt)})}}class _n extends Ye{constructor(L){super(L),this.cleanup=L.cleanup}decode_chain(L){return L.map((we,st)=>(st!==0&&(we.startsWith(this.config.prefix)?we=we.replace(this.config.prefix,""):we=" "+we),this.cleanup&&(we=A(we)),we))}}class ra extends Ye{constructor(L){super(L),this.byte_decoder=gt,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(L){const we=L.join(""),st=new Uint8Array([...we].map(Lt=>this.byte_decoder[Lt]));return this.text_decoder.decode(st)}decode_chain(L){const we=[];let st=[];for(const Mt of L)this.added_tokens.find(Lt=>Lt.content===Mt)!==void 0?(st.length>0&&(we.push(this.convert_tokens_to_string(st)),st=[]),we.push(Mt)):st.push(Mt);return st.length>0&&we.push(this.convert_tokens_to_string(st)),we}}class zo extends Ye{constructor(L){super(L),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(L){if(L.length===0)return"";const we=[L[0]];for(let Lt=1;Lt<L.length;++Lt)L[Lt]!==we.at(-1)&&we.push(L[Lt]);let Mt=we.filter(Lt=>Lt!==this.pad_token).join("");return this.cleanup&&(Mt=A(Mt).replaceAll(this.word_delimiter_token," ").trim()),Mt}decode_chain(L){return[this.convert_tokens_to_string(L)]}}class Jo extends Ye{constructor(L){super(L),this.decoders=L.decoders.map(we=>Ye.fromConfig(we))}decode_chain(L){return this.decoders.reduce((we,st)=>st.decode_chain(we),L)}}class ia extends Ye{constructor(L){super(L),this.suffix=this.config.suffix}decode_chain(L){return L.map((we,st)=>we.replaceAll(this.suffix,st===L.length-1?"":" "))}}class ii extends Ye{decode_chain(L){let we="";for(let st=1;st<L.length;st+=2)we+=L[st];return[we]}}class Sa extends Yr{constructor(L){super(),this.addPrefixSpace=L.add_prefix_space,this.replacement=L.replacement,this.strRep=L.str_rep||this.replacement,this.prepend_scheme=L.prepend_scheme??"always"}pre_tokenize_text(L,{section_index:we=void 0}={}){let st=L.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!st.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&we===0)&&(st=this.strRep+st),[st]}}class Na extends Ye{constructor(L){super(L),this.addPrefixSpace=L.add_prefix_space,this.replacement=L.replacement}decode_chain(L){const we=[];for(let st=0;st<L.length;++st){let Mt=L[st].replaceAll(this.replacement," ");this.addPrefixSpace&&st==0&&Mt.startsWith(" ")&&(Mt=Mt.substring(1)),we.push(Mt)}return we}}class Tu extends ge{constructor(L){super(L),this.charsmap=L.precompiled_charsmap}normalize(L){return L=L.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),L=L.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),L.includes("")?L=L.split("").map(st=>st.normalize("NFKC")).join(""):L=L.normalize("NFKC"),L}}class Ua extends Yr{constructor(L){super(),this.tokenizers=L.pretokenizers.map(we=>Yr.fromConfig(we))}pre_tokenize_text(L,we){return this.tokenizers.reduce((st,Mt)=>Mt.pre_tokenize(st,we),[L])}}class $u extends Yr{constructor(L){super()}pre_tokenize_text(L,we){return L.match(/\w+|[^\w\s]+/g)||[]}}class So extends Yr{constructor(L){super()}pre_tokenize_text(L,we){return se(L)}}class Ie extends Yr{constructor(L){super(),this.config=L,this.pattern=x(this.config.pattern),this.content=this.config.content}pre_tokenize_text(L,we){return this.pattern===null?[L]:[L.replaceAll(this.pattern,this.config.content)]}}const Nt=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Lr(Pt,L,we,st){for(const Mt of Object.keys(Pt)){const Lt=L-Pt[Mt].length,tn=we(Mt),Zo=new Array(Lt).fill(tn);Pt[Mt]=st==="right"?(0,c.mergeArrays)(Pt[Mt],Zo):(0,c.mergeArrays)(Zo,Pt[Mt])}}function Oo(Pt,L){for(const we of Object.keys(Pt))Pt[we].length=L}class tr extends s.Callable{constructor(we,st){super();_r(this,"return_token_type_ids",!1);_r(this,"padding_side","right");this._tokenizer_config=st,this.normalizer=ge.fromConfig(we.normalizer),this.pre_tokenizer=Yr.fromConfig(we.pre_tokenizer),this.model=et.fromConfig(we.model,st),this.post_processor=en.fromConfig(we.post_processor),this.decoder=Ye.fromConfig(we.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Mt of we.added_tokens){const Lt=new De(Mt);this.added_tokens.push(Lt),this.model.tokens_to_ids.set(Lt.content,Lt.id),this.model.vocab[Lt.id]=Lt.content,Lt.special&&(this.special_tokens.push(Lt.content),this.all_special_ids.push(Lt.id))}if(this.additional_special_tokens=st.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort((Mt,Lt)=>Lt.content.length-Mt.content.length).map(Mt=>`${Mt.lstrip?"\\s*":""}(${(0,c.escapeRegExp)(Mt.content)})${Mt.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=st.model_max_length,this.remove_space=st.remove_space,this.clean_up_tokenization_spaces=st.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=st.do_lowercase_and_remove_accent??!1,st.padding_side&&(this.padding_side=st.padding_side),this.legacy=!1,this.chat_template=st.chat_template??null,Array.isArray(this.chat_template)){const Mt=Object.create(null);for(const{name:Lt,template:tn}of this.chat_template){if(typeof Lt!="string"||typeof tn!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Mt[Lt]=tn}this.chat_template=Mt}this._compiled_template_cache=new Map}getToken(...we){for(const st of we){const Mt=this._tokenizer_config[st];if(Mt)if(typeof Mt=="object"){if(Mt.__type==="AddedToken")return Mt.content;throw Error(`Unknown token: ${Mt}`)}else return Mt}return null}static async from_pretrained(we,{progress_callback:st=null,config:Mt=null,cache_dir:Lt=null,local_files_only:tn=!1,revision:Zo="main",legacy:Js=null}={}){const Xs=await l(we,{progress_callback:st,config:Mt,cache_dir:Lt,local_files_only:tn,revision:Zo,legacy:Js});return new this(...Xs)}_call(we,{text_pair:st=null,add_special_tokens:Mt=!0,padding:Lt=!1,truncation:tn=null,max_length:Zo=null,return_tensor:Js=!0,return_token_type_ids:Xs=null}={}){const oa=Array.isArray(we);let va;if(oa){if(we.length===0)throw Error("text array must be non-empty");if(st!==null){if(Array.isArray(st)){if(we.length!==st.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");va=we.map(($a,hu)=>this._encode_plus($a,{text_pair:st[hu],add_special_tokens:Mt,return_token_type_ids:Xs}))}else va=we.map($a=>this._encode_plus($a,{add_special_tokens:Mt,return_token_type_ids:Xs}))}else{if(we==null)throw Error("text may not be null or undefined");if(Array.isArray(st))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");va=[this._encode_plus(we,{text_pair:st,add_special_tokens:Mt,return_token_type_ids:Xs})]}if(Zo===null?Lt==="max_length"?Zo=this.model_max_length:Zo=(0,a.max)(va.map($a=>$a.input_ids.length))[0]:tn||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),Zo=Math.min(Zo,this.model_max_length??1/0),Lt||tn)for(let $a=0;$a<va.length;++$a)va[$a].input_ids.length!==Zo&&(va[$a].input_ids.length>Zo?tn&&Oo(va[$a],Zo):Lt&&Lr(va[$a],Zo,hu=>hu==="input_ids"?this.pad_token_id:0,this.padding_side));const Wa={};if(Js){if(!(Lt&&tn)&&va.some(hu=>{var Au;for(const ka of Object.keys(hu))if(hu[ka].length!==((Au=va[0][ka])==null?void 0:Au.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const $a=[va.length,va[0].input_ids.length];for(const hu of Object.keys(va[0]))Wa[hu]=new h.Tensor("int64",BigInt64Array.from(va.flatMap(Au=>Au[hu]).map(BigInt)),$a)}else{for(const $a of Object.keys(va[0]))Wa[$a]=va.map(hu=>hu[$a]);if(!oa)for(const $a of Object.keys(Wa))Wa[$a]=Wa[$a][0]}return Wa}_encode_text(we){return we===null?null:(this.added_tokens_regex?we.split(this.added_tokens_regex).filter(Lt=>Lt):[we]).map((Lt,tn)=>{if(this.added_tokens.find(Js=>Js.content===Lt)!==void 0)return Lt;{if(this.remove_space===!0&&(Lt=Lt.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(Lt=K(Lt)),this.normalizer!==null&&(Lt=this.normalizer(Lt)),Lt.length===0)return[];const Js=this.pre_tokenizer!==null?this.pre_tokenizer(Lt,{section_index:tn}):[Lt];return this.model(Js)}}).flat()}_encode_plus(we,{text_pair:st=null,add_special_tokens:Mt=!0,return_token_type_ids:Lt=null}={}){const{tokens:tn,token_type_ids:Zo}=this._tokenize_helper(we,{pair:st,add_special_tokens:Mt}),Js=this.model.convert_tokens_to_ids(tn),Xs={input_ids:Js,attention_mask:new Array(Js.length).fill(1)};return(Lt??this.return_token_type_ids)&&Zo&&(Xs.token_type_ids=Zo),Xs}_tokenize_helper(we,{pair:st=null,add_special_tokens:Mt=!1}={}){const Lt=this._encode_text(we),tn=this._encode_text(st);return this.post_processor?this.post_processor(Lt,tn,{add_special_tokens:Mt}):{tokens:(0,c.mergeArrays)(Lt??[],tn??[])}}tokenize(we,{pair:st=null,add_special_tokens:Mt=!1}={}){return this._tokenize_helper(we,{pair:st,add_special_tokens:Mt}).tokens}encode(we,{text_pair:st=null,add_special_tokens:Mt=!0,return_token_type_ids:Lt=null}={}){return this._encode_plus(we,{text_pair:st,add_special_tokens:Mt,return_token_type_ids:Lt}).input_ids}batch_decode(we,st={}){return we instanceof h.Tensor&&(we=we.tolist()),we.map(Mt=>this.decode(Mt,st))}decode(we,st={}){if(we instanceof h.Tensor&&(we=R(we)),!Array.isArray(we)||we.length===0||!(0,c.isIntegralNumber)(we[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(we,st)}decode_single(we,{skip_special_tokens:st=!1,clean_up_tokenization_spaces:Mt=null}){let Lt=this.model.convert_ids_to_tokens(we);st&&(Lt=Lt.filter(Zo=>!this.special_tokens.includes(Zo)));let tn=this.decoder?this.decoder(Lt):Lt.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(tn=tn.replaceAll(this.decoder.end_of_word_suffix," "),st&&(tn=tn.trim())),(Mt??this.clean_up_tokenization_spaces)&&(tn=A(tn)),tn}get_chat_template({chat_template:we=null,tools:st=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const Mt=this.chat_template;if(we!==null&&Object.hasOwn(Mt,we))we=Mt[we];else if(we===null)if(st!==null&&"tool_use"in Mt)we=Mt.tool_use;else if("default"in Mt)we=Mt.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Mt).sort()}.`)}else if(we===null)if(this.chat_template)we=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return we}apply_chat_template(we,{tools:st=null,documents:Mt=null,chat_template:Lt=null,add_generation_prompt:tn=!1,tokenize:Zo=!0,padding:Js=!1,truncation:Xs=!1,max_length:oa=null,return_tensor:va=!0,return_dict:Wa=!1,tokenizer_kwargs:$a={},...hu}={}){if(Lt=this.get_chat_template({chat_template:Lt,tools:st}),typeof Lt!="string")throw Error(`chat_template must be a string, but got ${typeof Lt}`);let Au=this._compiled_template_cache.get(Lt);Au===void 0&&(Au=new t.Template(Lt),this._compiled_template_cache.set(Lt,Au));const ka=Object.create(null);for(const Gu of Nt){const xd=this.getToken(Gu);xd&&(ka[Gu]=xd)}const Va=Au.render({messages:we,add_generation_prompt:tn,tools:st,documents:Mt,...ka,...hu});if(Zo){const Gu=this._call(Va,{add_special_tokens:!1,padding:Js,truncation:Xs,max_length:oa,return_tensor:va,...$a});return Wa?Gu:Gu.input_ids}return Va}}class Po extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class Ko extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class jo extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class ri extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class Yo extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class la extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class da extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class na extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class ha extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class Wt extends tr{}class $o extends tr{}class Io extends tr{constructor(we,st){super(we,st);_r(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class ma extends tr{constructor(){super(...arguments);_r(this,"return_token_type_ids",!0)}}class Ba extends tr{}class eu extends tr{}class wu extends tr{}class Oa extends tr{constructor(L,we){super(L,we),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(st=>this.languageRegex.test(st)),this.lang_to_token=st=>st}_build_translation_inputs(L,we,st){return Ad(this,L,we,st)}}class bu extends Oa{}class tu extends tr{}class Bd extends tr{}const _u="";class m_ extends tr{constructor(we,st){super(we,st);_r(this,"padding_side","left");this.legacy=st.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Sa({replacement:_u,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(we){if(we===null)return null;if(this.legacy||we.length===0)return super._encode_text(we);let st=super._encode_text(_u+we.replaceAll(_u," "));return st.length>1&&st[0]===_u&&this.special_tokens.includes(st[1])&&(st=st.slice(1)),st}}class o_ extends tr{}class Id extends tr{}class M_ extends tr{}class s_ extends tr{}class P_ extends tr{}class k_ extends tr{}class O_ extends tr{}class i_ extends tr{}class Pd extends tr{}function Ad(Pt,L,we,st){if(!("language_codes"in Pt)||!Array.isArray(Pt.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Pt)||!(Pt.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Pt)||typeof Pt.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const Mt=st.src_lang,Lt=st.tgt_lang;if(!Pt.language_codes.includes(Lt))throw new Error(`Target language code "${Lt}" is not valid. Must be one of: {${Pt.language_codes.join(", ")}}`);if(Mt!==void 0){if(!Pt.language_codes.includes(Mt))throw new Error(`Source language code "${Mt}" is not valid. Must be one of: {${Pt.language_codes.join(", ")}}`);for(const tn of Pt.post_processor.config.single)if("SpecialToken"in tn&&Pt.languageRegex.test(tn.SpecialToken.id)){tn.SpecialToken.id=Pt.lang_to_token(Mt);break}}return st.forced_bos_token_id=Pt.model.convert_tokens_to_ids([Pt.lang_to_token(Lt)])[0],Pt._call(L,we)}class Ld extends tr{constructor(L,we){super(L,we),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(st=>this.languageRegex.test(st)),this.lang_to_token=st=>st}_build_translation_inputs(L,we,st){return Ad(this,L,we,st)}}class g_ extends tr{constructor(L,we){super(L,we),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(st=>this.languageRegex.test(st)).map(st=>st.slice(2,-2)),this.lang_to_token=st=>`__${st}__`}_build_translation_inputs(L,we,st){return Ad(this,L,we,st)}}class Rd extends tr{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(L,{return_timestamps:we=!1,return_language:st=!1,time_precision:Mt=null,force_full_sequences:Lt=!0}={}){if(Mt===null)throw Error("Must specify time_precision");let tn=null;const Zo=we==="word";function Js(){return{language:tn,timestamp:[null,null],text:""}}const Xs=[];let oa=Js(),va=0;const Wa=this.timestamp_begin;let $a=[],hu=[],Au=!1,ka=null;const Va=new Set(this.all_special_ids);for(const wr of L){const Su=wr.tokens,zu=Zo?wr.token_timestamps:null;let ba=null,vd=Wa;if("stride"in wr){const[xu,Fa,Ga]=wr.stride;if(va-=Fa,ka=xu-Ga,Fa&&(vd=Fa/Mt+Wa),Ga)for(let qs=Su.length-1;qs>=0;--qs){const La=Number(Su[qs]);if(La>=Wa){if(ba!==null&&(La-Wa)*Mt<ka)break;ba=La}}}let fa=[],Du=[];for(let xu=0;xu<Su.length;++xu){const Fa=Number(Su[xu]);if(Va.has(Fa)){const Ga=this.decode([Fa]),qs=u.WHISPER_LANGUAGE_MAPPING.get(Ga.slice(2,-2));if(qs!==void 0){if(tn!==null&&qs!==tn&&!we){$a.push(fa);const La=this.findLongestCommonSequence($a)[0],t_=this.decode(La);oa.text=t_,Xs.push(oa),$a=[],fa=[],oa=Js()}tn=oa.language=qs}}else if(Fa>=Wa){const Ga=(Fa-Wa)*Mt+va,qs=(0,a.round)(Ga,2);if(ba!==null&&Fa>=ba)Au=!0;else if(Au||$a.length>0&&Fa<vd)Au=!1;else if(oa.timestamp[0]===null)oa.timestamp[0]=qs;else if(qs!==oa.timestamp[0]){oa.timestamp[1]=qs,$a.push(fa),Zo&&hu.push(Du);const[La,t_]=this.findLongestCommonSequence($a,hu),Cd=this.decode(La);oa.text=Cd,Zo&&(oa.words=this.collateWordTimestamps(La,t_,tn)),Xs.push(oa),$a=[],fa=[],hu=[],Du=[],oa=Js()}}else if(fa.push(Fa),Zo){let Ga=(0,a.round)(zu[xu]+va,2),qs;if(xu+1<zu.length){qs=(0,a.round)(zu[xu+1]+va,2);const La=this.decode([Fa]);ce.test(La)&&(qs=(0,a.round)(Math.min(Ga+Mt,qs),2))}else qs=null;Du.push([Ga,qs])}}if("stride"in wr){const[xu,Fa,Ga]=wr.stride;va+=xu-Ga}fa.length>0?($a.push(fa),Zo&&hu.push(Du)):$a.every(xu=>xu.length===0)&&(oa=Js(),$a=[],fa=[],hu=[],Du=[])}if($a.length>0){if(Lt&&we)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[wr,Su]=this.findLongestCommonSequence($a,hu),zu=this.decode(wr);oa.text=zu,Zo&&(oa.words=this.collateWordTimestamps(wr,Su,tn)),Xs.push(oa)}let Gu=Object.create(null);const xd=Xs.map(wr=>wr.text).join("");if(we||st){for(let wr=0;wr<Xs.length;++wr){const Su=Xs[wr];we||delete Su.timestamp,st||delete Su.language}if(Zo){const wr=[];for(const Su of Xs)for(const zu of Su.words)wr.push(zu);Gu={chunks:wr}}else Gu={chunks:Xs}}return[xd,Gu]}findLongestCommonSequence(L,we=null){let st=L[0],Mt=st.length,Lt=[];const tn=Array.isArray(we)&&we.length>0;let Zo=tn?[]:null,Js=tn?we[0]:null;for(let Xs=1;Xs<L.length;++Xs){const oa=L[Xs];let va=0,Wa=[Mt,Mt,0,0];const $a=oa.length;for(let wr=1;wr<Mt+$a;++wr){const Su=Math.max(0,Mt-wr),zu=Math.min(Mt,Mt+$a-wr),ba=st.slice(Su,zu),vd=Math.max(0,wr-Mt),fa=Math.min($a,wr),Du=oa.slice(vd,fa);if(ba.length!==Du.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let xu;tn?xu=ba.filter((qs,La)=>qs===Du[La]&&Js[Su+La]<=we[Xs][vd+La]).length:xu=ba.filter((qs,La)=>qs===Du[La]).length;const Fa=wr/1e4,Ga=xu/wr+Fa;xu>1&&Ga>va&&(va=Ga,Wa=[Su,zu,vd,fa])}const[hu,Au,ka,Va]=Wa,Gu=Math.floor((Au+hu)/2),xd=Math.floor((Va+ka)/2);Lt.push(...st.slice(0,Gu)),st=oa.slice(xd),Mt=st.length,tn&&(Zo.push(...Js.slice(0,Gu)),Js=we[Xs].slice(xd))}return Lt.push(...st),tn?(Zo.push(...Js),[Lt,Zo]):[Lt,[]]}collateWordTimestamps(L,we,st){const[Mt,Lt,tn]=this.combineTokensIntoWords(L,st),Zo=[];for(let Js=0;Js<Mt.length;++Js){const Xs=tn[Js];Zo.push({text:Mt[Js],timestamp:[we[Xs.at(0)][0],we[Xs.at(-1)][1]]})}return Zo}combineTokensIntoWords(L,we,st=`"'([{-`,Mt=`"'.,!?:)]}`){we=we??"english";let Lt,tn,Zo;return["chinese","japanese","thai","lao","myanmar"].includes(we)?[Lt,tn,Zo]=this.splitTokensOnUnicode(L):[Lt,tn,Zo]=this.splitTokensOnSpaces(L),this.mergePunctuations(Lt,tn,Zo,st,Mt)}decode(L,we){let st;return we!=null&&we.decode_with_timestamps?(L instanceof h.Tensor&&(L=R(L)),st=this.decodeWithTimestamps(L,we)):st=super.decode(L,we),st}decodeWithTimestamps(L,we){const st=(we==null?void 0:we.time_precision)??.02,Mt=Array.from(this.all_special_ids).at(-1)+1;let Lt=[[]];for(let tn of L)if(tn=Number(tn),tn>=Mt){const Zo=((tn-Mt)*st).toFixed(2);Lt.push(`<|${Zo}|>`),Lt.push([])}else Lt[Lt.length-1].push(tn);return Lt=Lt.map(tn=>typeof tn=="string"?tn:super.decode(tn,we)),Lt.join("")}splitTokensOnUnicode(L){const we=this.decode(L,{decode_with_timestamps:!0}),st="",Mt=[],Lt=[],tn=[];let Zo=[],Js=[],Xs=0;for(let oa=0;oa<L.length;++oa){const va=L[oa];Zo.push(va),Js.push(oa);const Wa=this.decode(Zo,{decode_with_timestamps:!0});(!Wa.includes(st)||we[Xs+Wa.indexOf(st)]===st)&&(Mt.push(Wa),Lt.push(Zo),tn.push(Js),Zo=[],Js=[],Xs+=Wa.length)}return[Mt,Lt,tn]}splitTokensOnSpaces(L){const[we,st,Mt]=this.splitTokensOnUnicode(L),Lt=[],tn=[],Zo=[],Js=new RegExp(`^[${ee}]$`,"gu");for(let Xs=0;Xs<we.length;++Xs){const oa=we[Xs],va=st[Xs],Wa=Mt[Xs],$a=va[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),hu=oa.startsWith(" "),Au=oa.trim(),ka=Js.test(Au);if($a||hu||ka||Lt.length===0)Lt.push(oa),tn.push(va),Zo.push(Wa);else{const Va=Lt.length-1;Lt[Va]+=oa,tn[Va].push(...va),Zo[Va].push(...Wa)}}return[Lt,tn,Zo]}mergePunctuations(L,we,st,Mt,Lt){const tn=structuredClone(L),Zo=structuredClone(we),Js=structuredClone(st);let Xs=tn.length-2,oa=tn.length-1;for(;Xs>=0;)tn[Xs].startsWith(" ")&&Mt.includes(tn[Xs].trim())?(tn[oa]=tn[Xs]+tn[oa],Zo[oa]=(0,c.mergeArrays)(Zo[Xs],Zo[oa]),Js[oa]=(0,c.mergeArrays)(Js[Xs],Js[oa]),tn[Xs]="",Zo[Xs]=[],Js[Xs]=[]):oa=Xs,--Xs;for(Xs=0,oa=1;oa<tn.length;)!tn[Xs].endsWith(" ")&&Lt.includes(tn[oa])?(tn[Xs]+=tn[oa],Zo[Xs]=(0,c.mergeArrays)(Zo[Xs],Zo[oa]),Js[Xs]=(0,c.mergeArrays)(Js[Xs],Js[oa]),tn[oa]="",Zo[oa]=[],Js[oa]=[]):Xs=oa,++oa;return[tn.filter(va=>va),Zo.filter(va=>va.length>0),Js.filter(va=>va.length>0)]}}class a_ extends tr{}class l_ extends tr{}class b_ extends tr{}class ya extends tr{constructor(L,we){super(L,we),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(st=>this.languageRegex.test(st)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(L){if(L===null)return null;const[we,...st]=L.trim().split(this.languageRegex);if(st.length===0)return super._encode_text(we);if(st.length===2){const[Mt,Lt]=st;return this.supported_language_codes.includes(Mt)||console.warn(`Unsupported language code "${Mt}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,c.mergeArrays)([Mt],super._encode_text(Lt))}}}class u_ extends tr{}class $_ extends tr{}class A_ extends tr{}class y_ extends tr{}class w_ extends tr{}class S_ extends tr{constructor(L,we){super(L,we),this.decoder=new ii({})}}class d_ extends tr{}class I_{static async from_pretrained(L,{progress_callback:we=null,config:st=null,cache_dir:Mt=null,local_files_only:Lt=!1,revision:tn="main",legacy:Zo=null}={}){var Wa;const[Js,Xs]=await l(L,{progress_callback:we,config:st,cache_dir:Mt,local_files_only:Lt,revision:tn,legacy:Zo}),oa=((Wa=Xs.tokenizer_class)==null?void 0:Wa.replace(/Fast$/,""))??"PreTrainedTokenizer";let va=this.TOKENIZER_CLASS_MAPPING[oa];return va||(console.warn(`Unknown tokenizer class "${oa}", attempting to construct from base class.`),va=tr),new va(Js,Xs)}}_r(I_,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:Ba,DistilBertTokenizer:Wt,CamembertTokenizer:$o,DebertaTokenizer:Yo,DebertaV2Tokenizer:la,BertTokenizer:Po,HerbertTokenizer:da,ConvBertTokenizer:na,RoFormerTokenizer:ha,XLMTokenizer:Io,ElectraTokenizer:ma,MobileBertTokenizer:jo,SqueezeBertTokenizer:ri,AlbertTokenizer:Ko,GPT2Tokenizer:eu,BartTokenizer:wu,MBartTokenizer:Oa,MBart50Tokenizer:bu,RobertaTokenizer:tu,WhisperTokenizer:Rd,CodeGenTokenizer:a_,CLIPTokenizer:l_,SiglipTokenizer:b_,MarianTokenizer:ya,BloomTokenizer:Bd,NllbTokenizer:Ld,M2M100Tokenizer:g_,LlamaTokenizer:m_,CodeLlamaTokenizer:o_,XLMRobertaTokenizer:Id,MPNetTokenizer:M_,FalconTokenizer:s_,GPTNeoXTokenizer:P_,EsmTokenizer:k_,Wav2Vec2CTCTokenizer:u_,BlenderbotTokenizer:$_,BlenderbotSmallTokenizer:A_,SpeechT5Tokenizer:y_,NougatTokenizer:w_,VitsTokenizer:S_,Qwen2Tokenizer:O_,GemmaTokenizer:i_,Grok1Tokenizer:Pd,CohereTokenizer:d_,PreTrainedTokenizer:tr})},"./src/utils/audio.js":(e,r,i)=>{i.r(r),i.d(r,{hamming:()=>u,hanning:()=>t,mel_filter_bank:()=>Z,read_audio:()=>h,spectrogram:()=>ee,window_function:()=>ce});var s=i("./src/utils/hub.js"),c=i("./src/utils/maths.js"),n=i("./src/utils/core.js"),a=i("./src/utils/tensor.js");async function h(X,Re){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const De=await(await(0,s.getFile)(X)).arrayBuffer(),et=new AudioContext({sampleRate:Re});typeof Re>"u"&&console.warn(`No sampling rate provided, using default of ${et.sampleRate}Hz.`);const nt=await et.decodeAudioData(De);let it;if(nt.numberOfChannels===2){const _t=Math.sqrt(2),gt=nt.getChannelData(0),Dt=nt.getChannelData(1);it=new Float32Array(gt.length);for(let Ge=0;Ge<nt.length;++Ge)it[Ge]=_t*(gt[Ge]+Dt[Ge])/2}else it=nt.getChannelData(0);return it}function p(X,Re){if(X<1)return new Float64Array;if(X===1)return new Float64Array([1]);const De=1-Re,et=2*Math.PI/(X-1),nt=new Float64Array(X);for(let it=0;it<X;++it)nt[it]=Re-De*Math.cos(it*et);return nt}function t(X){return p(X,.5)}function u(X){return p(X,.54)}const l={htk:X=>2595*Math.log10(1+X/700),kaldi:X=>1127*Math.log(1+X/700),slaney:(X,Re=1e3,De=15,et=27/Math.log(6.4))=>X>=Re?De+Math.log(X/Re)*et:3*X/200};function f(X,Re="htk"){const De=l[Re];if(!De)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof X=="number"?De(X):X.map(et=>De(et))}const x={htk:X=>700*(10**(X/2595)-1),kaldi:X=>700*(Math.exp(X/1127)-1),slaney:(X,Re=1e3,De=15,et=Math.log(6.4)/27)=>X>=De?Re*Math.exp(et*(X-De)):200*X/3};function I(X,Re="htk"){const De=x[Re];if(!De)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof X=="number"?De(X):X.map(et=>De(et))}function R(X,Re){const De=Float64Array.from({length:Re.length-1},(_t,gt)=>Re[gt+1]-Re[gt]),et=Array.from({length:X.length},()=>new Array(Re.length));for(let _t=0;_t<X.length;++_t){const gt=et[_t];for(let Dt=0;Dt<Re.length;++Dt)gt[Dt]=Re[Dt]-X[_t]}const nt=Re.length-2,it=Array.from({length:nt},()=>new Array(X.length));for(let _t=0;_t<X.length;++_t){const gt=et[_t];for(let Dt=0;Dt<nt;++Dt){const Ge=-gt[Dt]/De[Dt],ge=gt[Dt+2]/De[Dt+1];it[Dt][_t]=Math.max(0,Math.min(Ge,ge))}}return it}function A(X,Re,De){const et=(Re-X)/(De-1);return Float64Array.from({length:De},(nt,it)=>X+et*it)}function Z(X,Re,De,et,nt,it=null,_t="htk",gt=!1){if(it!==null&&it!=="slaney")throw new Error('norm must be one of null or "slaney"');const Dt=f(De,_t),Ge=f(et,_t),ge=A(Dt,Ge,Re+2);let ct=I(ge,_t),Ot;if(gt){const gr=nt/(X*2);Ot=f(Float64Array.from({length:X},(Qe,Dr)=>Dr*gr),_t),ct=ge}else Ot=A(0,Math.floor(nt/2),X);const $t=R(Ot,ct);if(it!==null&&it==="slaney")for(let gr=0;gr<Re;++gr){const Qe=$t[gr],Dr=2/(ct[gr+2]-ct[gr]);for(let vn=0;vn<X;++vn)Qe[vn]*=Dr}return $t}function K(X,Re,De){const et=new X.constructor(X.length+Re+De),nt=X.length-1;for(let it=0;it<X.length;++it)et[Re+it]=X[it];for(let it=1;it<=Re;++it)et[Re-it]=X[(0,n.calculateReflectOffset)(it,nt)];for(let it=1;it<=De;++it)et[nt+Re+it]=X[(0,n.calculateReflectOffset)(nt-it,nt)];return et}function Q(X,Re,De,et,nt){if(De<=0)throw new Error("reference must be greater than zero");if(et<=0)throw new Error("min_value must be greater than zero");De=Math.max(et,De);const it=Math.log10(De);for(let _t=0;_t<X.length;++_t)X[_t]=Re*Math.log10(Math.max(et,X[_t])-it);if(nt!==null){if(nt<=0)throw new Error("db_range must be greater than zero");const _t=(0,c.max)(X)[0]-nt;for(let gt=0;gt<X.length;++gt)X[gt]=Math.max(X[gt],_t)}return X}function re(X,Re=1,De=1e-5,et=null){return Q(X,20,Re,De,et)}function se(X,Re=1,De=1e-10,et=null){return Q(X,10,Re,De,et)}async function ee(X,Re,De,et,{fft_length:nt=null,power:it=1,center:_t=!0,pad_mode:gt="reflect",onesided:Dt=!0,preemphasis:Ge=null,mel_filters:ge=null,mel_floor:ct=1e-10,log_mel:Ot=null,reference:$t=1,min_value:gr=1e-10,db_range:Qe=null,remove_dc_offset:Dr=null,min_num_frames:vn=null,max_num_frames:vr=null,do_pad:Eo=!0,transpose:Ao=!1}={}){const Yr=Re.length;if(nt===null&&(nt=De),De>nt)throw Error(`frame_length (${De}) may not be larger than fft_length (${nt})`);if(Yr!==De)throw new Error(`Length of the window (${Yr}) must equal frame_length (${De})`);if(et<=0)throw new Error("hop_length must be greater than zero");if(it===null&&ge!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(_t){if(gt!=="reflect")throw new Error(`pad_mode="${gt}" not implemented yet.`);const Ye=Math.floor((nt-1)/2)+1;X=K(X,Ye,Ye)}let Ze=Math.floor(1+Math.floor((X.length-De)/et));vn!==null&&Ze<vn&&(Ze=vn);const er=Dt?Math.floor(nt/2)+1:nt;let Kr=Ze,_o=Ze;vr!==null&&(vr>Ze?Eo&&(_o=vr):_o=Kr=vr);const Jr=new c.FFT(nt),en=new Float64Array(nt),Bo=new Float64Array(Jr.outputBufferSize),Ks=new Float32Array(er*_o);for(let Ye=0;Ye<Kr;++Ye){const le=Ye*et,at=Math.min(X.length-le,De);at!==De&&en.fill(0,0,De);for(let Ft=0;Ft<at;++Ft)en[Ft]=X[le+Ft];if(Dr){let Ft=0;for(let _n=0;_n<at;++_n)Ft+=en[_n];const ko=Ft/at;for(let _n=0;_n<at;++_n)en[_n]-=ko}if(Ge!==null){for(let Ft=at-1;Ft>=1;--Ft)en[Ft]-=Ge*en[Ft-1];en[0]*=1-Ge}for(let Ft=0;Ft<Re.length;++Ft)en[Ft]*=Re[Ft];Jr.realTransform(Bo,en);for(let Ft=0;Ft<er;++Ft){const ko=Ft<<1;Ks[Ft*_o+Ye]=Bo[ko]**2+Bo[ko+1]**2}}if(it!==null&&it!==2){const Ye=2/it;for(let le=0;le<Ks.length;++le)Ks[le]**=Ye}const ni=ge.length;let ti=await(0,a.matmul)(new a.Tensor("float32",ge.flat(),[ni,er]),new a.Tensor("float32",Ks,[er,_o]));Ao&&(ti=ti.transpose(1,0));const oe=ti.data;for(let Ye=0;Ye<oe.length;++Ye)oe[Ye]=Math.max(ct,oe[Ye]);if(it!==null&&Ot!==null){const Ye=Math.min(oe.length,Kr*ni);switch(Ot){case"log":for(let le=0;le<Ye;++le)oe[le]=Math.log(oe[le]);break;case"log10":for(let le=0;le<Ye;++le)oe[le]=Math.log10(oe[le]);break;case"dB":if(it===1)re(oe,$t,gr,Qe);else if(it===2)se(oe,$t,gr,Qe);else throw new Error(`Cannot use log_mel option '${Ot}' with power ${it}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${Ot}'`)}}return ti}function ce(X,Re,{periodic:De=!0,frame_length:et=null,center:nt=!0}={}){const it=De?X+1:X;let _t;switch(Re){case"boxcar":_t=new Float64Array(it).fill(1);break;case"hann":case"hann_window":_t=t(it);break;case"hamming":_t=u(it);break;case"povey":_t=t(it).map(gt=>Math.pow(gt,.85));break;default:throw new Error(`Unknown window type ${Re}.`)}if(De&&(_t=_t.subarray(0,X)),et===null)return _t;if(X>et)throw new Error(`Length of the window (${X}) may not be larger than frame_length (${et})`);return _t}},"./src/utils/constants.js":(e,r,i)=>{i.r(r),i.d(r,{GITHUB_ISSUE_URL:()=>s});const s="https://github.com/huggingface/transformers.js/issues/new/choose"},"./src/utils/core.js":(e,r,i)=>{i.r(r),i.d(r,{calculateDimensions:()=>p,calculateReflectOffset:()=>f,dispatchCallback:()=>s,escapeRegExp:()=>n,isIntegralNumber:()=>h,isTypedArray:()=>a,len:()=>I,mergeArrays:()=>u,pick:()=>x,pop:()=>t,product:()=>l,reverseDictionary:()=>c});function s(R,A){R&&R(A)}function c(R){return Object.fromEntries(Object.entries(R).map(([A,Z])=>[Z,A]))}function n(R){return R.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function a(R){var A,Z,K;return((K=(Z=(A=R==null?void 0:R.prototype)==null?void 0:A.__proto__)==null?void 0:Z.constructor)==null?void 0:K.name)==="TypedArray"}function h(R){return Number.isInteger(R)||typeof R=="bigint"}function p(R){const A=[];let Z=R;for(;Array.isArray(Z);)A.push(Z.length),Z=Z[0];return A}function t(R,A,Z=void 0){const K=R[A];if(K!==void 0)return delete R[A],K;if(Z===void 0)throw Error(`Key ${A} does not exist in object.`);return Z}function u(...R){return Array.prototype.concat.apply([],R)}function l(...R){return R.reduce((A,Z)=>A.flatMap(K=>Z.map(Q=>[K,Q])))}function f(R,A){return Math.abs((R+A)%(2*A)-A)}function x(R,A){return Object.assign({},...A.map(Z=>{if(R[Z]!==void 0)return{[Z]:R[Z]}}))}function I(R){let A=0;for(const Z of R)++A;return A}},"./src/utils/data-structures.js":(e,r,i)=>{i.r(r),i.d(r,{CharTrie:()=>c,PriorityQueue:()=>s,TokenLattice:()=>a});class s{constructor(t=(l,f)=>l>f,u=1/0){this._heap=[],this._comparator=t,this._maxSize=u}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...t){return this.extend(t)}extend(t){for(const u of t)if(this.size<this._maxSize)this._heap.push(u),this._siftUp();else{const l=this._smallest();this._comparator(u,this._heap[l])&&(this._heap[l]=u,this._siftUpFrom(l))}return this.size}pop(){const t=this.peek(),u=this.size-1;return u>0&&this._swap(0,u),this._heap.pop(),this._siftDown(),t}replace(t){const u=this.peek();return this._heap[0]=t,this._siftDown(),u}_parent(t){return(t+1>>>1)-1}_left(t){return(t<<1)+1}_right(t){return t+1<<1}_greater(t,u){return this._comparator(this._heap[t],this._heap[u])}_swap(t,u){const l=this._heap[t];this._heap[t]=this._heap[u],this._heap[u]=l}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(t){for(;t>0&&this._greater(t,this._parent(t));)this._swap(t,this._parent(t)),t=this._parent(t)}_siftDown(){let t=0;for(;this._left(t)<this.size&&this._greater(this._left(t),t)||this._right(t)<this.size&&this._greater(this._right(t),t);){const u=this._right(t)<this.size&&this._greater(this._right(t),this._left(t))?this._right(t):this._left(t);this._swap(t,u),t=u}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class c{constructor(){this.root=n.default()}extend(t){for(const u of t)this.push(u)}push(t){let u=this.root;for(const l of t){let f=u.children.get(l);f===void 0&&(f=n.default(),u.children.set(l,f)),u=f}u.isLeaf=!0}*commonPrefixSearch(t){let u=this.root;if(u===void 0)return;let l="";for(const f of t){if(l+=f,u=u.children.get(f),u===void 0)return;u.isLeaf&&(yield l)}}}class n{constructor(t,u){this.isLeaf=t,this.children=u}static default(){return new n(!1,new Map)}}class a{constructor(t,u,l){this.chars=Array.from(t),this.len=this.chars.length,this.bosTokenId=u,this.eosTokenId=l,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const f=new h(this.bosTokenId,0,0,0,0),x=new h(this.eosTokenId,1,this.len,0,0);this.nodes.push(f.clone()),this.nodes.push(x.clone()),this.beginNodes[this.len].push(x),this.endNodes[0].push(f)}insert(t,u,l,f){const x=this.nodes.length,I=new h(f,x,t,u,l);this.beginNodes[t].push(I),this.endNodes[t+u].push(I),this.nodes.push(I)}viterbi(){const t=this.len;let u=0;for(;u<=t;){if(this.beginNodes[u].length==0)return[];for(let R of this.beginNodes[u]){R.prev=null;let A=0,Z=null;for(let K of this.endNodes[u]){const Q=K.backtraceScore+R.score;(Z===null||Q>A)&&(Z=K.clone(),A=Q)}if(Z!==null)R.prev=Z,R.backtraceScore=A;else return[]}++u}const l=[],x=this.beginNodes[t][0].prev;if(x===null)return[];let I=x.clone();for(;I.prev!==null;)l.push(I.clone()),I=I.clone().prev.clone();return l.reverse(),l}piece(t){return this.chars.slice(t.pos,t.pos+t.length).join("")}tokens(){return this.viterbi().map(u=>this.piece(u))}tokenIds(){return this.viterbi().map(u=>u.tokenId)}}class h{constructor(t,u,l,f,x){this.tokenId=t,this.nodeId=u,this.pos=l,this.length=f,this.score=x,this.prev=null,this.backtraceScore=0}clone(){const t=new h(this.tokenId,this.nodeId,this.pos,this.length,this.score);return t.prev=this.prev,t.backtraceScore=this.backtraceScore,t}}},"./src/utils/devices.js":(e,r,i)=>{i.r(r),i.d(r,{DEVICE_TYPES:()=>s});const s=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,r,i)=>{i.r(r),i.d(r,{DATA_TYPES:()=>a,DEFAULT_DEVICE_DTYPE_MAPPING:()=>h,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>p,isWebGpuFp16Supported:()=>n});var s=i("./src/env.js"),c=i("./src/utils/devices.js");const n=function(){let t;return async function(){if(t===void 0)if(!s.apis.IS_WEBGPU_AVAILABLE)t=!1;else try{t=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{t=!1}return t}}(),a=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),h=Object.freeze({[c.DEVICE_TYPES.wasm]:a.q8}),p=Object.freeze({[a.fp32]:"",[a.fp16]:"_fp16",[a.int8]:"_int8",[a.uint8]:"_uint8",[a.q8]:"_quantized",[a.q4]:"_q4",[a.q4f16]:"_q4f16",[a.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,r,i)=>{i.r(r),i.d(r,{Callable:()=>s});const s=class{constructor(){let c=function(...n){return c._call(...n)};return Object.setPrototypeOf(c,new.target.prototype)}_call(...c){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,r,i)=>{i.r(r),i.d(r,{getFile:()=>u,getModelFile:()=>R,getModelJSON:()=>A});var s=i("?7a2c"),c=i("?a42a"),n=i("./src/env.js"),a=i("./src/utils/core.js");const h={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class p{constructor(re){if(this.filePath=re,this.headers=new Headers,this.exists=s.existsSync(re),this.exists){this.status=200,this.statusText="OK";let se=s.statSync(re);this.headers.set("content-length",se.size.toString()),this.updateContentType();let ee=this;this.body=new ReadableStream({start(ce){ee.arrayBuffer().then(X=>{ce.enqueue(new Uint8Array(X)),ce.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const re=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",h[re]??"application/octet-stream")}clone(){let re=new p(this.filePath);return re.exists=this.exists,re.status=this.status,re.statusText=this.statusText,re.headers=new Headers(this.headers),re}async arrayBuffer(){return(await s.promises.readFile(this.filePath)).buffer}async blob(){const re=await s.promises.readFile(this.filePath);return new Blob([re],{type:this.headers.get("content-type")})}async text(){return await s.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function t(Q,re=null,se=null){let ee;try{ee=new URL(Q)}catch{return!1}return!(re&&!re.includes(ee.protocol)||se&&!se.includes(ee.hostname))}async function u(Q){var re;if(n.env.useFS&&!t(Q,["http:","https:","blob:"]))return new p(Q);if(typeof process<"u"&&((re=process==null?void 0:process.release)==null?void 0:re.name)==="node"){const se=!!(define_process_env_default!=null&&define_process_env_default.TESTING_REMOTELY),ee=n.env.version,ce=new Headers;if(ce.set("User-Agent",`transformers.js/${ee}; is_ci/${se};`),t(Q,["http:","https:"],["huggingface.co","hf.co"])){const Re=(define_process_env_default==null?void 0:define_process_env_default.HF_TOKEN)??(define_process_env_default==null?void 0:define_process_env_default.HF_ACCESS_TOKEN);Re&&ce.set("Authorization",`Bearer ${Re}`)}return fetch(Q,{headers:ce})}else return fetch(Q)}const l={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function f(Q,re,se){if(!se)return null;const ee=l[Q]??`Error (${Q}) occurred while trying to load file`;throw Error(`${ee}: "${re}".`)}class x{constructor(re){this.path=re}async match(re){let se=c.join(this.path,re),ee=new p(se);if(ee.exists)return ee}async put(re,se){const ee=Buffer.from(await se.arrayBuffer());let ce=c.join(this.path,re);try{await s.promises.mkdir(c.dirname(ce),{recursive:!0}),await s.promises.writeFile(ce,ee)}catch(X){console.warn("An error occurred while writing the file to cache:",X)}}}async function I(Q,...re){for(let se of re)try{let ee=await Q.match(se);if(ee)return ee}catch{continue}}async function R(Q,re,se=!0,ee={}){if(!n.env.allowLocalModels){if(ee.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!n.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,a.dispatchCallback)(ee.progress_callback,{status:"initiate",name:Q,file:re});let ce;if(!ce&&n.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{ce=await caches.open("transformers-cache")}catch(Ot){console.warn("An error occurred while opening the browser cache:",Ot)}}if(!ce&&n.env.useFSCache&&(ce=new x(ee.cache_dir??n.env.cacheDir)),!ce&&n.env.useCustomCache){if(!n.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!n.env.customCache.match||!n.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");ce=n.env.customCache}const X=ee.revision??"main";let Re=K(Q,re),De=K(n.env.localModelPath,Re),et=K(n.env.remoteHost,n.env.remotePathTemplate.replaceAll("{model}",Q).replaceAll("{revision}",encodeURIComponent(X)),re),nt=X==="main"?Re:K(Q,X,re),it,_t=ce instanceof x?nt:et,gt=!1,Dt;ce&&(Dt=await I(ce,De,_t));const Ge=Dt!==void 0;if(Dt===void 0){if(n.env.allowLocalModels)if(t(Re,["http:","https:"])){if(ee.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${Re}.`);if(!n.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${Re}.`)}else try{Dt=await u(De),it=De}catch($t){console.warn(`Unable to load from local path "${De}": "${$t}"`)}if(Dt===void 0||Dt.status===404){if(ee.local_files_only||!n.env.allowRemoteModels){if(se)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${De}".`);return null}if(Dt=await u(et),Dt.status!==200)return f(Dt.status,et,se);it=_t}gt=ce&&typeof Response<"u"&&Dt instanceof Response&&Dt.status===200}(0,a.dispatchCallback)(ee.progress_callback,{status:"download",name:Q,file:re});const ge={status:"progress",name:Q,file:re};let ct;return ee.progress_callback?Ge&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(ct=new Uint8Array(await Dt.arrayBuffer()),(0,a.dispatchCallback)(ee.progress_callback,{...ge,progress:100,loaded:ct.length,total:ct.length})):ct=await Z(Dt,Ot=>{(0,a.dispatchCallback)(ee.progress_callback,{...ge,...Ot})}):ct=new Uint8Array(await Dt.arrayBuffer()),gt&&it&&await ce.match(it)===void 0&&await ce.put(it,new Response(ct,{headers:Dt.headers})).catch(Ot=>{console.warn(`Unable to add response to browser cache: ${Ot}.`)}),(0,a.dispatchCallback)(ee.progress_callback,{status:"done",name:Q,file:re}),ct}async function A(Q,re,se=!0,ee={}){let ce=await R(Q,re,se,ee);if(ce===null)return{};let Re=new TextDecoder("utf-8").decode(ce);return JSON.parse(Re)}async function Z(Q,re){const se=Q.headers.get("Content-Length");se===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let ee=parseInt(se??"0"),ce=new Uint8Array(ee),X=0;const Re=Q.body.getReader();async function De(){const{done:et,value:nt}=await Re.read();if(et)return;let it=X+nt.length;if(it>ee){ee=it;let gt=new Uint8Array(ee);gt.set(ce),ce=gt}ce.set(nt,X),X=it;const _t=X/ee*100;return re({progress:_t,loaded:X,total:ee}),De()}return await De(),ce}function K(...Q){return Q=Q.map((re,se)=>(se&&(re=re.replace(new RegExp("^/"),"")),se!==Q.length-1&&(re=re.replace(new RegExp("/$"),"")),re)),Q.join("/")}},"./src/utils/image.js":(e,r,i)=>{i.r(r),i.d(r,{RawImage:()=>I});var s=i("./src/utils/hub.js"),c=i("./src/env.js"),n=i("./src/utils/tensor.js"),a=i("?2b25");const h=typeof self<"u",p=h&&self.constructor.name==="DedicatedWorkerGlobalScope";let t,u,l;if(h)t=(R,A)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(R,A)},l=self.createImageBitmap,u=self.ImageData;else if(a)l=async R=>{const Z=(await R.metadata()).channels,{data:K,info:Q}=await R.rotate().raw().toBuffer({resolveWithObject:!0}),re=new I(new Uint8ClampedArray(K),Q.width,Q.height,Q.channels);return Z!==void 0&&Z!==Q.channels&&re.convert(Z),re};else throw new Error("Unable to load image processing library.");const f={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},x=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class I{constructor(A,Z,K,Q){this.data=A,this.width=Z,this.height=K,this.channels=Q}get size(){return[this.width,this.height]}static async read(A){if(A instanceof I)return A;if(typeof A=="string"||A instanceof URL)return await this.fromURL(A);throw new Error(`Unsupported input type: ${typeof A}`)}static fromCanvas(A){if(!h)throw new Error("fromCanvas() is only supported in browser environments.");const K=A.getContext("2d").getImageData(0,0,A.width,A.height).data;return new I(K,A.width,A.height,4)}static async fromURL(A){const Z=await(0,s.getFile)(A);if(Z.status!==200)throw new Error(`Unable to read image from "${A}" (${Z.status} ${Z.statusText})`);const K=await Z.blob();return this.fromBlob(K)}static async fromBlob(A){if(h){const Z=await l(A),K=t(Z.width,Z.height).getContext("2d");return K.drawImage(Z,0,0),new this(K.getImageData(0,0,Z.width,Z.height).data,Z.width,Z.height,4)}else{const Z=a(await A.arrayBuffer());return await l(Z)}}static fromTensor(A,Z="CHW"){if(A.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${A.dims.length} dimensions.`);if(Z==="CHW")A=A.transpose(1,2,0);else if(Z!=="HWC")throw new Error(`Unsupported channel format: ${Z}`);if(!(A.data instanceof Uint8ClampedArray||A.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${A.type}`);switch(A.dims[2]){case 1:case 2:case 3:case 4:return new I(A.data,A.dims[1],A.dims[0],A.dims[2]);default:throw new Error(`Unsupported number of channels: ${A.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const A=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let Z=0,K=0;Z<this.data.length;Z+=this.channels){const Q=this.data[Z],re=this.data[Z+1],se=this.data[Z+2];A[K++]=Math.round(.2989*Q+.587*re+.114*se)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(A,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const A=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let Z=0,K=0;Z<this.data.length;++Z)A[K++]=this.data[Z],A[K++]=this.data[Z],A[K++]=this.data[Z];break;case 4:for(let Z=0,K=0;Z<this.data.length;Z+=4)A[K++]=this.data[Z],A[K++]=this.data[Z+1],A[K++]=this.data[Z+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(A,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const A=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let Z=0,K=0;Z<this.data.length;++Z)A[K++]=this.data[Z],A[K++]=this.data[Z],A[K++]=this.data[Z],A[K++]=255;break;case 3:for(let Z=0,K=0;Z<this.data.length;Z+=3)A[K++]=this.data[Z],A[K++]=this.data[Z+1],A[K++]=this.data[Z+2],A[K++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(A,this.width,this.height,4)}async resize(A,Z,{resample:K=2}={}){let Q=f[K]??K;if(h){const re=this.channels,se=this.toCanvas(),ee=t(A,Z).getContext("2d");return ee.drawImage(se,0,0,A,Z),new I(ee.getImageData(0,0,A,Z).data,A,Z,4).convert(re)}else{let re=this.toSharp();switch(Q){case"box":case"hamming":(Q==="box"||Q==="hamming")&&(console.warn(`Resampling method ${Q} is not yet supported. Using bilinear instead.`),Q="bilinear");case"nearest":case"bilinear":case"bicubic":re=re.affine([A/this.width,0,0,Z/this.height],{interpolator:Q});break;case"lanczos":re=re.resize({width:A,height:Z,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${Q} is not supported.`)}return await l(re)}}async pad([A,Z,K,Q]){if(A=Math.max(A,0),Z=Math.max(Z,0),K=Math.max(K,0),Q=Math.max(Q,0),A===0&&Z===0&&K===0&&Q===0)return this;if(h){const re=this.channels,se=this.toCanvas(),ee=this.width+A+Z,ce=this.height+K+Q,X=t(ee,ce).getContext("2d");return X.drawImage(se,0,0,this.width,this.height,A,K,ee,ce),new I(X.getImageData(0,0,ee,ce).data,ee,ce,4).convert(re)}else{const re=this.toSharp().extend({left:A,right:Z,top:K,bottom:Q});return await l(re)}}async crop([A,Z,K,Q]){if(A=Math.max(A,0),Z=Math.max(Z,0),K=Math.min(K,this.width-1),Q=Math.min(Q,this.height-1),A===0&&Z===0&&K===this.width-1&&Q===this.height-1)return this;const re=K-A+1,se=Q-Z+1;if(h){const ee=this.channels,ce=this.toCanvas(),X=t(re,se).getContext("2d");return X.drawImage(ce,A,Z,re,se,0,0,re,se),new I(X.getImageData(0,0,re,se).data,re,se,4).convert(ee)}else{const ee=this.toSharp().extract({left:A,top:Z,width:re,height:se});return await l(ee)}}async center_crop(A,Z){if(this.width===A&&this.height===Z)return this;const K=(this.width-A)/2,Q=(this.height-Z)/2;if(h){const re=this.channels,se=this.toCanvas(),ee=t(A,Z).getContext("2d");let ce=0,X=0,Re=0,De=0;return K>=0?ce=K:Re=-K,Q>=0?X=Q:De=-Q,ee.drawImage(se,ce,X,A,Z,Re,De,A,Z),new I(ee.getImageData(0,0,A,Z).data,A,Z,4).convert(re)}else{let re=this.toSharp();if(K>=0&&Q>=0)re=re.extract({left:Math.floor(K),top:Math.floor(Q),width:A,height:Z});else if(K<=0&&Q<=0){const se=Math.floor(-Q),ee=Math.floor(-K);re=re.extend({top:se,left:ee,right:A-this.width-ee,bottom:Z-this.height-se})}else{let se=[0,0],ee=0;Q<0?(se[0]=Math.floor(-Q),se[1]=Z-this.height-se[0]):ee=Math.floor(Q);let ce=[0,0],X=0;K<0?(ce[0]=Math.floor(-K),ce[1]=A-this.width-ce[0]):X=Math.floor(K),re=re.extend({top:se[0],bottom:se[1],left:ce[0],right:ce[1]}).extract({left:X,top:ee,width:A,height:Z})}return await l(re)}}async toBlob(A="image/png",Z=1){if(!h)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:A,quality:Z})}toTensor(A="CHW"){let Z=new n.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(A!=="HWC")if(A==="CHW")Z=Z.permute(2,0,1);else throw new Error(`Unsupported channel format: ${A}`);return Z}toCanvas(){if(!h)throw new Error("toCanvas() is only supported in browser environments.");const A=this.clone().rgba(),Z=t(A.width,A.height),K=new u(A.data,A.width,A.height);return Z.getContext("2d").putImageData(K,0,0),Z}_update(A,Z,K,Q=null){return this.data=A,this.width=Z,this.height=K,Q!==null&&(this.channels=Q),this}clone(){return new I(this.data.slice(),this.width,this.height,this.channels)}convert(A){if(this.channels===A)return this;switch(A){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(A){if(h){if(p)throw new Error("Unable to save an image from a Web Worker.");const Z=A.split(".").pop().toLowerCase(),K=x.get(Z)??"image/png",Q=await this.toBlob(K),re=URL.createObjectURL(Q),se=document.createElement("a");se.href=re,se.download=A,se.click(),se.remove()}else{if(c.env.useFS)return await this.toSharp().toFile(A);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(h)throw new Error("toSharp() is only supported in server-side environments.");return a(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}},"./src/utils/maths.js":(e,r,i)=>{i.r(r),i.d(r,{FFT:()=>R,bankers_round:()=>K,cos_sim:()=>p,dot:()=>h,dynamic_time_warping:()=>Q,interpolate_data:()=>s,log_softmax:()=>a,magnitude:()=>t,max:()=>l,medianFilter:()=>A,min:()=>u,permute_data:()=>c,round:()=>Z,softmax:()=>n});function s(re,[se,ee,ce],[X,Re],De="bilinear",et=!1){const nt=Re/ce,it=X/ee,_t=new re.constructor(X*Re*se),gt=ee*ce,Dt=X*Re;for(let Ge=0;Ge<X;++Ge)for(let ge=0;ge<Re;++ge){const ct=Ge*Re+ge,Ot=(ge+.5)/nt-.5,$t=(Ge+.5)/it-.5;let gr=Math.floor(Ot),Qe=Math.floor($t);const Dr=Math.min(gr+1,ce-1),vn=Math.min(Qe+1,ee-1);gr=Math.max(gr,0),Qe=Math.max(Qe,0);const vr=Ot-gr,Eo=$t-Qe,Ao=(1-vr)*(1-Eo),Yr=vr*(1-Eo),Ze=(1-vr)*Eo,er=vr*Eo,Kr=Qe*ce,_o=vn*ce,Jr=Kr+gr,en=Kr+Dr,Bo=_o+gr,Ks=_o+Dr;for(let ni=0;ni<se;++ni){const ti=ni*gt;_t[ni*Dt+ct]=Ao*re[ti+Jr]+Yr*re[ti+en]+Ze*re[ti+Bo]+er*re[ti+Ks]}}return _t}function c(re,se,ee){const ce=new Array(ee.length),X=new Array(ee.length);for(let et=ee.length-1,nt=1;et>=0;--et)X[et]=nt,ce[et]=se[ee[et]],nt*=ce[et];const Re=ee.map((et,nt)=>X[ee.indexOf(nt)]),De=new re.constructor(re.length);for(let et=0;et<re.length;++et){let nt=0;for(let it=se.length-1,_t=et;it>=0;--it)nt+=_t%se[it]*Re[it],_t=Math.floor(_t/se[it]);De[nt]=re[et]}return[De,ce]}function n(re){const se=l(re)[0],ee=re.map(Re=>Math.exp(Re-se)),ce=ee.reduce((Re,De)=>Re+De,0);return ee.map(Re=>Re/ce)}function a(re){const se=l(re)[0];let ee=0;for(let Re=0;Re<re.length;++Re)ee+=Math.exp(re[Re]-se);const ce=Math.log(ee);return re.map(Re=>Re-se-ce)}function h(re,se){let ee=0;for(let ce=0;ce<re.length;++ce)ee+=re[ce]*se[ce];return ee}function p(re,se){const ee=h(re,se),ce=t(re),X=t(se);return ee/(ce*X)}function t(re){return Math.sqrt(re.reduce((se,ee)=>se+ee*ee,0))}function u(re){if(re.length===0)throw Error("Array must not be empty");let se=re[0],ee=0;for(let ce=1;ce<re.length;++ce)re[ce]<se&&(se=re[ce],ee=ce);return[se,ee]}function l(re){if(re.length===0)throw Error("Array must not be empty");let se=re[0],ee=0;for(let ce=1;ce<re.length;++ce)re[ce]>se&&(se=re[ce],ee=ce);return[Number(se),ee]}function f(re){return re>0&&(re&re-1)===0}class x{constructor(se){if(this.size=se|0,this.size<=1||!f(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=se<<1,this.table=new Float64Array(this.size*2);for(let ce=0;ce<this.table.length;ce+=2){const X=Math.PI*ce/this.size;this.table[ce]=Math.cos(X),this.table[ce+1]=-Math.sin(X)}let ee=0;for(let ce=1;this.size>ce;ce<<=1)++ee;this._width=ee%2===0?ee-1:ee,this._bitrev=new Int32Array(1<<this._width);for(let ce=0;ce<this._bitrev.length;++ce){this._bitrev[ce]=0;for(let X=0;X<this._width;X+=2){const Re=this._width-X-2;this._bitrev[ce]|=(ce>>>X&3)<<Re}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(se,ee){const ce=ee||new Array(se.length>>>1);for(let X=0;X<se.length;X+=2)ce[X>>>1]=se[X];return ce}toComplexArray(se,ee){const ce=ee||this.createComplexArray();for(let X=0;X<ce.length;X+=2)ce[X]=se[X>>>1],ce[X+1]=0;return ce}transform(se,ee){if(se===ee)throw new Error("Input and output buffers must be different");this._transform4(se,ee,1)}realTransform(se,ee){if(se===ee)throw new Error("Input and output buffers must be different");this._realTransform4(se,ee,1)}inverseTransform(se,ee){if(se===ee)throw new Error("Input and output buffers must be different");this._transform4(se,ee,-1);for(let ce=0;ce<se.length;++ce)se[ce]/=this.size}_transform4(se,ee,ce){const X=this._csize;let De=1<<this._width,et=X/De<<1,nt,it;const _t=this._bitrev;if(et===4)for(nt=0,it=0;nt<X;nt+=et,++it){const Dt=_t[it];this._singleTransform2(ee,se,nt,Dt,De)}else for(nt=0,it=0;nt<X;nt+=et,++it){const Dt=_t[it];this._singleTransform4(ee,se,nt,Dt,De,ce)}const gt=this.table;for(De>>=2;De>=2;De>>=2){et=X/De<<1;const Dt=et>>>2;for(nt=0;nt<X;nt+=et){const Ge=nt+Dt-1;for(let ge=nt,ct=0;ge<Ge;ge+=2,ct+=De){const Ot=ge,$t=Ot+Dt,gr=$t+Dt,Qe=gr+Dt,Dr=se[Ot],vn=se[Ot+1],vr=se[$t],Eo=se[$t+1],Ao=se[gr],Yr=se[gr+1],Ze=se[Qe],er=se[Qe+1],Kr=gt[ct],_o=ce*gt[ct+1],Jr=vr*Kr-Eo*_o,en=vr*_o+Eo*Kr,Bo=gt[2*ct],Ks=ce*gt[2*ct+1],ni=Ao*Bo-Yr*Ks,ti=Ao*Ks+Yr*Bo,oe=gt[3*ct],Ye=ce*gt[3*ct+1],le=Ze*oe-er*Ye,at=Ze*Ye+er*oe,Ft=Dr+ni,ko=vn+ti,_n=Dr-ni,ra=vn-ti,zo=Jr+le,Jo=en+at,ia=ce*(Jr-le),ii=ce*(en-at);se[Ot]=Ft+zo,se[Ot+1]=ko+Jo,se[$t]=_n+ii,se[$t+1]=ra-ia,se[gr]=Ft-zo,se[gr+1]=ko-Jo,se[Qe]=_n-ii,se[Qe+1]=ra+ia}}}}_singleTransform2(se,ee,ce,X,Re){const De=se[X],et=se[X+1],nt=se[X+Re],it=se[X+Re+1];ee[ce]=De+nt,ee[ce+1]=et+it,ee[ce+2]=De-nt,ee[ce+3]=et-it}_singleTransform4(se,ee,ce,X,Re,De){const et=Re*2,nt=Re*3,it=se[X],_t=se[X+1],gt=se[X+Re],Dt=se[X+Re+1],Ge=se[X+et],ge=se[X+et+1],ct=se[X+nt],Ot=se[X+nt+1],$t=it+Ge,gr=_t+ge,Qe=it-Ge,Dr=_t-ge,vn=gt+ct,vr=Dt+Ot,Eo=De*(gt-ct),Ao=De*(Dt-Ot);ee[ce]=$t+vn,ee[ce+1]=gr+vr,ee[ce+2]=Qe+Ao,ee[ce+3]=Dr-Eo,ee[ce+4]=$t-vn,ee[ce+5]=gr-vr,ee[ce+6]=Qe-Ao,ee[ce+7]=Dr+Eo}_realTransform4(se,ee,ce){const X=this._csize;let De=1<<this._width,et=X/De<<1,nt,it;const _t=this._bitrev;if(et===4)for(nt=0,it=0;nt<X;nt+=et,++it){const Ge=_t[it];this._singleRealTransform2(ee,se,nt,Ge>>>1,De>>>1)}else for(nt=0,it=0;nt<X;nt+=et,++it){const Ge=_t[it];this._singleRealTransform4(ee,se,nt,Ge>>>1,De>>>1,ce)}const gt=this.table;for(De>>=2;De>=2;De>>=2){et=X/De<<1;const Ge=et>>>1,ge=Ge>>>1,ct=ge>>>1;for(nt=0;nt<X;nt+=et)for(let Ot=0,$t=0;Ot<=ct;Ot+=2,$t+=De){const gr=nt+Ot,Qe=gr+ge,Dr=Qe+ge,vn=Dr+ge,vr=se[gr],Eo=se[gr+1],Ao=se[Qe],Yr=se[Qe+1],Ze=se[Dr],er=se[Dr+1],Kr=se[vn],_o=se[vn+1],Jr=vr,en=Eo,Bo=gt[$t],Ks=ce*gt[$t+1],ni=Ao*Bo-Yr*Ks,ti=Ao*Ks+Yr*Bo,oe=gt[2*$t],Ye=ce*gt[2*$t+1],le=Ze*oe-er*Ye,at=Ze*Ye+er*oe,Ft=gt[3*$t],ko=ce*gt[3*$t+1],_n=Kr*Ft-_o*ko,ra=Kr*ko+_o*Ft,zo=Jr+le,Jo=en+at,ia=Jr-le,ii=en-at,Sa=ni+_n,Na=ti+ra,Tu=ce*(ni-_n),Ua=ce*(ti-ra);if(se[gr]=zo+Sa,se[gr+1]=Jo+Na,se[Qe]=ia+Ua,se[Qe+1]=ii-Tu,Ot===0){se[Dr]=zo-Sa,se[Dr+1]=Jo-Na;continue}if(Ot===ct)continue;const $u=nt+ge-Ot,So=nt+Ge-Ot;se[$u]=ia-ce*Ua,se[$u+1]=-ii-ce*Tu,se[So]=zo-ce*Sa,se[So+1]=-Jo+ce*Na}}const Dt=X>>>1;for(let Ge=2;Ge<Dt;Ge+=2)se[X-Ge]=se[Ge],se[X-Ge+1]=-se[Ge+1]}_singleRealTransform2(se,ee,ce,X,Re){const De=se[X],et=se[X+Re];ee[ce]=De+et,ee[ce+1]=0,ee[ce+2]=De-et,ee[ce+3]=0}_singleRealTransform4(se,ee,ce,X,Re,De){const et=Re*2,nt=Re*3,it=se[X],_t=se[X+Re],gt=se[X+et],Dt=se[X+nt],Ge=it+gt,ge=it-gt,ct=_t+Dt,Ot=De*(_t-Dt);ee[ce]=Ge+ct,ee[ce+1]=0,ee[ce+2]=ge,ee[ce+3]=-Ot,ee[ce+4]=Ge-ct,ee[ce+5]=0,ee[ce+6]=ge,ee[ce+7]=Ot}}class I{constructor(se){const ee=2*(se-1),ce=2*(2*se-1),X=2**Math.ceil(Math.log2(ce));this.bufferSize=X,this._a=ee;const Re=new Float64Array(ce),De=new Float64Array(X);this._chirpBuffer=new Float64Array(X),this._buffer1=new Float64Array(X),this._buffer2=new Float64Array(X),this._outBuffer1=new Float64Array(X),this._outBuffer2=new Float64Array(X);const et=-2*Math.PI/se,nt=Math.cos(et),it=Math.sin(et);for(let _t=0;_t<ce>>1;++_t){const gt=(_t+1-se)**2/2,Dt=Math.sqrt(nt**2+it**2)**gt,Ge=gt*Math.atan2(it,nt),ge=2*_t;Re[ge]=Dt*Math.cos(Ge),Re[ge+1]=Dt*Math.sin(Ge),De[ge]=Re[ge],De[ge+1]=-Re[ge+1]}this._slicedChirpBuffer=Re.subarray(ee,ce),this._f=new x(X>>1),this._f.transform(this._chirpBuffer,De)}_transform(se,ee,ce){const X=this._buffer1,Re=this._buffer2,De=this._outBuffer1,et=this._outBuffer2,nt=this._chirpBuffer,it=this._slicedChirpBuffer,_t=this._a;if(ce)for(let gt=0;gt<it.length;gt+=2){const Dt=gt+1,Ge=gt>>1,ge=ee[Ge];X[gt]=ge*it[gt],X[Dt]=ge*it[Dt]}else for(let gt=0;gt<it.length;gt+=2){const Dt=gt+1;X[gt]=ee[gt]*it[gt]-ee[Dt]*it[Dt],X[Dt]=ee[gt]*it[Dt]+ee[Dt]*it[gt]}this._f.transform(De,X);for(let gt=0;gt<nt.length;gt+=2){const Dt=gt+1;Re[gt]=De[gt]*nt[gt]-De[Dt]*nt[Dt],Re[Dt]=De[gt]*nt[Dt]+De[Dt]*nt[gt]}this._f.inverseTransform(et,Re);for(let gt=0;gt<et.length;gt+=2){const Dt=et[gt+_t],Ge=et[gt+_t+1],ge=it[gt],ct=it[gt+1];se[gt]=Dt*ge-Ge*ct,se[gt+1]=Dt*ct+Ge*ge}}transform(se,ee){this._transform(se,ee,!1)}realTransform(se,ee){this._transform(se,ee,!0)}}class R{constructor(se){this.fft_length=se,this.isPowerOfTwo=f(se),this.isPowerOfTwo?(this.fft=new x(se),this.outputBufferSize=2*se):(this.fft=new I(se),this.outputBufferSize=this.fft.bufferSize)}realTransform(se,ee){this.fft.realTransform(se,ee)}transform(se,ee){this.fft.transform(se,ee)}}function A(re,se){if(se%2===0||se<=0)throw new Error("Window size must be a positive odd number");const ee=new re.constructor(re.length),ce=new re.constructor(se),X=Math.floor(se/2);for(let Re=0;Re<re.length;++Re){let De=0;for(let et=-X;et<=X;++et){let nt=Re+et;nt<0?nt=Math.abs(nt):nt>=re.length&&(nt=2*(re.length-1)-nt),ce[De++]=re[nt]}ce.sort(),ee[Re]=ce[X]}return ee}function Z(re,se){const ee=Math.pow(10,se);return Math.round(re*ee)/ee}function K(re){const se=Math.round(re);return Math.abs(re)%1===.5?se%2===0?se:se-1:se}function Q(re){const se=re.length,ee=re[0].length,ce=[se+1,ee+1],X=Array.from({length:ce[0]},()=>Array(ce[1]).fill(1/0));X[0][0]=0;const Re=Array.from({length:ce[0]},()=>Array(ce[1]).fill(-1));for(let _t=1;_t<ce[1];++_t)for(let gt=1;gt<ce[0];++gt){const Dt=X[gt-1][_t-1],Ge=X[gt-1][_t],ge=X[gt][_t-1];let ct,Ot;Dt<Ge&&Dt<ge?(ct=Dt,Ot=0):Ge<Dt&&Ge<ge?(ct=Ge,Ot=1):(ct=ge,Ot=2),X[gt][_t]=re[gt-1][_t-1]+ct,Re[gt][_t]=Ot}for(let _t=0;_t<ce[1];++_t)Re[0][_t]=2;for(let _t=0;_t<ce[0];++_t)Re[_t][0]=1;let De=se,et=ee,nt=[],it=[];for(;De>0||et>0;)switch(nt.push(De-1),it.push(et-1),Re[De][et]){case 0:--De,--et;break;case 1:--De;break;case 2:--et;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${De}, ${et}]. Please file a bug report.`)}return nt.reverse(),it.reverse(),[nt,it]}},"./src/utils/tensor.js":(e,r,i)=>{i.r(r),i.d(r,{Tensor:()=>h,cat:()=>re,full:()=>De,full_like:()=>et,interpolate:()=>u,interpolate_4d:()=>l,layer_norm:()=>A,matmul:()=>f,mean:()=>ce,mean_pooling:()=>R,ones:()=>nt,ones_like:()=>it,permute:()=>t,quantize_embeddings:()=>Dt,rfft:()=>x,stack:()=>se,std_mean:()=>ee,topk:()=>I,zeros:()=>_t,zeros_like:()=>gt});var s=i("./src/utils/maths.js"),c=i("./src/backends/onnx.js"),n=i("./src/ops/registry.js");const a=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class h{constructor(...ge){_r(this,"ort_tensor");return(0,c.isONNXTensor)(ge[0])?this.ort_tensor=ge[0]:this.ort_tensor=new c.Tensor(ge[0],ge[1],ge[2]),new Proxy(this,{get:(ct,Ot)=>{if(typeof Ot=="string"){let $t=Number(Ot);if(Number.isInteger($t))return ct._getitem($t)}return ct[Ot]},set:(ct,Ot,$t)=>ct[Ot]=$t})}get dims(){return this.ort_tensor.dims}set dims(ge){this.ort_tensor.dims=ge}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[ge,...ct]=this.dims;if(ct.length>0){const Ot=ct.reduce(($t,gr)=>$t*gr);for(let $t=0;$t<ge;++$t)yield this._subarray($t,Ot,ct)}else yield*this.data}_getitem(ge){const[ct,...Ot]=this.dims;if(ge=Q(ge,ct),Ot.length>0){const $t=Ot.reduce((gr,Qe)=>gr*Qe);return this._subarray(ge,$t,Ot)}else return new h(this.type,[this.data[ge]],Ot)}indexOf(ge){const ct=this.data;for(let Ot=0;Ot<ct.length;++Ot)if(ct[Ot]==ge)return Ot;return-1}_subarray(ge,ct,Ot){const $t=ge*ct,gr=(ge+1)*ct,Qe="subarray"in this.data?this.data.subarray($t,gr):this.data.slice($t,gr);return new h(this.type,Qe,Ot)}item(){const ge=this.data;if(ge.length!==1)throw new Error(`a Tensor with ${ge.length} elements cannot be converted to Scalar`);return ge[0]}tolist(){return p(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const ge=this.data;for(let ct=0;ct<ge.length;++ct)ge[ct]=1/(1+Math.exp(-ge[ct]));return this}map(ge){return this.clone().map_(ge)}map_(ge){const ct=this.data;for(let Ot=0;Ot<ct.length;++Ot)ct[Ot]=ge(ct[Ot],Ot,ct);return this}mul(ge){return this.clone().mul_(ge)}mul_(ge){const ct=this.data;for(let Ot=0;Ot<ct.length;++Ot)ct[Ot]*=ge;return this}div(ge){return this.clone().div_(ge)}div_(ge){const ct=this.data;for(let Ot=0;Ot<ct.length;++Ot)ct[Ot]/=ge;return this}add(ge){return this.clone().add_(ge)}add_(ge){const ct=this.data;for(let Ot=0;Ot<ct.length;++Ot)ct[Ot]+=ge;return this}sub(ge){return this.clone().sub_(ge)}sub_(ge){const ct=this.data;for(let Ot=0;Ot<ct.length;++Ot)ct[Ot]-=ge;return this}clone(){return new h(this.type,this.data.slice(),this.dims.slice())}slice(...ge){const ct=[],Ot=[];for(let vr=0;vr<this.dims.length;++vr){let Eo=ge[vr];if(Eo==null)Ot.push([0,this.dims[vr]]),ct.push(this.dims[vr]);else if(typeof Eo=="number")Eo=Q(Eo,this.dims[vr],vr),Ot.push([Eo,Eo+1]);else if(Array.isArray(Eo)&&Eo.length===2){let[Ao,Yr]=Eo;if(Ao=Ao===null?0:Q(Ao,this.dims[vr],vr,!1),Yr=Yr===null?this.dims[vr]:Q(Yr,this.dims[vr],vr,!1),Ao>Yr)throw new Error(`Invalid slice: ${Eo}`);const Ze=[Math.max(Ao,0),Math.min(Yr,this.dims[vr])];Ot.push(Ze),ct.push(Ze[1]-Ze[0])}else throw new Error(`Invalid slice: ${Eo}`)}const $t=Ot.map(([vr,Eo])=>Eo-vr),gr=$t.reduce((vr,Eo)=>vr*Eo),Qe=this.data,Dr=new Qe.constructor(gr),vn=this.stride();for(let vr=0;vr<gr;++vr){let Eo=0;for(let Ao=$t.length-1,Yr=vr;Ao>=0;--Ao){const Ze=$t[Ao];Eo+=(Yr%Ze+Ot[Ao][0])*vn[Ao],Yr=Math.floor(Yr/Ze)}Dr[vr]=Qe[Eo]}return new h(this.type,Dr,ct)}permute(...ge){return t(this,ge)}transpose(...ge){return this.permute(...ge)}sum(ge=null,ct=!1){return this.norm(1,ge,ct)}norm(ge="fro",ct=null,Ot=!1){if(ge==="fro")ge=2;else if(typeof ge=="string")throw Error(`Unsupported norm: ${ge}`);const $t=this.data;if(ct===null){let Dr=$t.reduce((vn,vr)=>vn+vr**ge,0)**(1/ge);return new h(this.type,[Dr],[])}ct=Q(ct,this.dims.length);const gr=this.dims.slice();gr[ct]=1;const Qe=new $t.constructor($t.length/this.dims[ct]);for(let Dr=0;Dr<$t.length;++Dr){let vn=0;for(let vr=this.dims.length-1,Eo=Dr,Ao=1;vr>=0;--vr){const Yr=this.dims[vr];if(vr!==ct){const Ze=Eo%Yr;vn+=Ze*Ao,Ao*=gr[vr]}Eo=Math.floor(Eo/Yr)}Qe[vn]+=$t[Dr]**ge}if(ge!==1)for(let Dr=0;Dr<Qe.length;++Dr)Qe[Dr]=Qe[Dr]**(1/ge);return Ot||gr.splice(ct,1),new h(this.type,Qe,gr)}normalize_(ge=2,ct=1){ct=Q(ct,this.dims.length);const Ot=this.norm(ge,ct,!0),$t=this.data,gr=Ot.data;for(let Qe=0;Qe<$t.length;++Qe){let Dr=0;for(let vn=this.dims.length-1,vr=Qe,Eo=1;vn>=0;--vn){const Ao=this.dims[vn];if(vn!==ct){const Yr=vr%Ao;Dr+=Yr*Eo,Eo*=this.dims[vn]}vr=Math.floor(vr/Ao)}$t[Qe]/=gr[Dr]}return this}normalize(ge=2,ct=1){return this.clone().normalize_(ge,ct)}stride(){return X(this.dims)}squeeze(ge=null){return new h(this.type,this.data,Z(this.dims,ge))}squeeze_(ge=null){return this.dims=Z(this.dims,ge),this}unsqueeze(ge=null){return new h(this.type,this.data,K(this.dims,ge))}unsqueeze_(ge=null){return this.dims=K(this.dims,ge),this}flatten_(ge=0,ct=-1){ct=(ct+this.dims.length)%this.dims.length;let Ot=this.dims.slice(0,ge),$t=this.dims.slice(ge,ct+1),gr=this.dims.slice(ct+1);return this.dims=[...Ot,$t.reduce((Qe,Dr)=>Qe*Dr,1),...gr],this}flatten(ge=0,ct=-1){return this.clone().flatten_(ge,ct)}view(...ge){let ct=-1;for(let $t=0;$t<ge.length;++$t)if(ge[$t]===-1){if(ct!==-1)throw new Error("Only one dimension can be inferred");ct=$t}const Ot=this.data;if(ct!==-1){const $t=ge.reduce((gr,Qe,Dr)=>Dr!==ct?gr*Qe:gr,1);ge[ct]=Ot.length/$t}return new h(this.type,Ot,ge)}neg_(){const ge=this.data;for(let ct=0;ct<ge.length;++ct)ge[ct]=-ge[ct];return this}neg(){return this.clone().neg_()}clamp_(ge,ct){const Ot=this.data;for(let $t=0;$t<Ot.length;++$t)Ot[$t]=Math.min(Math.max(Ot[$t],ge),ct);return this}clamp(ge,ct){return this.clone().clamp_(ge,ct)}round_(){const ge=this.data;for(let ct=0;ct<ge.length;++ct)ge[ct]=Math.round(ge[ct]);return this}round(){return this.clone().round_()}mean(ge=null,ct=!1){return ce(this,ge,ct)}to(ge){if(this.type===ge)return this;if(!a.hasOwnProperty(ge))throw new Error(`Unsupported type: ${ge}`);return new h(ge,a[ge].from(this.data),this.dims)}}function p(Ge,ge){const ct=Ge.length,Ot=ge.reduce((gr,Qe)=>gr*Qe);if(ct!==Ot)throw Error(`cannot reshape array of size ${ct} into shape (${ge})`);let $t=Ge;for(let gr=ge.length-1;gr>=0;gr--)$t=$t.reduce((Qe,Dr)=>{let vn=Qe[Qe.length-1];return vn.length<ge[gr]?vn.push(Dr):Qe.push([Dr]),Qe},[[]]);return $t[0]}function t(Ge,ge){const[ct,Ot]=(0,s.permute_data)(Ge.data,Ge.dims,ge);return new h(Ge.type,ct,Ot)}function u(Ge,[ge,ct],Ot="bilinear",$t=!1){const gr=Ge.dims.at(-3)??1,Qe=Ge.dims.at(-2),Dr=Ge.dims.at(-1);let vn=(0,s.interpolate_data)(Ge.data,[gr,Qe,Dr],[ge,ct],Ot,$t);return new h(Ge.type,vn,[gr,ge,ct])}async function l(Ge,{size:ge=null,mode:ct="bilinear"}={}){if(Ge.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!ge)throw new Error("`interpolate_4d` requires a `size` argument.");let Ot;if(ge.length===2)Ot=[...Ge.dims.slice(0,2),...ge];else if(ge.length===3)Ot=[Ge.dims[0],...ge];else if(ge.length===4)Ot=ge;else throw new Error("`size` must be of length 2, 3, or 4.");let $t;if(ct==="bilinear")$t=await n.TensorOpRegistry.bilinear_interpolate_4d;else if(ct==="bicubic")$t=await n.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${ct}`);const gr=new h("int64",new BigInt64Array(Ot.map(BigInt)),[Ot.length]);return await $t({x:Ge,s:gr})}async function f(Ge,ge){return await(await n.TensorOpRegistry.matmul)({a:Ge,b:ge})}async function x(Ge,ge){return await(await n.TensorOpRegistry.rfft)({x:Ge,a:ge})}async function I(Ge,ge){const ct=await n.TensorOpRegistry.top_k;return ge===null?ge=Ge.dims.at(-1):ge=Math.min(ge,Ge.dims.at(-1)),await ct({x:Ge,k:new h("int64",[BigInt(ge)],[1])})}function R(Ge,ge){const ct=Ge.data,Ot=ge.data,$t=[Ge.dims[0],Ge.dims[2]],gr=new ct.constructor($t[0]*$t[1]),[Qe,Dr,vn]=Ge.dims;let vr=0;for(let Eo=0;Eo<Qe;++Eo){const Ao=Eo*vn*Dr;for(let Yr=0;Yr<vn;++Yr){let Ze=0,er=0;const Kr=Eo*Dr,_o=Ao+Yr;for(let en=0;en<Dr;++en){const Bo=Number(Ot[Kr+en]);er+=Bo,Ze+=ct[_o+en*vn]*Bo}const Jr=Ze/er;gr[vr++]=Jr}}return new h(Ge.type,gr,$t)}function A(Ge,ge,{eps:ct=1e-5}={}){if(Ge.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[Ot,$t]=Ge.dims;if(ge.length!==1&&ge[0]!==$t)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[gr,Qe]=ee(Ge,1,0,!0),Dr=gr.data,vn=Qe.data,vr=Ge.data,Eo=new vr.constructor(vr.length);for(let Ao=0;Ao<Ot;++Ao){const Yr=Ao*$t;for(let Ze=0;Ze<$t;++Ze){const er=Yr+Ze;Eo[er]=(vr[er]-vn[Ao])/(Dr[Ao]+ct)}}return new h(Ge.type,Eo,Ge.dims)}function Z(Ge,ge){return Ge=Ge.slice(),ge===null?Ge=Ge.filter(ct=>ct!==1):typeof ge=="number"?Ge[ge]===1&&Ge.splice(ge,1):Array.isArray(ge)&&(Ge=Ge.filter((ct,Ot)=>ct!==1||!ge.includes(Ot))),Ge}function K(Ge,ge){return ge=Q(ge,Ge.length+1),Ge=Ge.slice(),Ge.splice(ge,0,1),Ge}function Q(Ge,ge,ct=null,Ot=!0){if(Ot&&(Ge<-ge||Ge>=ge))throw new Error(`IndexError: index ${Ge} is out of bounds for dimension${ct===null?"":" "+ct} with size ${ge}`);return Ge<0&&(Ge=(Ge%ge+ge)%ge),Ge}function re(Ge,ge=0){ge=Q(ge,Ge[0].dims.length);const ct=Ge[0].dims.slice();ct[ge]=Ge.reduce((Qe,Dr)=>Qe+Dr.dims[ge],0);const Ot=ct.reduce((Qe,Dr)=>Qe*Dr,1),$t=new Ge[0].data.constructor(Ot),gr=Ge[0].type;if(ge===0){let Qe=0;for(const Dr of Ge){const vn=Dr.data;$t.set(vn,Qe),Qe+=vn.length}}else{let Qe=0;for(let Dr=0;Dr<Ge.length;++Dr){const{data:vn,dims:vr}=Ge[Dr];for(let Eo=0;Eo<vn.length;++Eo){let Ao=0;for(let Yr=vr.length-1,Ze=Eo,er=1;Yr>=0;--Yr){const Kr=vr[Yr];let _o=Ze%Kr;Yr===ge&&(_o+=Qe),Ao+=_o*er,er*=ct[Yr],Ze=Math.floor(Ze/Kr)}$t[Ao]=vn[Eo]}Qe+=vr[ge]}}return new h(gr,$t,ct)}function se(Ge,ge=0){return re(Ge.map(ct=>ct.unsqueeze(ge)),ge)}function ee(Ge,ge=null,ct=1,Ot=!1){const $t=Ge.data,gr=Ge.dims;if(ge===null){const Yr=$t.reduce((_o,Jr)=>_o+Jr,0)/$t.length,Ze=Math.sqrt($t.reduce((_o,Jr)=>_o+(Jr-Yr)**2,0)/($t.length-ct)),er=new h(Ge.type,[Yr],[]);return[new h(Ge.type,[Ze],[]),er]}ge=Q(ge,gr.length);const Qe=ce(Ge,ge,Ot),Dr=Qe.data,vn=gr.slice();vn[ge]=1;const vr=new $t.constructor($t.length/gr[ge]);for(let Ao=0;Ao<$t.length;++Ao){let Yr=0;for(let Ze=gr.length-1,er=Ao,Kr=1;Ze>=0;--Ze){const _o=gr[Ze];if(Ze!==ge){const Jr=er%_o;Yr+=Jr*Kr,Kr*=vn[Ze]}er=Math.floor(er/_o)}vr[Yr]+=($t[Ao]-Dr[Yr])**2}for(let Ao=0;Ao<vr.length;++Ao)vr[Ao]=Math.sqrt(vr[Ao]/(gr[ge]-ct));return Ot||vn.splice(ge,1),[new h(Ge.type,vr,vn),Qe]}function ce(Ge,ge=null,ct=!1){const Ot=Ge.data;if(ge===null){const Dr=Ot.reduce((vn,vr)=>vn+vr,0);return new h(Ge.type,[Dr/Ot.length],[])}const $t=Ge.dims;ge=Q(ge,$t.length);const gr=$t.slice();gr[ge]=1;const Qe=new Ot.constructor(Ot.length/$t[ge]);for(let Dr=0;Dr<Ot.length;++Dr){let vn=0;for(let vr=$t.length-1,Eo=Dr,Ao=1;vr>=0;--vr){const Yr=$t[vr];if(vr!==ge){const Ze=Eo%Yr;vn+=Ze*Ao,Ao*=gr[vr]}Eo=Math.floor(Eo/Yr)}Qe[vn]+=Ot[Dr]}if($t[ge]!==1)for(let Dr=0;Dr<Qe.length;++Dr)Qe[Dr]=Qe[Dr]/$t[ge];return ct||gr.splice(ge,1),new h(Ge.type,Qe,gr)}function X(Ge){const ge=new Array(Ge.length);for(let ct=Ge.length-1,Ot=1;ct>=0;--ct)ge[ct]=Ot,Ot*=Ge[ct];return ge}function Re(Ge,ge,ct,Ot){const $t=Ge.reduce((gr,Qe)=>gr*Qe,1);return new h(ct,new Ot($t).fill(ge),Ge)}function De(Ge,ge){let ct,Ot;if(typeof ge=="number")ct="float32",Ot=Float32Array;else if(typeof ge=="bigint")ct="int64",Ot=BigInt64Array;else throw new Error(`Unsupported data type: ${typeof ge}`);return Re(Ge,ge,ct,Ot)}function et(Ge,ge){return De(Ge.dims,ge)}function nt(Ge){return Re(Ge,1n,"int64",BigInt64Array)}function it(Ge){return nt(Ge.dims)}function _t(Ge){return Re(Ge,0n,"int64",BigInt64Array)}function gt(Ge){return _t(Ge.dims)}function Dt(Ge,ge){if(Ge.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(Ge.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(ge))throw new Error("The precision must be either 'binary' or 'ubinary'");const ct=ge==="binary",Ot=ct?"int8":"uint8",$t=ct?Int8Array:Uint8Array,gr=Ge.data,Qe=new $t(gr.length/8);for(let Dr=0;Dr<gr.length;++Dr){const vn=gr[Dr]>0?1:0,vr=Math.floor(Dr/8),Eo=Dr%8;Qe[vr]|=vn<<7-Eo,ct&&Eo===0&&(Qe[vr]-=128)}return new h(Ot,Qe,[Ge.dims[0],Ge.dims[1]/8])}}},__webpack_module_cache__={};function __webpack_require__(e){var r=__webpack_module_cache__[e];if(r!==void 0)return r.exports;var i=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](i,i.exports,__webpack_require__),i.exports}__webpack_require__.m=__webpack_modules__;(()=>{var e=Object.getPrototypeOf?i=>Object.getPrototypeOf(i):i=>i.__proto__,r;__webpack_require__.t=function(i,s){if(s&1&&(i=this(i)),s&8||typeof i=="object"&&i&&(s&4&&i.__esModule||s&16&&typeof i.then=="function"))return i;var c=Object.create(null);__webpack_require__.r(c);var n={};r=r||[null,e({}),e([]),e(e)];for(var a=s&2&&i;typeof a=="object"&&!~r.indexOf(a);a=e(a))Object.getOwnPropertyNames(a).forEach(h=>n[h]=()=>i[h]);return n.default=()=>i,__webpack_require__.d(c,n),c}})();__webpack_require__.d=(e,r)=>{for(var i in r)__webpack_require__.o(r,i)&&!__webpack_require__.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})};__webpack_require__.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r);__webpack_require__.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};(()=>{var e;if(typeof import.meta.url=="string"&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e})();__webpack_require__.b=new URL("./",import.meta.url);var __webpack_exports__={};/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/__webpack_require__.r(__webpack_exports__);__webpack_require__.d(__webpack_exports__,{ASTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ASTFeatureExtractor,ASTForAudioClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ASTForAudioClassification,ASTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ASTModel,ASTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ASTPreTrainedModel,AlbertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification,AlbertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel,AlbertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel,AlbertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer,AudioClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.AudioClassificationPipeline,AutoConfig:()=>_configs_js__WEBPACK_IMPORTED_MODULE_5__.AutoConfig,AutoModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel,AutoModelForAudioClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioFrameClassification,AutoModelForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCTC,AutoModelForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation,AutoModelForImageToImage:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection,AutoModelForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq,AutoModelForXVector:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.AutoProcessor,AutoTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.AutomaticSpeechRecognitionPipeline,BartForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration,BartForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification,BartModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel,BartPretrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel,BartTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer,BaseModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput,BaseStreamer:()=>_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__.BaseStreamer,BeitFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.BeitFeatureExtractor,BeitForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BeitForImageClassification,BeitModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BeitModel,BeitPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BeitPreTrainedModel,BertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM,BertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering,BertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification,BertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification,BertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel,BertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel,BertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer,BitImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.BitImageProcessor,BlenderbotForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotForConditionalGeneration,BlenderbotModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotModel,BlenderbotPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotTokenizer,BloomForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BloomForCausalLM,BloomModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BloomModel,BloomPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.BloomPreTrainedModel,BloomTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer,CLIPFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.CLIPFeatureExtractor,CLIPImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.CLIPImageProcessor,CLIPModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel,CLIPPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegForImageSegmentation,CLIPSegModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegModel,CLIPSegPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegPreTrainedModel,CLIPTextModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModel,CLIPTextModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModelWithProjection,CLIPTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer,CLIPVisionModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModel,CLIPVisionModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForSequenceClassification,CamembertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForTokenClassification,CamembertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertModel,CamembertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertPreTrainedModel,CamembertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CamembertTokenizer,CausalLMOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutput,CausalLMOutputWithPast:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ClapFeatureExtractor,ClapModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapModel,ClapPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapPreTrainedModel,ClapTextModelWithProjection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ClapTextModelWithProjection,CodeGenForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM,CodeGenModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel,CodeGenPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel,CodeGenTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer,CodeLlamaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeLlamaTokenizer,CohereForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CohereForCausalLM,CohereModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CohereModel,CoherePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.CoherePreTrainedModel,CohereTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CohereTokenizer,ConvBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForTokenClassification,ConvBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertModel,ConvBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertPreTrainedModel,ConvBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ConvBertTokenizer,ConvNextFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextForImageClassification,ConvNextImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextImageProcessor,ConvNextModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextModel,ConvNextPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2ForImageClassification,ConvNextV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DPTFeatureExtractor,DPTForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DPTForDepthEstimation,DPTImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DPTImageProcessor,DPTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DPTModel,DPTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DPTPreTrainedModel,DebertaForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForSequenceClassification,DebertaForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForTokenClassification,DebertaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaModel,DebertaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaPreTrainedModel,DebertaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaTokenizer,DebertaV2ForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForTokenClassification,DebertaV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2Model,DebertaV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaV2Tokenizer,DecisionTransformerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DeiTFeatureExtractor,DeiTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTForImageClassification,DeiTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTModel,DeiTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.DepthEstimationPipeline,DepthProForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DepthProPreTrainedModel,DetrFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DetrFeatureExtractor,DetrForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection,DetrForSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation,DetrModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrModel,DetrObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel,DetrSegmentationOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput,Dinov2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2ForImageClassification,Dinov2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2Model,Dinov2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2PreTrainedModel,DistilBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification,DistilBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel,DistilBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel,DistilBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.DonutFeatureExtractor,DonutSwinModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinModel,DonutSwinPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.EfficientNetImageProcessor,EfficientNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetModel,EfficientNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForSequenceClassification,ElectraForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForTokenClassification,ElectraModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraModel,ElectraPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraPreTrainedModel,ElectraTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ElectraTokenizer,EosTokenCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.EosTokenCriteria,EsmForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForMaskedLM,EsmForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForSequenceClassification,EsmForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForTokenClassification,EsmModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmModel,EsmPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.EsmPreTrainedModel,EsmTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.EsmTokenizer,FFT:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT,FalconForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FalconForCausalLM,FalconModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FalconModel,FalconPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FalconPreTrainedModel,FalconTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer,FastViTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTForImageClassification,FastViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTModel,FastViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.FeatureExtractionPipeline,FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.FeatureExtractor,FillMaskPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.FillMaskPipeline,Florence2ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Florence2PreTrainedModel,Florence2Processor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Florence2Processor,GLPNFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNForDepthEstimation,GLPNModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNModel,GLPNPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNPreTrainedModel,GPT2LMHeadModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel,GPT2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model,GPT2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel,GPT2Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJForCausalLM,GPTJModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJModel,GPTJPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM,GPTNeoModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel,GPTNeoPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXForCausalLM,GPTNeoXModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2ForCausalLM,Gemma2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2Model,Gemma2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2PreTrainedModel,GemmaForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaForCausalLM,GemmaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaModel,GemmaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaPreTrainedModel,GemmaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GemmaTokenizer,GraniteForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteForCausalLM,GraniteModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteModel,GranitePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GranitePreTrainedModel,Grok1Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Grok1Tokenizer,GroupViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GroupViTModel,GroupViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.GroupViTPreTrainedModel,HerbertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.HerbertTokenizer,HieraForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HieraForImageClassification,HieraModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HieraModel,HieraPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HieraPreTrainedModel,HubertForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForCTC,HubertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForSequenceClassification,HubertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertModel,HubertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.HubertPreTrainedModel,ImageClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ImageFeatureExtractor,ImageMattingOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ImageMattingOutput,ImageSegmentationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageSegmentationPipeline,ImageToImagePipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageToImagePipeline,ImageToTextPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageToTextPipeline,InterruptableStoppingCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.InterruptableStoppingCriteria,JAISLMHeadModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.JAISLMHeadModel,JAISModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.JAISModel,JAISPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.JAISPreTrainedModel,LlamaForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaForCausalLM,LlamaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaModel,LlamaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaPreTrainedModel,LlamaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer,LlavaForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaForConditionalGeneration,LlavaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaPreTrainedModel,LongT5ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5ForConditionalGeneration,LongT5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5Model,LongT5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration,M2M100Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model,M2M100PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel,M2M100Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.M2M100Tokenizer,MBart50Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBart50Tokenizer,MBartForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForCausalLM,MBartForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForConditionalGeneration,MBartForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForSequenceClassification,MBartModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartModel,MBartPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MBartPreTrainedModel,MBartTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBartTokenizer,MPNetForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForSequenceClassification,MPNetForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForTokenClassification,MPNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetModel,MPNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetPreTrainedModel,MPNetTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer,MT5ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration,MT5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model,MT5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel,MarianMTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel,MarianModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel,MarianPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel,MarianTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer,MaskFormerFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerForInstanceSegmentation,MaskFormerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerModel,MaskFormerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerPreTrainedModel,MaskedLMOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput,MaxLengthCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.MaxLengthCriteria,MistralForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MistralForCausalLM,MistralModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MistralModel,MistralPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MistralPreTrainedModel,MobileBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification,MobileBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel,MobileBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel,MobileBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer,MobileNetV1FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1ForImageClassification,MobileNetV1Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2ForImageClassification,MobileNetV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3ForImageClassification,MobileNetV3Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4ForImageClassification,MobileNetV4Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification,MobileViTImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTImageProcessor,MobileViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTModel,MobileViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2ForImageClassification,MobileViTV2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2PreTrainedModel,ModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput,Moondream1ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Moondream1ForConditionalGeneration,MptForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MptForCausalLM,MptModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MptModel,MptPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MptPreTrainedModel,MusicgenForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenForConditionalGeneration,MusicgenModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenModel,MusicgenPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenPreTrainedModel,NllbTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer,NomicBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertModel,NomicBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertPreTrainedModel,NougatImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.NougatImageProcessor,NougatTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NougatTokenizer,OPTForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OPTForCausalLM,OPTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OPTModel,OPTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OPTPreTrainedModel,ObjectDetectionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ObjectDetectionPipeline,OpenELMForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMForCausalLM,OpenELMModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMModel,OpenELMPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTForObjectDetection,OwlViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTModel,OwlViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTPreTrainedModel,OwlViTProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.OwlViTProcessor,Owlv2ForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Owlv2ImageProcessor,Owlv2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2Model,Owlv2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2PreTrainedModel,Phi3ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3ForCausalLM,Phi3Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3Model,Phi3PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3PreTrainedModel,PhiForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PhiForCausalLM,PhiModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PhiModel,PhiPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PhiPreTrainedModel,Pipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.Pipeline,PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel,PreTrainedTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer,PretrainedConfig:()=>_configs_js__WEBPACK_IMPORTED_MODULE_5__.PretrainedConfig,PretrainedMixin:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin,Processor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Processor,PvtForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PvtForImageClassification,PvtImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.PvtImageProcessor,PvtModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PvtModel,PvtPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnoteModel,PyAnnotePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2ForCausalLM,Qwen2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2Model,Qwen2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Qwen2Tokenizer,RTDetrForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrForObjectDetection,RTDetrImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.RTDetrImageProcessor,RTDetrModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrModel,RTDetrObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrPreTrainedModel,RawImage:()=>_utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage,ResNetForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetForImageClassification,ResNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetModel,ResNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForTokenClassification,RoFormerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerModel,RoFormerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerPreTrainedModel,RoFormerTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RoFormerTokenizer,RobertaForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification,RobertaForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification,RobertaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel,RobertaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel,RobertaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer,SamImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SamImageProcessor,SamImageSegmentationOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput,SamModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel,SamPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel,SamProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SamProcessor,SapiensFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SapiensFeatureExtractor,SapiensForDepthEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SegformerFeatureExtractor,SegformerForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForSemanticSegmentation,SegformerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerModel,SegformerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput,SequenceClassifierOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput,SiglipImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SiglipImageProcessor,SiglipModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipModel,SiglipPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipPreTrainedModel,SiglipTextModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipTextModel,SiglipTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SiglipTokenizer,SiglipVisionModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipVisionModel,SpeechT5FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5HifiGan,SpeechT5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5Model,SpeechT5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5PreTrainedModel,SpeechT5Processor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.SpeechT5Processor,SpeechT5Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer,StableLmForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmForCausalLM,StableLmModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmModel,StableLmPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2ForCausalLM,Starcoder2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2Model,Starcoder2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2PreTrainedModel,StoppingCriteria:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.StoppingCriteria,StoppingCriteriaList:()=>_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__.StoppingCriteriaList,SummarizationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.SummarizationPipeline,Swin2SRForImageSuperResolution:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Swin2SRImageProcessor,Swin2SRModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRModel,Swin2SRPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRPreTrainedModel,SwinForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SwinForImageClassification,SwinModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SwinModel,SwinPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.SwinPreTrainedModel,T5ForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration,T5Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model,T5PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel,T5Tokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer,TableTransformerForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerForObjectDetection,TableTransformerModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerPreTrainedModel,Tensor:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor,Text2TextGenerationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.Text2TextGenerationPipeline,TextClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextClassificationPipeline,TextGenerationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextGenerationPipeline,TextStreamer:()=>_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__.TextStreamer,TextToAudioPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextToAudioPipeline,TokenClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TokenClassificationPipeline,TokenClassifierOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput,TokenizerModel:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel,TrOCRForCausalLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRPreTrainedModel,TranslationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TranslationPipeline,UniSpeechForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForSequenceClassification,UniSpeechModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechModel,UniSpeechPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatPreTrainedModel,ViTFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTFeatureExtractor,ViTForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification,ViTImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTImageProcessor,ViTMAEModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMAEModel,ViTMAEPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNForImageClassification,ViTMSNModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNModel,ViTMSNPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNPreTrainedModel,ViTModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTModel,ViTPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitMatteForImageMatting,VitMatteImageProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.VitMatteImageProcessor,VitMattePreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitMattePreTrainedModel,VitsModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModel,VitsModelOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModelOutput,VitsPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.VitsPreTrainedModel,VitsTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.VitsTokenizer,Wav2Vec2BertForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2PreTrainedModel,Wav2Vec2ProcessorWithLM:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForAudioFrameClassification,WavLMForCTC:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForCTC,WavLMForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForSequenceClassification,WavLMForXVector:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForXVector,WavLMModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMModel,WavLMPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration,WhisperModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel,WhisperPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel,WhisperProcessor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperProcessor,WhisperTextStreamer:()=>_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__.WhisperTextStreamer,WhisperTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer,XLMForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForQuestionAnswering,XLMForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForSequenceClassification,XLMForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForTokenClassification,XLMModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMModel,XLMPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification,XLMRobertaModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer,XLMTokenizer:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMTokenizer,XLMWithLMHeadModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XLMWithLMHeadModel,XVectorOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.XVectorOutput,YolosFeatureExtractor:()=>_processors_js__WEBPACK_IMPORTED_MODULE_4__.YolosFeatureExtractor,YolosForObjectDetection:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosForObjectDetection,YolosModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosModel,YolosObjectDetectionOutput:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>_models_js__WEBPACK_IMPORTED_MODULE_2__.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotObjectDetectionPipeline,bankers_round:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.bankers_round,cat:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat,cos_sim:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim,dot:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot,dynamic_time_warping:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dynamic_time_warping,env:()=>_env_js__WEBPACK_IMPORTED_MODULE_0__.env,full:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.full,full_like:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.full_like,getKeyValueShapes:()=>_configs_js__WEBPACK_IMPORTED_MODULE_5__.getKeyValueShapes,hamming:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.hamming,hanning:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.hanning,interpolate:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate,interpolate_4d:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate_4d,interpolate_data:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data,is_chinese_char:()=>_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.is_chinese_char,layer_norm:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.layer_norm,log_softmax:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax,magnitude:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude,matmul:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.matmul,max:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max,mean:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean,mean_pooling:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling,medianFilter:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter,mel_filter_bank:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.mel_filter_bank,min:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min,ones:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones,ones_like:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones_like,permute:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.permute,permute_data:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.permute_data,pipeline:()=>_pipelines_js__WEBPACK_IMPORTED_MODULE_1__.pipeline,quantize_embeddings:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.quantize_embeddings,read_audio:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.read_audio,rfft:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.rfft,round:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round,softmax:()=>_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax,spectrogram:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.spectrogram,stack:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack,std_mean:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean,topk:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk,window_function:()=>_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.window_function,zeros:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.zeros,zeros_like:()=>_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.zeros_like});var _env_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./src/env.js"),_pipelines_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/pipelines.js"),_models_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./src/models.js"),_tokenizers_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./src/tokenizers.js"),_processors_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./src/processors.js"),_configs_js__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./src/configs.js"),_utils_audio_js__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./src/utils/audio.js"),_utils_image_js__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__("./src/utils/image.js"),_utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__("./src/utils/tensor.js"),_utils_maths_js__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__("./src/utils/maths.js"),_generation_streamers_js__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__("./src/generation/streamers.js"),_generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__("./src/generation/stopping_criteria.js");__webpack_exports__.ASTFeatureExtractor;__webpack_exports__.ASTForAudioClassification;__webpack_exports__.ASTModel;__webpack_exports__.ASTPreTrainedModel;__webpack_exports__.AlbertForMaskedLM;__webpack_exports__.AlbertForQuestionAnswering;__webpack_exports__.AlbertForSequenceClassification;__webpack_exports__.AlbertModel;__webpack_exports__.AlbertPreTrainedModel;__webpack_exports__.AlbertTokenizer;__webpack_exports__.AudioClassificationPipeline;__webpack_exports__.AutoConfig;var __webpack_exports__AutoModel=__webpack_exports__.AutoModel;__webpack_exports__.AutoModelForAudioClassification;__webpack_exports__.AutoModelForAudioFrameClassification;__webpack_exports__.AutoModelForCTC;__webpack_exports__.AutoModelForCausalLM;__webpack_exports__.AutoModelForDepthEstimation;__webpack_exports__.AutoModelForDocumentQuestionAnswering;__webpack_exports__.AutoModelForImageClassification;__webpack_exports__.AutoModelForImageFeatureExtraction;__webpack_exports__.AutoModelForImageMatting;__webpack_exports__.AutoModelForImageSegmentation;__webpack_exports__.AutoModelForImageToImage;__webpack_exports__.AutoModelForMaskGeneration;__webpack_exports__.AutoModelForMaskedLM;__webpack_exports__.AutoModelForNormalEstimation;__webpack_exports__.AutoModelForObjectDetection;__webpack_exports__.AutoModelForQuestionAnswering;__webpack_exports__.AutoModelForSemanticSegmentation;__webpack_exports__.AutoModelForSeq2SeqLM;__webpack_exports__.AutoModelForSequenceClassification;__webpack_exports__.AutoModelForSpeechSeq2Seq;__webpack_exports__.AutoModelForTextToSpectrogram;__webpack_exports__.AutoModelForTextToWaveform;__webpack_exports__.AutoModelForTokenClassification;__webpack_exports__.AutoModelForUniversalSegmentation;__webpack_exports__.AutoModelForVision2Seq;__webpack_exports__.AutoModelForXVector;__webpack_exports__.AutoModelForZeroShotObjectDetection;__webpack_exports__.AutoProcessor;var __webpack_exports__AutoTokenizer=__webpack_exports__.AutoTokenizer;__webpack_exports__.AutomaticSpeechRecognitionPipeline;__webpack_exports__.BartForConditionalGeneration;__webpack_exports__.BartForSequenceClassification;__webpack_exports__.BartModel;__webpack_exports__.BartPretrainedModel;__webpack_exports__.BartTokenizer;__webpack_exports__.BaseModelOutput;__webpack_exports__.BaseStreamer;__webpack_exports__.BeitFeatureExtractor;__webpack_exports__.BeitForImageClassification;__webpack_exports__.BeitModel;__webpack_exports__.BeitPreTrainedModel;__webpack_exports__.BertForMaskedLM;__webpack_exports__.BertForQuestionAnswering;__webpack_exports__.BertForSequenceClassification;__webpack_exports__.BertForTokenClassification;__webpack_exports__.BertModel;__webpack_exports__.BertPreTrainedModel;__webpack_exports__.BertTokenizer;__webpack_exports__.BitImageProcessor;__webpack_exports__.BlenderbotForConditionalGeneration;__webpack_exports__.BlenderbotModel;__webpack_exports__.BlenderbotPreTrainedModel;__webpack_exports__.BlenderbotSmallForConditionalGeneration;__webpack_exports__.BlenderbotSmallModel;__webpack_exports__.BlenderbotSmallPreTrainedModel;__webpack_exports__.BlenderbotSmallTokenizer;__webpack_exports__.BlenderbotTokenizer;__webpack_exports__.BloomForCausalLM;__webpack_exports__.BloomModel;__webpack_exports__.BloomPreTrainedModel;__webpack_exports__.BloomTokenizer;__webpack_exports__.CLIPFeatureExtractor;__webpack_exports__.CLIPImageProcessor;__webpack_exports__.CLIPModel;__webpack_exports__.CLIPPreTrainedModel;__webpack_exports__.CLIPSegForImageSegmentation;__webpack_exports__.CLIPSegModel;__webpack_exports__.CLIPSegPreTrainedModel;__webpack_exports__.CLIPTextModel;__webpack_exports__.CLIPTextModelWithProjection;__webpack_exports__.CLIPTokenizer;__webpack_exports__.CLIPVisionModel;__webpack_exports__.CLIPVisionModelWithProjection;__webpack_exports__.CamembertForMaskedLM;__webpack_exports__.CamembertForQuestionAnswering;__webpack_exports__.CamembertForSequenceClassification;__webpack_exports__.CamembertForTokenClassification;__webpack_exports__.CamembertModel;__webpack_exports__.CamembertPreTrainedModel;__webpack_exports__.CamembertTokenizer;__webpack_exports__.CausalLMOutput;__webpack_exports__.CausalLMOutputWithPast;__webpack_exports__.ChineseCLIPFeatureExtractor;__webpack_exports__.ChineseCLIPModel;__webpack_exports__.ChineseCLIPPreTrainedModel;__webpack_exports__.ClapAudioModelWithProjection;__webpack_exports__.ClapFeatureExtractor;__webpack_exports__.ClapModel;__webpack_exports__.ClapPreTrainedModel;__webpack_exports__.ClapTextModelWithProjection;__webpack_exports__.CodeGenForCausalLM;__webpack_exports__.CodeGenModel;__webpack_exports__.CodeGenPreTrainedModel;__webpack_exports__.CodeGenTokenizer;__webpack_exports__.CodeLlamaTokenizer;__webpack_exports__.CohereForCausalLM;__webpack_exports__.CohereModel;__webpack_exports__.CoherePreTrainedModel;__webpack_exports__.CohereTokenizer;__webpack_exports__.ConvBertForMaskedLM;__webpack_exports__.ConvBertForQuestionAnswering;__webpack_exports__.ConvBertForSequenceClassification;__webpack_exports__.ConvBertForTokenClassification;__webpack_exports__.ConvBertModel;__webpack_exports__.ConvBertPreTrainedModel;__webpack_exports__.ConvBertTokenizer;__webpack_exports__.ConvNextFeatureExtractor;__webpack_exports__.ConvNextForImageClassification;__webpack_exports__.ConvNextImageProcessor;__webpack_exports__.ConvNextModel;__webpack_exports__.ConvNextPreTrainedModel;__webpack_exports__.ConvNextV2ForImageClassification;__webpack_exports__.ConvNextV2Model;__webpack_exports__.ConvNextV2PreTrainedModel;__webpack_exports__.DPTFeatureExtractor;__webpack_exports__.DPTForDepthEstimation;__webpack_exports__.DPTImageProcessor;__webpack_exports__.DPTModel;__webpack_exports__.DPTPreTrainedModel;__webpack_exports__.DebertaForMaskedLM;__webpack_exports__.DebertaForQuestionAnswering;__webpack_exports__.DebertaForSequenceClassification;__webpack_exports__.DebertaForTokenClassification;__webpack_exports__.DebertaModel;__webpack_exports__.DebertaPreTrainedModel;__webpack_exports__.DebertaTokenizer;__webpack_exports__.DebertaV2ForMaskedLM;__webpack_exports__.DebertaV2ForQuestionAnswering;__webpack_exports__.DebertaV2ForSequenceClassification;__webpack_exports__.DebertaV2ForTokenClassification;__webpack_exports__.DebertaV2Model;__webpack_exports__.DebertaV2PreTrainedModel;__webpack_exports__.DebertaV2Tokenizer;__webpack_exports__.DecisionTransformerModel;__webpack_exports__.DecisionTransformerPreTrainedModel;__webpack_exports__.DeiTFeatureExtractor;__webpack_exports__.DeiTForImageClassification;__webpack_exports__.DeiTModel;__webpack_exports__.DeiTPreTrainedModel;__webpack_exports__.DepthAnythingForDepthEstimation;__webpack_exports__.DepthAnythingPreTrainedModel;__webpack_exports__.DepthEstimationPipeline;__webpack_exports__.DepthProForDepthEstimation;__webpack_exports__.DepthProPreTrainedModel;__webpack_exports__.DetrFeatureExtractor;__webpack_exports__.DetrForObjectDetection;__webpack_exports__.DetrForSegmentation;__webpack_exports__.DetrModel;__webpack_exports__.DetrObjectDetectionOutput;__webpack_exports__.DetrPreTrainedModel;__webpack_exports__.DetrSegmentationOutput;__webpack_exports__.Dinov2ForImageClassification;__webpack_exports__.Dinov2Model;__webpack_exports__.Dinov2PreTrainedModel;__webpack_exports__.DistilBertForMaskedLM;__webpack_exports__.DistilBertForQuestionAnswering;__webpack_exports__.DistilBertForSequenceClassification;__webpack_exports__.DistilBertForTokenClassification;__webpack_exports__.DistilBertModel;__webpack_exports__.DistilBertPreTrainedModel;__webpack_exports__.DistilBertTokenizer;__webpack_exports__.DocumentQuestionAnsweringPipeline;__webpack_exports__.DonutFeatureExtractor;__webpack_exports__.DonutSwinModel;__webpack_exports__.DonutSwinPreTrainedModel;__webpack_exports__.EfficientNetForImageClassification;__webpack_exports__.EfficientNetImageProcessor;__webpack_exports__.EfficientNetModel;__webpack_exports__.EfficientNetPreTrainedModel;__webpack_exports__.ElectraForMaskedLM;__webpack_exports__.ElectraForQuestionAnswering;__webpack_exports__.ElectraForSequenceClassification;__webpack_exports__.ElectraForTokenClassification;__webpack_exports__.ElectraModel;__webpack_exports__.ElectraPreTrainedModel;__webpack_exports__.ElectraTokenizer;__webpack_exports__.EosTokenCriteria;__webpack_exports__.EsmForMaskedLM;__webpack_exports__.EsmForSequenceClassification;__webpack_exports__.EsmForTokenClassification;__webpack_exports__.EsmModel;__webpack_exports__.EsmPreTrainedModel;__webpack_exports__.EsmTokenizer;__webpack_exports__.FFT;__webpack_exports__.FalconForCausalLM;__webpack_exports__.FalconModel;__webpack_exports__.FalconPreTrainedModel;__webpack_exports__.FalconTokenizer;__webpack_exports__.FastViTForImageClassification;__webpack_exports__.FastViTModel;__webpack_exports__.FastViTPreTrainedModel;__webpack_exports__.FeatureExtractionPipeline;__webpack_exports__.FeatureExtractor;__webpack_exports__.FillMaskPipeline;__webpack_exports__.Florence2ForConditionalGeneration;__webpack_exports__.Florence2PreTrainedModel;__webpack_exports__.Florence2Processor;__webpack_exports__.GLPNFeatureExtractor;__webpack_exports__.GLPNForDepthEstimation;__webpack_exports__.GLPNModel;__webpack_exports__.GLPNPreTrainedModel;__webpack_exports__.GPT2LMHeadModel;__webpack_exports__.GPT2Model;__webpack_exports__.GPT2PreTrainedModel;__webpack_exports__.GPT2Tokenizer;__webpack_exports__.GPTBigCodeForCausalLM;__webpack_exports__.GPTBigCodeModel;__webpack_exports__.GPTBigCodePreTrainedModel;__webpack_exports__.GPTJForCausalLM;__webpack_exports__.GPTJModel;__webpack_exports__.GPTJPreTrainedModel;__webpack_exports__.GPTNeoForCausalLM;__webpack_exports__.GPTNeoModel;__webpack_exports__.GPTNeoPreTrainedModel;__webpack_exports__.GPTNeoXForCausalLM;__webpack_exports__.GPTNeoXModel;__webpack_exports__.GPTNeoXPreTrainedModel;__webpack_exports__.GPTNeoXTokenizer;__webpack_exports__.Gemma2ForCausalLM;__webpack_exports__.Gemma2Model;__webpack_exports__.Gemma2PreTrainedModel;__webpack_exports__.GemmaForCausalLM;__webpack_exports__.GemmaModel;__webpack_exports__.GemmaPreTrainedModel;__webpack_exports__.GemmaTokenizer;__webpack_exports__.GraniteForCausalLM;__webpack_exports__.GraniteModel;__webpack_exports__.GranitePreTrainedModel;__webpack_exports__.Grok1Tokenizer;__webpack_exports__.GroupViTModel;__webpack_exports__.GroupViTPreTrainedModel;__webpack_exports__.HerbertTokenizer;__webpack_exports__.HieraForImageClassification;__webpack_exports__.HieraModel;__webpack_exports__.HieraPreTrainedModel;__webpack_exports__.HubertForCTC;__webpack_exports__.HubertForSequenceClassification;__webpack_exports__.HubertModel;__webpack_exports__.HubertPreTrainedModel;__webpack_exports__.ImageClassificationPipeline;__webpack_exports__.ImageFeatureExtractionPipeline;__webpack_exports__.ImageFeatureExtractor;__webpack_exports__.ImageMattingOutput;__webpack_exports__.ImageSegmentationPipeline;__webpack_exports__.ImageToImagePipeline;__webpack_exports__.ImageToTextPipeline;__webpack_exports__.InterruptableStoppingCriteria;__webpack_exports__.JAISLMHeadModel;__webpack_exports__.JAISModel;__webpack_exports__.JAISPreTrainedModel;__webpack_exports__.LlamaForCausalLM;__webpack_exports__.LlamaModel;__webpack_exports__.LlamaPreTrainedModel;__webpack_exports__.LlamaTokenizer;__webpack_exports__.LlavaForConditionalGeneration;__webpack_exports__.LlavaPreTrainedModel;__webpack_exports__.LongT5ForConditionalGeneration;__webpack_exports__.LongT5Model;__webpack_exports__.LongT5PreTrainedModel;__webpack_exports__.M2M100ForConditionalGeneration;__webpack_exports__.M2M100Model;__webpack_exports__.M2M100PreTrainedModel;__webpack_exports__.M2M100Tokenizer;__webpack_exports__.MBart50Tokenizer;__webpack_exports__.MBartForCausalLM;__webpack_exports__.MBartForConditionalGeneration;__webpack_exports__.MBartForSequenceClassification;__webpack_exports__.MBartModel;__webpack_exports__.MBartPreTrainedModel;__webpack_exports__.MBartTokenizer;__webpack_exports__.MPNetForMaskedLM;__webpack_exports__.MPNetForQuestionAnswering;__webpack_exports__.MPNetForSequenceClassification;__webpack_exports__.MPNetForTokenClassification;__webpack_exports__.MPNetModel;__webpack_exports__.MPNetPreTrainedModel;__webpack_exports__.MPNetTokenizer;__webpack_exports__.MT5ForConditionalGeneration;__webpack_exports__.MT5Model;__webpack_exports__.MT5PreTrainedModel;__webpack_exports__.MarianMTModel;__webpack_exports__.MarianModel;__webpack_exports__.MarianPreTrainedModel;__webpack_exports__.MarianTokenizer;__webpack_exports__.MaskFormerFeatureExtractor;__webpack_exports__.MaskFormerForInstanceSegmentation;__webpack_exports__.MaskFormerModel;__webpack_exports__.MaskFormerPreTrainedModel;__webpack_exports__.MaskedLMOutput;__webpack_exports__.MaxLengthCriteria;__webpack_exports__.MistralForCausalLM;__webpack_exports__.MistralModel;__webpack_exports__.MistralPreTrainedModel;__webpack_exports__.MobileBertForMaskedLM;__webpack_exports__.MobileBertForQuestionAnswering;__webpack_exports__.MobileBertForSequenceClassification;__webpack_exports__.MobileBertModel;__webpack_exports__.MobileBertPreTrainedModel;__webpack_exports__.MobileBertTokenizer;__webpack_exports__.MobileNetV1FeatureExtractor;__webpack_exports__.MobileNetV1ForImageClassification;__webpack_exports__.MobileNetV1Model;__webpack_exports__.MobileNetV1PreTrainedModel;__webpack_exports__.MobileNetV2FeatureExtractor;__webpack_exports__.MobileNetV2ForImageClassification;__webpack_exports__.MobileNetV2Model;__webpack_exports__.MobileNetV2PreTrainedModel;__webpack_exports__.MobileNetV3FeatureExtractor;__webpack_exports__.MobileNetV3ForImageClassification;__webpack_exports__.MobileNetV3Model;__webpack_exports__.MobileNetV3PreTrainedModel;__webpack_exports__.MobileNetV4FeatureExtractor;__webpack_exports__.MobileNetV4ForImageClassification;__webpack_exports__.MobileNetV4Model;__webpack_exports__.MobileNetV4PreTrainedModel;__webpack_exports__.MobileViTFeatureExtractor;__webpack_exports__.MobileViTForImageClassification;__webpack_exports__.MobileViTImageProcessor;__webpack_exports__.MobileViTModel;__webpack_exports__.MobileViTPreTrainedModel;__webpack_exports__.MobileViTV2ForImageClassification;__webpack_exports__.MobileViTV2Model;__webpack_exports__.MobileViTV2PreTrainedModel;__webpack_exports__.ModelOutput;__webpack_exports__.Moondream1ForConditionalGeneration;__webpack_exports__.MptForCausalLM;__webpack_exports__.MptModel;__webpack_exports__.MptPreTrainedModel;__webpack_exports__.MusicgenForCausalLM;__webpack_exports__.MusicgenForConditionalGeneration;__webpack_exports__.MusicgenModel;__webpack_exports__.MusicgenPreTrainedModel;__webpack_exports__.NllbTokenizer;__webpack_exports__.NomicBertModel;__webpack_exports__.NomicBertPreTrainedModel;__webpack_exports__.NougatImageProcessor;__webpack_exports__.NougatTokenizer;__webpack_exports__.OPTForCausalLM;__webpack_exports__.OPTModel;__webpack_exports__.OPTPreTrainedModel;__webpack_exports__.ObjectDetectionPipeline;__webpack_exports__.OpenELMForCausalLM;__webpack_exports__.OpenELMModel;__webpack_exports__.OpenELMPreTrainedModel;__webpack_exports__.OwlViTFeatureExtractor;__webpack_exports__.OwlViTForObjectDetection;__webpack_exports__.OwlViTModel;__webpack_exports__.OwlViTPreTrainedModel;__webpack_exports__.OwlViTProcessor;__webpack_exports__.Owlv2ForObjectDetection;__webpack_exports__.Owlv2ImageProcessor;__webpack_exports__.Owlv2Model;__webpack_exports__.Owlv2PreTrainedModel;__webpack_exports__.Phi3ForCausalLM;__webpack_exports__.Phi3Model;__webpack_exports__.Phi3PreTrainedModel;__webpack_exports__.PhiForCausalLM;__webpack_exports__.PhiModel;__webpack_exports__.PhiPreTrainedModel;__webpack_exports__.Pipeline;__webpack_exports__.PreTrainedModel;__webpack_exports__.PreTrainedTokenizer;__webpack_exports__.PretrainedConfig;__webpack_exports__.PretrainedMixin;__webpack_exports__.Processor;__webpack_exports__.PvtForImageClassification;__webpack_exports__.PvtImageProcessor;__webpack_exports__.PvtModel;__webpack_exports__.PvtPreTrainedModel;__webpack_exports__.PyAnnoteFeatureExtractor;__webpack_exports__.PyAnnoteForAudioFrameClassification;__webpack_exports__.PyAnnoteModel;__webpack_exports__.PyAnnotePreTrainedModel;__webpack_exports__.PyAnnoteProcessor;__webpack_exports__.QuestionAnsweringModelOutput;__webpack_exports__.QuestionAnsweringPipeline;__webpack_exports__.Qwen2ForCausalLM;__webpack_exports__.Qwen2Model;__webpack_exports__.Qwen2PreTrainedModel;__webpack_exports__.Qwen2Tokenizer;__webpack_exports__.RTDetrForObjectDetection;__webpack_exports__.RTDetrImageProcessor;__webpack_exports__.RTDetrModel;__webpack_exports__.RTDetrObjectDetectionOutput;__webpack_exports__.RTDetrPreTrainedModel;__webpack_exports__.RawImage;__webpack_exports__.ResNetForImageClassification;__webpack_exports__.ResNetModel;__webpack_exports__.ResNetPreTrainedModel;__webpack_exports__.RoFormerForMaskedLM;__webpack_exports__.RoFormerForQuestionAnswering;__webpack_exports__.RoFormerForSequenceClassification;__webpack_exports__.RoFormerForTokenClassification;__webpack_exports__.RoFormerModel;__webpack_exports__.RoFormerPreTrainedModel;__webpack_exports__.RoFormerTokenizer;__webpack_exports__.RobertaForMaskedLM;__webpack_exports__.RobertaForQuestionAnswering;__webpack_exports__.RobertaForSequenceClassification;__webpack_exports__.RobertaForTokenClassification;__webpack_exports__.RobertaModel;__webpack_exports__.RobertaPreTrainedModel;__webpack_exports__.RobertaTokenizer;__webpack_exports__.SamImageProcessor;__webpack_exports__.SamImageSegmentationOutput;__webpack_exports__.SamModel;__webpack_exports__.SamPreTrainedModel;__webpack_exports__.SamProcessor;__webpack_exports__.SapiensFeatureExtractor;__webpack_exports__.SapiensForDepthEstimation;__webpack_exports__.SapiensForNormalEstimation;__webpack_exports__.SapiensForSemanticSegmentation;__webpack_exports__.SapiensPreTrainedModel;__webpack_exports__.SeamlessM4TFeatureExtractor;__webpack_exports__.SegformerFeatureExtractor;__webpack_exports__.SegformerForImageClassification;__webpack_exports__.SegformerForSemanticSegmentation;__webpack_exports__.SegformerModel;__webpack_exports__.SegformerPreTrainedModel;__webpack_exports__.Seq2SeqLMOutput;__webpack_exports__.SequenceClassifierOutput;__webpack_exports__.SiglipImageProcessor;__webpack_exports__.SiglipModel;__webpack_exports__.SiglipPreTrainedModel;__webpack_exports__.SiglipTextModel;__webpack_exports__.SiglipTokenizer;__webpack_exports__.SiglipVisionModel;__webpack_exports__.SpeechT5FeatureExtractor;__webpack_exports__.SpeechT5ForSpeechToText;__webpack_exports__.SpeechT5ForTextToSpeech;__webpack_exports__.SpeechT5HifiGan;__webpack_exports__.SpeechT5Model;__webpack_exports__.SpeechT5PreTrainedModel;__webpack_exports__.SpeechT5Processor;__webpack_exports__.SpeechT5Tokenizer;__webpack_exports__.SqueezeBertForMaskedLM;__webpack_exports__.SqueezeBertForQuestionAnswering;__webpack_exports__.SqueezeBertForSequenceClassification;__webpack_exports__.SqueezeBertModel;__webpack_exports__.SqueezeBertPreTrainedModel;__webpack_exports__.SqueezeBertTokenizer;__webpack_exports__.StableLmForCausalLM;__webpack_exports__.StableLmModel;__webpack_exports__.StableLmPreTrainedModel;__webpack_exports__.Starcoder2ForCausalLM;__webpack_exports__.Starcoder2Model;__webpack_exports__.Starcoder2PreTrainedModel;__webpack_exports__.StoppingCriteria;__webpack_exports__.StoppingCriteriaList;__webpack_exports__.SummarizationPipeline;__webpack_exports__.Swin2SRForImageSuperResolution;__webpack_exports__.Swin2SRImageProcessor;__webpack_exports__.Swin2SRModel;__webpack_exports__.Swin2SRPreTrainedModel;__webpack_exports__.SwinForImageClassification;__webpack_exports__.SwinModel;__webpack_exports__.SwinPreTrainedModel;__webpack_exports__.T5ForConditionalGeneration;__webpack_exports__.T5Model;__webpack_exports__.T5PreTrainedModel;__webpack_exports__.T5Tokenizer;__webpack_exports__.TableTransformerForObjectDetection;__webpack_exports__.TableTransformerModel;__webpack_exports__.TableTransformerObjectDetectionOutput;__webpack_exports__.TableTransformerPreTrainedModel;__webpack_exports__.Tensor;__webpack_exports__.Text2TextGenerationPipeline;__webpack_exports__.TextClassificationPipeline;__webpack_exports__.TextGenerationPipeline;__webpack_exports__.TextStreamer;__webpack_exports__.TextToAudioPipeline;__webpack_exports__.TokenClassificationPipeline;__webpack_exports__.TokenClassifierOutput;__webpack_exports__.TokenizerModel;__webpack_exports__.TrOCRForCausalLM;__webpack_exports__.TrOCRPreTrainedModel;__webpack_exports__.TranslationPipeline;__webpack_exports__.UniSpeechForCTC;__webpack_exports__.UniSpeechForSequenceClassification;__webpack_exports__.UniSpeechModel;__webpack_exports__.UniSpeechPreTrainedModel;__webpack_exports__.UniSpeechSatForAudioFrameClassification;__webpack_exports__.UniSpeechSatForCTC;__webpack_exports__.UniSpeechSatForSequenceClassification;__webpack_exports__.UniSpeechSatModel;__webpack_exports__.UniSpeechSatPreTrainedModel;__webpack_exports__.ViTFeatureExtractor;__webpack_exports__.ViTForImageClassification;__webpack_exports__.ViTImageProcessor;__webpack_exports__.ViTMAEModel;__webpack_exports__.ViTMAEPreTrainedModel;__webpack_exports__.ViTMSNForImageClassification;__webpack_exports__.ViTMSNModel;__webpack_exports__.ViTMSNPreTrainedModel;__webpack_exports__.ViTModel;__webpack_exports__.ViTPreTrainedModel;__webpack_exports__.VisionEncoderDecoderModel;__webpack_exports__.VitMatteForImageMatting;__webpack_exports__.VitMatteImageProcessor;__webpack_exports__.VitMattePreTrainedModel;__webpack_exports__.VitsModel;__webpack_exports__.VitsModelOutput;__webpack_exports__.VitsPreTrainedModel;__webpack_exports__.VitsTokenizer;__webpack_exports__.Wav2Vec2BertForCTC;__webpack_exports__.Wav2Vec2BertForSequenceClassification;__webpack_exports__.Wav2Vec2BertModel;__webpack_exports__.Wav2Vec2BertPreTrainedModel;__webpack_exports__.Wav2Vec2CTCTokenizer;__webpack_exports__.Wav2Vec2FeatureExtractor;__webpack_exports__.Wav2Vec2ForAudioFrameClassification;__webpack_exports__.Wav2Vec2ForCTC;__webpack_exports__.Wav2Vec2ForSequenceClassification;__webpack_exports__.Wav2Vec2Model;__webpack_exports__.Wav2Vec2PreTrainedModel;__webpack_exports__.Wav2Vec2ProcessorWithLM;__webpack_exports__.WavLMForAudioFrameClassification;__webpack_exports__.WavLMForCTC;__webpack_exports__.WavLMForSequenceClassification;__webpack_exports__.WavLMForXVector;__webpack_exports__.WavLMModel;__webpack_exports__.WavLMPreTrainedModel;__webpack_exports__.WeSpeakerFeatureExtractor;__webpack_exports__.WeSpeakerResNetModel;__webpack_exports__.WeSpeakerResNetPreTrainedModel;__webpack_exports__.WhisperFeatureExtractor;__webpack_exports__.WhisperForConditionalGeneration;__webpack_exports__.WhisperModel;__webpack_exports__.WhisperPreTrainedModel;__webpack_exports__.WhisperProcessor;__webpack_exports__.WhisperTextStreamer;__webpack_exports__.WhisperTokenizer;__webpack_exports__.XLMForQuestionAnswering;__webpack_exports__.XLMForSequenceClassification;__webpack_exports__.XLMForTokenClassification;__webpack_exports__.XLMModel;__webpack_exports__.XLMPreTrainedModel;__webpack_exports__.XLMRobertaForMaskedLM;__webpack_exports__.XLMRobertaForQuestionAnswering;__webpack_exports__.XLMRobertaForSequenceClassification;__webpack_exports__.XLMRobertaForTokenClassification;__webpack_exports__.XLMRobertaModel;__webpack_exports__.XLMRobertaPreTrainedModel;__webpack_exports__.XLMRobertaTokenizer;__webpack_exports__.XLMTokenizer;__webpack_exports__.XLMWithLMHeadModel;__webpack_exports__.XVectorOutput;__webpack_exports__.YolosFeatureExtractor;__webpack_exports__.YolosForObjectDetection;__webpack_exports__.YolosModel;__webpack_exports__.YolosObjectDetectionOutput;__webpack_exports__.YolosPreTrainedModel;__webpack_exports__.ZeroShotAudioClassificationPipeline;__webpack_exports__.ZeroShotClassificationPipeline;__webpack_exports__.ZeroShotImageClassificationPipeline;__webpack_exports__.ZeroShotObjectDetectionPipeline;__webpack_exports__.bankers_round;__webpack_exports__.cat;__webpack_exports__.cos_sim;__webpack_exports__.dot;__webpack_exports__.dynamic_time_warping;__webpack_exports__.env;__webpack_exports__.full;__webpack_exports__.full_like;__webpack_exports__.getKeyValueShapes;__webpack_exports__.hamming;__webpack_exports__.hanning;__webpack_exports__.interpolate;__webpack_exports__.interpolate_4d;__webpack_exports__.interpolate_data;__webpack_exports__.is_chinese_char;__webpack_exports__.layer_norm;__webpack_exports__.log_softmax;__webpack_exports__.magnitude;__webpack_exports__.matmul;__webpack_exports__.max;__webpack_exports__.mean;__webpack_exports__.mean_pooling;__webpack_exports__.medianFilter;__webpack_exports__.mel_filter_bank;__webpack_exports__.min;__webpack_exports__.ones;__webpack_exports__.ones_like;__webpack_exports__.permute;__webpack_exports__.permute_data;__webpack_exports__.pipeline;__webpack_exports__.quantize_embeddings;__webpack_exports__.read_audio;__webpack_exports__.rfft;__webpack_exports__.round;__webpack_exports__.softmax;__webpack_exports__.spectrogram;__webpack_exports__.stack;__webpack_exports__.std_mean;__webpack_exports__.topk;__webpack_exports__.window_function;__webpack_exports__.zeros;__webpack_exports__.zeros_like;const{Map:Map_1}=globals;function get_each_context$1(e,r,i){const s=e.slice();return s[4]=r[i],s[22]=i,s}function create_default_slot$2(e){let r,i,s,c,n,a,h,p,t;return s=new MagnifyingGlass({props:{className:"size-3"}}),{c(){r=element("div"),i=element("div"),create_component(s.$$.fragment),c=space(),n=element("input"),this.h()},l(u){r=claim_element(u,"DIV",{class:!0});var l=children(r);i=claim_element(l,"DIV",{class:!0});var f=children(i);claim_component(s.$$.fragment,f),f.forEach(detach),c=claim_space(l),n=claim_element(l,"INPUT",{class:!0,placeholder:!0}),l.forEach(detach),this.h()},h(){attr(i,"class","self-center ml-1 mr-3"),attr(n,"class","w-full text-sm pr-4 py-1 rounded-r-xl outline-none bg-transparent"),attr(n,"placeholder",a=e[3].t("Search")),attr(r,"class","flex flex-1")},m(u,l){insert_hydration(u,r,l),append_hydration(r,i),mount_component(s,i,null),append_hydration(r,c),append_hydration(r,n),set_input_value(n,e[0]),h=!0,p||(t=[listen(n,"input",e[8]),listen(n,"focus",e[9])],p=!0)},p(u,l){(!h||l&8&&a!==(a=u[3].t("Search")))&&attr(n,"placeholder",a),l&1&&n.value!==u[0]&&set_input_value(n,u[0])},i(u){h||(transition_in(s.$$.fragment,u),h=!0)},o(u){transition_out(s.$$.fragment,u),h=!1},d(u){u&&detach(r),destroy_component(s),p=!1,run_all(t)}}}function create_if_block_3$1(e){let r,i,s,c;return s=new Spinner({}),{c(){r=element("div"),i=element("div"),create_component(s.$$.fragment),this.h()},l(n){r=claim_element(n,"DIV",{class:!0});var a=children(r);i=claim_element(a,"DIV",{class:!0});var h=children(i);claim_component(s.$$.fragment,h),h.forEach(detach),a.forEach(detach),this.h()},h(){attr(i,"class","m-auto"),attr(r,"class","absolute top-0 bottom-0 left-0 right-0 flex")},m(n,a){insert_hydration(n,r,a),append_hydration(r,i),mount_component(s,i,null),c=!0},i(n){c||(transition_in(s.$$.fragment,n),c=!0)},o(n){transition_out(s.$$.fragment,n),c=!1},d(n){n&&detach(r),destroy_component(s)}}}function create_else_block$1(e){let r,i,s,c,n=e[3].t("RK")+"",a,h,p,t=e[3].t("Model")+"",u,l,f,x=e[3].t("Rating")+"",I,R,A,Z=e[3].t("Won")+"",K,Q,re,se=e[3].t("Lost")+"",ee,ce,X,Re=[],De=new Map_1,et,nt=ensure_array_like(e[1]);const it=_t=>_t[4].id;for(let _t=0;_t<nt.length;_t+=1){let gt=get_each_context$1(e,nt,_t),Dt=it(gt);De.set(Dt,Re[_t]=create_each_block$1(Dt,gt))}return{c(){r=element("table"),i=element("thead"),s=element("tr"),c=element("th"),a=text(n),h=space(),p=element("th"),u=text(t),l=space(),f=element("th"),I=text(x),R=space(),A=element("th"),K=text(Z),Q=space(),re=element("th"),ee=text(se),ce=space(),X=element("tbody");for(let _t=0;_t<Re.length;_t+=1)Re[_t].c();this.h()},l(_t){r=claim_element(_t,"TABLE",{class:!0});var gt=children(r);i=claim_element(gt,"THEAD",{class:!0});var Dt=children(i);s=claim_element(Dt,"TR",{class:!0});var Ge=children(s);c=claim_element(Ge,"TH",{scope:!0,class:!0});var ge=children(c);a=claim_text(ge,n),ge.forEach(detach),h=claim_space(Ge),p=claim_element(Ge,"TH",{scope:!0,class:!0});var ct=children(p);u=claim_text(ct,t),ct.forEach(detach),l=claim_space(Ge),f=claim_element(Ge,"TH",{scope:!0,class:!0});var Ot=children(f);I=claim_text(Ot,x),Ot.forEach(detach),R=claim_space(Ge),A=claim_element(Ge,"TH",{scope:!0,class:!0});var $t=children(A);K=claim_text($t,Z),$t.forEach(detach),Q=claim_space(Ge),re=claim_element(Ge,"TH",{scope:!0,class:!0});var gr=children(re);ee=claim_text(gr,se),gr.forEach(detach),Ge.forEach(detach),Dt.forEach(detach),ce=claim_space(gt),X=claim_element(gt,"TBODY",{class:!0});var Qe=children(X);for(let Dr=0;Dr<Re.length;Dr+=1)Re[Dr].l(Qe);Qe.forEach(detach),gt.forEach(detach),this.h()},h(){attr(c,"scope","col"),attr(c,"class","px-3 py-1.5 cursor-pointer select-none w-3"),attr(p,"scope","col"),attr(p,"class","px-3 py-1.5 cursor-pointer select-none"),attr(f,"scope","col"),attr(f,"class","px-3 py-1.5 text-right cursor-pointer select-none w-fit"),attr(A,"scope","col"),attr(A,"class","px-3 py-1.5 text-right cursor-pointer select-none w-5"),attr(re,"scope","col"),attr(re,"class","px-3 py-1.5 text-right cursor-pointer select-none w-5"),attr(s,"class",""),attr(i,"class","text-xs text-gray-700 uppercase bg-gray-50 dark:bg-gray-850 dark:text-gray-400 -translate-y-0.5"),attr(X,"class",""),attr(r,"class",et="w-full text-sm text-left text-gray-500 dark:text-gray-400 table-auto max-w-full rounded "+(e[2]?"opacity-20":""))},m(_t,gt){insert_hydration(_t,r,gt),append_hydration(r,i),append_hydration(i,s),append_hydration(s,c),append_hydration(c,a),append_hydration(s,h),append_hydration(s,p),append_hydration(p,u),append_hydration(s,l),append_hydration(s,f),append_hydration(f,I),append_hydration(s,R),append_hydration(s,A),append_hydration(A,K),append_hydration(s,Q),append_hydration(s,re),append_hydration(re,ee),append_hydration(r,ce),append_hydration(r,X);for(let Dt=0;Dt<Re.length;Dt+=1)Re[Dt]&&Re[Dt].m(X,null)},p(_t,gt){gt&8&&n!==(n=_t[3].t("RK")+"")&&set_data(a,n),gt&8&&t!==(t=_t[3].t("Model")+"")&&set_data(u,t),gt&8&&x!==(x=_t[3].t("Rating")+"")&&set_data(I,x),gt&8&&Z!==(Z=_t[3].t("Won")+"")&&set_data(K,Z),gt&8&&se!==(se=_t[3].t("Lost")+"")&&set_data(ee,se),gt&2&&(nt=ensure_array_like(_t[1]),Re=update_keyed_each(Re,gt,it,1,_t,nt,De,X,destroy_block,create_each_block$1,null,get_each_context$1)),gt&4&&et!==(et="w-full text-sm text-left text-gray-500 dark:text-gray-400 table-auto max-w-full rounded "+(_t[2]?"opacity-20":""))&&attr(r,"class",et)},d(_t){_t&&detach(r);for(let gt=0;gt<Re.length;gt+=1)Re[gt].d()}}}function create_if_block$2(e){let r,i=e[3].t("No models found")+"",s;return{c(){r=element("div"),s=text(i),this.h()},l(c){r=claim_element(c,"DIV",{class:!0});var n=children(r);s=claim_text(n,i),n.forEach(detach),this.h()},h(){attr(r,"class","text-center text-xs text-gray-500 dark:text-gray-400 py-1")},m(c,n){insert_hydration(c,r,n),append_hydration(r,s)},p(c,n){n&8&&i!==(i=c[3].t("No models found")+"")&&set_data(s,i)},d(c){c&&detach(r)}}}function create_else_block_2$1(e){let r,i=(e[4].stats.won/e[4].stats.count*100).toFixed(1)+"",s,c,n,a,h=e[4].stats.won+"",p;return{c(){r=element("span"),s=text(i),c=text("%"),n=space(),a=element("span"),p=text(h),this.h()},l(t){r=claim_element(t,"SPAN",{class:!0});var u=children(r);s=claim_text(u,i),c=claim_text(u,"%"),u.forEach(detach),n=claim_space(t),a=claim_element(t,"SPAN",{class:!0});var l=children(a);p=claim_text(l,h),l.forEach(detach),this.h()},h(){attr(r,"class","hidden group-hover:inline"),attr(a,"class","group-hover:hidden")},m(t,u){insert_hydration(t,r,u),append_hydration(r,s),append_hydration(r,c),insert_hydration(t,n,u),insert_hydration(t,a,u),append_hydration(a,p)},p(t,u){u&2&&i!==(i=(t[4].stats.won/t[4].stats.count*100).toFixed(1)+"")&&set_data(s,i),u&2&&h!==(h=t[4].stats.won+"")&&set_data(p,h)},d(t){t&&(detach(r),detach(n),detach(a))}}}function create_if_block_2$2(e){let r;return{c(){r=text("-")},l(i){r=claim_text(i,"-")},m(i,s){insert_hydration(i,r,s)},p:noop,d(i){i&&detach(r)}}}function create_else_block_1$1(e){let r,i=(e[4].stats.lost/e[4].stats.count*100).toFixed(1)+"",s,c,n,a,h=e[4].stats.lost+"",p;return{c(){r=element("span"),s=text(i),c=text("%"),n=space(),a=element("span"),p=text(h),this.h()},l(t){r=claim_element(t,"SPAN",{class:!0});var u=children(r);s=claim_text(u,i),c=claim_text(u,"%"),u.forEach(detach),n=claim_space(t),a=claim_element(t,"SPAN",{class:!0});var l=children(a);p=claim_text(l,h),l.forEach(detach),this.h()},h(){attr(r,"class","hidden group-hover:inline"),attr(a,"class","group-hover:hidden")},m(t,u){insert_hydration(t,r,u),append_hydration(r,s),append_hydration(r,c),insert_hydration(t,n,u),insert_hydration(t,a,u),append_hydration(a,p)},p(t,u){u&2&&i!==(i=(t[4].stats.lost/t[4].stats.count*100).toFixed(1)+"")&&set_data(s,i),u&2&&h!==(h=t[4].stats.lost+"")&&set_data(p,h)},d(t){t&&(detach(r),detach(n),detach(a))}}}function create_if_block_1$2(e){let r;return{c(){r=text("-")},l(i){r=claim_text(i,"-")},m(i,s){insert_hydration(i,r,s)},p:noop,d(i){i&&detach(r)}}}function create_each_block$1(e,r){var ct;let i,s,c,n=(((ct=r[4])==null?void 0:ct.rating)!=="-"?r[22]+1:"-")+"",a,h,p,t,u,l,f,x,I,R,A=r[4].name+"",Z,K,Q,re=r[4].rating+"",se,ee,ce,X,Re,De,et,nt;function it(Ot,$t){return Ot[4].stats.won==="-"?create_if_block_2$2:create_else_block_2$1}let _t=it(r),gt=_t(r);function Dt(Ot,$t){return Ot[4].stats.lost==="-"?create_if_block_1$2:create_else_block_1$1}let Ge=Dt(r),ge=Ge(r);return{key:e,first:null,c(){i=element("tr"),s=element("td"),c=element("div"),a=text(n),h=space(),p=element("td"),t=element("div"),u=element("div"),l=element("img"),I=space(),R=element("div"),Z=text(A),K=space(),Q=element("td"),se=text(re),ee=space(),ce=element("td"),X=element("div"),gt.c(),Re=space(),De=element("td"),et=element("div"),ge.c(),nt=space(),this.h()},l(Ot){i=claim_element(Ot,"TR",{class:!0});var $t=children(i);s=claim_element($t,"TD",{class:!0});var gr=children(s);c=claim_element(gr,"DIV",{class:!0});var Qe=children(c);a=claim_text(Qe,n),Qe.forEach(detach),gr.forEach(detach),h=claim_space($t),p=claim_element($t,"TD",{class:!0});var Dr=children(p);t=claim_element(Dr,"DIV",{class:!0});var vn=children(t);u=claim_element(vn,"DIV",{class:!0});var vr=children(u);l=claim_element(vr,"IMG",{src:!0,alt:!0,class:!0}),vr.forEach(detach),I=claim_space(vn),R=claim_element(vn,"DIV",{class:!0});var Eo=children(R);Z=claim_text(Eo,A),Eo.forEach(detach),vn.forEach(detach),Dr.forEach(detach),K=claim_space($t),Q=claim_element($t,"TD",{class:!0});var Ao=children(Q);se=claim_text(Ao,re),Ao.forEach(detach),ee=claim_space($t),ce=claim_element($t,"TD",{class:!0});var Yr=children(ce);X=claim_element(Yr,"DIV",{class:!0});var Ze=children(X);gt.l(Ze),Ze.forEach(detach),Yr.forEach(detach),Re=claim_space($t),De=claim_element($t,"TD",{class:!0});var er=children(De);et=claim_element(er,"DIV",{class:!0});var Kr=children(et);ge.l(Kr),Kr.forEach(detach),er.forEach(detach),nt=claim_space($t),$t.forEach(detach),this.h()},h(){var Ot,$t,gr;attr(c,"class","line-clamp-1"),attr(s,"class","px-3 py-1.5 text-left font-medium text-gray-900 dark:text-white w-fit"),src_url_equal(l.src,f=((gr=($t=(Ot=r[4])==null?void 0:Ot.info)==null?void 0:$t.meta)==null?void 0:gr.profile_image_url)??"/favicon.png")||attr(l,"src",f),attr(l,"alt",x=r[4].name),attr(l,"class","size-5 rounded-full object-cover shrink-0"),attr(u,"class","flex-shrink-0"),attr(R,"class","font-medium text-gray-800 dark:text-gray-200 pr-4"),attr(t,"class","flex items-center gap-2"),attr(p,"class","px-3 py-1.5 flex flex-col justify-center"),attr(Q,"class","px-3 py-1.5 text-right font-medium text-gray-900 dark:text-white w-max"),attr(X,"class","w-10"),attr(ce,"class","px-3 py-1.5 text-right font-semibold text-green-500"),attr(et,"class","w-10"),attr(De,"class","px-3 py-1.5 text-right font-semibold text-red-500"),attr(i,"class","bg-white dark:bg-gray-900 dark:border-gray-850 text-xs group"),this.first=i},m(Ot,$t){insert_hydration(Ot,i,$t),append_hydration(i,s),append_hydration(s,c),append_hydration(c,a),append_hydration(i,h),append_hydration(i,p),append_hydration(p,t),append_hydration(t,u),append_hydration(u,l),append_hydration(t,I),append_hydration(t,R),append_hydration(R,Z),append_hydration(i,K),append_hydration(i,Q),append_hydration(Q,se),append_hydration(i,ee),append_hydration(i,ce),append_hydration(ce,X),gt.m(X,null),append_hydration(i,Re),append_hydration(i,De),append_hydration(De,et),ge.m(et,null),append_hydration(i,nt)},p(Ot,$t){var gr,Qe,Dr,vn;r=Ot,$t&2&&n!==(n=(((gr=r[4])==null?void 0:gr.rating)!=="-"?r[22]+1:"-")+"")&&set_data(a,n),$t&2&&!src_url_equal(l.src,f=((vn=(Dr=(Qe=r[4])==null?void 0:Qe.info)==null?void 0:Dr.meta)==null?void 0:vn.profile_image_url)??"/favicon.png")&&attr(l,"src",f),$t&2&&x!==(x=r[4].name)&&attr(l,"alt",x),$t&2&&A!==(A=r[4].name+"")&&set_data(Z,A),$t&2&&re!==(re=r[4].rating+"")&&set_data(se,re),_t===(_t=it(r))&&gt?gt.p(r,$t):(gt.d(1),gt=_t(r),gt&&(gt.c(),gt.m(X,null))),Ge===(Ge=Dt(r))&&ge?ge.p(r,$t):(ge.d(1),ge=Ge(r),ge&&(ge.c(),ge.m(et,null)))},d(Ot){Ot&&detach(i),gt.d(),ge.d()}}}function create_fragment$5(e){let r,i,s,c=e[3].t("Leaderboard")+"",n,a,h,p,t,u=e[1].length+"",l,f,x,I,R,A,Z,K,Q,re,se,ee,ce=e[3].t("The evaluation leaderboard is based on the Elo rating system and is updated in real-time.")+"",X,Re,De=e[3].t("The leaderboard is currently in beta, and we may adjust the rating calculations as we refine the algorithm.")+"",et,nt;I=new Tooltip({props:{content:e[3].t("Re-rank models by topic similarity"),$$slots:{default:[create_default_slot$2]},$$scope:{ctx:e}}});let it=e[2]&&create_if_block_3$1();function _t(Ge,ge){return(Ge[1]??[]).length===0?create_if_block$2:create_else_block$1}let gt=_t(e),Dt=gt(e);return{c(){r=element("div"),i=element("div"),s=element("div"),n=text(c),a=space(),h=element("div"),p=space(),t=element("span"),l=text(u),f=space(),x=element("div"),create_component(I.$$.fragment),R=space(),A=element("div"),it&&it.c(),Z=space(),Dt.c(),K=space(),Q=element("div"),re=element("div"),se=element("div"),ee=text(" "),X=text(ce),Re=space(),et=text(De),this.h()},l(Ge){r=claim_element(Ge,"DIV",{class:!0});var ge=children(r);i=claim_element(ge,"DIV",{class:!0});var ct=children(i);s=claim_element(ct,"DIV",{class:!0});var Ot=children(s);n=claim_text(Ot,c),Ot.forEach(detach),a=claim_space(ct),h=claim_element(ct,"DIV",{class:!0}),children(h).forEach(detach),p=claim_space(ct),t=claim_element(ct,"SPAN",{class:!0});var $t=children(t);l=claim_text($t,u),$t.forEach(detach),ct.forEach(detach),f=claim_space(ge),x=claim_element(ge,"DIV",{class:!0});var gr=children(x);claim_component(I.$$.fragment,gr),gr.forEach(detach),ge.forEach(detach),R=claim_space(Ge),A=claim_element(Ge,"DIV",{class:!0});var Qe=children(A);it&&it.l(Qe),Z=claim_space(Qe),Dt.l(Qe),Qe.forEach(detach),K=claim_space(Ge),Q=claim_element(Ge,"DIV",{class:!0});var Dr=children(Q);re=claim_element(Dr,"DIV",{class:!0});var vn=children(re);se=claim_element(vn,"DIV",{class:!0});var vr=children(se);ee=claim_text(vr," "),X=claim_text(vr,ce),vr.forEach(detach),Re=claim_space(vn),et=claim_text(vn,De),vn.forEach(detach),Dr.forEach(detach),this.h()},h(){attr(s,"class","gap-1"),attr(h,"class","flex self-center w-[1px] h-6 mx-2.5 bg-gray-50 dark:bg-gray-850"),attr(t,"class","text-lg font-medium text-gray-500 dark:text-gray-300 mr-1.5"),attr(i,"class","flex md:self-center text-lg font-medium px-0.5 shrink-0 items-center"),attr(x,"class","flex space-x-2"),attr(r,"class","mt-0.5 mb-2 gap-1 flex flex-col md:flex-row justify-between"),attr(A,"class","scrollbar-hidden relative whitespace-nowrap overflow-x-auto max-w-full rounded pt-0.5"),attr(se,"class","line-clamp-1"),attr(re,"class","text-right"),attr(Q,"class","text-gray-500 text-xs mt-1.5 w-full flex justify-end")},m(Ge,ge){insert_hydration(Ge,r,ge),append_hydration(r,i),append_hydration(i,s),append_hydration(s,n),append_hydration(i,a),append_hydration(i,h),append_hydration(i,p),append_hydration(i,t),append_hydration(t,l),append_hydration(r,f),append_hydration(r,x),mount_component(I,x,null),insert_hydration(Ge,R,ge),insert_hydration(Ge,A,ge),it&&it.m(A,null),append_hydration(A,Z),Dt.m(A,null),insert_hydration(Ge,K,ge),insert_hydration(Ge,Q,ge),append_hydration(Q,re),append_hydration(re,se),append_hydration(se,ee),append_hydration(se,X),append_hydration(re,Re),append_hydration(re,et),nt=!0},p(Ge,[ge]){(!nt||ge&8)&&c!==(c=Ge[3].t("Leaderboard")+"")&&set_data(n,c),(!nt||ge&2)&&u!==(u=Ge[1].length+"")&&set_data(l,u);const ct={};ge&8&&(ct.content=Ge[3].t("Re-rank models by topic similarity")),ge&8388617&&(ct.$$scope={dirty:ge,ctx:Ge}),I.$set(ct),Ge[2]?it?ge&4&&transition_in(it,1):(it=create_if_block_3$1(),it.c(),transition_in(it,1),it.m(A,Z)):it&&(group_outros(),transition_out(it,1,1,()=>{it=null}),check_outros()),gt===(gt=_t(Ge))&&Dt?Dt.p(Ge,ge):(Dt.d(1),Dt=gt(Ge),Dt&&(Dt.c(),Dt.m(A,null))),(!nt||ge&8)&&ce!==(ce=Ge[3].t("The evaluation leaderboard is based on the Elo rating system and is updated in real-time.")+"")&&set_data(X,ce),(!nt||ge&8)&&De!==(De=Ge[3].t("The leaderboard is currently in beta, and we may adjust the rating calculations as we refine the algorithm.")+"")&&set_data(et,De)},i(Ge){nt||(transition_in(I.$$.fragment,Ge),transition_in(it),nt=!0)},o(Ge){transition_out(I.$$.fragment,Ge),transition_out(it),nt=!1},d(Ge){Ge&&(detach(r),detach(R),detach(A),detach(K),detach(Q)),destroy_component(I),it&&it.d(),Dt.d()}}}const EMBEDDING_MODEL="TaylorAI/bge-micro-v2";function instance$4(e,r,i){let s,c;component_subscribe(e,models,X=>i(12,s=X));const n=getContext("i18n");component_subscribe(e,n,X=>i(3,c=X));let a=null,h=null,{feedbacks:p=[]}=r,t=[],u="",l=new Map,f=!0,x;const I=async(X=new Map)=>{const Re=R(p,X);i(1,t=s.filter(De=>{var et,nt;return(De==null?void 0:De.owned_by)!=="arena"&&(((nt=(et=De==null?void 0:De.info)==null?void 0:et.meta)==null?void 0:nt.hidden)??!1)!==!0}).map(De=>{const et=Re.get(De.id);return{...De,rating:et?Math.round(et.rating):"-",stats:{count:et?et.won+et.lost:0,won:et?et.won.toString():"-",lost:et?et.lost.toString():"-"}}}).sort((De,et)=>De.rating==="-"&&et.rating!=="-"?1:et.rating==="-"&&De.rating!=="-"?-1:De.rating!=="-"&&et.rating!=="-"?et.rating-De.rating:De.name.localeCompare(et.name))),i(2,f=!1)};function R(X,Re){const De=new Map,et=32;function nt(gt){return De.get(gt)||{rating:1e3,won:0,lost:0}}function it(gt,Dt,Ge){const ge=nt(gt);ge.rating+=Dt,Ge===1?ge.won++:Ge===0&&ge.lost++,De.set(gt,ge)}function _t(gt,Dt,Ge,ge){const ct=1/(1+Math.pow(10,(Dt-gt)/400));return et*(Ge-ct)*ge}return X.forEach(gt=>{const Dt=gt.data.model_id,Ge=nt(Dt);let ge;switch(gt.data.rating.toString()){case"1":ge=1;break;case"-1":ge=0;break;default:return}const ct=u!==""?Re.get(gt.id)||0:1;(gt.data.sibling_model_ids||[]).forEach($t=>{const gr=nt($t),Qe=_t(Ge.rating,gr.rating,ge,ct),Dr=_t(gr.rating,Ge.rating,1-ge,ct);it(Dt,Qe,ge),it($t,Dr,1-ge)})}),De}const A=(X,Re)=>{if(X.length!==Re.length)throw new Error("Vectors must be the same length");let De=0,et=0,nt=0;for(let it=0;it<X.length;it++)De+=X[it]*Re[it],et+=X[it]**2,nt+=Re[it]**2;return et=Math.sqrt(et),nt=Math.sqrt(nt),et===0||nt===0?0:De/(et*nt)},Z=(X,Re)=>{let De=0;for(const et of Re.values()){const nt=A(X,et);De=Math.max(De,nt)}return De},K=async()=>{window.tokenizer||(window.tokenizer=await __webpack_exports__AutoTokenizer.from_pretrained(EMBEDDING_MODEL)),window.model||(window.model=await __webpack_exports__AutoModel.from_pretrained(EMBEDDING_MODEL)),a=window.tokenizer,i(4,h=window.model);const X=new Set(p.flatMap(Re=>Re.data.tags||[]));await re(Array.from(X))},Q=async X=>{const Re=await a(X);return(await h(Re)).last_hidden_state.mean(1).ort_tensor.data},re=async X=>{const Re=new Map;for(const De of X)l.has(De)||l.set(De,await Q(De)),Re.set(De,l.get(De));return Re},se=async()=>{if(i(2,f=!0),u.trim()===""){I();return}clearTimeout(x),x=setTimeout(async()=>{const X=await Q(u),Re=new Map;for(const De of p){const et=De.data.tags||[],nt=await re(et),it=Z(X,nt);Re.set(De.id,it)}I(Re)},1500)};onMount(async()=>{I()});function ee(){u=this.value,i(0,u)}const ce=()=>{K()};return e.$$set=X=>{"feedbacks"in X&&i(7,p=X.feedbacks)},e.$$.update=()=>{e.$$.dirty&1&&se()},[u,t,f,c,h,n,K,p,ee,ce]}class Leaderboard extends SvelteComponent{constructor(r){super(),init(this,r,instance$4,create_fragment$5,safe_not_equal,{feedbacks:7})}}function create_fragment$4(e){let r,i;return{c(){r=svg_element("svg"),i=svg_element("path"),this.h()},l(s){r=claim_svg_element(s,"svg",{xmlns:!0,fill:!0,viewBox:!0,"stroke-width":!0,stroke:!0,class:!0});var c=children(r);i=claim_svg_element(c,"path",{"stroke-linecap":!0,"stroke-linejoin":!0,d:!0}),children(i).forEach(detach),c.forEach(detach),this.h()},h(){attr(i,"stroke-linecap","round"),attr(i,"stroke-linejoin","round"),attr(i,"d","M12 16.5V9.75m0 0 3 3m-3-3-3 3M6.75 19.5a4.5 4.5 0 0 1-1.41-8.775 5.25 5.25 0 0 1 10.233-2.33 3 3 0 0 1 3.758 3.848A3.752 3.752 0 0 1 18 19.5H6.75Z"),attr(r,"xmlns","http://www.w3.org/2000/svg"),attr(r,"fill","none"),attr(r,"viewBox","0 0 24 24"),attr(r,"stroke-width",e[1]),attr(r,"stroke","currentColor"),attr(r,"class",e[0])},m(s,c){insert_hydration(s,r,c),append_hydration(r,i)},p(s,[c]){c&2&&attr(r,"stroke-width",s[1]),c&1&&attr(r,"class",s[0])},i:noop,o:noop,d(s){s&&detach(r)}}}function instance$3(e,r,i){let{className:s="w-4 h-4"}=r,{strokeWidth:c="1.5"}=r;return e.$$set=n=>{"className"in n&&i(0,s=n.className),"strokeWidth"in n&&i(1,c=n.strokeWidth)},[s,c]}class CloudArrowUp extends SvelteComponent{constructor(r){super(),init(this,r,instance$3,create_fragment$4,safe_not_equal,{className:0,strokeWidth:1})}}function create_default_slot_3$1(e){let r;const i=e[4].default,s=create_slot(i,e,e[7],null);return{c(){s&&s.c()},l(c){s&&s.l(c)},m(c,n){s&&s.m(c,n),r=!0},p(c,n){s&&s.p&&(!r||n&128)&&update_slot_base(s,i,c,c[7],r?get_slot_changes(i,c[7],n,null):get_all_dirty_from_scope(c[7]),null)},i(c){r||(transition_in(s,c),r=!0)},o(c){transition_out(s,c),r=!1},d(c){s&&s.d(c)}}}function create_default_slot_2$1(e){let r,i;return r=new Tooltip({props:{content:e[1].t("More"),$$slots:{default:[create_default_slot_3$1]},$$scope:{ctx:e}}}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&2&&(n.content=s[1].t("More")),c&128&&(n.$$scope={dirty:c,ctx:s}),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_default_slot_1$1(e){let r,i,s,c=e[1].t("Delete")+"",n,a;return r=new GarbageBin({props:{strokeWidth:"2"}}),{c(){create_component(r.$$.fragment),i=space(),s=element("div"),n=text(c),this.h()},l(h){claim_component(r.$$.fragment,h),i=claim_space(h),s=claim_element(h,"DIV",{class:!0});var p=children(s);n=claim_text(p,c),p.forEach(detach),this.h()},h(){attr(s,"class","flex items-center")},m(h,p){mount_component(r,h,p),insert_hydration(h,i,p),insert_hydration(h,s,p),append_hydration(s,n),a=!0},p(h,p){(!a||p&2)&&c!==(c=h[1].t("Delete")+"")&&set_data(n,c)},i(h){a||(transition_in(r.$$.fragment,h),a=!0)},o(h){transition_out(r.$$.fragment,h),a=!1},d(h){h&&(detach(i),detach(s)),destroy_component(r,h)}}}function create_default_slot$1(e){let r,i;return r=new Menu_item({props:{class:"flex  gap-2  items-center px-3 py-1.5 text-sm  cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800 rounded-md",$$slots:{default:[create_default_slot_1$1]},$$scope:{ctx:e}}}),r.$on("click",e[5]),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&130&&(n.$$scope={dirty:c,ctx:s}),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_content_slot(e){let r,i,s;return i=new Menu_content({props:{class:"w-full max-w-[150px] rounded-xl px-1 py-1.5 z-50 bg-white dark:bg-gray-850 dark:text-white shadow-lg",sideOffset:-2,side:"bottom",align:"start",transition:flyAndScale,$$slots:{default:[create_default_slot$1]},$$scope:{ctx:e}}}),{c(){r=element("div"),create_component(i.$$.fragment),this.h()},l(c){r=claim_element(c,"DIV",{slot:!0});var n=children(r);claim_component(i.$$.fragment,n),n.forEach(detach),this.h()},h(){attr(r,"slot","content")},m(c,n){insert_hydration(c,r,n),mount_component(i,r,null),s=!0},p(c,n){const a={};n&131&&(a.$$scope={dirty:n,ctx:c}),i.$set(a)},i(c){s||(transition_in(i.$$.fragment,c),s=!0)},o(c){transition_out(i.$$.fragment,c),s=!1},d(c){c&&detach(r),destroy_component(i)}}}function create_fragment$3(e){let r,i,s;function c(a){e[6](a)}let n={$$slots:{content:[create_content_slot],default:[create_default_slot_2$1]},$$scope:{ctx:e}};return e[0]!==void 0&&(n.show=e[0]),r=new Dropdown({props:n}),binding_callbacks.push(()=>bind(r,"show",c)),r.$on("change",change_handler),{c(){create_component(r.$$.fragment)},l(a){claim_component(r.$$.fragment,a)},m(a,h){mount_component(r,a,h),s=!0},p(a,[h]){const p={};h&131&&(p.$$scope={dirty:h,ctx:a}),!i&&h&1&&(i=!0,p.show=a[0],add_flush_callback(()=>i=!1)),r.$set(p)},i(a){s||(transition_in(r.$$.fragment,a),s=!0)},o(a){transition_out(r.$$.fragment,a),s=!1},d(a){destroy_component(r,a)}}}const change_handler=e=>{};function instance$2(e,r,i){let s,{$$slots:c={},$$scope:n}=r;const a=createEventDispatcher(),h=getContext("i18n");component_subscribe(e,h,l=>i(1,s=l));let p=!1;const t=()=>{a("delete"),i(0,p=!1)};function u(l){p=l,i(0,p)}return e.$$set=l=>{"$$scope"in l&&i(7,n=l.$$scope)},[p,s,a,h,c,t,u,n]}class FeedbackMenu extends SvelteComponent{constructor(r){super(),init(this,r,instance$2,create_fragment$3,safe_not_equal,{})}}function get_each_context(e,r,i){const s=e.slice();return s[13]=r[i],s}function create_default_slot_4(e){let r,i,s,c,n;return i=new ArrowDownTray({props:{className:"size-3"}}),{c(){r=element("button"),create_component(i.$$.fragment),this.h()},l(a){r=claim_element(a,"BUTTON",{class:!0});var h=children(r);claim_component(i.$$.fragment,h),h.forEach(detach),this.h()},h(){attr(r,"class","p-2 rounded-xl hover:bg-gray-100 dark:bg-gray-900 dark:hover:bg-gray-850 transition font-medium text-sm flex items-center space-x-1")},m(a,h){insert_hydration(a,r,h),mount_component(i,r,null),s=!0,c||(n=listen(r,"click",e[8]),c=!0)},p:noop,i(a){s||(transition_in(i.$$.fragment,a),s=!0)},o(a){transition_out(i.$$.fragment,a),s=!1},d(a){a&&detach(r),destroy_component(i),c=!1,n()}}}function create_else_block(e){let r,i,s,c,n=e[3].t("User")+"",a,h,p,t=e[3].t("Models")+"",u,l,f,x=e[3].t("Result")+"",I,R,A,Z=e[3].t("Updated At")+"",K,Q,re,se="",ee,ce,X=[],Re=new Map,De,et=ensure_array_like(e[2]);const nt=it=>it[13].id;for(let it=0;it<et.length;it+=1){let _t=get_each_context(e,et,it),gt=nt(_t);Re.set(gt,X[it]=create_each_block(gt,_t))}return{c(){r=element("table"),i=element("thead"),s=element("tr"),c=element("th"),a=text(n),h=space(),p=element("th"),u=text(t),l=space(),f=element("th"),I=text(x),R=space(),A=element("th"),K=text(Z),Q=space(),re=element("th"),re.innerHTML=se,ee=space(),ce=element("tbody");for(let it=0;it<X.length;it+=1)X[it].c();this.h()},l(it){r=claim_element(it,"TABLE",{class:!0});var _t=children(r);i=claim_element(_t,"THEAD",{class:!0});var gt=children(i);s=claim_element(gt,"TR",{class:!0});var Dt=children(s);c=claim_element(Dt,"TH",{scope:!0,class:!0});var Ge=children(c);a=claim_text(Ge,n),Ge.forEach(detach),h=claim_space(Dt),p=claim_element(Dt,"TH",{scope:!0,class:!0});var ge=children(p);u=claim_text(ge,t),ge.forEach(detach),l=claim_space(Dt),f=claim_element(Dt,"TH",{scope:!0,class:!0});var ct=children(f);I=claim_text(ct,x),ct.forEach(detach),R=claim_space(Dt),A=claim_element(Dt,"TH",{scope:!0,class:!0});var Ot=children(A);K=claim_text(Ot,Z),Ot.forEach(detach),Q=claim_space(Dt),re=claim_element(Dt,"TH",{scope:!0,class:!0,"data-svelte-h":!0}),get_svelte_dataset(re)!=="svelte-twvnjj"&&(re.innerHTML=se),Dt.forEach(detach),gt.forEach(detach),ee=claim_space(_t),ce=claim_element(_t,"TBODY",{class:!0});var $t=children(ce);for(let gr=0;gr<X.length;gr+=1)X[gr].l($t);$t.forEach(detach),_t.forEach(detach),this.h()},h(){attr(c,"scope","col"),attr(c,"class","px-3 text-right cursor-pointer select-none w-0"),attr(p,"scope","col"),attr(p,"class","px-3 pr-1.5 cursor-pointer select-none"),attr(f,"scope","col"),attr(f,"class","px-3 py-1.5 text-right cursor-pointer select-none w-fit"),attr(A,"scope","col"),attr(A,"class","px-3 py-1.5 text-right cursor-pointer select-none w-0"),attr(re,"scope","col"),attr(re,"class","px-3 py-1.5 text-right cursor-pointer select-none w-0"),attr(s,"class",""),attr(i,"class","text-xs text-gray-700 uppercase bg-gray-50 dark:bg-gray-850 dark:text-gray-400 -translate-y-0.5"),attr(ce,"class",""),attr(r,"class","w-full text-sm text-left text-gray-500 dark:text-gray-400 table-auto max-w-full rounded")},m(it,_t){insert_hydration(it,r,_t),append_hydration(r,i),append_hydration(i,s),append_hydration(s,c),append_hydration(c,a),append_hydration(s,h),append_hydration(s,p),append_hydration(p,u),append_hydration(s,l),append_hydration(s,f),append_hydration(f,I),append_hydration(s,R),append_hydration(s,A),append_hydration(A,K),append_hydration(s,Q),append_hydration(s,re),append_hydration(r,ee),append_hydration(r,ce);for(let gt=0;gt<X.length;gt+=1)X[gt]&&X[gt].m(ce,null);De=!0},p(it,_t){(!De||_t&8)&&n!==(n=it[3].t("User")+"")&&set_data(a,n),(!De||_t&8)&&t!==(t=it[3].t("Models")+"")&&set_data(u,t),(!De||_t&8)&&x!==(x=it[3].t("Result")+"")&&set_data(I,x),(!De||_t&8)&&Z!==(Z=it[3].t("Updated At")+"")&&set_data(K,Z),_t&44&&(et=ensure_array_like(it[2]),group_outros(),X=update_keyed_each(X,_t,nt,1,it,et,Re,ce,outro_and_destroy_block,create_each_block,null,get_each_context),check_outros())},i(it){if(!De){for(let _t=0;_t<et.length;_t+=1)transition_in(X[_t]);De=!0}},o(it){for(let _t=0;_t<X.length;_t+=1)transition_out(X[_t]);De=!1},d(it){it&&detach(r);for(let _t=0;_t<X.length;_t+=1)X[_t].d()}}}function create_if_block_2$1(e){let r,i=e[3].t("No feedbacks found")+"",s;return{c(){r=element("div"),s=text(i),this.h()},l(c){r=claim_element(c,"DIV",{class:!0});var n=children(r);s=claim_text(n,i),n.forEach(detach),this.h()},h(){attr(r,"class","text-center text-xs text-gray-500 dark:text-gray-400 py-1")},m(c,n){insert_hydration(c,r,n),append_hydration(r,s)},p(c,n){n&8&&i!==(i=c[3].t("No feedbacks found")+"")&&set_data(s,i)},i:noop,o:noop,d(c){c&&detach(r)}}}function create_default_slot_3(e){let r,i,s,c;return{c(){r=element("div"),i=element("img"),this.h()},l(n){r=claim_element(n,"DIV",{class:!0});var a=children(r);i=claim_element(a,"IMG",{src:!0,alt:!0,class:!0}),a.forEach(detach),this.h()},h(){var n,a,h,p;src_url_equal(i.src,s=((a=(n=e[13])==null?void 0:n.user)==null?void 0:a.profile_image_url)??"/user.png")||attr(i,"src",s),attr(i,"alt",c=(p=(h=e[13])==null?void 0:h.user)==null?void 0:p.name),attr(i,"class","size-5 rounded-full object-cover shrink-0"),attr(r,"class","flex-shrink-0")},m(n,a){insert_hydration(n,r,a),append_hydration(r,i)},p(n,a){var h,p,t,u;a&4&&!src_url_equal(i.src,s=((p=(h=n[13])==null?void 0:h.user)==null?void 0:p.profile_image_url)??"/user.png")&&attr(i,"src",s),a&4&&c!==(c=(u=(t=n[13])==null?void 0:t.user)==null?void 0:u.name)&&attr(i,"alt",c)},d(n){n&&detach(r)}}}function create_else_block_2(e){var c;let r,i=((c=e[13].data)==null?void 0:c.model_id)+"",s;return{c(){r=element("div"),s=text(i),this.h()},l(n){r=claim_element(n,"DIV",{class:!0});var a=children(r);s=claim_text(a,i),a.forEach(detach),this.h()},h(){attr(r,"class","text-sm font-medium text-gray-600 dark:text-gray-400 flex-1 py-1.5")},m(n,a){insert_hydration(n,r,a),append_hydration(r,s)},p(n,a){var h;a&4&&i!==(i=((h=n[13].data)==null?void 0:h.model_id)+"")&&set_data(s,i)},i:noop,o:noop,d(n){n&&detach(r)}}}function create_if_block_6(e){var h;let r,i=((h=e[13].data)==null?void 0:h.model_id)+"",s,c,n,a;return n=new Tooltip({props:{content:e[13].data.sibling_model_ids.join(", "),$$slots:{default:[create_default_slot_2]},$$scope:{ctx:e}}}),{c(){r=element("div"),s=text(i),c=space(),create_component(n.$$.fragment),this.h()},l(p){r=claim_element(p,"DIV",{class:!0});var t=children(r);s=claim_text(t,i),t.forEach(detach),c=claim_space(p),claim_component(n.$$.fragment,p),this.h()},h(){attr(r,"class","font-semibold text-gray-600 dark:text-gray-400 flex-1")},m(p,t){insert_hydration(p,r,t),append_hydration(r,s),insert_hydration(p,c,t),mount_component(n,p,t),a=!0},p(p,t){var l;(!a||t&4)&&i!==(i=((l=p[13].data)==null?void 0:l.model_id)+"")&&set_data(s,i);const u={};t&4&&(u.content=p[13].data.sibling_model_ids.join(", ")),t&65548&&(u.$$scope={dirty:t,ctx:p}),n.$set(u)},i(p){a||(transition_in(n.$$.fragment,p),a=!0)},o(p){transition_out(n.$$.fragment,p),a=!1},d(p){p&&(detach(r),detach(c)),destroy_component(n,p)}}}function create_else_block_1(e){let r=e[13].data.sibling_model_ids.join(", ")+"",i;return{c(){i=text(r)},l(s){i=claim_text(s,r)},m(s,c){insert_hydration(s,i,c)},p(s,c){c&4&&r!==(r=s[13].data.sibling_model_ids.join(", ")+"")&&set_data(i,r)},d(s){s&&detach(i)}}}function create_if_block_7(e){let r=e[13].data.sibling_model_ids.slice(0,2).join(", ")+"",i,s,c=e[3].t("and {{COUNT}} more",{COUNT:e[13].data.sibling_model_ids.length-2})+"",n;return{c(){i=text(r),s=text(", "),n=text(c)},l(a){i=claim_text(a,r),s=claim_text(a,", "),n=claim_text(a,c)},m(a,h){insert_hydration(a,i,h),insert_hydration(a,s,h),insert_hydration(a,n,h)},p(a,h){h&4&&r!==(r=a[13].data.sibling_model_ids.slice(0,2).join(", ")+"")&&set_data(i,r),h&12&&c!==(c=a[3].t("and {{COUNT}} more",{COUNT:a[13].data.sibling_model_ids.length-2})+"")&&set_data(n,c)},d(a){a&&(detach(i),detach(s),detach(n))}}}function create_default_slot_2(e){let r;function i(n,a){return n[13].data.sibling_model_ids.length>2?create_if_block_7:create_else_block_1}let s=i(e),c=s(e);return{c(){r=element("div"),c.c(),this.h()},l(n){r=claim_element(n,"DIV",{class:!0});var a=children(r);c.l(a),a.forEach(detach),this.h()},h(){attr(r,"class","text-[0.65rem] text-gray-600 dark:text-gray-400 line-clamp-1")},m(n,a){insert_hydration(n,r,a),c.m(r,null)},p(n,a){s===(s=i(n))&&c?c.p(n,a):(c.d(1),c=s(n),c&&(c.c(),c.m(r,null)))},d(n){n&&detach(r),c.d()}}}function create_if_block_5(e){let r,i;return r=new Badge({props:{type:"error",content:e[3].t("Lost")}}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&8&&(n.content=s[3].t("Lost")),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_if_block_4(e){let r,i;return r=new Badge({props:{type:"muted",content:e[3].t("Draw")}}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&8&&(n.content=s[3].t("Draw")),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_if_block_3(e){let r,i;return r=new Badge({props:{type:"info",content:e[3].t("Won")}}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&8&&(n.content=s[3].t("Won")),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_default_slot_1(e){let r,i,s;return i=new EllipsisHorizontal({}),{c(){r=element("button"),create_component(i.$$.fragment),this.h()},l(c){r=claim_element(c,"BUTTON",{class:!0});var n=children(r);claim_component(i.$$.fragment,n),n.forEach(detach),this.h()},h(){attr(r,"class","self-center w-fit text-sm p-1.5 dark:text-gray-300 dark:hover:text-white hover:bg-black/5 dark:hover:bg-white/5 rounded-xl")},m(c,n){insert_hydration(c,r,n),mount_component(i,r,null),s=!0},p:noop,i(c){s||(transition_in(i.$$.fragment,c),s=!0)},o(c){transition_out(i.$$.fragment,c),s=!1},d(c){c&&detach(r),destroy_component(i)}}}function create_each_block(e,r){var Ot,$t;let i,s,c,n,a,h,p,t,u,l,f,x,I,R,A,Z,K,Q,re,se,ee=dayjs(r[13].updated_at*1e3).fromNow()+"",ce,X,Re,De,et,nt;n=new Tooltip({props:{content:($t=(Ot=r[13])==null?void 0:Ot.user)==null?void 0:$t.name,$$slots:{default:[create_default_slot_3]},$$scope:{ctx:r}}});const it=[create_if_block_6,create_else_block_2],_t=[];function gt(gr,Qe){var Dr;return(Dr=gr[13].data)!=null&&Dr.sibling_model_ids?0:1}u=gt(r),l=_t[u]=it[u](r);const Dt=[create_if_block_3,create_if_block_4,create_if_block_5],Ge=[];function ge(gr,Qe){return Qe&4&&(R=null),Qe&4&&(A=null),Qe&4&&(Z=null),R==null&&(R=gr[13].data.rating.toString()==="1"),R?0:(A==null&&(A=gr[13].data.rating.toString()==="0"),A?1:(Z==null&&(Z=gr[13].data.rating.toString()==="-1"),Z?2:-1))}~(K=ge(r,-1))&&(Q=Ge[K]=Dt[K](r));function ct(...gr){return r[9](r[13],...gr)}return De=new FeedbackMenu({props:{$$slots:{default:[create_default_slot_1]},$$scope:{ctx:r}}}),De.$on("delete",ct),{key:e,first:null,c(){i=element("tr"),s=element("td"),c=element("div"),create_component(n.$$.fragment),a=space(),h=element("td"),p=element("div"),t=element("div"),l.c(),f=space(),x=element("td"),I=element("div"),Q&&Q.c(),re=space(),se=element("td"),ce=text(ee),X=space(),Re=element("td"),create_component(De.$$.fragment),et=space(),this.h()},l(gr){i=claim_element(gr,"TR",{class:!0});var Qe=children(i);s=claim_element(Qe,"TD",{class:!0});var Dr=children(s);c=claim_element(Dr,"DIV",{class:!0});var vn=children(c);claim_component(n.$$.fragment,vn),vn.forEach(detach),Dr.forEach(detach),a=claim_space(Qe),h=claim_element(Qe,"TD",{class:!0});var vr=children(h);p=claim_element(vr,"DIV",{class:!0});var Eo=children(p);t=claim_element(Eo,"DIV",{class:!0});var Ao=children(t);l.l(Ao),Ao.forEach(detach),Eo.forEach(detach),vr.forEach(detach),f=claim_space(Qe),x=claim_element(Qe,"TD",{class:!0});var Yr=children(x);I=claim_element(Yr,"DIV",{class:!0});var Ze=children(I);Q&&Q.l(Ze),Ze.forEach(detach),Yr.forEach(detach),re=claim_space(Qe),se=claim_element(Qe,"TD",{class:!0});var er=children(se);ce=claim_text(er,ee),er.forEach(detach),X=claim_space(Qe),Re=claim_element(Qe,"TD",{class:!0});var Kr=children(Re);claim_component(De.$$.fragment,Kr),Kr.forEach(detach),et=claim_space(Qe),Qe.forEach(detach),this.h()},h(){attr(c,"class","flex justify-center"),attr(s,"class","py-0.5 text-right font-semibold"),attr(t,"class","flex flex-col h-full"),attr(p,"class","flex flex-col items-start gap-0.5 h-full"),attr(h,"class","py-1 pl-3 flex flex-col"),attr(I,"class","flex justify-end"),attr(x,"class","px-3 py-1 text-right font-medium text-gray-900 dark:text-white w-max"),attr(se,"class","px-3 py-1 text-right font-medium"),attr(Re,"class","px-3 py-1 text-right font-semibold"),attr(i,"class","bg-white dark:bg-gray-900 dark:border-gray-850 text-xs"),this.first=i},m(gr,Qe){insert_hydration(gr,i,Qe),append_hydration(i,s),append_hydration(s,c),mount_component(n,c,null),append_hydration(i,a),append_hydration(i,h),append_hydration(h,p),append_hydration(p,t),_t[u].m(t,null),append_hydration(i,f),append_hydration(i,x),append_hydration(x,I),~K&&Ge[K].m(I,null),append_hydration(i,re),append_hydration(i,se),append_hydration(se,ce),append_hydration(i,X),append_hydration(i,Re),mount_component(De,Re,null),append_hydration(i,et),nt=!0},p(gr,Qe){var Ao,Yr;r=gr;const Dr={};Qe&4&&(Dr.content=(Yr=(Ao=r[13])==null?void 0:Ao.user)==null?void 0:Yr.name),Qe&65540&&(Dr.$$scope={dirty:Qe,ctx:r}),n.$set(Dr);let vn=u;u=gt(r),u===vn?_t[u].p(r,Qe):(group_outros(),transition_out(_t[vn],1,1,()=>{_t[vn]=null}),check_outros(),l=_t[u],l?l.p(r,Qe):(l=_t[u]=it[u](r),l.c()),transition_in(l,1),l.m(t,null));let vr=K;K=ge(r,Qe),K===vr?~K&&Ge[K].p(r,Qe):(Q&&(group_outros(),transition_out(Ge[vr],1,1,()=>{Ge[vr]=null}),check_outros()),~K?(Q=Ge[K],Q?Q.p(r,Qe):(Q=Ge[K]=Dt[K](r),Q.c()),transition_in(Q,1),Q.m(I,null)):Q=null),(!nt||Qe&4)&&ee!==(ee=dayjs(r[13].updated_at*1e3).fromNow()+"")&&set_data(ce,ee);const Eo={};Qe&65536&&(Eo.$$scope={dirty:Qe,ctx:r}),De.$set(Eo)},i(gr){nt||(transition_in(n.$$.fragment,gr),transition_in(l),transition_in(Q),transition_in(De.$$.fragment,gr),nt=!0)},o(gr){transition_out(n.$$.fragment,gr),transition_out(l),transition_out(Q),transition_out(De.$$.fragment,gr),nt=!1},d(gr){gr&&detach(i),destroy_component(n),_t[u].d(),~K&&Ge[K].d(),destroy_component(De)}}}function create_if_block_1$1(e){let r,i,s=e[3].t("Help us create the best community leaderboard by sharing your feedback history!")+"",c,n,a,h,p;return h=new Tooltip({props:{content:e[3].t("To protect your privacy, only ratings, model IDs, tags, and metadata are shared from your feedbackyour chat logs remain private and are not included."),$$slots:{default:[create_default_slot]},$$scope:{ctx:e}}}),{c(){r=element("div"),i=element("div"),c=text(s),n=space(),a=element("div"),create_component(h.$$.fragment),this.h()},l(t){r=claim_element(t,"DIV",{class:!0});var u=children(r);i=claim_element(u,"DIV",{class:!0});var l=children(i);c=claim_text(l,s),l.forEach(detach),n=claim_space(u),a=claim_element(u,"DIV",{class:!0});var f=children(a);claim_component(h.$$.fragment,f),f.forEach(detach),u.forEach(detach),this.h()},h(){attr(i,"class","line-clamp-1 text-gray-500 text-xs"),attr(a,"class","flex space-x-1 ml-auto"),attr(r,"class","flex flex-col justify-end w-full text-right gap-1")},m(t,u){insert_hydration(t,r,u),append_hydration(r,i),append_hydration(i,c),append_hydration(r,n),append_hydration(r,a),mount_component(h,a,null),p=!0},p(t,u){(!p||u&8)&&s!==(s=t[3].t("Help us create the best community leaderboard by sharing your feedback history!")+"")&&set_data(c,s);const l={};u&8&&(l.content=t[3].t("To protect your privacy, only ratings, model IDs, tags, and metadata are shared from your feedbackyour chat logs remain private and are not included.")),u&65544&&(l.$$scope={dirty:u,ctx:t}),h.$set(l)},i(t){p||(transition_in(h.$$.fragment,t),p=!0)},o(t){transition_out(h.$$.fragment,t),p=!1},d(t){t&&detach(r),destroy_component(h)}}}function create_default_slot(e){let r,i,s=e[3].t("Share to OpenWebUI Community")+"",c,n,a,h,p,t,u;return h=new CloudArrowUp({props:{className:"size-3",strokeWidth:"3"}}),{c(){r=element("button"),i=element("div"),c=text(s),n=space(),a=element("div"),create_component(h.$$.fragment),this.h()},l(l){r=claim_element(l,"BUTTON",{class:!0});var f=children(r);i=claim_element(f,"DIV",{class:!0});var x=children(i);c=claim_text(x,s),x.forEach(detach),n=claim_space(f),a=claim_element(f,"DIV",{class:!0});var I=children(a);claim_component(h.$$.fragment,I),I.forEach(detach),f.forEach(detach),this.h()},h(){attr(i,"class","self-center mr-2 font-medium line-clamp-1"),attr(a,"class","self-center"),attr(r,"class","flex text-xs items-center px-3 py-1.5 rounded-xl bg-gray-50 hover:bg-gray-100 dark:bg-gray-850 dark:hover:bg-gray-800 dark:text-gray-200 transition")},m(l,f){insert_hydration(l,r,f),append_hydration(r,i),append_hydration(i,c),append_hydration(r,n),append_hydration(r,a),mount_component(h,a,null),p=!0,t||(u=listen(r,"click",e[10]),t=!0)},p(l,f){(!p||f&8)&&s!==(s=l[3].t("Share to OpenWebUI Community")+"")&&set_data(c,s)},i(l){p||(transition_in(h.$$.fragment,l),p=!0)},o(l){transition_out(h.$$.fragment,l),p=!1},d(l){l&&detach(r),destroy_component(h),t=!1,u()}}}function create_if_block$1(e){let r,i,s;function c(a){e[11](a)}let n={count:e[0].length,perPage:10};return e[1]!==void 0&&(n.page=e[1]),r=new Pagination_1({props:n}),binding_callbacks.push(()=>bind(r,"page",c)),{c(){create_component(r.$$.fragment)},l(a){claim_component(r.$$.fragment,a)},m(a,h){mount_component(r,a,h),s=!0},p(a,h){const p={};h&1&&(p.count=a[0].length),!i&&h&2&&(i=!0,p.page=a[1],add_flush_callback(()=>i=!1)),r.$set(p)},i(a){s||(transition_in(r.$$.fragment,a),s=!0)},o(a){transition_out(r.$$.fragment,a),s=!1},d(a){destroy_component(r,a)}}}function create_fragment$2(e){let r,i,s=e[3].t("Feedback History")+"",c,n,a,h,p,t=e[0].length+"",u,l,f,x,I,R,A,Z,K,Q,re,se,ee;I=new Tooltip({props:{content:e[3].t("Export"),$$slots:{default:[create_default_slot_4]},$$scope:{ctx:e}}});const ce=[create_if_block_2$1,create_else_block],X=[];function Re(nt,it){return(nt[0]??[]).length===0?0:1}Z=Re(e),K=X[Z]=ce[Z](e);let De=e[0].length>0&&create_if_block_1$1(e),et=e[0].length>10&&create_if_block$1(e);return{c(){r=element("div"),i=element("div"),c=text(s),n=space(),a=element("div"),h=space(),p=element("span"),u=text(t),l=space(),f=element("div"),x=element("div"),create_component(I.$$.fragment),R=space(),A=element("div"),K.c(),Q=space(),De&&De.c(),re=space(),et&&et.c(),se=empty(),this.h()},l(nt){r=claim_element(nt,"DIV",{class:!0});var it=children(r);i=claim_element(it,"DIV",{class:!0});var _t=children(i);c=claim_text(_t,s),n=claim_space(_t),a=claim_element(_t,"DIV",{class:!0}),children(a).forEach(detach),h=claim_space(_t),p=claim_element(_t,"SPAN",{class:!0});var gt=children(p);u=claim_text(gt,t),gt.forEach(detach),_t.forEach(detach),l=claim_space(it),f=claim_element(it,"DIV",{});var Dt=children(f);x=claim_element(Dt,"DIV",{});var Ge=children(x);claim_component(I.$$.fragment,Ge),Ge.forEach(detach),Dt.forEach(detach),it.forEach(detach),R=claim_space(nt),A=claim_element(nt,"DIV",{class:!0});var ge=children(A);K.l(ge),ge.forEach(detach),Q=claim_space(nt),De&&De.l(nt),re=claim_space(nt),et&&et.l(nt),se=empty(),this.h()},h(){attr(a,"class","flex self-center w-[1px] h-6 mx-2.5 bg-gray-50 dark:bg-gray-850"),attr(p,"class","text-lg font-medium text-gray-500 dark:text-gray-300"),attr(i,"class","flex md:self-center text-lg font-medium px-0.5"),attr(r,"class","mt-0.5 mb-2 gap-1 flex flex-row justify-between"),attr(A,"class","scrollbar-hidden relative whitespace-nowrap overflow-x-auto max-w-full rounded pt-0.5")},m(nt,it){insert_hydration(nt,r,it),append_hydration(r,i),append_hydration(i,c),append_hydration(i,n),append_hydration(i,a),append_hydration(i,h),append_hydration(i,p),append_hydration(p,u),append_hydration(r,l),append_hydration(r,f),append_hydration(f,x),mount_component(I,x,null),insert_hydration(nt,R,it),insert_hydration(nt,A,it),X[Z].m(A,null),insert_hydration(nt,Q,it),De&&De.m(nt,it),insert_hydration(nt,re,it),et&&et.m(nt,it),insert_hydration(nt,se,it),ee=!0},p(nt,[it]){(!ee||it&8)&&s!==(s=nt[3].t("Feedback History")+"")&&set_data(c,s),(!ee||it&1)&&t!==(t=nt[0].length+"")&&set_data(u,t);const _t={};it&8&&(_t.content=nt[3].t("Export")),it&65536&&(_t.$$scope={dirty:it,ctx:nt}),I.$set(_t);let gt=Z;Z=Re(nt),Z===gt?X[Z].p(nt,it):(group_outros(),transition_out(X[gt],1,1,()=>{X[gt]=null}),check_outros(),K=X[Z],K?K.p(nt,it):(K=X[Z]=ce[Z](nt),K.c()),transition_in(K,1),K.m(A,null)),nt[0].length>0?De?(De.p(nt,it),it&1&&transition_in(De,1)):(De=create_if_block_1$1(nt),De.c(),transition_in(De,1),De.m(re.parentNode,re)):De&&(group_outros(),transition_out(De,1,1,()=>{De=null}),check_outros()),nt[0].length>10?et?(et.p(nt,it),it&1&&transition_in(et,1)):(et=create_if_block$1(nt),et.c(),transition_in(et,1),et.m(se.parentNode,se)):et&&(group_outros(),transition_out(et,1,1,()=>{et=null}),check_outros())},i(nt){ee||(transition_in(I.$$.fragment,nt),transition_in(K),transition_in(De),transition_in(et),ee=!0)},o(nt){transition_out(I.$$.fragment,nt),transition_out(K),transition_out(De),transition_out(et),ee=!1},d(nt){nt&&(detach(r),detach(R),detach(A),detach(Q),detach(re),detach(se)),destroy_component(I),X[Z].d(),De&&De.d(nt),et&&et.d(nt)}}}function instance$1(e,r,i){let s,c;const{saveAs:n}=fileSaver;dayjs.extend(relativeTime);const a=getContext("i18n");component_subscribe(e,a,A=>i(3,c=A));let{feedbacks:h=[]}=r,p=1;const t=async A=>{await deleteFeedbackById(localStorage.token,A).catch(K=>(toast.error(K),null))&&i(0,h=h.filter(K=>K.id!==A))},u=async()=>{toast.success(c.t("Redirecting you to OpenWebUI Community"));const A=h.map(re=>{const{snapshot:se,user:ee,...ce}=re;return ce});console.log(A);const Z="https://openwebui.com",K=await window.open(`${Z}/leaderboard`,"_blank"),Q=re=>{re.origin===Z&&re.data==="loaded"&&(K.postMessage(JSON.stringify(A),"*"),window.removeEventListener("message",Q))};window.addEventListener("message",Q,!1)},l=async()=>{const A=await exportAllFeedbacks(localStorage.token).catch(Z=>(toast.error(Z),null));if(A){let Z=new Blob([JSON.stringify(A)],{type:"application/json"});n(Z,`feedback-history-export-${Date.now()}.json`)}},f=()=>{l()},x=(A,Z)=>{t(A.id)},I=async()=>{u()};function R(A){p=A,i(1,p)}return e.$$set=A=>{"feedbacks"in A&&i(0,h=A.feedbacks)},e.$$.update=()=>{e.$$.dirty&3&&i(2,s=h.slice((p-1)*10,p*10))},[h,p,s,c,a,t,u,l,f,x,I,R]}class Feedbacks extends SvelteComponent{constructor(r){super(),init(this,r,instance$1,create_fragment$2,safe_not_equal,{feedbacks:0})}}function create_if_block(e){let r,i,s,c,n='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M4 2a1.5 1.5 0 0 0-1.5 1.5v9A1.5 1.5 0 0 0 4 14h8a1.5 1.5 0 0 0 1.5-1.5V6.621a1.5 1.5 0 0 0-.44-1.06L9.94 2.439A1.5 1.5 0 0 0 8.878 2H4Zm6 5.75a.75.75 0 0 1 1.5 0v3.5a.75.75 0 0 1-1.5 0v-3.5Zm-2.75 1.5a.75.75 0 0 1 1.5 0v2a.75.75 0 0 1-1.5 0v-2Zm-2 .75a.75.75 0 0 0-.75.75v.5a.75.75 0 0 0 1.5 0v-.5a.75.75 0 0 0-.75-.75Z" clip-rule="evenodd"></path></svg>',a,h,p=e[3].t("Leaderboard")+"",t,u,l,f,x,I='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M5.25 2A2.25 2.25 0 0 0 3 4.25v9a.75.75 0 0 0 1.183.613l1.692-1.195 1.692 1.195a.75.75 0 0 0 .866 0l1.692-1.195 1.693 1.195A.75.75 0 0 0 13 13.25v-9A2.25 2.25 0 0 0 10.75 2h-5.5Zm3.03 3.28a.75.75 0 0 0-1.06-1.06L4.97 6.47a.75.75 0 0 0 0 1.06l2.25 2.25a.75.75 0 0 0 1.06-1.06l-.97-.97h1.315c.76 0 1.375.616 1.375 1.375a.75.75 0 0 0 1.5 0A2.875 2.875 0 0 0 8.625 6.25H7.311l.97-.97Z" clip-rule="evenodd"></path></svg>',R,A,Z=e[3].t("Feedbacks")+"",K,Q,re,se,ee,ce,X,Re,De;const et=[create_if_block_1,create_if_block_2],nt=[];function it(_t,gt){return _t[0]==="leaderboard"?0:_t[0]==="feedbacks"?1:-1}return~(ee=it(e))&&(ce=nt[ee]=et[ee](e)),{c(){r=element("div"),i=element("div"),s=element("button"),c=element("div"),c.innerHTML=n,a=space(),h=element("div"),t=text(p),l=space(),f=element("button"),x=element("div"),x.innerHTML=I,R=space(),A=element("div"),K=text(Z),re=space(),se=element("div"),ce&&ce.c(),this.h()},l(_t){r=claim_element(_t,"DIV",{class:!0});var gt=children(r);i=claim_element(gt,"DIV",{id:!0,class:!0});var Dt=children(i);s=claim_element(Dt,"BUTTON",{class:!0});var Ge=children(s);c=claim_element(Ge,"DIV",{class:!0,"data-svelte-h":!0}),get_svelte_dataset(c)!=="svelte-ujm47k"&&(c.innerHTML=n),a=claim_space(Ge),h=claim_element(Ge,"DIV",{class:!0});var ge=children(h);t=claim_text(ge,p),ge.forEach(detach),Ge.forEach(detach),l=claim_space(Dt),f=claim_element(Dt,"BUTTON",{class:!0});var ct=children(f);x=claim_element(ct,"DIV",{class:!0,"data-svelte-h":!0}),get_svelte_dataset(x)!=="svelte-1fzwrf2"&&(x.innerHTML=I),R=claim_space(ct),A=claim_element(ct,"DIV",{class:!0});var Ot=children(A);K=claim_text(Ot,Z),Ot.forEach(detach),ct.forEach(detach),Dt.forEach(detach),re=claim_space(gt),se=claim_element(gt,"DIV",{class:!0});var $t=children(se);ce&&ce.l($t),$t.forEach(detach),gt.forEach(detach),this.h()},h(){attr(c,"class","self-center mr-2"),attr(h,"class","self-center"),attr(s,"class",u="px-0.5 py-1 min-w-fit rounded-lg lg:flex-none flex text-right transition "+(e[0]==="leaderboard"?"":" text-gray-300 dark:text-gray-600 hover:text-gray-700 dark:hover:text-white")),attr(x,"class","self-center mr-2"),attr(A,"class","self-center"),attr(f,"class",Q="px-0.5 py-1 min-w-fit rounded-lg lg:flex-none flex text-right transition "+(e[0]==="feedbacks"?"":" text-gray-300 dark:text-gray-600 hover:text-gray-700 dark:hover:text-white")),attr(i,"id","users-tabs-container"),attr(i,"class","tabs flex flex-row overflow-x-auto gap-2.5 max-w-full lg:gap-1 lg:flex-col lg:flex-none lg:w-40 dark:text-gray-200 text-sm font-medium text-left scrollbar-none"),attr(se,"class","flex-1 mt-1 lg:mt-0 overflow-y-scroll"),attr(r,"class","flex flex-col lg:flex-row w-full h-full pb-2 lg:space-x-4")},m(_t,gt){insert_hydration(_t,r,gt),append_hydration(r,i),append_hydration(i,s),append_hydration(s,c),append_hydration(s,a),append_hydration(s,h),append_hydration(h,t),append_hydration(i,l),append_hydration(i,f),append_hydration(f,x),append_hydration(f,R),append_hydration(f,A),append_hydration(A,K),append_hydration(r,re),append_hydration(r,se),~ee&&nt[ee].m(se,null),X=!0,Re||(De=[listen(s,"click",e[5]),listen(f,"click",e[6])],Re=!0)},p(_t,gt){(!X||gt&8)&&p!==(p=_t[3].t("Leaderboard")+"")&&set_data(t,p),(!X||gt&1&&u!==(u="px-0.5 py-1 min-w-fit rounded-lg lg:flex-none flex text-right transition "+(_t[0]==="leaderboard"?"":" text-gray-300 dark:text-gray-600 hover:text-gray-700 dark:hover:text-white")))&&attr(s,"class",u),(!X||gt&8)&&Z!==(Z=_t[3].t("Feedbacks")+"")&&set_data(K,Z),(!X||gt&1&&Q!==(Q="px-0.5 py-1 min-w-fit rounded-lg lg:flex-none flex text-right transition "+(_t[0]==="feedbacks"?"":" text-gray-300 dark:text-gray-600 hover:text-gray-700 dark:hover:text-white")))&&attr(f,"class",Q);let Dt=ee;ee=it(_t),ee===Dt?~ee&&nt[ee].p(_t,gt):(ce&&(group_outros(),transition_out(nt[Dt],1,1,()=>{nt[Dt]=null}),check_outros()),~ee?(ce=nt[ee],ce?ce.p(_t,gt):(ce=nt[ee]=et[ee](_t),ce.c()),transition_in(ce,1),ce.m(se,null)):ce=null)},i(_t){X||(transition_in(ce),X=!0)},o(_t){transition_out(ce),X=!1},d(_t){_t&&detach(r),~ee&&nt[ee].d(),Re=!1,run_all(De)}}}function create_if_block_2(e){let r,i;return r=new Feedbacks({props:{feedbacks:e[2]}}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&4&&(n.feedbacks=s[2]),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_if_block_1(e){let r,i;return r=new Leaderboard({props:{feedbacks:e[2]}}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p(s,c){const n={};c&4&&(n.feedbacks=s[2]),r.$set(n)},i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}function create_fragment$1(e){let r,i,s=e[1]&&create_if_block(e);return{c(){s&&s.c(),r=empty()},l(c){s&&s.l(c),r=empty()},m(c,n){s&&s.m(c,n),insert_hydration(c,r,n),i=!0},p(c,[n]){c[1]?s?(s.p(c,n),n&2&&transition_in(s,1)):(s=create_if_block(c),s.c(),transition_in(s,1),s.m(r.parentNode,r)):s&&(group_outros(),transition_out(s,1,1,()=>{s=null}),check_outros())},i(c){i||(transition_in(s),i=!0)},o(c){transition_out(s),i=!1},d(c){c&&detach(r),s&&s.d(c)}}}function instance(e,r,i){let s;const c=getContext("i18n");component_subscribe(e,c,u=>i(3,s=u));let n="leaderboard",a=!1,h=[];return onMount(async()=>{i(2,h=await getAllFeedbacks(localStorage.token)),i(1,a=!0);const u=document.getElementById("users-tabs-container");u&&u.addEventListener("wheel",function(l){l.deltaY!==0&&(u.scrollLeft+=l.deltaY)})}),[n,a,h,s,c,()=>{i(0,n="leaderboard")},()=>{i(0,n="feedbacks")}]}class Evaluations extends SvelteComponent{constructor(r){super(),init(this,r,instance,create_fragment$1,safe_not_equal,{})}}function create_fragment(e){let r,i;return r=new Evaluations({}),{c(){create_component(r.$$.fragment)},l(s){claim_component(r.$$.fragment,s)},m(s,c){mount_component(r,s,c),i=!0},p:noop,i(s){i||(transition_in(r.$$.fragment,s),i=!0)},o(s){transition_out(r.$$.fragment,s),i=!1},d(s){destroy_component(r,s)}}}class Page extends SvelteComponent{constructor(r){super(),init(this,r,null,create_fragment,safe_not_equal,{})}}export{Page as component};
//# sourceMappingURL=8.DaUa-vBp.js.map
