{"version":3,"file":"DpN1w328.js","sources":["../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["/** @import { Effect, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tget,\n\tis_destroying_effect,\n\tset_active_effect,\n\tuntrack\n} from '../runtime.js';\nimport * as e from '../errors.js';\nimport { DESTROYED, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number>, parent_effect: Effect }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\tvar previous_effect = active_effect;\n\n\t\t\ttry {\n\t\t\t\tset_active_effect(target.parent_effect);\n\n\t\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\t\ttarget.special[key] = prop(\n\t\t\t\t\t{\n\t\t\t\t\t\tget [key]() {\n\t\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {string} */ (key),\n\t\t\t\t\tPROPS_IS_UPDATED\n\t\t\t\t);\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t}\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy(\n\t\t{\n\t\t\tprops,\n\t\t\texclude,\n\t\t\tspecial: {},\n\t\t\tversion: source(0),\n\t\t\t// TODO this is only necessary because we need to track component\n\t\t\t// destruction inside `prop`, because of `bind:this`, but it\n\t\t\t// seems likely that we can simplify `bind:this` instead\n\t\t\tparent_effect: /** @type {Effect} */ (active_effect)\n\t\t},\n\t\tlegacy_rest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @type {ProxyHandler<{ props: Array<Record<string | symbol, unknown> | (() => Record<string | symbol, unknown>)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\n\tvar get_fallback = () => {\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\n\t\t\tfallback_value = lazy\n\t\t\t\t? untrack(/** @type {() => V} */ (fallback))\n\t\t\t\t: /** @type {V} */ (fallback);\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\t/** @type {((v: V) => void) | undefined} */\n\tvar setter;\n\n\tif (bindable) {\n\t\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t\t// or `createClassComponent(Component, props)`\n\t\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\t\tsetter =\n\t\t\tget_descriptor(props, key)?.set ??\n\t\t\t(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);\n\t}\n\n\tvar initial_value;\n\tvar is_store_sub = false;\n\n\tif (bindable) {\n\t\t[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tinitial_value = /** @type {V} */ (props[key]);\n\t}\n\n\tif (initial_value === undefined && fallback !== undefined) {\n\t\tinitial_value = get_fallback();\n\n\t\tif (setter) {\n\t\t\tif (runes) e.props_invalid_value(key);\n\t\t\tsetter(initial_value);\n\t\t}\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\n\t\t\tif (value !== undefined) {\n\t\t\t\t// in legacy mode, we don't revert to the fallback value\n\t\t\t\t// if the prop goes from defined to undefined. The easiest\n\t\t\t\t// way to model this is to make the fallback undefined\n\t\t\t\t// as soon as the prop has a value\n\t\t\t\tfallback_value = /** @type {V} */ (undefined);\n\t\t\t}\n\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// prop is never written to — we only need a getter\n\tif (runes && (flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// prop is written to, but the parent component had `bind:foo` which\n\t// means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn /** @type {() => V} */ (\n\t\t\tfunction (/** @type {V} */ value, /** @type {boolean} */ mutation) {\n\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t);\n\t}\n\n\t// Either prop is written to, but there's no binding, which means we\n\t// create a derived that we can write to locally.\n\t// Or we are in legacy mode where we always create a derived to replicate that\n\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\tvar overridden = false;\n\n\tvar d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {\n\t\toverridden = false;\n\t\treturn getter();\n\t});\n\n\tif (DEV) {\n\t\td.label = key;\n\t}\n\n\t// Capture the initial value if it's bindable\n\tif (bindable) get(d);\n\n\tvar parent_effect = /** @type {Effect} */ (active_effect);\n\n\treturn /** @type {() => V} */ (\n\t\tfunction (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconst new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;\n\n\t\t\t\tset(d, new_value);\n\t\t\t\toverridden = true;\n\n\t\t\t\tif (fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\t// special case — avoid recalculating the derived if we're in a\n\t\t\t// teardown function and the prop was overridden locally, or the\n\t\t\t// component was already destroyed (this latter part is necessary\n\t\t\t// because `bind:this` can read props after the component has\n\t\t\t// been destroyed. TODO simplify `bind:this`\n\t\t\tif ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {\n\t\t\t\treturn d.v;\n\t\t\t}\n\n\t\t\treturn get(d);\n\t\t}\n\t);\n}\n"],"names":["legacy_rest_props_handler","target","key","get","value","previous_effect","active_effect","set_active_effect","prop","PROPS_IS_UPDATED","update","legacy_rest_props","props","exclude","source","spread_props_handler","p","is_function","i","desc","get_descriptor","descriptor","STATE_SYMBOL","LEGACY_PROPS","keys","spread_props","flags","fallback","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","fallback_value","fallback_dirty","get_fallback","untrack","setter","is_entry_props","_a","v","initial_value","is_store_sub","capture_store_binding","e.props_invalid_value","getter","legacy_parent","mutation","overridden","d","PROPS_IS_IMMUTABLE","derived","derived_safe_equal","parent_effect","new_value","proxy","set","is_destroying_effect","DESTROYED"],"mappings":"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","x_google_ignoreList":[0]}