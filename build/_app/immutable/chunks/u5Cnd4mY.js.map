{"version":3,"file":"u5Cnd4mY.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/each.js"],"sourcesContent":["/** @import { EachItem, EachOutroGroup, EachState, Effect, EffectNodes, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tshould_defer_append\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { COMMENT_NODE, EFFECT_OFFSCREEN, INERT } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n// When making substantive changes to this file, validate them with the each block stress test:\n// https://svelte.dev/playground/1972b2cf46564476ad8c8c6405b23b7b\n// This test also exists in this repo, as `packages/svelte/tests/manual/each-stress-test`\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {Effect[]} to_destroy\n * @param {null | Node} controlled_anchor\n */\nfunction pause_effects(state, to_destroy, controlled_anchor) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = to_destroy.length;\n\n\t/** @type {EachOutroGroup} */\n\tvar group;\n\tvar remaining = to_destroy.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tlet effect = to_destroy[i];\n\n\t\tpause_effect(\n\t\t\teffect,\n\t\t\t() => {\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\t\tgroup.done.add(effect);\n\n\t\t\t\t\tif (group.pending.size === 0) {\n\t\t\t\t\t\tvar groups = /** @type {Set<EachOutroGroup>} */ (state.outrogroups);\n\n\t\t\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\t\t\tgroups.delete(group);\n\n\t\t\t\t\t\tif (groups.size === 0) {\n\t\t\t\t\t\t\tstate.outrogroups = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tremaining -= 1;\n\t\t\t\t}\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t}\n\n\tif (remaining === 0) {\n\t\t// If we're in a controlled each block (i.e. the block is the only child of an\n\t\t// element), and we are removing all items, _and_ there are no out transitions,\n\t\t// we can use the fast path — emptying the element and replacing the anchor\n\t\tvar fast_path = transitions.length === 0 && controlled_anchor !== null;\n\n\t\tif (fast_path) {\n\t\t\tvar anchor = /** @type {Element} */ (controlled_anchor);\n\t\t\tvar parent_node = /** @type {Element} */ (anchor.parentNode);\n\n\t\t\tclear_text_content(parent_node);\n\t\t\tparent_node.append(anchor);\n\n\t\t\tstate.items.clear();\n\t\t}\n\n\t\tdestroy_effects(to_destroy, !fast_path);\n\t} else {\n\t\tgroup = {\n\t\t\tpending: new Set(to_destroy),\n\t\t\tdone: new Set()\n\t\t};\n\n\t\t(state.outrogroups ??= new Set()).add(group);\n\t}\n}\n\n/**\n * @param {Effect[]} to_destroy\n * @param {boolean} remove_dom\n */\nfunction destroy_effects(to_destroy, remove_dom = true) {\n\t// TODO only destroy effects if no pending batch needs them. otherwise,\n\t// just re-add the `EFFECT_OFFSCREEN` flag\n\tfor (var i = 0; i < to_destroy.length; i++) {\n\t\tdestroy_effect(to_destroy[i], remove_dom);\n\t}\n}\n\n/** @type {TemplateNode} */\nvar offscreen_anchor;\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {Map<any, EachItem>} */\n\tvar items = new Map();\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(get_first_child(parent_node))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\t/** @type {V[]} */\n\tvar array;\n\n\tvar first_run = true;\n\n\tfunction commit() {\n\t\tstate.fallback = fallback;\n\t\treconcile(state, array, anchor, flags, get_key);\n\n\t\tif (fallback !== null) {\n\t\t\tif (array.length === 0) {\n\t\t\t\tif ((fallback.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback.f ^= EFFECT_OFFSCREEN;\n\t\t\t\t\tmove(fallback, null, anchor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\t// TODO only null out if no pending batch needs it,\n\t\t\t\t\t// otherwise re-add `fallback.fragment` and move the\n\t\t\t\t\t// effect into it\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tarray = /** @type {V[]} */ (get(each_array));\n\t\tvar length = array.length;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tvar keys = new Set();\n\t\tvar batch = /** @type {Batch} */ (current_batch);\n\t\tvar defer = should_defer_append();\n\n\t\tfor (var index = 0; index < length; index += 1) {\n\t\t\tif (\n\t\t\t\thydrating &&\n\t\t\t\thydrate_node.nodeType === COMMENT_NODE &&\n\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t) {\n\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\tmismatch = true;\n\t\t\t\tset_hydrating(false);\n\t\t\t}\n\n\t\t\tvar value = array[index];\n\t\t\tvar key = get_key(value, index);\n\n\t\t\tvar item = first_run ? null : items.get(key);\n\n\t\t\tif (item) {\n\t\t\t\t// update before reconciliation, to trigger any async updates\n\t\t\t\tif (item.v) internal_set(item.v, value);\n\t\t\t\tif (item.i) internal_set(item.i, index);\n\n\t\t\t\tif (defer) {\n\t\t\t\t\tbatch.skipped_effects.delete(item.e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\titem = create_item(\n\t\t\t\t\titems,\n\t\t\t\t\tfirst_run ? anchor : (offscreen_anchor ??= create_text()),\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\tindex,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\n\t\t\t\tif (!first_run) {\n\t\t\t\t\titem.e.f |= EFFECT_OFFSCREEN;\n\t\t\t\t}\n\n\t\t\t\titems.set(key, item);\n\t\t\t}\n\n\t\t\tkeys.add(key);\n\t\t}\n\n\t\tif (length === 0 && fallback_fn && !fallback) {\n\t\t\tif (first_run) {\n\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t} else {\n\t\t\t\tfallback = branch(() => fallback_fn((offscreen_anchor ??= create_text())));\n\t\t\t\tfallback.f |= EFFECT_OFFSCREEN;\n\t\t\t}\n\t\t}\n\n\t\t// remove excess nodes\n\t\tif (hydrating && length > 0) {\n\t\t\tset_hydrate_node(skip_nodes());\n\t\t}\n\n\t\tif (!first_run) {\n\t\t\tif (defer) {\n\t\t\t\tfor (const [key, item] of items) {\n\t\t\t\t\tif (!keys.has(key)) {\n\t\t\t\t\t\tbatch.skipped_effects.add(item.e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbatch.oncommit(commit);\n\t\t\t\tbatch.ondiscard(() => {\n\t\t\t\t\t// TODO presumably we need to do something here?\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\t/** @type {EachState} */\n\tvar state = { effect, flags, items, outrogroups: null, fallback };\n\n\tfirst_run = false;\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {EachState} state\n * @param {Array<V>} array\n * @param {Element | Comment | Text} anchor\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(state, array, anchor, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar current = state.effect.first;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar seen;\n\n\t/** @type {Effect | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar to_animate;\n\n\t/** @type {Effect[]} */\n\tvar matched = [];\n\n\t/** @type {Effect[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\t\t// offscreen == coming in now, no animation in that case,\n\t\t\t// else this would happen https://github.com/sveltejs/svelte/issues/17181\n\t\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\teffect.nodes?.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(effect);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\n\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\tif (state.outrogroups !== null) {\n\t\t\tfor (const group of state.outrogroups) {\n\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\tgroup.done.delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) !== 0) {\n\t\t\teffect.f ^= EFFECT_OFFSCREEN;\n\n\t\t\tif (effect === current) {\n\t\t\t\tmove(effect, null, anchor);\n\t\t\t} else {\n\t\t\t\tvar next = prev ? prev.next : current;\n\n\t\t\t\tif (effect === state.effect.last) {\n\t\t\t\t\tstate.effect.last = effect.prev;\n\t\t\t\t}\n\n\t\t\t\tif (effect.prev) effect.prev.next = effect.next;\n\t\t\t\tif (effect.next) effect.next.prev = effect.prev;\n\t\t\t\tlink(state, prev, effect);\n\t\t\t\tlink(state, effect, next);\n\n\t\t\t\tmove(effect, next, anchor);\n\t\t\t\tprev = effect;\n\n\t\t\t\tmatched = [];\n\t\t\t\tstashed = [];\n\n\t\t\t\tcurrent = prev.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & INERT) !== 0) {\n\t\t\tresume_effect(effect);\n\t\t\tif (is_animated) {\n\t\t\t\teffect.nodes?.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif (effect !== current) {\n\t\t\tif (seen !== undefined && seen.has(effect)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(effect);\n\t\t\t\t\tmove(effect, current, anchor);\n\n\t\t\t\t\tlink(state, effect.prev, effect.next);\n\t\t\t\t\tlink(state, effect, prev === null ? state.effect.first : prev.next);\n\t\t\t\t\tlink(state, prev, effect);\n\n\t\t\t\t\tprev = effect;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current !== effect) {\n\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\tmatched.push(effect);\n\t\t}\n\n\t\tprev = effect;\n\t\tcurrent = effect.next;\n\t}\n\n\tif (state.outrogroups !== null) {\n\t\tfor (const group of state.outrogroups) {\n\t\t\tif (group.pending.size === 0) {\n\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\tstate.outrogroups?.delete(group);\n\t\t\t}\n\t\t}\n\n\t\tif (state.outrogroups.size === 0) {\n\t\t\tstate.outrogroups = null;\n\t\t}\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\t/** @type {Effect[]} */\n\t\tvar to_destroy = [];\n\n\t\tif (seen !== undefined) {\n\t\t\tfor (effect of seen) {\n\t\t\t\tif ((effect.f & INERT) === 0) {\n\t\t\t\t\tto_destroy.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.f & INERT) === 0 && current !== state.fallback) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (effect of to_animate) {\n\t\t\t\teffect.nodes?.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @template V\n * @param {Map<any, EachItem>} items\n * @param {Node} anchor\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(items, anchor, value, key, index, render_fn, flags, get_collection) {\n\tvar v =\n\t\t(flags & EACH_ITEM_REACTIVE) !== 0\n\t\t\t? (flags & EACH_ITEM_IMMUTABLE) === 0\n\t\t\t\t? mutable_source(value, false, false)\n\t\t\t\t: source(value)\n\t\t\t: null;\n\n\tvar i = (flags & EACH_INDEX_REACTIVE) !== 0 ? source(index) : null;\n\n\tif (DEV && v) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\tv.trace = () => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[i?.v ?? index];\n\t\t};\n\t}\n\n\treturn {\n\t\tv,\n\t\ti,\n\t\te: branch(() => {\n\t\t\trender_fn(anchor, v ?? value, i ?? index, get_collection);\n\n\t\t\treturn () => {\n\t\t\t\titems.delete(key);\n\t\t\t};\n\t\t})\n\t};\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(effect, next, anchor) {\n\tif (!effect.nodes) return;\n\n\tvar node = effect.nodes.start;\n\tvar end = effect.nodes.end;\n\n\tvar dest =\n\t\tnext && (next.f & EFFECT_OFFSCREEN) === 0\n\t\t\t? /** @type {EffectNodes} */ (next.nodes).start\n\t\t\t: anchor;\n\n\twhile (node !== null) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\n\t\tif (node === end) {\n\t\t\treturn;\n\t\t}\n\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {Effect | null} prev\n * @param {Effect | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.effect.first = next;\n\t} else {\n\t\tprev.next = next;\n\t}\n\n\tif (next === null) {\n\t\tstate.effect.last = prev;\n\t} else {\n\t\tnext.prev = prev;\n\t}\n}\n"],"names":["index","_","pause_effects","state","to_destroy","controlled_anchor","transitions","length","group","remaining","i","effect","pause_effect","groups","destroy_effects","array_from","fast_path","anchor","parent_node","clear_text_content","remove_dom","destroy_effect","offscreen_anchor","each","node","flags","get_collection","get_key","render_fn","fallback_fn","items","is_controlled","EACH_IS_CONTROLLED","hydrating","set_hydrate_node","get_first_child","create_text","hydrate_next","fallback","each_array","derived_safe_equal","collection","is_array","array","first_run","commit","reconcile","EFFECT_OFFSCREEN","move","resume_effect","block","get","mismatch","is_else","read_hydration_instruction","HYDRATION_START_ELSE","skip_nodes","set_hydrating","keys","batch","current_batch","defer","should_defer_append","hydrate_node","COMMENT_NODE","HYDRATION_END","value","key","item","internal_set","create_item","branch","is_animated","EACH_IS_ANIMATED","current","seen","prev","to_animate","matched","stashed","_b","_a","next","link","INERT","_d","_c","start","j","a","b","_e","destroy_length","_g","_f","_i","_h","queue_micro_task","v","EACH_ITEM_REACTIVE","EACH_ITEM_IMMUTABLE","source","mutable_source","EACH_INDEX_REACTIVE","end","dest","next_node","get_next_sibling"],"mappings":"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","x_google_ignoreList":[0]}