{"version":3,"file":"Cmf4RC8y.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/branches.js","../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { Batch, current_batch } from '../../reactivity/batch.js';\nimport {\n\tbranch,\n\tdestroy_effect,\n\tmove_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { hydrate_node, hydrating } from '../hydration.js';\nimport { create_text, should_defer_append } from '../operations.js';\n\n/**\n * @typedef {{ effect: Effect, fragment: DocumentFragment }} Branch\n */\n\n/**\n * @template Key\n */\nexport class BranchManager {\n\t/** @type {TemplateNode} */\n\tanchor;\n\n\t/** @type {Map<Batch, Key>} */\n\t#batches = new Map();\n\n\t/**\n\t * Map of keys to effects that are currently rendered in the DOM.\n\t * These effects are visible and actively part of the document tree.\n\t * Example:\n\t * ```\n\t * {#if condition}\n\t * \tfoo\n\t * {:else}\n\t * \tbar\n\t * {/if}\n\t * ```\n\t * Can result in the entries `true->Effect` and `false->Effect`\n\t * @type {Map<Key, Effect>}\n\t */\n\t#onscreen = new Map();\n\n\t/**\n\t * Similar to #onscreen with respect to the keys, but contains branches that are not yet\n\t * in the DOM, because their insertion is deferred.\n\t * @type {Map<Key, Branch>}\n\t */\n\t#offscreen = new Map();\n\n\t/**\n\t * Keys of effects that are currently outroing\n\t * @type {Set<Key>}\n\t */\n\t#outroing = new Set();\n\n\t/**\n\t * Whether to pause (i.e. outro) on change, or destroy immediately.\n\t * This is necessary for `<svelte:element>`\n\t */\n\t#transition = true;\n\n\t/**\n\t * @param {TemplateNode} anchor\n\t * @param {boolean} transition\n\t */\n\tconstructor(anchor, transition = true) {\n\t\tthis.anchor = anchor;\n\t\tthis.#transition = transition;\n\t}\n\n\t#commit = () => {\n\t\tvar batch = /** @type {Batch} */ (current_batch);\n\n\t\t// if this batch was made obsolete, bail\n\t\tif (!this.#batches.has(batch)) return;\n\n\t\tvar key = /** @type {Key} */ (this.#batches.get(batch));\n\n\t\tvar onscreen = this.#onscreen.get(key);\n\n\t\tif (onscreen) {\n\t\t\t// effect is already in the DOM â€” abort any current outro\n\t\t\tresume_effect(onscreen);\n\t\t\tthis.#outroing.delete(key);\n\t\t} else {\n\t\t\t// effect is currently offscreen. put it in the DOM\n\t\t\tvar offscreen = this.#offscreen.get(key);\n\n\t\t\tif (offscreen) {\n\t\t\t\tthis.#onscreen.set(key, offscreen.effect);\n\t\t\t\tthis.#offscreen.delete(key);\n\n\t\t\t\t// remove the anchor...\n\t\t\t\t/** @type {TemplateNode} */ (offscreen.fragment.lastChild).remove();\n\n\t\t\t\t// ...and append the fragment\n\t\t\t\tthis.anchor.before(offscreen.fragment);\n\t\t\t\tonscreen = offscreen.effect;\n\t\t\t}\n\t\t}\n\n\t\tfor (const [b, k] of this.#batches) {\n\t\t\tthis.#batches.delete(b);\n\n\t\t\tif (b === batch) {\n\t\t\t\t// keep values for newer batches\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst offscreen = this.#offscreen.get(k);\n\n\t\t\tif (offscreen) {\n\t\t\t\t// for older batches, destroy offscreen effects\n\t\t\t\t// as they will never be committed\n\t\t\t\tdestroy_effect(offscreen.effect);\n\t\t\t\tthis.#offscreen.delete(k);\n\t\t\t}\n\t\t}\n\n\t\t// outro/destroy all onscreen effects...\n\t\tfor (const [k, effect] of this.#onscreen) {\n\t\t\t// ...except the one that was just committed\n\t\t\t//    or those that are already outroing (else the transition is aborted and the effect destroyed right away)\n\t\t\tif (k === key || this.#outroing.has(k)) continue;\n\n\t\t\tconst on_destroy = () => {\n\t\t\t\tconst keys = Array.from(this.#batches.values());\n\n\t\t\t\tif (keys.includes(k)) {\n\t\t\t\t\t// keep the effect offscreen, as another batch will need it\n\t\t\t\t\tvar fragment = document.createDocumentFragment();\n\t\t\t\t\tmove_effect(effect, fragment);\n\n\t\t\t\t\tfragment.append(create_text()); // TODO can we avoid this?\n\n\t\t\t\t\tthis.#offscreen.set(k, { effect, fragment });\n\t\t\t\t} else {\n\t\t\t\t\tdestroy_effect(effect);\n\t\t\t\t}\n\n\t\t\t\tthis.#outroing.delete(k);\n\t\t\t\tthis.#onscreen.delete(k);\n\t\t\t};\n\n\t\t\tif (this.#transition || !onscreen) {\n\t\t\t\tthis.#outroing.add(k);\n\t\t\t\tpause_effect(effect, on_destroy, false);\n\t\t\t} else {\n\t\t\t\ton_destroy();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @param {Batch} batch\n\t */\n\t#discard = (batch) => {\n\t\tthis.#batches.delete(batch);\n\n\t\tconst keys = Array.from(this.#batches.values());\n\n\t\tfor (const [k, branch] of this.#offscreen) {\n\t\t\tif (!keys.includes(k)) {\n\t\t\t\tdestroy_effect(branch.effect);\n\t\t\t\tthis.#offscreen.delete(k);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {any} key\n\t * @param {null | ((target: TemplateNode) => void)} fn\n\t */\n\tensure(key, fn) {\n\t\tvar batch = /** @type {Batch} */ (current_batch);\n\t\tvar defer = should_defer_append();\n\n\t\tif (fn && !this.#onscreen.has(key) && !this.#offscreen.has(key)) {\n\t\t\tif (defer) {\n\t\t\t\tvar fragment = document.createDocumentFragment();\n\t\t\t\tvar target = create_text();\n\n\t\t\t\tfragment.append(target);\n\n\t\t\t\tthis.#offscreen.set(key, {\n\t\t\t\t\teffect: branch(() => fn(target)),\n\t\t\t\t\tfragment\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.#onscreen.set(\n\t\t\t\t\tkey,\n\t\t\t\t\tbranch(() => fn(this.anchor))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.#batches.set(batch, key);\n\n\t\tif (defer) {\n\t\t\tfor (const [k, effect] of this.#onscreen) {\n\t\t\t\tif (k === key) {\n\t\t\t\t\tbatch.skipped_effects.delete(effect);\n\t\t\t\t} else {\n\t\t\t\t\tbatch.skipped_effects.add(effect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const [k, branch] of this.#offscreen) {\n\t\t\t\tif (k === key) {\n\t\t\t\t\tbatch.skipped_effects.delete(branch.effect);\n\t\t\t\t} else {\n\t\t\t\t\tbatch.skipped_effects.add(branch.effect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbatch.oncommit(this.#commit);\n\t\t\tbatch.ondiscard(this.#discard);\n\t\t} else {\n\t\t\tif (hydrating) {\n\t\t\t\tthis.anchor = hydrate_node;\n\t\t\t}\n\n\t\t\tthis.#commit();\n\t\t}\n\t}\n}\n","/** @import { TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE } from '../../../../constants.js';\nimport { BranchManager } from './branches.js';\n\n// TODO reinstate https://github.com/sveltejs/svelte/pull/15250\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, fn, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar branches = new BranchManager(node);\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\t/**\n\t * @param {boolean} condition,\n\t * @param {null | ((anchor: Node) => void)} fn\n\t */\n\tfunction update_branch(condition, fn) {\n\t\tif (hydrating) {\n\t\t\tconst is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tvar anchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tbranches.anchor = anchor;\n\n\t\t\t\tset_hydrating(false);\n\t\t\t\tbranches.ensure(condition, fn);\n\t\t\t\tset_hydrating(true);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tbranches.ensure(condition, fn);\n\t}\n\n\tblock(() => {\n\t\tvar has_branch = false;\n\n\t\tfn((fn, flag = true) => {\n\t\t\thas_branch = true;\n\t\t\tupdate_branch(flag, fn);\n\t\t});\n\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(false, null);\n\t\t}\n\t}, flags);\n}\n"],"names":["BranchManager","anchor","transition","__publicField","__privateAdd","_batches","_onscreen","_offscreen","_outroing","_transition","_commit","batch","current_batch","__privateGet","key","onscreen","resume_effect","offscreen","b","k","destroy_effect","effect","on_destroy","fragment","move_effect","create_text","pause_effect","_discard","keys","branch","__privateSet","fn","defer","should_defer_append","target","hydrating","hydrate_node","if_block","node","elseif","hydrate_next","branches","flags","EFFECT_TRANSPARENT","update_branch","condition","is_else","read_hydration_instruction","HYDRATION_START_ELSE","skip_nodes","set_hydrate_node","set_hydrating","block","has_branch","flag"],"mappings":"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","x_google_ignoreList":[0,1]}